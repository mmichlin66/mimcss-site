(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["mimcss"] = factory();
	else
		root["mimcss"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/api/ColorAPI.js":
/*!*****************************!*\
  !*** ./lib/api/ColorAPI.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Colors": () => (/* binding */ Colors),
/* harmony export */   "registerColor": () => (/* binding */ registerColor),
/* harmony export */   "rgb": () => (/* binding */ rgb),
/* harmony export */   "hsl": () => (/* binding */ hsl),
/* harmony export */   "lab": () => (/* binding */ lab),
/* harmony export */   "lch": () => (/* binding */ lch),
/* harmony export */   "colorContrast": () => (/* binding */ colorContrast),
/* harmony export */   "colorMix": () => (/* binding */ colorMix),
/* harmony export */   "alpha": () => (/* binding */ alpha)
/* harmony export */ });
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");

/**
 * Object whose property names are the well-known Web color names while values correspond to the
 * hexadecimal representation of the RGB separations (without an alpha mask). The properties of
 * this object can be used wherever the [[CssColor]] type can be used. Since the properties are
 * of the `number` type, they can be used for manipulating the color value.
*/
const Colors = {
    black: 0x000000,
    silver: 0xc0c0c0,
    gray: 0x808080,
    white: 0xffffff,
    maroon: 0x800000,
    red: 0xff0000,
    purple: 0x800080,
    fuchsia: 0xff00ff,
    green: 0x008000,
    lime: 0x00ff00,
    olive: 0x808000,
    yellow: 0xffff00,
    navy: 0x000080,
    blue: 0x0000ff,
    teal: 0x008080,
    aqua: 0x00ffff,
    orange: 0xffa500,
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    blanchedalmond: 0xffebcd,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    oldlace: 0xfdf5e6,
    olivedrab: 0x6b8e23,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    whitesmoke: 0xf5f5f5,
    yellowgreen: 0x9acd32,
    rebeccapurple: 0x663399,
};
/**
 * Object where we keep the registered custom colors. We need it to determine whether the color
 * is a standard or a custom one.
 */
const customColors = {};
/**
 * Registers a new custom color or changes the value of the existing custom color. The name of the
 * custom color should have been already added to the [[INamedColors]] interface using the module
 * augmentation technique. Note that values of standard Web colors cannot be changed.
 *
 * @param name Color name. This name cannot be a name of the standard Web color.
 * @param value Color value to assign to the given named color.
 * @returns Flag indicating whether the operation was successful.
 */
const registerColor = (name, value) => {
    if (!name || value == null)
        return false;
    // try to retrieve this name from the CustomColors object. Non-undefined value means that
    // we already have this color registered.
    let customValue = customColors[name];
    // if the color name already exists in the Colors object we will only allow changing its
    // value if this is a custom color.
    if (name in Colors && customValue != null)
        return false;
    // add the value to the Colors and CustomColors objects
    Colors[name] = value;
    customColors[name] = value;
    return true;
};
/**
 * Converts color value from the numeric representation to the CSS color string.
 */
let colorNumber2s = (val) => {
    // if the number is negative, remember that fact and get the positive number
    let isNegative = val < 0;
    let n = isNegative ? -val : val;
    // if the number has a floating point part, separate it into alpha channel
    let a = 0;
    if (!Number.isInteger(n)) {
        let k = Math.floor(n);
        // a = Math.round( (n - k) * 100);
        a = Math.round((n - k) * 255);
        n = k;
    }
    // If the number was negative we revert the color by negating all the bits. In any case,
    // we clear everything beyond the first three bytes.
    n = isNegative ? ~(0xFF000000 | n) : 0x00FFFFFF & n;
    let s = "#" + n.toString(16).padStart(6, "0");
    return a ? s + a.toString(16).padStart(2, "0") : s;
};
/**
 * Converts color style value to the CSS string. We convert numeric values to the #RRGGBBAA
 * representation. If a string value is a custom color added via INamedColors module
 * augmentation we get its number from the `custmColors` object and also convert it to the
 * #RRGGBBAA representation. Standard named colors as well as are returned as is.
 */
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[11] = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    str: v => v in customColors ? colorNumber2s(customColors[v]) : v,
    num: colorNumber2s
});
/**
 * Converts color style value to the CSS string. We convert numeric values to the #RRGGBBAA
 * representation. If a string value is a custom color added via INamedColors module
 * augmentation we get its number from the `custmColors` object and also convert it to the
 * #RRGGBBAA representation. Standard named colors as well as are returned as is.
 */
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[30] = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { any: 11 /* Color */ });
/**
 * Converts the color separation value to a CSS string.
 */
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[28] = (c) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(c, {
    num: c => {
        c = c < 0 ? -c : c;
        return (c === 0 || c >= 1) ? "" + c : (Math.round(c * 100) + "%");
    }
});
/**
 * Converts the color specified as red, green, blue separation values and an optional alpha
 * mask to a CSS color representation. Each color separation can be represented as a number with
 * the following meaning:
 *   - Integer number -255 to 255. Numbers beyond this range will be clamped. Negative numbers
 *     will be inverted.
 *   - Floating number -1.0 to 1.0 non-inclusive, which is multiplied by 100 treated as percentage.
 *     Floating numbers beyond this range will be rounded and treated as integer numbers. Negative
 *     numbers will be inverted.
 *
 * The alpha mask can be one of the following:
 *   - Floating number 0 to 1 inclusive.
 *   - Integer or floating number 1 to 100, which is divided by 100. Floating numbers will be
 *     rounded. Numbers beyond this range will be clamped.
 *   - The sign of alpha is ignored; that is, only the absolute value is considered.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb()
 *
 * @param r Red separation value.
 * @param g Green separation value.
 * @param b Blue separation value.
 * @param a Optional alpha mask as a percentage value.
 * @return The `IRgbFunc` object representing the invocation of the `rgb()` CSS function
 */
const rgb = (r, g, b, a) => {
    return { fn: "rgb", r, g, b, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rgb = {
    p: [["r", 28 /* ColorSeparation */], ["g", 28 /* ColorSeparation */], ["b", 28 /* ColorSeparation */], ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Converts the color specified as hue-saturation-lightness components and an optional alpha
 * mask to a CSS color representation. This method should be used when defining CSS color
 * values in styleset properties.
 *
 * The Hue component is treated as the CSS `<angle>` type. Numbers are considered degrees.
 *
 * The Saturation and Lightness components are treated as percentages:
 *   - The sign is ignored; that is, only the absolute value is considered.
 *   - Floating number 0 to 1 inclusive are multiplied by 100 and treated as percentage.
 *   - Integer or floating number 1 to 100 are treated as percentage. Floating numbers will be
 *     rounded. Numbers beyond this range will be clamped to 100.
 *
 * The alpha mask can be one of the following:
 *   - Floating number 0 to 1 inclusive.
 *   - Integer or floating number 1 to 100, which is divided by 100. Floating numbers will be
 *     rounded. Numbers beyond this range will be clamped.
 *   - The sign of alpha is ignored; that is, only the absolute value is considered.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl()
 *
 * @param h Hue component as an angle value.
 * @param s Saturation component as a percentage value.
 * @param l Lightness component as a percentage value.
 * @param a Optional alpha mask as a percentage value.
 * @return The `IHslFunc` object representing the invocation of the `hsl()` CSS function
 */
const hsl = (h, s, l, a) => {
    return { fn: "hsl", h, s, l, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.hsl = {
    p: [["h", 4 /* Angle */], ["s", 2 /* Percent */], ["l", 2 /* Percent */], ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Converts the color specified as L\*a\*b\* components and an optional alpha
 * mask to a CSS color representation. This method should be used when defining CSS color
 * values in styleset properties.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lab()
 *
 * @param l CIE Lightness component
 * @param da Distance along the a axis in the Lab colorspace
 * @param db Distance along the b axis in the Lab colorspace
 * @param a Optional alpha mask as a percentage value.
 * @returns The `ILabFunc` object representing the invocation of the `lab()` CSS function
 */
const lab = (l, da, db, a) => {
    return { fn: "lab", l, da, db, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.lab = {
    p: [["l", 27 /* AlwaysPercent */], "da", "db", ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Converts the color specified as lightness-chroma-hue components and an optional alpha
 * mask to a CSS color representation. This method should be used when defining CSS color
 * values in styleset properties.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lch()
 *
 * @param l CIE Lightness component
 * @param c Chroma component
 * @param h Hue component as an angle value.
 * @param a Optional alpha mask as a percentage value.
 * @returns The `ILchFunc` object representing the invocation of the `lch()` CSS function
 */
const lch = (l, c, h, a) => {
    return { fn: "lch", l, c, h, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.lch = {
    p: [["l", 27 /* AlwaysPercent */], "c", ["h", 4 /* Angle */], ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Implements the `color-contrast()` CSS property.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-contrast()
 *
 * @param c Color to which the list of colors in the `vs` property will be compared
 * @param vs List of colors from which to select the most contrasting to the base color.
 * @returns The `IColorContrastFunc` object representing the invocation of the `color-contrast()`
 * CSS function
 */
const colorContrast = (c, ...vs) => ({ fn: "color-contrast", c, vs });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["color-contrast"] = {
    p: [
        ["c", (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, 11 /* Color */) + " vs"],
        ["vs", (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v, 11 /* Color */, ",")]
    ],
    s: " "
};
/**
 * Represents an invocation of the CSS `color-mix()` function. This interface is returned from the
 * [[colorMix]] function. Developers can use this structure wherever [[CssColor]] is accepted.
 */
class ColorMixFunc {
    constructor(c, p) {
        this.fn = "color-mix";
        this.c1 = [c, p];
    }
    with(c, p) { this.c2 = [c, p]; return this; }
    in(cs) { this.cs = cs; return this; }
}
/**
 * Implements the `color-mix()` CSS property.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-nix()
 *
 * **Examples**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefnition
 * {
 *     // color-mix( "blue", "red")
 *     cls1 = this.$class({
 *         color: css.colorMix("blue").with("red");
 *     })
 *
 *     // color-mix( in srgb, "blue 30%", "red" 60%)
 *     cls2 = this.$class({
 *         color: css.colorMix("blue", 30).with("red", 60).in("srgb");
 *     })
 * }
 * ```
 *
 * @param cs Color space. Default is "lch".
 * @returns The `IColorMixBuilder` object that allows adding colors and optional percentages to mix
 */
const colorMix = (c, p) => new ColorMixFunc(c, p);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["color-mix"] = [
    ["cs", (v) => v ? "in " + (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v) : ""],
    ["c1", v => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[v[0], 11 /* Color */], [v[1], 2 /* Percent */]])],
    ["c2", v => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[v[0], 11 /* Color */], [v[1], 2 /* Percent */]])],
];
/**
 * Converts the given color and the alpha mask to the CSS Color representation. This
 * method should be used when defining CSS color values in styleset properties.
 *
 * The color can be specified as a numeric value or as a color name from the [[INamedColors]]
 * interface - including colors added using the module augmentation technique.
 *
 * The alpha mask is specified as a number:
 *   - The sign is ignored; that is, only the absolute value is considered.
 *   - Number 0 to 1 inclusive, which is treated as percentage.
 *   - Number 1 to 100 inclusive, which is treated as percentage.
 *   - Numbers greater than 100 are clamped to 100;
 *
 * **Examples**
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     // applying alpha to a numeric color
 *     cls1 = this.$class({ color: css.alpha( 0xAA00AA, 0.5) })
 *
 *     // applying alpha to a named color
 *     cls1 = this.$class({ color: css.alpha( "darkolivegreen", 0.5) })
 * }
 * ```
 * @param c Color value as either a number or a named color
 * @param a Alpha channel value
 */
const alpha = (c, a) => ({ fn: "alpha", c, a });
const alpha2s = (c, a) => {
    // if the alpha is 0, return transparent color
    if (a === 0)
        return "#0000";
    // convert color to numeric value (if it's not a number yet). If the color was given as a
    // string that we cannot find in the Colors object, return pure white.
    let n = typeof c === "string" ? Colors[c] : c;
    if (n == null)
        return "#FFF";
    // negative and positive values of alpha are treated identically, so convert to positive
    if (a < 0)
        a = -a;
    // convert alpha to a number with absolute value less than 1 (if it is not yet). If alpha
    // is 1 or 100, then set it to 0 because 0 in the colorNumberToString means "no alpha".
    a = a === 1 || a >= 100 ? 0 : a > 1 ? a / 100 : a;
    // make the new alpha
    return colorNumber2s(n >= 0 ? n + a : n - a);
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.alpha = (v) => alpha2s(v.c, v.a);


/***/ }),

/***/ "./lib/api/ColorTypes.js":
/*!*******************************!*\
  !*** ./lib/api/ColorTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/CoreAPI.js":
/*!****************************!*\
  !*** ./lib/api/CoreAPI.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selector": () => (/* binding */ selector),
/* harmony export */   "sel": () => (/* binding */ sel),
/* harmony export */   "nstag": () => (/* binding */ nstag),
/* harmony export */   "steps": () => (/* binding */ steps),
/* harmony export */   "cubicBezier": () => (/* binding */ cubicBezier),
/* harmony export */   "media": () => (/* binding */ media),
/* harmony export */   "supports": () => (/* binding */ supports),
/* harmony export */   "raw": () => (/* binding */ raw),
/* harmony export */   "url": () => (/* binding */ url),
/* harmony export */   "cursor": () => (/* binding */ cursor),
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "counter": () => (/* binding */ counter),
/* harmony export */   "counters": () => (/* binding */ counters),
/* harmony export */   "usevar": () => (/* binding */ usevar)
/* harmony export */ });
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Selector functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns a string representation of a selector. This function is a tag function and must be
 * invoked with the template string without parentheses. This function can be used wherever the
 * [[CssSelector]] types are allowed. The parameters embedded into the string
 * must conform to the [[CssSelector]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     // css: ul > li {...}
 *     s1 = this.$style( css.selector`ul > li`, {...})
 *
 *     // css: ul.c1:hover {...}
 *     c1 = this.$class({...})
 *     s2 = this.$style( css.selector`ul.${this.c1}:hover`, {...})
 * }
 * ```
 */
const selector = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.tag2s)(parts, params);
/**
 * Array of attribute comparison operation strings - needed to check whether a string is an
 * attribute comparison operation.
 */
const attrComparisonOperations = ["=", "~=", "|=", "^=", "$=", "*="];
// SelectorProcessingInfo object that used several times, so it is "cached" here
const pseudoClassWithSelectorsInfo = { f: wrapAndAddSelectors, a: [","], p: ":" };
/**
 * Object containing information about how properties and methods of the ISelectorBuilder interface
 * should be converted to CssSelector values. If a name of the property is not in this object, it
 * is treated as a non-parameterized pseudo class.
 */
const selectorInfos = {
    // helper methods
    "attr": addAttrSelector,
    "and": { f: addSelectorsWithCombinators, a: [""] },
    "or": { f: addSelectorsWithCombinators, a: [","] },
    "child": { f: addSelectorsWithCombinators, a: [">"] },
    "desc": { f: addSelectorsWithCombinators, a: [" "] },
    "sib": { f: addSelectorsWithCombinators, a: ["~"] },
    "adj": { f: addSelectorsWithCombinators, a: ["+"] },
    // simple pseudo elements
    "after": 1 /* SimplePseudoElement */,
    "backdrop": 1 /* SimplePseudoElement */,
    "before": 1 /* SimplePseudoElement */,
    "cue": 1 /* SimplePseudoElement */,
    "firstLetter": 1 /* SimplePseudoElement */,
    "firstLine": 1 /* SimplePseudoElement */,
    "grammarError": 1 /* SimplePseudoElement */,
    "marker": 1 /* SimplePseudoElement */,
    "placeholder": 1 /* SimplePseudoElement */,
    "selection": 1 /* SimplePseudoElement */,
    "spellingError": 1 /* SimplePseudoElement */,
    // parameterized pseudo classes
    "dir": 2 /* ParameterizedPseudoClass */,
    // "has": pseudoClassWithSelectorsInfo,
    "host$": { f: wrapAndAddSelectors, a: [","], p: ":", n: ":host" },
    "hostContext": pseudoClassWithSelectorsInfo,
    "is": pseudoClassWithSelectorsInfo,
    "lang": 2 /* ParameterizedPseudoClass */,
    "not": pseudoClassWithSelectorsInfo,
    "nthChild": addNthPseudoClass,
    "nthLastChild": addNthPseudoClass,
    "nthOfType": addNthPseudoClass,
    "nthLastOfType": addNthPseudoClass,
    "where": pseudoClassWithSelectorsInfo,
    // parameterized pseudo elements
    "part": 3 /* ParameterizedPseudoElement */,
    "slotted": { f: wrapAndAddSelectors, a: [","], p: "::" },
};
/**
 * Proxy handler that serves as an implementation of the ISelectorBuilder interface.
 */
class SelectorBuilderHandler {
    constructor(items) {
        this.items = [];
        this.items = items;
    }
    get(t, propName, r) {
        if (typeof propName !== "string")
            return undefined;
        // the following makes our object to implement the ISelectorFunc interface
        if (propName === "fn")
            return "sel";
        else if (propName === "items")
            return this.items;
        let info = selectorInfos[propName];
        if (!info)
            return pushSelector.call(this, pseudoCamelTodDash(":", propName));
        else if (info === 1 /* SimplePseudoElement */)
            return pushSelector.call(this, pseudoCamelTodDash("::", propName));
        else if (info === 2 /* ParameterizedPseudoClass */)
            return addParameterizedPseudoEntity.bind(this, pseudoCamelTodDash(":", propName));
        else if (info === 3 /* ParameterizedPseudoElement */)
            return addParameterizedPseudoEntity.bind(this, pseudoCamelTodDash("::", propName));
        else if (typeof info === "function")
            return info.bind(this, propName);
        else {
            propName = info.n ?? (info.p ? pseudoCamelTodDash(info.p, propName) : propName);
            return info.f.bind(this, propName, ...info.a);
        }
    }
    ownKeys(t) { return SelectorBuilderHandler.keys; }
    has(t, p) { return SelectorBuilderHandler.keys.includes(p); }
}
// array of keys that are considered "own": these are the keys from the ISelectorFunc interface
SelectorBuilderHandler.keys = ["fn", "items"];
// adds an attribute selector
function addAttrSelector(propName, attrName, p2, p3, p4, p5) {
    return pushSelector.call(this, attrComparisonOperations.includes(p2)
        ? { fn: "attr-sel", name: attrName, val: p3, op: p2, cf: p4, ns: p5 }
        : { fn: "attr-sel", name: attrName, val: p2, cf: p3, ns: p4 });
}
// Pushes a selector for the given parameterized pseudo entity to the list of items
function addParameterizedPseudoEntity(entity, param) {
    return pushSelector.call(this, { fn: entity, p: param });
}
// Adds the given selectors intermingled with the given combinator to the list of items.
function addSelectorsWithCombinators(entity, combinator, ...newItems) {
    return pushSelectorsWithCombinators.call(this, combinator, true, ...newItems);
}
// Wraps the given selectors with the invocation of the given pseudo entity and pushes them
// to the list of items
function wrapAndAddSelectors(name, combinator, ...newItems) {
    this.items.push(name + "(");
    pushSelectorsWithCombinators.call(this, combinator, false, ...newItems);
    this.items.push(")");
    return this.proxy;
}
// Pushes the "nth" pseudo class with the given parameters to the list of items
function addNthPseudoClass(propName, p1, p2) {
    return pushSelector.call(this, { fn: pseudoCamelTodDash(":", propName), p: p2 != null ? [p1, p2] : p1 });
}
// Pushes the given selectors intermingled with the given combinator to the list of items. The
// "insertBefore" parameter indicates whether the combinator should be inserted before the first
// selector item.
function pushSelectorsWithCombinators(combinator, insertBefore, ...newItems) {
    if (insertBefore && combinator)
        this.items.push(combinator);
    for (let i = 0; i < newItems.length; i++) {
        if (i > 0 && combinator)
            this.items.push(combinator);
        this.items.push(newItems[i]);
    }
    return this.proxy;
}
// Pushes the given argument to the list of items
function pushSelector(item) {
    this.items.push(item);
    return this.proxy;
}
// combines the given prefix with the pseudo entity camel name converted to dash form
const pseudoCamelTodDash = (prefix, name) => prefix + (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.camelToDash)(name);
/**
 * Creates selector builder object that provides means to build complex selectors from multiple
 * selector items of all possible kinds including tags, classess, IDs, attributes, pseudo classes
 * and pseudo elements combined with CSS combinators. This function returns the [[ISelectorBuilder]]
 * interface, which has methods and properties for all selector items.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     cls = this.$class({...})
 *     myID = this.$id({...})
 *
 *     // produces CSS: label.cls1[for="myID"]:hover {...}
 *     s1 = this.$style( css.sel("label").and(this.cls1)).attr("for", this.myID).hover, {...})
 * }
 * ```
 * @param items List of selector items to initialize the complex selector. If multiple items are
 * specified, they are treated as list; that is, they are combined with the `","` combinator.
 * @returns
 */
const sel = (...items) => {
    let handler = new SelectorBuilderHandler(items);
    let proxy = new Proxy({}, handler);
    // the handler should reference the proxy in order to return it from methods (and properties)
    // to allow chain calls.
    handler.proxy = proxy;
    return proxy;
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.fdo.sel = v => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.a2s)(v.items, { sep: "", recursive: true }, "");
/**
 * Creates a new selector for the given element tags with the given namespace prefix. The
 * `ns` parameter specifies the namespace prefix as either a string or a reference to the
 * namespace rule. The `tags` parameter specifies either a single tag or an array of tags. In
 * addition, an asterisk symbol (`"*"`) can be specified to target all elements.
 *
 * When multiple tags are specified, they will be combied using the selector combinators
 * specified by the `comb` parameter.
 *
 * **Examples:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     // define HTML as default namespace and "svg" as a prefix for SVG namespace
 *     htmlNS = this.$namespace( css.WebNamespaces.HTML)
 *     svgNS = this.$namespace( css.WebNamespaces.SVG, "svg")
 *
 *     // produces CSS "svg|a {}", which will match only SVG `<a>` elements
 *     rule1 = this.$style( css.nstag( this.svgNS, "a"), {})
 *
 *     // produces CSS "*|a {}", which will match both HTML and SVG `<a>` elements
 *     rule2 = this.$style( css.nstag( "*", "a"), {})
 *
 *     // produces CSS "svg|circle, svg|ellipse {}"
 *     rule3 = this.$style( css.nstag( this.svgNS, ["circle", "ellipse"]), {})
 * }
 * ```
 *
 * @param ns Namespace prefix string or reference to a namespace rule. This can also be `"*"`,
 * in which case tags of all naespaces are selected
 * @param tags One or more element tag names.
 * @param comb Optional selector combinator if more than one tag is given. Default is `","`.
 * @returns Object representing parameters from which namespaced tag selector is created.
 */
const nstag = (ns, tags, comb = ",") => ({ fn: "nstag", ns, tags, comb });
_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.fdo.nstag = (v) => {
    let prefix = typeof v.ns === "string" ? v.ns + "|" : v.ns.prefix ? v.ns.prefix + "|" : "";
    return typeof v.tags === "string" ? prefix + v.tags : v.tags.map(tag => prefix + tag).join(v.comb);
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Animation and transition timing functions.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns a function representing an invocation of the CSS `steps()` function.
 *
 * @category Transition and Animation
 */
const steps = (n, j) => ({ fn: "steps", n, j });
_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.fdo.steps = ["n", "j"];
/**
* Returns a function representing an invocation of the CSS `cubic-bezier()` function.
*
* @category Transition and Animation
*/
const cubicBezier = (n1, n2, n3, n4) => ({ fn: "cubic-bezier", n1, n2, n3, n4 });
_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.fdo["cubic-bezier"] = ["n1", "n2", "n3", "n4"];
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// @media and @supports queries.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Tag function that represents a media query. This function allows expressing media queries in
 * a natural string form while embedding media feature values in type safe manner. The string can
 * contain any media expressions while the embedded objects must be of type [[IMediaFeatureset]].
 * Multiple features in the feature set will be expanded into clauses combined with the "and"
 * operator.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends StyleDefinition
 * {
 *     // screen and (min-width: 400px) and (max-width: 600px) and (orientation: portrait)
 *     ifNarrowDevice = this.$media(
 *         css.media`screen and ${{width:[400,600], orientation: "portrait"}}`, ...)
 * }
 * ```
 */
const media = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.tag2s)(parts, params, v => typeof v === "string" ? v : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_1__.media2s)(v));
/**
 * Tag function that represents a supports query. This function allows expressing supports
 * queries in a natural string form while embedding media feature values in type safe manner. The
 * string can contain any supports expressions while the embedded objects must be of type
 * Styleset. Multiple properties in the styleset will be expanded into clauses combined with the
 * "or" operator.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends StyleDefinition
 * {
 *     // not (transform-origin: 30px 30px 30px)
 *     ifNoTransformOrigin = this.$supports(
 *         css.supports`not (${{transform-origin: [30, 30, 30]}})`, ...)
 * }
 * ```
 */
const supports = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.tag2s)(parts, params, v => typeof v === "string" ? v : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_1__.supports2s)(v));
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * The `raw` function allows specifying arbitrary text for properties whose type normally doesn't
 * allow strings.This function is a tag function and must be invoked with the template string
 * without parentheses. The `raw` function can be used for any style property. Note, however, that
 * no validation checks are performed on the structure of the string. If the string isn't valid
 * for the style property, the property will not become part of the style rule inserted into the
 * DOM.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     poly = this.$class({
 *         clipPath: css.raw`polygon(50% 20%, 90% 80%, 10% 80%)`
 *     })
 * }
 * ```
 */
const raw = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.tag2s)(parts, params);
/**
 * Returns a function representing the CSS `url()` function. The string parameter
 * will be wrapped in a `url()` invocation. The function can also accept the IIDRule object to
 * create url(#element) invocation, which is often used to address SVG elements by their IDs.
 */
const url = (p) => ({ fn: "url", p });
_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.fdo.url = [["p", { str: 23 /* Quoted */ }]];
// Implementation
function cursor(url, x, y) {
    return { fn: "cursor", url, x, y };
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.fdo.cursor = (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.mv2s)([url(v.url), v.x, v.y]);
/**
 * Returns a function representing the `attr()` CSS function. It returns [[IStringProxy]] and
 * theoretically can be used in any style property wherever the CSS `<string>` type is accepted;
 * however, its use by browsers is currently limited to the `content` property. Also not all
 * browsers currently support type, units or fallback values.
 *
 * @param attrName Name of the attribute whose value should be returned.
 * @param typeOrUnit Optional type or unit keyword that determines the returned CSS type.
 * @param fallback Optional value that is used if the attribute is not found on the element.
 * @returns
 */
const attr = (attrName, typeOrUnit, fallback) => () => `attr(${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.mv2s)([(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.mv2s)([attrName, typeOrUnit]), fallback], ",")})`;
/**
 * Returns a representation of the CSS `counter()` function with an optional counter style.
 *
 * @param c Counter name or counter rule object
 * @returns ICounterFunc object representing the invocation of the `counter()` CSS function
 */
const counter = (counterObj, style) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.f2s)("counter", [counterObj, style]);
/**
 * Returns a representation of the CSS `counters()` function with the given separator and
 * an optional counter style.
 *
 * @param counterObj Counter name or counter rule object
 * @param sep Separator string between multiple counters
 * @param style Counter style
 * @returns ICounterFunc object representing the invocation of the `counter()` CSS function
 */
const counters = (counterObj, sep, style) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.f2s)("counters", [counterObj, [sep, 23 /* Quoted */], style]);
/**
 * Returns a function representing the invocation of the `var()` CSS function for the given custom
 * CSS property with optional fallbacks. Usually, when you want to refer to a custom CSS property
 * in style rules, it is enough to just refer to the style definition property created using the
 * [[$var]] function; however, if you want to provide a fallback value, you must use this function.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends StyleDefinition
 * {
 *     // create custom CSS property but without an assigned value; it can be assigned
 *     // later programmatically
 *     bgColor = this.$var( "color")
 *
 *     div = this.$tag( "div", {
 *         // use the custom CSS property with the given fallback value
 *         backgroundColor: css.usevar( this.bgColor, "beige")
 *     })
 * }
 * ```
 *
 * @typeparam K Key of the [[IVarTemplateStyleset]] interface that determines the type of the
 * custom CSS property and of the fallback value.
 * @param varObj Custom CSS property object created using the [[$var]] function.
 * @param fallback Fallback value that will be used if the custom CSS property isnt set.
 * @returns The `IRawProxy` callable interface, whcih allows the `usevar` function to be called
 * in any context.
 */
const usevar = (varObj, fallback) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.f2s)("var", [varObj.cssName, (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(varObj.template, fallback)]);


/***/ }),

/***/ "./lib/api/CoreTypes.js":
/*!******************************!*\
  !*** ./lib/api/CoreTypes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Basic types.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
;



/***/ }),

/***/ "./lib/api/FontTypes.js":
/*!******************************!*\
  !*** ./lib/api/FontTypes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/MediaTypes.js":
/*!*******************************!*\
  !*** ./lib/api/MediaTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/NumericAPI.js":
/*!*******************************!*\
  !*** ./lib/api/NumericAPI.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Num": () => (/* binding */ Num),
/* harmony export */   "Percent": () => (/* binding */ Percent),
/* harmony export */   "percent": () => (/* binding */ percent),
/* harmony export */   "Len": () => (/* binding */ Len),
/* harmony export */   "Q": () => (/* binding */ Q),
/* harmony export */   "ch": () => (/* binding */ ch),
/* harmony export */   "cm": () => (/* binding */ cm),
/* harmony export */   "em": () => (/* binding */ em),
/* harmony export */   "ex": () => (/* binding */ ex),
/* harmony export */   "ic": () => (/* binding */ ic),
/* harmony export */   "inch": () => (/* binding */ inch),
/* harmony export */   "lh": () => (/* binding */ lh),
/* harmony export */   "mm": () => (/* binding */ mm),
/* harmony export */   "pc": () => (/* binding */ pc),
/* harmony export */   "pt": () => (/* binding */ pt),
/* harmony export */   "px": () => (/* binding */ px),
/* harmony export */   "vb": () => (/* binding */ vb),
/* harmony export */   "vh": () => (/* binding */ vh),
/* harmony export */   "vi": () => (/* binding */ vi),
/* harmony export */   "vw": () => (/* binding */ vw),
/* harmony export */   "rem": () => (/* binding */ rem),
/* harmony export */   "rlh": () => (/* binding */ rlh),
/* harmony export */   "vmin": () => (/* binding */ vmin),
/* harmony export */   "vmax": () => (/* binding */ vmax),
/* harmony export */   "fr": () => (/* binding */ fr),
/* harmony export */   "Angle": () => (/* binding */ Angle),
/* harmony export */   "deg": () => (/* binding */ deg),
/* harmony export */   "rad": () => (/* binding */ rad),
/* harmony export */   "grad": () => (/* binding */ grad),
/* harmony export */   "turn": () => (/* binding */ turn),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "ms": () => (/* binding */ ms),
/* harmony export */   "s": () => (/* binding */ s),
/* harmony export */   "Resolution": () => (/* binding */ Resolution),
/* harmony export */   "dpi": () => (/* binding */ dpi),
/* harmony export */   "dpcm": () => (/* binding */ dpcm),
/* harmony export */   "dppx": () => (/* binding */ dppx),
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "Frequency": () => (/* binding */ Frequency),
/* harmony export */   "hz": () => (/* binding */ hz),
/* harmony export */   "khz": () => (/* binding */ khz),
/* harmony export */   "fitContent": () => (/* binding */ fitContent),
/* harmony export */   "ratio": () => (/* binding */ ratio),
/* harmony export */   "rect": () => (/* binding */ rect)
/* harmony export */ });
/* harmony import */ var _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/NumericImpl */ "./lib/impl/NumericImpl.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");


// Helper function for units conversion
const toUnitsProxy = (n, unit) => () => n + unit;
/**
 * The `Num` object contains methods that implement CSS mathematic functions on the `<number>`
 * CSS type. It implements the [[INumericMath]] interface and thus allows using the methods such
 * as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the [[CssNumber]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     // define custom CSS property - note that its value can be changed
 *     // programmatically
 *     columnQty = this.$var( "CssNumber", 3)
 *
 *     // max( 5, var(--columnQty))
 *     cls1 = this.$class({
 *         columns: css.Num.max( 5, this.columnQty)
 *     })
 * }
 * ```
 */
const Num = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.NumberMath;
/**
 * The `Percent` object contains methods that implement CSS mathematic functions on the
 * `<percentage>` CSS type. It implements the [[INumericMath]] interface and thus allows using
 * the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the
 * [[CssPercent]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     initialZoom = css.var( "CssPercent", 1.5)
 *
 *     // min( 0.5, var(--initialZoom))
 *     cls1 = this.$class({
 *         zoom: css.Percent.min( 0.5, this.initialZoom)
 *     })
 * }
 * ```
 */
const Percent = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.PercentMath;
/**
 * Creates percent value by appenfing the `"%"` sign to the given number. This function should be
 * used whenever a `<percentage>` CSS type is used for a style property or value.
 * @category Units
 */
const percent = (n) => toUnitsProxy(n, "%");
/**
 * The `Len` object contains methods that implement CSS mathematic functions on the
 * `<length> | <percentage>` CSS type. It implements the [[INumericMath]] interface and thus
 * allows using the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters
 * of the [[CssLength]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     defaultPadding = css.var( "CssLength", 8)
 *
 *     // calc( 200px - (2 * var(--defaultPadding)))
 *     cls1 = this.$class({
 *         width: css.Len.calc` 200px - (2 * ${this.defaultPadding})`
 *     })
 * }
 * ```
 */
const Len = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.LengthMath;
/**
 * Creates length value in quarters of an inch.
 * @category Units
 */
const Q = (n) => toUnitsProxy(n, "Q");
/**
 * Creates length value in ch units, which is equal to the used advance measure of the `“0”` (ZERO,
 * U+0030) glyph found in the font used to render it. (The advance measure of a glyph is its
 * advance width or height, whichever is in the inline axis of the element.)
 * @category Units
 */
const ch = (n) => toUnitsProxy(n, "ch");
/**
 * Creates length value in cantimeters.
 * @category Units
 */
const cm = (n) => toUnitsProxy(n, "cm");
/**
 * Creates length value in calculated font-sizes of the element.
 * @category Units
 */
const em = (n) => toUnitsProxy(n, "em");
/**
 * Creates length value in heights of lowercase letter 'x' in the font.
 * @category Units
 */
const ex = (n) => toUnitsProxy(n, "ex");
/**
 * Creates length value in ic units.
 * @category Units
 */
const ic = (n) => toUnitsProxy(n, "ic");
/**
 * Creates length value in inches.
 * @category Units
 */
const inch = (n) => toUnitsProxy(n, "in");
/**
 * Creates length value in line-heights of the element.
 * @category Units
 */
const lh = (n) => toUnitsProxy(n, "lh");
/**
 * Creates length value in millimeters.
 * @category Units
 */
const mm = (n) => toUnitsProxy(n, "mm");
/**
 * Creates length value in picas.
 * @category Units
 */
const pc = (n) => toUnitsProxy(n, "pc");
/**
 * Creates length value in points.
 * @category Units
 */
const pt = (n) => toUnitsProxy(n, "pt");
/**
 * Creates length value in pixels.
 * @category Units
 */
const px = (n) => toUnitsProxy(n, "px");
/**
 * Creates length value in 1% of the size of the initial containing block, in the direction
 * of the root element’s block axis.
 * @category Units
 */
const vb = (n) => toUnitsProxy(n, "vb");
/**
 * Creates length value in 1% of the height of the viewport's initial containing block.
 * @category Units
 */
const vh = (n) => toUnitsProxy(n, "vh");
/**
 * Creates length value in 1% of the size of the initial containing block, in the direction
 * of the root element’s inline axis.
 * @category Units
 */
const vi = (n) => toUnitsProxy(n, "vi");
/**
 * Creates length value in 1% of the width of the viewport's initial containing block.
 * @category Units
 */
const vw = (n) => toUnitsProxy(n, "vw");
/**
 * Creates length value in font-sizes of the root element (<html>).
 * @category Units
 */
const rem = (n) => toUnitsProxy(n, "rem");
/**
 * Creates length value in line-heights of the root element (<html>).
 * @category Units
 */
const rlh = (n) => toUnitsProxy(n, "rlh");
/**
 * Creates length value in the units which are a smaller value between vw and vh.
 * @category Units
 */
const vmin = (n) => toUnitsProxy(n, "vmin");
/**
 * Creates length value in the units which are a larger value between vw and vh.
 * @category Units
 */
const vmax = (n) => toUnitsProxy(n, "vmax");
/**
 * Creates length value for flex.
 * @category Units
 */
const fr = (n) => toUnitsProxy(n, "fr");
/**
 * The `Angle` object contains methods that implement CSS mathematic functions on the
 * `<angle> | <percentage>` CSS type. It implements the [[INumericMath]] interface and thus
 * allows using the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters
 * of the [[CssAngle]] type.
 */
const Angle = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.AngleMath;
/**
 * Creates angle value in degrees.
 * @category Units
 */
const deg = (n) => toUnitsProxy(n, "deg");
/**
 * Creates angle value in radians.
 * @category Units
 */
const rad = (n) => toUnitsProxy(n, "rad");
/**
 * Creates angle value in gradians.
 * @category Units
 */
const grad = (n) => toUnitsProxy(n, "grad");
/**
 * Creates angle value in turns.
 * @category Units
 */
const turn = (n) => toUnitsProxy(n, "turn");
/**
 * The `Time` object contains methods that implement CSS mathematic functions on the `<time>`
 * CSS type. It implements the [[INumericMath]] interface and thus allows using the methods such
 * as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the [[CssTime]] type.
 */
const Time = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.TimeMath;
/**
* Creates time value in milliseconds.
* @category Units
*/
const ms = (n) => toUnitsProxy(n, "ms");
/**
 * Creates time value in seconds.
 * @category Units
 */
const s = (n) => toUnitsProxy(n, "s");
/**
 * The `Resolution` object contains methods that implement CSS mathematic functions on the
 * `<resolution>` CSS type. It implements the [[INumericMath]] interface and thus allows using
 * the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the
 * [[CssResolution]] type.
 */
const Resolution = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.ResolutionMath;
/**
* Creates resolution value in DPI.
* @category Units
*/
const dpi = (n) => toUnitsProxy(n, "dpi");
/**
 * Creates resolution value in DPCM.
 * @category Units
 */
const dpcm = (n) => toUnitsProxy(n, "dpcm");
/**
 * Creates resolution value in DPPX.
 * @category Units
 */
const dppx = (n) => toUnitsProxy(n, "dppx");
/**
 * Creates resolution value in X.
 * @category Units
 */
const x = (n) => toUnitsProxy(n, "x");
/**
 * The `Frequency` object contains methods that implement CSS mathematic functions on the `<frequency>`
 * CSS type. It implements the [[INumericMath]] interface and thus allows using the methods such
 * as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the [[CssFrequency]] type.
 */
const Frequency = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.FrequencyMath;
/**
* Creates frequency value in Hertz.
* @category Units
*/
const hz = (n) => toUnitsProxy(n, "hz");
/**
 * Creates frequency value in Kilo-Hertz.
 * @category Units
 */
const khz = (n) => toUnitsProxy(n, "khz");
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an [[IFitContentProxy]] function representing the `fit-content()` CSS function
 * ([MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/fit-content())).
 */
const fitContent = (size) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.f2s)("fit-content", [[size, 3 /* Length */]]);
/**
 * Returns an [[IAspectRatioProxy]] function representing the `<ratio>` CSS type.
 */
const ratio = (w, h) => () => [w, h].join("/");
/**
 * Returns an [[IRectProxy]] function representing the `rect()` CSS function used for the `clip`
 * style property.
 * @deprecated The CSS `clip` property and `rect()` function are deprecated.
 */
const rect = (top, right, bottom, left) => () => `rect(${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.a2s)([top, right, bottom, left], 3 /* Length */, ",")})`;


/***/ }),

/***/ "./lib/api/NumericTypes.js":
/*!*********************************!*\
  !*** ./lib/api/NumericTypes.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
;
;
;
;
;
;
;



/***/ }),

/***/ "./lib/api/RuleAPI.js":
/*!****************************!*\
  !*** ./lib/api/RuleAPI.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleDefinition": () => (/* binding */ StyleDefinition),
/* harmony export */   "embedded": () => (/* binding */ embedded),
/* harmony export */   "configNameGeneration": () => (/* binding */ configNameGeneration),
/* harmony export */   "classes": () => (/* binding */ classes),
/* harmony export */   "chooseClass": () => (/* binding */ chooseClass),
/* harmony export */   "virtual": () => (/* binding */ virtual),
/* harmony export */   "ThemeDefinition": () => (/* binding */ ThemeDefinition),
/* harmony export */   "activate": () => (/* binding */ activate),
/* harmony export */   "deactivate": () => (/* binding */ deactivate),
/* harmony export */   "getActiveTheme": () => (/* binding */ getActiveTheme),
/* harmony export */   "startSSR": () => (/* binding */ startSSR),
/* harmony export */   "stopSSR": () => (/* binding */ stopSSR),
/* harmony export */   "startHydration": () => (/* binding */ startHydration),
/* harmony export */   "stopHydration": () => (/* binding */ stopHydration)
/* harmony export */ });
/* harmony import */ var _rules_Rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules/Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules/RuleContainer */ "./lib/rules/RuleContainer.js");
/* harmony import */ var _rules_StyleRules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rules/StyleRules */ "./lib/rules/StyleRules.js");
/* harmony import */ var _rules_AnimationRule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules/AnimationRule */ "./lib/rules/AnimationRule.js");
/* harmony import */ var _rules_VarRule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules/VarRule */ "./lib/rules/VarRule.js");
/* harmony import */ var _rules_CounterRules__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rules/CounterRules */ "./lib/rules/CounterRules.js");
/* harmony import */ var _rules_GridRules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rules/GridRules */ "./lib/rules/GridRules.js");
/* harmony import */ var _rules_MiscRules__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../rules/MiscRules */ "./lib/rules/MiscRules.js");
/* harmony import */ var _rules_GroupRules__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rules/GroupRules */ "./lib/rules/GroupRules.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");











/**
 * The `StyleDefinition` class is a base for all classes that contain defininitions of CSS rules.
 * Style definition classes are regular TypeScript classes and as such can have any fields and
 * methods - both instance and static. Normally, however, they contain instance properties
 * initialized with functions returning style rules and at-rules, such as [[$class]],
 * [[$tag]], [[$media]], [[$counter]] and others.
 *
 * **Examples**
 *
 * ```typescript
 * // top-level style definition class
 * class MyStyles extends css.StyleDefinition
 * {
 *     cls = this.$class({ color: "red"})
 *
 *     // using style-definition class for @media rule
 *     ifNarrowScreen = this.$media( { maxWidth: 800 },
 *         class extends css.StyleDefinition<MyStyles>
 *         {
 *             cls = this.$class({ color: "pink"})
 *         }
 *     )
 * }
 * ```
 *
 * @typeparam P Parent style definition class. Parent of a top-level class is null.
 */
class StyleDefinition {
    /**
     * Style definition instances are created directly only by the *styled components* - that is,
     * components that use different styles for each instance. Otherwise, style definition
     * instances are created when either the [[$use]] method or [[activate]] function is called.
     * @param parent Reference to the parent style definition class
     */
    constructor(parent) {
        this.$parent = parent;
        // Style Definition instance points to rule container
        let rc = new _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.RuleContainer(this);
        this[_rules_Rule__WEBPACK_IMPORTED_MODULE_0__.symRC] = rc;
        // instead of returning an instance of our class, the constructor returns a proxy. This
        // allows creating proxies for all properties defined in the class.
        return new Proxy(this, rc);
    }
    /**
     * Creates a new abstract rule, which defines a styleset that can be extended by other style rules.
     * Abstract rules don't have selectors and are not inserted into the DOM. Abstract rules can
     * themselves extend other rules - both abstract and non-abstract.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     colorBox = this.$abstract({
     *         backgroundColor: "orange",
     *         borderRadius: css.percent(10),
     *         border: [4, "solid", "red"],
     *         ":hover": {
     *             opacity: 0.7
     *         }
     *     })
     *
     *     box = this.$class({
     *         "+": this.colorBox,
     *         width: 200,
     *         height: 200,
     *     })
     *
     *     specialElm = this.$id({
     *         "+": this.colorBox,
     *         width: 600,
     *         height: 400,
     *     })
     * }
     * ```
     *
     * @param styleset One or more styleset objects that will be inherited by style rules that
     * extend this abstract rule.
     * @returns `IStyleRule` object that should be used by the derived rules in the `"+"` property.
     */
    $abstract(styleset) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_2__.AbstractRule(this, styleset);
    }
    /**
     * Creates a new class rule. The class name will be created when the rule is processed as part of
     * the style definition class. The name can be also overridden by providing either an explicit
     * name or another class rule. The function can be called without parameters just to "declare"
     * the class. Such class can be later used either in conditional grouping rules or in derived
     * style definition classes.
     *
     * The returned [[IClassRule]] interface has the `name` property that should be used to assign
     * the class to an HTML element
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     vbox = this.$class({
     *         display: "flex",
     *         flexDirection: "column",
     *         alignItems: "center"
     *     })
     * }
     * ...
     * let styles = css.activate( MyClasses);
     * ...
     * render
     * {
     *     return <div class={styles.vbox.name}>
     *         <span>Hello</span>
     *         <span>World!</span>
     *     </div>
     * }
     * ```
     *
     * @param styleset One or more styleset objects that define style properties of the class.
     * @param nameOverride string or another `IClassRule` object that determines the name of the
     * class. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the class to match a name
     * of another, probably external, class. If this parameter is defined as a string, it should
     * not have the `"."` prefix.
     * @returns `IClassRule` object that should be used for getting the class name and for accessing
     * the style properties if needed.
     */
    $class(styleset, nameOverride) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_2__.ClassRule(this, styleset, nameOverride);
    }
    /**
     * Creates a new class name rule, which combines one or more other class names. This creates a
     * "synonym" that is easier to apply to an element's class attribute than an array of two or
     * more class rules.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // declare class - just to be used later
     *     spaced = css.class({gap: 8})
     *
     *     vbox = this.$class({
     *         display: "flex",
     *         flexDirection: "column"
     *     })
     *
     *     // use $classname rule to combine the names of classes vbox and spaced
     *     spacedVbox = this.$classname( this.vbox, this.spaced)
     * }
     * ...
     * let styles = css.activate( MyClasses);
     * ...
     * render
     * {
     *     // without spacedVbox, the class would be: {[styles.vbox.name, styles.spaced.name]}
     *     return <div class={styles.spacedVbox.name}>
     *         <span>Hello</span>
     *         <span>World!</span>
     *     </div>
     * }
     * ```
     *
     * @param ...classes List of class names specified either as a string or [[IClassRule]] or
     * [[IClassNameRule]] objects.
     * @returns `IClassNameRule` object whose `name` property contains the combined class name, e.g.
     * `"class1 class2"`. The `cssClassName` property contains the combined selector, e.g.
     * `".class1.class2"`.
     */
    $classname(...classes) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_7__.ClassNameRule(this, classes);
    }
    /**
     * Creates a new ID rule. The ID name will be created when the rule is processed as part of
     * the style definition class. The name can be also overridden by providing either an explicit
     * name or another ID rule. The function can be called without parameters just to "declare"
     * the ID. Such ID can be later used either in conditional grouping rules or in derived
     * style definition classes.
     *
     * The returned [[IIDRule]] interface has the `name` property that should be used to assign
     * the ID to an HTML element.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     container = this.$id({
     *         display: "flex",
     *         flexDirection: "column",
     *         alignItems: "center"
     *     })
     * }
     * ...
     * let styles = css.activate( MyClasses);
     * ...
     * render
     * {
     *     return <div id={styles.container.name}>
     *         <span>Hello</span>
     *         <span>World!</span>
     *     </div>
     * }
     * ```
     *
     * @param styleset One or more styleset objects that define style properties of the element.
     * @param nameOverride string or another `IIDRule` object that determines the name of the ID.
     * If this optional parameter is defined, the name will override the Mimcss name assignment
     * mechanism. This might be useful if there is a need for the ID to match a name of another ID.
     * If this parameter is defined as a string, it should not have the `"."` prefix.
     * @returns `IIDRule` object that should be used for getting the ID name and for accessing
     * the style properties if needed.
     */
    $id(styleset, nameOverride) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_2__.IDRule(this, styleset, nameOverride);
    }
    /**
     * Creates a new style rule for the given HTML or SVG element tags. The `tag` parameter specifies
     * either a single tag or an array of tags. In addition, an asterisk symbol (`"*"`) can be
     * specified to target all elements.
     *
     * When multiple tags are specified, they will be treated as a selector list; that is, they will
     * be separated by commas.
     *
     * **Examples:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // using string for selecting a single elemenet tag;
     *     // produces CSS "tr {}"
     *     tr = this.$tag( "tr", {})
     *
     *     // using array for selecting multiple elemenet tags;
     *     // produces CSS "h1, h2, h3 {}"
     *     header123 = this.$tag( ["h1", "h2", "h3"], {})
     *
     *     // using asterisk to address all elements
     *     // produces CSS "* {}"
     *     all = this.$tag( "*", {})
     * }
     * ```
     *
     * @param tag One or more element tags
     * @param styleset One or more styleset objects that define style properties for the tags.
     * @returns `IStyleRule` object representing the tag rule.
     */
    $tag(tag, styleset) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_2__.SelectorRule(this, Array.isArray(tag) ? tag.join(",") : tag, styleset);
    }
    /**
     * Creates a new style rule with an arbitrary complex selector. Selectors can be specified as
     * one or array of [[SelectorItem]] objects where each `SelectorItem` is one of the following
     * types:
     * - string - allows any content but lacks type-safety checks.
     * - any style rule, that is a rule that implements the [[IStyleRule]] interface. This allows
     *   using prevously defined tag, class, ID and other style rules as selector items
     * - [[selector]] function - a tag function that allows convenient mixing of free-format strings
     *   and strongly typed style rules.
     *
     * When multiple selector items are specified, they will be concatenated into a single string.
     *
     * Note that although style rules can be used for selecting element tags, the [[$tag]] function would
     * be more appropriate because it will catch misspellings of tag names.
     *
     * **Examples:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // using a string
     *     style1 = this.$style( "li::before", {})
     *
     *     id = this.$id()
     *     cls = this.$class()
     *
     *     // using an array of style rules. The selector will be "#id.cls"
     *     style2 = this.$style( [this.id, this.cls], {})
     *
     *     // using the selector function. The selector will be "#id > .cls"
     *     style3 = this.$style( css.selector`${this.id} > ${this.cls}`, {})
     *
     *     // using a string for selecting element tag.
     *     h1 = this.$style( "h1", {})
     * }
     * ```
     *
     * @param selector Style rule selector
     * @param styleset One or more styleset objects that define style properties for this selector.
     * @returns `IStyleRule` object representing the style rule.
     */
    $style(selector, styleset) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_2__.SelectorRule(this, selector, styleset);
    }
    /**
     * Creates new animation rule. The animation name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another animation rule. The function can be called without parameters just to
     * "declare" the animation. Such animation can be later used either in conditional grouping rules
     * or in derived style definition classes.
     *
     * The returned [[IAnimationRule]] interface represents an object that should be used when
     * using the keyframes name in the `animation-name` or `animation` style properties.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     vanish = this.$keyframes([
     *         [0, { opacity: 100 }],
     *     	   [100, { opacity: 0 }],
     *     ])
     *
     *     vanishingBlock = this.$class({
     *         animation: { name: this.vanish, duration: 2000, count: "infinite", direction: "alternate" }
     *     })
     * }
     * ```
     *
     * @param frames Array of [[AnimationFrame]] objects. Each animation frame contains a waypoint
     * and a styleset.
     * @param nameOverride String or another `IAnimationRule` object that determines the name of the
     * animation. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * another animation.
     * @returns `IAnimationRule` object that should be used for getting the animation name.
     */
    $keyframes(frames, nameOverride) {
        return new _rules_AnimationRule__WEBPACK_IMPORTED_MODULE_3__.AnimationRule(this, frames, nameOverride);
    }
    /**
     * Creates new custom variable object that defines a custom CSS property. The variable name will
     * be created when the rule is processed as part of the style definition class. The name can be
     * also overridden by providing either an explicit name or another custom variable rule. The
     * function can be called without specifying the value just to "declare" the variable. Such
     * variable can be later used either in conditional grouping rules or in derived style definition
     * classes.
     *
     * Custom properties defined using the `$var` function are included into the `:root {}` block;
     * however, they can be redefined with different values under any style rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // define and use custom CSS property
     *     importantTextColor = this.$var( "color", "red")
     *     important = this.$class({
     *         color: this.importantTextColor
     *     })
     *
     *     // use different value for the custom property under another CSS class
     *     special = this.$class({
     *         "+": this.important,
     *         "--": [ [this.importantTextColor, "maroon"] ]
     *     })
     * }
     * ```
     *
     * @param template Either a name of a style property (in camel-case) or a name of the property from
     * the [[IVarTemplateStyleset]] interface. The type corresponding to this property defines the type
     * of the second parameter.
     * @param value The value assigned to the property.
     * @param nameOverride String or another `IVarRule` object that determines the name of the
     * custom property. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing property. If this parameter is defined as a string, it should not have the `"."` prefix.
     * @returns The `IVarRule` object that represents the custom property. Any usage of this object in
     * style properties or function parameters is substituted by the `var()` CSS function invocation.
     */
    $var(template, value, nameOverride) {
        return new _rules_VarRule__WEBPACK_IMPORTED_MODULE_4__.VarRule(this, template, value, nameOverride);
    }
    // implementation
    $property(syntax, initValue, inherits = true, nameOverride) {
        return new _rules_VarRule__WEBPACK_IMPORTED_MODULE_4__.PropertyRule(this, syntax, initValue, inherits, nameOverride);
    }
    /**
     * Creates a "constant" that can be used anywhere the type defined by the `template` parameter can
     * be used. They are called constants, because they provide a convenient and lightweight way of
     * defining values that are unchanged during the application lifetime. Although constants are
     * defined very similarly to custom properties (see the [[$var]] function), they cannot participate
     * in the cascade and cannot be redefined under style rules. Constant can use any expression that
     * satisfies the type defined by the `template` parameter including other constants, custom
     * properties and functions.
     *
     * No CSS rules are created for constants and, due to this fact, constants are preferable to custom
     * properties unless the intention is to change the variable value at run-time or to redefine its
     * value under different style rules.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // defining and using custom CSS property
     *     defaultTextColor = this.$const( "color", "red")
     *     para = this.$style( "p", {
     *         color: this.defaultTextColor
     *     })
     * }
     * ```
     *
     * @param template Either a name of a style property (in camel-case) or a name of the property from
     * the [[IVarTemplateStyleset]] interface. The type corresponding to that property defines the type
     * of the second parameter.
     * @param value The value assigned to the constant.
     * @returns The `IConstRule` object that represents the value of the constant. The value is
     * computed once when the style definition is processed.
     */
    $const(template, value) {
        return new _rules_VarRule__WEBPACK_IMPORTED_MODULE_4__.ConstRule(this, template, value);
    }
    /**
     * Creates new counter object. The counter name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another counter rule.
     *
     * Counter rules don't create any CSS rules, but they create unique names that can be used
     * for `counter-reset` and `counter-increment` style properties. Counter rules are usually used
     * in conjunction with the [[counter]] and [[counters]] functions.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     counter = this.$counter()
     *     ol = this.$style( "ol", { counterReset: this.counter, listStyleType: "none" })
     *     li = this.$style( "li", {
     *         counterIncrement: this.counter,
     *         "::before": { content: css.counters( this.counter) }
     *     })
     * }
     * ```
     *
     * @param nameOverride String or another `ICounterRule` object that determines the name of the
     * counter. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing counter.
     * @returns The `ICounterRule` object that represents the counter.
     */
    $counter(nameOverride) {
        return new _rules_CounterRules__WEBPACK_IMPORTED_MODULE_5__.CounterRule(this, nameOverride);
    }
    /**
     * Creates new counter style rule. The counter style name will be created when the rule is
     * processed as part of the style definition class. The name can be also overridden by providing
     * either an explicit name or another counter style rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     counterStyle = this.$counterStyle({
     *         system: "cyclic",
     *         symbols: ["one", "two", "three"],
     *         suffix: " - "
     *     })
     * }
     * ```
     *
     * @param counterStyleset An object that defines counter style features.
     * @param nameOverride String or another `ICounterStyleRule` object that determines the name of the
     * counter style. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing counter style.
     * @returns The `ICounterStyleRule` object that represents the counter style.
     */
    $counterStyle(counterStyleset, nameOverride) {
        return new _rules_CounterRules__WEBPACK_IMPORTED_MODULE_5__.CounterStyleRule(this, counterStyleset, nameOverride);
    }
    /**
     * Creates a new grid line rule. The line name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another grid line rule. The grid line rules are used to define values of
     * style properties `grid-row-start/end` and `grid-column-start/end`.
     *
     * No CSS rule is created for grid lines - these objects are solely used for creating names, which
     * can be type-safely referred to from style rules.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     gridLineFirst = this.$gridline()
     *     gridLineLast = this.$gridline()
     *
     *     grid = this.$class({
     *         display: "grid",
     *         gridTemplateColumns: [ [this.gridLineFirst], "1fr", "2fr", [this.gridLineLast] ],
     *         gridTemplateRows: css.repeat( 2, "1fr"),
     *     })
     *
     *     first = this.$class({
     *         gridColumnStart: this.gridLineFirst,
     *     })
     *
     *     last = this.$class({
     *         gridColumnEnd: this.gridLineLast,
     *     })
     * }
     * ```
     *
     * @param nameOverride String or another `IGridLineRule` object that determines the name of the
     * line. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing grid line.
     * @param isStartEndOrNone Flag indicating whether the `"-start"` or `"-end"` suffix should be
     * appended to the rule name. If the flag is true, `"-start"` is appended; if the flag is false,
     * `"-end"` is appended; if the flag is undefined, no suffix is appended to the rule name.
     * @returns The `IGridLineRule` object that represents the grid line.
     */
    $gridline(nameOverride, isStartEndOrNone) {
        return new _rules_GridRules__WEBPACK_IMPORTED_MODULE_6__.GridLineRule(this, nameOverride, isStartEndOrNone);
    }
    /**
     * Creates a new grid area rule. The area name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another grid area rule. The grid area rules are used to define values of
     * style properties `grid-area`, `grid-row-start/end`, `grid-column-start/end` and
     * `grid-template-areas`.
     *
     * No CSS rule is created for grid areas - these objects are solely used for creating names, which
     * can be type-safely referred to from style rules.
     *
     * Every grid area defines two grid line rules in each direction, which can be accessed using the
     * [[IGridAreaRule.startLine]] and [[IGridAreaRule.endLine]] properties.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     headerArea = this.$gridarea();
     *     mainArea = this.$gridarea();
     *
     *     grid = this.$class({
     *         display: "grid",
     *         gridTemplateColumns: "1fr",
     *         gridTemplateRows: ["3em", "1fr"],
     *         gridTemplateAreas: [
     *             [this.headerArea, 1,1, 1,1],
     *             [this.mainArea, 2,1, 2,1],
     *         ],
     *     })
     *
     *     header = this.$class({
     *         gridArea: this.headerArea,
     *         backgroundColor: "blue"
     *     })
     *
     *     main = this.$class({
     *         gridArea: this.mainArea,
     *         backgroundColor: "lightgrey"
     *     })
     * }
     * ```
     *
     * @param nameOverride String or another `IGridAreaRule` object that determines the name of the
     * area. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing grid area.
     * @returns The `IGridAreaRule` object that represents the grid area.
     */
    $gridarea(nameOverride) {
        return new _rules_GridRules__WEBPACK_IMPORTED_MODULE_6__.GridAreaRule(this, nameOverride);
    }
    /**
     * Creates a new `@font-face` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     font = this.$fontface({
     *         fontFamily: "Roboto",
     *         fontStyle: "italic",
     *         fontWeight: 700,
     *         src: {url: 'roboto.woff', format: 'woff'}
     *     });
     * }
     * ```
     *
     * @param fontface Object implementing the `IFontFace` interface defining the parameter of the
     * font to use.
     * @returns The `IFontFaceRule` object that represents the @font-face rule.
     */
    $fontface(fontface) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_7__.FontFaceRule(this, fontface);
    }
    /**
     * Creates a new `@import` rule referencing the given CSS file.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     importedCssFiles = [
     *         this.$import( "common-3rdparty.css"),
     *         this.$import( "small-screen-3rdparty.css", {maxWidth: 600}),
     *     ]
     * }
     * ```
     *
     * @param url URL to the CSS file. Relative URLs are resolved relative to the base URL of the
     * page where the Mimcss library is invoked.
     * @returns The `IImportRule` object that represents the `@import` rule.
     */
    $import(url, mediaQuery, supportsQuery) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_7__.ImportRule(this, url, mediaQuery, supportsQuery);
    }
    /**
     * Creates new `@namespace` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     init = [
     *         this.$namespace( css.WebNamespaces.SVG, "svg")
     *     ]
     * }
     * ```
     *
     * @param namespace Namespace string - use the [[WebNamespaces]] for well-known namespaces.
     * @param prefix Prefix string to use for the namespace.
     * @returns The `INamespaceRule` object that represents the namespace rule.
     */
    $namespace(namespace, prefix) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_7__.NamespaceRule(this, namespace, prefix);
    }
    /**
     * Creates new `@page` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     init = [
     *         this.$page( ":first", { margin: "auto" })
     *     ]
     * }
     * ```
     *
     * @param pseudoClass Optional name of the page pseudo style.
     * @param styleset Styles to apply.
     * @returns The `IPageRule` object that represents the page rule.
     */
    $page(pseudoClass, styleset) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_2__.PageRule(this, pseudoClass, styleset);
    }
    /**
     * Creates a new `@supports` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     cls = this.$class({ color: "red"})
     *
     *     ifGridSupported = this.$media( { display: "grid" },
     *         class extends css.StyleDefinition<MyStyles>
     *         {
     *             cls = this.$class({ color: "pink"})
     *         }
     *     )
     * }
     * ```
     *
     * @param statement Supports statement containing one or more supports queries.
     * @param instOrClass Either style definition class or an instance of a style defintion class.
     * @returns `ISupportsRule` object representing the supports rule
     */
    $supports(statement, instOrClass) {
        return new _rules_GroupRules__WEBPACK_IMPORTED_MODULE_8__.SupportsRule(this, statement, instOrClass);
    }
    /**
     * Creates new `@media` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     cls = this.$class({ color: "red"})
     *
     *     ifNarrowScreen = this.$media( { maxWidth: 800 },
     *         class extends css.StyleDefinition<MyStyles>
     *         {
     *             cls = this.$class({ color: "pink"})
     *         }
     *     )
     * }
     * ```
     *
     * @param statement Media statement containing one or more media queries.
     * @param instOrClass Either style definition class or an instance of a style defintion class.
     * @returns `IMediaRule` object representing the media rule
     */
    $media(statement, instOrClass) {
        return new _rules_GroupRules__WEBPACK_IMPORTED_MODULE_8__.MediaRule(this, statement, instOrClass);
    }
    /**
     * Processes the given style definition class or instance and creates unique names for all named
     * entities. For a given style definition class only a single instance is created, no matter how
     * many times this function is invoked. However, if an instance, which has not yet been processed,
     * is passed, then a new set of unique names will be created for it.
     *
     * The `$use` function is used to reference a style definition from another style definition, for
     * example:
     *
     * ```typescript
     * class CommonStyles extends css.StyleDefinition
     * {
     *     error = this.$class({ color: "red"})
     * }
     *
     * class PageStyles extends css.StyleDefinition
     * {
     *     common = this.$use( CommonStyles)
     *
     *     erroMessage = this.$class({
     *         "+": this.common.error,
     *         fontWeight: "bold"
     *     })
     * }
     * ```
     *
     * When the `$use` function is called, the rules from the referenced style definition are not
     * inserted into the DOM; they will be inserted when the style definition class that contains
     * the `$use` call is activated. The same style definition class can be used from several
     * other style definitions: as long as there is at least one referencing style definition that
     * is activated, the rules will be in the DOM; as soon as all referencing style definitions are
     * deactivated, the rules from the referenced definition are removed from the DOM.
     *
     * @param instOrClass Either style definition class or an instance of a style definition class.
     * @returns An instance of the style definition class, which will be activated and deactivated
     * along with the enclosing style definition.
     */
    $use(instOrClass) {
        return (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.processSD)(instOrClass);
    }
}
/**
 * Decorator function for style definition classes that will be embedded into an embedding
 * container for the given category. All style definitions for a given category will be activated
 * and deactivated together and their rules will be inserted into a single `<style>` element.
 *
 * **Example:**
 * ```typescript
 * @css.embedded("widgets")
 * class FirstWidgetStyles extends css.StyleDefinition {...}
 *
 * @css.embedded("widgets")
 * class SecondWidgetStyles extends css.StyleDefinition {...}
 * ```
 */
const embedded = (category) => 
// we return the function that is the actual decorator.
_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.embeddedDecorator.bind(undefined, category);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name generation.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Sets the method uses to generate names of CSS entities. If yes, the names will be created by
 * appending a unique number to the given prefix. If the prefix is not specified, the standard
 * prefix "n" will be used.
 *
 * By default the development version of the library (mimcss.dev.js) uses the [[UniqueScoped]]
 * method and the production version (mimcss.js) uses the [[Optimized]] method. This function can
 * be called to switch to the alternative method of name generation in either the development or
 * the production builds.
 *
 * @param method Indicates what method to use.
 * @param prefix Optional string that will serve as a prefix to which unique numbers will be added
 * to generate optimized names. Ignored if the `method` parameter is anything other than
 * [[NameGenerationMethod.Optimized]].
 */
const configNameGeneration = (method, prefix) => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.configNames)(method, prefix);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Helper functions.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Concatenates the names of the given classes into a single string that can be assigned to a
 * `class` property of an HTML element. This can be useful when an element should have multiple
 * classes assigned to it and some of these classes are specified as [[IClassRule]] or
 * [[IClassNameRule]] while others are specified as strings.
 *
 * @param classProps Variable argument list of either class names or class rule objects.
 * @returns The string that combines all class names (separated with space) from the input array.
 */
const classes = (...classProps) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_9__.v2s)(classProps, {
    obj: (v) => v.name,
    item: classes
});
/**
 * Chooses the first non-empty name from the given list of classes. This is useful when an element
 * should have a single class applied to it while the class can be chosen from an ordered list or
 * hierarchy of possible choices.
 *
 * @param classProps Variable argument list of either class names or class rule objects.
 * @returns The first non-empty class name from the input array or null if all inputs are empty.
 */
const chooseClass = (...classProps) => {
    for (let classProp of classProps) {
        let name = typeof classProp === "string" ? classProp :
            Array.isArray(classProp) ? chooseClass(classProp) :
                classProp && classProp.name;
        // if non-null and non-empty name - return it
        if (name)
            return name;
    }
    return "";
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Rule virtualization and theming.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Decorator that should be applied to a rule if it is defined and used in the same style
 * definition class but then is overridden in a derived style definition class. The problem
 * this solves is this: when a rule is defined in a base class and then overridden in a derived
 * class, when an instance of the derived class is created, the rules that are created in the
 * base and derived classes see different values of the rule. Since our rules are defined as
 * part of the constructor, the base class constructor's code only sees the value assigned in that
 * code. If another rule in the base class uses this first rule, this value is remembered.
 *
 * The `@virtual` decorator creates a Proxy object for the rule with the handler that keeps the
 * most recent value set. Thus when a rule in the base class's constructor uses a virtualized
 * rule, the first rule will see the overridden value of the rule when accessed in the
 * post-constructor code.
 *
 * @deprecated This decorator is deprecated as all rules defined in style definition classes are
 * always virtualized.
 */
const virtual = (target, name) => { };
/**
 * The `ThemeDefinition` class is a base for all classes that define themes. In addition to
 * being a style definition class, themes provide some extra capabilities related to style
 * inheritance and theme activation.
 *
 * @typeparam P Parent style definition class. Parent of a top-level class is null.
 */
class ThemeDefinition extends StyleDefinition {
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Activation.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Activates the given style definition class or instance and inserts all its rules into DOM. If
 * the class is not yet associated with an instance, the instance is first created and processed.
 * Note that each style definition instance maintains a reference counter of how many times it was
 * activated and deactivated. The rules are inserted into DOM only upon first activation.
 *
 * Activating a class (as opposed to activating a directly created instance) is intended for
 * "global" CSS entities - that is, entities that are used throughout the application or
 * application area. No matter how many times a class is activated or how many times it is used
 * from other style definitions, a single instance is created and used by Mimcss.
 *
 * **Example**
 * ```typescript
 * class CommonStyles extends css.StyleDefinition
 * {
 *     red = this.$class({ color: red })
 * }
 *
 * class MyComponent
 * {
 *     private styles: CommonStyles;
 *
 *     // Activate class
 *     willMount() { this.styles = css.activate( CommonStyles); }
 *     willUnmount() { css.deactivate( this.styles); }
 *     render() { return <div className={this.styles.red.name}</div> }
 * }
 * ```
 *
 * Activating an instance (as opposed to activating a class) is intended for "scoped" CSS entities -
 * that is, entities that apply to instances of certain components, a.k.a. *Styled Components*.
 * In this approach, every instance of a component creates its own instance of the style definition
 * class and Mimcss will create independent instances of CSS rules specific (*scoped*) to each
 * component instance.
 *
 * **Example**
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     red = this.$class({ color: red })
 * }
 *
 * class MyComponent
 * {
 *     // Create style definition directly
 *     private styles = new MyStyles();
 *
 *     // Activate instance
 *     willMount() { this.styles = css.activate( this.styles); }
 *     willUnmount() { css.deactivate( this.styles); }
 *     render() { return <div className={this.styles.red.name}</div> }
 * }
 * ```
 *
 * @typeparam T Type of the style definition class or instance passed to the function. This is
 * also the type, which is returned form the function.
 * @param instOrClass Style definition class or instance
 * @param schedulerType Identifier of a pre-defined or registered scheduler. If not specified, the
 * scheduler set as default will be used.
 * @returns Instance of the style definition class - either created (if this was the first
 * activation of the class) or already associated with the class. If the input parameter is an
 * instance (as opposed to a class), the return value is the same instance.
 */
const activate = (instOrClass, schedulerType) => {
    let instance = (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.processSD)(instOrClass);
    if (instance)
        (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_10__.getActivator)(schedulerType).activate(instance);
    return instance;
};
/**
 * Deactivates the given style definition instance by removing its rules from DOM. Note that each
 * style definition instance maintains a counter of how many times it was activated and
 * deactivated. The rules are removed from DOM only when this counter goes down to 0.
 *
 * @param sd Instance of a style definition class to be deactivated.
 * @param schedulerType Identifier of a pre-defined or registered scheduler. If not specified, the
 * scheduler set as default will be used.
 */
const deactivate = (sd, schedulerType) => (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_10__.getActivator)(schedulerType).deactivate(sd);
/**
 * Returns the theme definition object, which is currently active for the given theme declaration
 * class.
 * @param themeClass Theme declaration class
 * @returns Theme instance, which is currently active for the given theme class or undefined
 * if no instance is currently active.
 */
const getActiveTheme = (themeClass) => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.getCurrentTheme)(themeClass);
///////////////////////////////////////////////////////////////////////////////////////////////
//
// SSR support.
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Sets server-side activation context. Throws an error if non-default activation context is
 * already set.
 */
const startSSR = () => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.s_startSSR)();
/**
 * Stops server-side activation functionality and returns a string with serialized styles. The
 * string should be added to the `<head>` element using `insertAdjacentHTML()` method.
 * Throws an error if SSR has not been started.
 * @returns String containing serialized styles
 */
const stopSSR = () => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.s_stopSSR)();
/**
 * Sets hydration activation context. Throws an error if non-default activation context is
 * already set.
 */
const startHydration = () => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.s_startHydration)();
/**
 * Stops hydration activation functionality and restore the default activation context.
 * @returns String containing serialized styles
 */
const stopHydration = () => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.s_stopHydration)();


/***/ }),

/***/ "./lib/api/RuleTypes.js":
/*!******************************!*\
  !*** ./lib/api/RuleTypes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/SchedulingAPI.js":
/*!**********************************!*\
  !*** ./lib/api/SchedulingAPI.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "forceDOMUpdate": () => (/* binding */ forceDOMUpdate),
/* harmony export */   "cancelDOMUpdate": () => (/* binding */ cancelDOMUpdate),
/* harmony export */   "setDefaultScheduler": () => (/* binding */ setDefaultScheduler),
/* harmony export */   "registerScheduler": () => (/* binding */ registerScheduler)
/* harmony export */ });
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Scheduling.
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Writes to DOM all style changes caused by the calls to the activate and deactivate functions
 * accumulated since the last activation of the given scheduling type.
 */
const forceDOMUpdate = (schedulerType) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.getActivator(schedulerType).forceDOMUpdate();
/**
 * Removes all scheduled activations caused by the calls to the activate and deactivate functions
 * accumulated since the last activation of the given scheduling type.
 */
const cancelDOMUpdate = (schedulerType) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.getActivator(schedulerType).cancelDOMUpdate();
/**
 * Sets the default scheduling type that is used by activate and deactivate functions that are
 * called without explicitly providing value to the scheduling parameter. Returns the type of the
 * previous default activator or 0 if an error occurs (e.g. the given scheduler type ID is not
 * registered).
 */
const setDefaultScheduler = (schedulerType) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.setDefaultScheduler(schedulerType);
/**
 * Registers the given scheduler object and returns the scheduler type identifier, which
 * should be used when calling activate and deactivate functions.
 */
const registerScheduler = (scheduler) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.registerScheduler(scheduler);


/***/ }),

/***/ "./lib/api/SchedulingTypes.js":
/*!************************************!*\
  !*** ./lib/api/SchedulingTypes.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/ShapeAPI.js":
/*!*****************************!*\
  !*** ./lib/api/ShapeAPI.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearGradient": () => (/* binding */ linearGradient),
/* harmony export */   "radialGradient": () => (/* binding */ radialGradient),
/* harmony export */   "conicGradient": () => (/* binding */ conicGradient),
/* harmony export */   "crossFade": () => (/* binding */ crossFade),
/* harmony export */   "imageSet": () => (/* binding */ imageSet),
/* harmony export */   "registerPaintWorklet": () => (/* binding */ registerPaintWorklet),
/* harmony export */   "paint": () => (/* binding */ paint),
/* harmony export */   "brightness": () => (/* binding */ brightness),
/* harmony export */   "contrast": () => (/* binding */ contrast),
/* harmony export */   "grayscale": () => (/* binding */ grayscale),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "opacity": () => (/* binding */ opacity),
/* harmony export */   "saturate": () => (/* binding */ saturate),
/* harmony export */   "sepia": () => (/* binding */ sepia),
/* harmony export */   "blur": () => (/* binding */ blur),
/* harmony export */   "dropShadow": () => (/* binding */ dropShadow),
/* harmony export */   "hueRotate": () => (/* binding */ hueRotate),
/* harmony export */   "matrix": () => (/* binding */ matrix),
/* harmony export */   "matrix3d": () => (/* binding */ matrix3d),
/* harmony export */   "perspective": () => (/* binding */ perspective),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "rotate3d": () => (/* binding */ rotate3d),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleX": () => (/* binding */ scaleX),
/* harmony export */   "scaleY": () => (/* binding */ scaleY),
/* harmony export */   "scaleZ": () => (/* binding */ scaleZ),
/* harmony export */   "scale3d": () => (/* binding */ scale3d),
/* harmony export */   "skew": () => (/* binding */ skew),
/* harmony export */   "skewX": () => (/* binding */ skewX),
/* harmony export */   "skewY": () => (/* binding */ skewY),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "translateX": () => (/* binding */ translateX),
/* harmony export */   "translateY": () => (/* binding */ translateY),
/* harmony export */   "translateZ": () => (/* binding */ translateZ),
/* harmony export */   "translate3d": () => (/* binding */ translate3d),
/* harmony export */   "inset": () => (/* binding */ inset),
/* harmony export */   "circle": () => (/* binding */ circle),
/* harmony export */   "ellipse": () => (/* binding */ ellipse),
/* harmony export */   "polygon": () => (/* binding */ polygon),
/* harmony export */   "path": () => (/* binding */ path),
/* harmony export */   "ray": () => (/* binding */ ray),
/* harmony export */   "minmax": () => (/* binding */ minmax),
/* harmony export */   "repeat": () => (/* binding */ repeat),
/* harmony export */   "span": () => (/* binding */ span)
/* harmony export */ });
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Images and gradients.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
const gradientNameToString = (val) => `${val.repeat ? "repeating-" : ""}${val.fn}`;
const gradientStopsOrHintsToString = (val, math) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    item: {
        num: 11 /* Color */,
        arr: { 1: [math], any: [11 /* Color */, math, math] }
    },
    sep: ","
});
/**
 * Function returning the ILinearGradientBuilder interface representing the `linear-gradient` CSS functions.
 *
 * *Examples:*
 *
 * ```typescript
 * backgroundImage: linearGradient( "red", "blue")
 *
 * backgroundImage: linearGradient( ["red", 30], ["green", 50, 60], ["blue", 80]).repeating()
 *
 * backgroundImage: linearGradient( "red", "blue").to( 45)
 * ```
 *
 * @param stops Variable argument list specifying stops or hints that will be added to
 * the gradient definition.
 *
 * @category Image
 */
const linearGradient = (...stops) => new LinearGradientBuilder(stops);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["linear-gradient"] = {
    fn: gradientNameToString,
    f: (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([
        (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val.angle, { num: 4 /* Angle */, str: v => "to " + v }),
        gradientStopsOrHintsToString(val.stops, 3 /* Length */)
    ], ",")
};
/**
 * Function returning the IRadialGradient interface representing the `radial-gradient` CSS functions.
 *
 * *Examples:*
 *
 * ```typescript
 * backgroundImage: radialGradient( "red", "blue")
 *
 * backgroundImage: radialGradient( "red", "blue").circle( css.percent(30)).at( ["center", css.percent(65)])
 *
 * backgroundImage: radialGradient( "red", "blue").circle( 200).repeating()
 *
 * backgroundImage: radialGradient( "red", "blue").ellipse( "closest-side")
 * ```
 *
 * @param stops Variable argument list specifying stops or hints that will be added to
 * the gradient definition.
 *
 * @category Image
 */
const radialGradient = (...stops) => new RadialGradientBuilder(stops);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["radial-gradient"] = {
    fn: gradientNameToString,
    f: (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([
        (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([val.shape, [val.size, 13 /* MultiLengthWithSpace */], [val.pos, 9 /* AtPosition */]]),
        gradientStopsOrHintsToString(val.stops, 3 /* Length */)
    ], ",")
};
/**
 * Function returning the IConicGradient interface representing the `radial-gradient` CSS functions.
 *
 * *Examples:*
 *
 * ```typescript
 * backgroundImage: conicGradient( "red", "blue")
 *
 * backgroundImage: conicGradient().repeating().add( "red", "blue")
 *
 * backgroundImage: conicGradient( "red", "blue").from( 0.25).at( ["center", css.percent(65)])
 * ```
 *
 * @param stops Variable argument list specifying stops or hints that will be added to
 * the gradient definition.
 *
 * @category Image
 */
const conicGradient = (...stops) => new ConicGradientBuilder(stops);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["conic-gradient"] = {
    fn: gradientNameToString,
    f: (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([
        (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[val.angle, (v) => "from " + (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, 4 /* Angle */)], [val.pos, 9 /* AtPosition */]]),
        gradientStopsOrHintsToString(val.stops, 4 /* Angle */)
    ], ",")
};
/**
 * Base class for gradient implementation
 */
class GradientBuilder {
    constructor(stops) {
        this.stops = stops ?? [];
    }
    repeating(flag) {
        this.repeat = flag == null ? true : flag;
        return this;
    }
    add(...stopsOrHints) {
        this.stops.push(...stopsOrHints);
        return this;
    }
}
/**
 * Implements functionality of linear gradients
 */
class LinearGradientBuilder extends GradientBuilder {
    constructor() {
        super(...arguments);
        this.fn = "linear-gradient";
    }
    to(angle) { this.angle = angle; return this; }
}
/**
 * Implements functionality of radial gradients
 */
class RadialGradientBuilder extends GradientBuilder {
    constructor() {
        super(...arguments);
        this.fn = "radial-gradient";
    }
    circle(sizeOrExtent) {
        this.shape = "circle";
        this.size = sizeOrExtent;
        return this;
    }
    ellipse(...params) {
        this.shape = "ellipse";
        this.size =
            params.length === 1 ? params[0] :
                params.length === 2 ? [params[0], params[1]] :
                    undefined;
        return this;
    }
    extent(extent) { this.size = extent; return this; }
    at(pos) { this.pos = pos; return this; }
}
/**
 * Implements functionality of conic gradients
 */
class ConicGradientBuilder extends GradientBuilder {
    constructor() {
        super(...arguments);
        this.fn = "conic-gradient";
    }
    from(angle) { this.angle = angle; return this; }
    at(pos) { this.pos = pos; return this; }
}
/** Implementation */
function crossFade() {
    return new CrossFadeBuilder(...arguments);
}
/**
 * Implements functionality of cross-fade()
 */
class CrossFadeBuilder {
    constructor() {
        this.fn = "cross-fade";
        let p1 = arguments[0];
        if (Array.isArray(p1) && p1.length === 3) {
            // this is the old signature
            this.old = p1;
        }
        else {
            // this is the new signature
            this.add(...arguments);
        }
    }
    add(...images) {
        if (!this.images)
            this.images = [];
        for (let item of images)
            this.images.push(Array.isArray(item) ? item : [item]);
        return this;
    }
    color(c) { this.c = c; return this; }
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["cross-fade"] = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.f2s)("cross-fade", [
    val.images
        ? (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[val.images, { item: { arr: [0 /* Default */, 2 /* Percent */] }, sep: "," }], [val.c, 11 /* Color */]], ",")
        : (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val.old, { arr: [0 /* Default */, 0 /* Default */, 2 /* Percent */], sep: "," })
]);
/**
 * Returns an IImageSetFunc object representing the `image-set()` CSS function.
 *
 * @param items One or more items specifying an image and optionally image type and resolution.
 * @returns
 *
 * @category Image
 */
const imageSet = (...items) => ({ fn: "image-set", items });
const imageTypeToString = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    str: v => `type("${v.indexOf("/") > 0 ? val : "image/" + val}")`
});
const imageResolutionToString = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    num: v => v + "x"
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["image-set"] = [
    [
        "items", {
            item: {
                str: 23 /* Quoted */,
                arr: {
                    1: [23 /* Quoted */],
                    2: [23 /* Quoted */, { str: imageTypeToString, num: imageResolutionToString }],
                    3: [23 /* Quoted */, imageTypeToString, imageResolutionToString],
                }
            },
            sep: ","
        }
    ]
];
/**
 * Registers a paint worklet with the given name, optional argument syntax and optional URL of
 * the worklet module. The worklet name should have been added to the [[IPaintWorklets]] interface
 * using the module augmentation technique. Although it is possible to use paint worklets without
 * adding them to the [[IPaintWorklets]] interface, this will prevent Mimcss from enforcing the
 * types of arguments when the [[paint]] function is invoked.
 * @param name Worklet name
 * @param syntax Tuple containing syntax definitions for worklet arguments.
 * @param url URL to the worklet module. If specified, the module will be automatically added.
 */
const registerPaintWorklet = async (name, syntax = [], url) => {
    if (CSS.paintWorklet) {
        if (!registeredPaintWorkletInfos[name]) {
            registeredPaintWorkletInfos[name] = { syntax, url };
            // if URL is specified use it to add worklet module
            if (url && !addedPaintWorkletModules.has(url)) {
                addedPaintWorkletModules.add(url);
                try {
                    await CSS.paintWorklet.addModule(url);
                }
                catch (x) {
                    console.error(`Error adding module '${url}' for paint worklet '${name}'`, x);
                }
            }
        }
    }
};
/**
 * Information about registered paint worklets.
 */
let registeredPaintWorkletInfos = {};
/**
 * Set of URLs of already added paint worklet modules.
 */
let addedPaintWorkletModules = new Set();
/**
 * Returns the IPaintFunc object describing an invocation of the `paint()` CSS function.
 *
 * @param name Paint worklet name.
 * @param args Parameters to be passed to the paint worklet.
 *
 * @category Image
 *
 * @ts-expect-error: Erroneously reports TS2370 although the rest's type is an array (a tuple) */
const paint = (name, ...args) => ({ fn: "paint", name: name, args: args });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.paint = (v) => {
    if (!v?.args?.length)
        return `paint(${v.name})`;
    let info = registeredPaintWorkletInfos[v.name];
    let buf = [];
    for (let i = 0; i < v.args.length; i++) {
        let syntax = info?.syntax[i];
        buf.push(syntax ? (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_1__.sp2s)(syntax, v.args[i]) : (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v.args[i]));
    }
    return `paint(${v.name},${buf.filter(v => !!v).join(",")})`;
};
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Filters
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an IFilterProxy function representing one of the filter CSS function.
 */
const filterPercent = (fn, p) => ({ fn, p });
/**
 * Returns an [[IPercentFilterFunc]] object representing the `brightness()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: brightness(150%)
 *     bright = this.$class({ filter: css.brightness(150)})
 *
 *     // filter: brightness(50%)
 *     dim = this.$class({ filter: css.brightness(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const brightness = (p) => filterPercent("brightness", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `contrast()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: contrast(150%)
 *     highContrast = this.$class({ filter: css.contrast(150)})
 *
 *     // filter: contrast(50%)
 *     lowContrast = this.$class({ filter: css.contrast(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const contrast = (p) => filterPercent("contrast", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `grayscale()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: grayscale(100%)
 *     gray = this.$class({ filter: css.grayscale(100)})
 *
 *     // filter: grayscale(50%)
 *     halfColor = this.$class({ filter: css.grayscale(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const grayscale = (p) => filterPercent("grayscale", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `invert()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: invert(100%)
 *     inverted = this.$class({ filter: css.invert(100)})
 *
 *     // filter: invert(75%)
 *     somewhatnverted = this.$class({ filter: css.invert(0.75)})
 *
 *     // filter: invert(50%)
 *     gray = this.$class({ filter: css.invert(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const invert = (p) => filterPercent("invert", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `opacity()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: opacity(50%)
 *     halfTransparent = this.$class({ filter: css.opacity(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const opacity = (p) => filterPercent("opacity", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `saturate()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: saturate(150%)
 *     superSaturated = this.$class({ filter: css.saturate(150)})
 *
 *     // filter: saturate(50%)
 *     underSaturated = this.$class({ filter: css.saturate(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const saturate = (p) => filterPercent("saturate", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `sepia()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: sepia(100%)
 *     vintage = this.$class({ filter: css.sepia(100)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const sepia = (p) => filterPercent("sepia", p);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.brightness = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.contrast = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.grayscale = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.invert = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.opacity = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.saturate =
    _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.sepia = 2 /* Percent */;
/**
 * Returns an [[IBlurFunc]] object representing the `blur()` CSS function parameters.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: blur(0)
 *     sharp = this.$class({ filter: css.blur(0)})
 *
 *     // filter: blur(2px)
 *     blurred = this.$class({ filter: css.blur(2)})
 *
 *     // filter: blur(1.5em)
 *     superBlurred = this.$class({ filter: css.blur(1.5)})
 * }
 * ```
 *
 * @param r Radius of the blur.
 * @returns The `IBlurFunc` interface containing the blur radius
 * @category Filter
 */
const blur = (r) => ({ fn: "blur", r });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.blur = 3 /* Length */;
/**
 * Returns an [[IDropShadowFunc]] object representing the `dropShadow()` CSS function parameters.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: drop-shadow(30px 10px 4px blue)
 *     blurredShadow = this.$class({ filter: css.dropShadow( 30, 10, "blue", 4)})
 *
 *     // filter: drop-shadow(2.5em -1.5em green)
 *     sharpShadow = this.$class({ filter: css.dropShadow( 2.5, -1.5, "green")})
 *
 *     // filter: drop-shadow(0 0 20px orange)
 *     haloShadow = this.$class({ filter: css.dropShadow( 0, 0, "orange", 20px)})
 * }
 * ```
 *
 * @param x Horizontal offset of the shadow.
 * @param y Vertical offset of the shadow.
 * @param color Color of the shadow. If undefined, the color of the shadow is taken from the color
 * property.
 * @param blur Value of the shadow's blurring. If undefined, the shadow will be sharp (not blurred).
 * @returns The `IDropShadowFunc` interface containing the shadow parameters.
 *
 * @category Filter
 */
const dropShadow = (x, y, color, blur) => ({ fn: "drop-shadow", x, y, color, blur });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["drop-shadow"] = {
    p: ["x", "y", "blur", ["color", 11 /* Color */]],
    do: 3 /* Length */,
    s: " "
};
/**
 * Returns an [[IHueRotateFunc]] object representing the `hue-rotate()` CSS function parameters.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: hue-rotate(90deg)
 *     toTheRight = this.$class({ filter: css.hueRotate(90)})
 *
 *     // filter: hue-rotate(-0.25turn)
 *     toTheLeft = this.$class({ filter: css.blur(-0.25)})
 * }
 * ```
 *
 * @param a The relative change in hue of the input sample.
 * @returns The `IHueRotateFunc` interface containing the hue rotation angle
 * @category Filter
 */
const hueRotate = (a) => ({ fn: "hue-rotate", a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["hue-rotate"] = 4 /* Angle */;
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Transforms
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an IMatrixFunc object representing the `matrix()` CSS function.
 *
 * @category Transform
 */
const matrix = (a, b, c, d, tx, ty) => ({ fn: "matrix", a, b, c, d, tx, ty });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.matrix = ["a", "b", "c", "d", "tx", "ty"];
/**
 * Returns an IMatrix3dFunc function representing the `matrix3d()` CSS function.
 *
 * @category Transform
 */
const matrix3d = (a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) => ({ fn: "matrix3d", a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4 });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.matrix = ["a1", "b1", "c1", "d1", "a2", "b2", "c2", "d2", "a3", "b3", "c3", "d3", "a4", "b4", "c4", "d4"];
/**
 * Returns an IPerspectiveFunc function representing the `perspective()` CSS function.
 *
 * @category Transform
 */
const perspective = (d) => ({ fn: "perspective", d });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.perspective = 3 /* Length */;
/**
 * Returns an IRotateFunc function representing the `rotate()` CSS function.
 *
 * @category Transform
 */
const rotate = (a) => ({ fn: "rotate", a });
/**
 * Returns an ITransformProxy function representing the `rotateX()` CSS function.
 *
 * @category Transform
 */
const rotateX = (a) => ({ fn: "rotateX", a });
/**
 * Returns an ITransformProxy function representing the `rotateY()` CSS function.
 *
 * @category Transform
 */
const rotateY = (a) => ({ fn: "rotateY", a });
/**
 * Returns an ITransformProxy function representing the `rotateZ()` CSS function.
 *
 * @category Transform
 */
const rotateZ = (a) => ({ fn: "rotateZ", a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotate = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotateX = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotateY = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotateZ = 4 /* Angle */;
/**
 * Returns an IRotate3dFunc function representing the `rotate3d()` CSS function.
 *
 * @category Transform
 */
const rotate3d = (x, y, z, a) => ({ fn: "rotate3d", x, y, z, a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotate3d = ["x", "y", "z", ["a", 4 /* Angle */]];
/**
 * Returns an IScaleFunc function representing the `scale()` CSS function.
 *
 * @category Transform
 */
const scale = (sx, sy) => ({ fn: "scale", sx, sy });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.scale = ["sx", "sy"];
/**
 * Returns an IScale1dFunc function representing the `scaleX()` CSS function.
 *
 * @category Transform
 */
const scaleX = (s) => ({ fn: "scaleX", s });
/**
 * Returns an IScale1dFunc function representing the `scaleY()` CSS function.
 *
 * @category Transform
 */
const scaleY = (s) => ({ fn: "scaleY", s });
/**
 * Returns an IScale1dFunc function representing the `scaleZ()` CSS function.
 *
 * @category Transform
 */
const scaleZ = (s) => ({ fn: "scaleZ", s });
/**
 * Returns an IScale3dFunc function representing the `scale3d()` CSS function.
 *
 * @category Transform
 */
const scale3d = (sx, sy, sz) => ({ fn: "scale3d", sx, sy, sz });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.scale3d = ["sx", "sy", "sz"];
/**
 * Returns an ISkewFunc function representing the `skew()` CSS function.
 *
 * @category Transform
 */
const skew = (ax, ay) => ({ fn: "skew", ax, ay });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.skew = {
    p: ["ax", "ay"],
    do: 4 /* Angle */
};
/**
 * Returns an ISkew1dFunc function representing the `skewX()` CSS function.
 *
 * @category Transform
 */
const skewX = (a) => ({ fn: "skewX", a });
/**
 * Returns an ISkew1dFunc function representing the `skewY()` CSS function.
 *
 * @category Transform
 */
const skewY = (a) => ({ fn: "skewY", a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.skewX = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.skewY = 4 /* Angle */;
/**
 * Returns an ITranslateFunc function representing the `translate()` CSS function.
 *
 * @category Transform
 */
const translate = (x, y) => ({ fn: "translate", x, y });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translate = {
    p: ["x", "y"],
    do: 3 /* Length */
};
/**
 * Returns an ITranslate1dFunc function representing the `translateX()` CSS function.
 *
 * @category Transform
 */
const translateX = (d) => ({ fn: "translateX", d });
/**
 * Returns an ITranslate1dFunc function representing the `translateY()` CSS function.
 *
 * @category Transform
 */
const translateY = (d) => ({ fn: "translateY", d });
/**
 * Returns an ITranslate1dFunc function representing the `translateZ()` CSS function.
 *
 * @category Transform
 */
const translateZ = (d) => ({ fn: "translateZ", d });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translateX = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translateY = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translateZ = 3 /* Length */;
/**
 * Returns an ITranslate3dFunc function representing the `translate3d()` CSS function.
 *
 * @category Transform
 */
const translate3d = (x, y, z) => ({ fn: "translate3d", x, y, z });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translate3d = {
    p: ["x", "y", "z"],
    do: 3 /* Length */
};
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Basic shapes
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an IInsetBuilder object representing the `inset()` CSS function.
 *
 * *Example:*
 *
 * ```typescript
 * clipPath: inset( css.percent(15))
 *
 * clipPath: inset( 10, 12, 14, 16).round( 8)
 * ```
 *
 * @category Basic Shape
 */
const inset = (o1, o2, o3, o4) => ({
    fn: "inset", o1, o2, o3, o4,
    round(r) { this.r = r; return this; }
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.inset = {
    p: ["o1", "o2", "o3", "o4", ["r", v => "round " + _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[20](v)]],
    do: 3 /* Length */,
    s: " "
};
/**
 * Returns an ICircleBuilder object representing the `circle()` CSS function.
 *
 * *Example:*
 *
 * ```typescript
 * clipPath: circle( 100)
 *
 * clipPath: circle( 100).at( ["center", css.percent(30)])
 * ```
 *
 * @category Basic Shape
 */
const circle = (r) => ({
    fn: "circle", r,
    at(pos) { this.pos = pos; return this; }
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.circle = {
    p: [["r", 3 /* Length */], ["pos", 9 /* AtPosition */]],
    s: " "
};
// implementation
function ellipse() {
    return {
        fn: "ellipse", rx: arguments[0], ry: arguments[1],
        at(pos) { this.pos = pos; return this; }
    };
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.ellipse = {
    p: ["rx", "ry", ["pos", 9 /* AtPosition */]],
    do: 3 /* Length */,
    s: " "
};
/**
 * Returns an IPolygon object representing the `polygon()` CSS function.
 *
 * *Example:*
 *
 * ```typescript
 * clipPath: css.polygon( [0,100], [50,0], [100,100])
 *
 * clipPath: css.polygon( [0,100], [50,0], [100,100]).fill( "evenodd")
 * ```
 *
 * @category Basic Shape
 */
const polygon = (...points) => ({
    fn: "polygon", points: points ?? [],
    add(...points) { this.points.push(...points); return this; },
    fill(rule) { this.rule = rule; return this; }
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.polygon = [
    "rule",
    ["points", { item: 13 /* MultiLengthWithSpace */, sep: "," }],
];
/**
 * Returns an IPathBuilder object that allows building a CSS path.
 *
 * @category Basic Shape
 */
const path = (fillRule) => new PathBuilder(fillRule);
/**
 * The IPathBuilder interface represents the object that accumulates path commands that are then
 * converted to a string parameter of the CSS `path()` function.
 */
class PathBuilder {
    constructor(rule) {
        this.fn = "path";
        this.items = [];
        this.rule = rule;
    }
    // Adds the given command and parameters to the path.
    add(command, params) {
        this.items.push([command, params]);
        return this;
    }
    M(...params) { return this.add("M", params); }
    m(...params) { return this.add("m", params); }
    L(...params) { return this.add("L", params); }
    l(...params) { return this.add("l", params); }
    H(...params) { return this.add("H", params); }
    h(...params) { return this.add("h", params); }
    V(...params) { return this.add("V", params); }
    v(...params) { return this.add("v", params); }
    C(...params) { return this.add("C", params); }
    c(...params) { return this.add("c", params); }
    S(...params) { return this.add("S", params); }
    s(...params) { return this.add("s", params); }
    Q(...params) { return this.add("Q", params); }
    q(...params) { return this.add("q", params); }
    T(...params) { return this.add("T", params); }
    t(...params) { return this.add("t", params); }
    A(...params) { return this.add("A", params); }
    a(...params) { return this.add("a", params); }
    z() { return this.add("z"); }
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.path = ["rule", ["items", (v) => `"${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v)}"`]];
/**
 * Returns an IRay object representing invocation of the `ray()` CSS function.
 *
 * @category Basic Shape
 */
const ray = (angle, size, contain) => ({ fn: "ray", angle, size, contain });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.ray = {
    p: [
        ["angle", 4 /* Angle */],
        ["size", 3 /* Length */],
        ["contain", (v) => (v ? "contain" : "")]
    ],
    s: " "
};
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Grids
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
* Returns an IMinMax function representing the `minmax()` CSS function.
*
* @category Grid
*/
const minmax = (min, max) => ({ fn: "minmax", min, max });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.minmax = [["min", 3 /* Length */], ["max", 3 /* Length */]];
/**
 * Returns an IRepeat function representing the `repeat()` CSS function.
 *
 * @category Grid
 */
const repeat = (count, ...tracks) => ({ fn: "repeat", count, tracks });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.repeat = ["count", ["tracks", { item: 22 /* GridTrack */ }]];
/**
 * Returns an IGridSpanFunc function representing the `span` expression for grid layouts. If the first
 * parameter is a number, the second parameter (if defined) must be a name; if the first parameter
 * is a name, the second parameter (if defined) must be a number.
 *
 * @category Grid
 */
const span = (p1, p2) => ({ fn: "span", p1, p2 });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.span = (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)(["span", v.p1, v.p2]);


/***/ }),

/***/ "./lib/api/ShapeTypes.js":
/*!*******************************!*\
  !*** ./lib/api/ShapeTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/StyleAPI.js":
/*!*****************************!*\
  !*** ./lib/api/StyleAPI.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerStyleProperty": () => (/* binding */ registerStyleProperty),
/* harmony export */   "getStylePropValue": () => (/* binding */ getStylePropValue),
/* harmony export */   "setElementStyle": () => (/* binding */ setElementStyle),
/* harmony export */   "setElementStringStyle": () => (/* binding */ setElementStringStyle),
/* harmony export */   "stylesetToString": () => (/* binding */ stylesetToString),
/* harmony export */   "stylesetToStringStyleset": () => (/* binding */ stylesetToStringStyleset),
/* harmony export */   "diffStylesets": () => (/* binding */ diffStylesets),
/* harmony export */   "mediaToString": () => (/* binding */ mediaToString),
/* harmony export */   "supportsToString": () => (/* binding */ supportsToString)
/* harmony export */ });
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Styleset manipulation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Registers the given function to be used for converting values of the given style property to
 * string. The `registerStyleProperty` function must be used after adding the property to the
 * [[IStyleset]] interface via the module augmentation technique if the conversion to string
 * requires non-standard operations. This function should not be called for propeties whose
 * values only include numbers, strings, functions returning a string, objects whose `toString`
 * method produces the necessary string or arrays of the above types.
 *
 * This function can be used for style properties that are not yet supported by Mimcss. This is
 * also the way to support properties with vendor prefixes.
 */
const registerStyleProperty = (name, toStringFunc) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s_registerSP)(name, toStringFunc);
/**
 * Converts the given value corresponding to the given style property to a CSS string.
 * @param stylePropName Style property name that determines how the value should be converted
 * to a CSS compliant string.
 * @param stylePropValue Value to convert.
 */
const getStylePropValue = (stylePropName, stylePropValue) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(stylePropName, stylePropValue);
// Sets style property on HTML or SVG element
const setElementStyleProp = (elm, name, value, schedulerType) => (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_1__.getActivator)(schedulerType).updateStyle(elm, name, (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(name, value), false);
/**
 * Sets values of the style properties from the given Styleset object to the `style` attribute
 * of the given HTML element.
 * @param elm HTML/SVG element whose styles will be set.
 * @param styleset Styleset object which provides values for style properties.
 */
const setElementStyle = (elm, styleset, schedulerType) => setElementStringStyle(elm, styleset ? stylesetToStringStyleset(styleset) : null, schedulerType);
/**
 * Sets values of the style properties from the given StringStyleset object to the `style` attribute
 * of the given HTML element.
 * @param elm HTML/SVG element whose styles will be set.
 * @param styleset [[StringStyleset]] object which provides values for style properties.
 */
const setElementStringStyle = (elm, styleset, schedulerType) => (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_1__.getActivator)(schedulerType).updateStyle(elm, null, styleset, false);
/**
 * Serializes the given [[Styleset]] to a string.
 * @param styleset
 */
const stylesetToString = (styleset) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2s)(styleset);
/**
 * Converts the given [[Styleset]] object into an object, where each Styleset's property is
 * converted to its string value.
 * @param styleset
 */
const stylesetToStringStyleset = (styleset) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(styleset);
/**
 * Compares two Styleset objects by converting style properties to strings and returns an object
 * that contains string values of properties that were new or have different values in the new
 * styleset and undefined values for properties that exist in the old styleset but don't exist
 * in the new one.
 * @param oldStyleset
 * @param newStyleset
 * @returns StringStyleset object with properties that have different values in the old and new
 * stylesets. Properties that existed in the old but don't exist in the new styleset, will have
 * their values set to `"unset"`. If there is no differences between the two stylesets null is
 * returned.
 */
const diffStylesets = (oldStyleset, newStyleset) => {
    if (!oldStyleset && !newStyleset)
        return null;
    else if (!oldStyleset)
        return (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(newStyleset);
    else if (!newStyleset)
        return (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(oldStyleset);
    // first convert both stylesets to their string versions
    let oldStringStyleset = (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(oldStyleset);
    let newStringStyleset = (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(newStyleset);
    let updateVal = null;
    // loop over keys in the old style object and find those that are not in the new one. These
    // will be removed.
    for (let key in oldStringStyleset) {
        let newStringVal = newStringStyleset[key];
        if (newStringVal == null) {
            updateVal = updateVal || {};
            updateVal[key] = "unset";
        }
        else {
            let oldStringVal = oldStringStyleset[key];
            if (oldStringVal !== newStringVal) {
                updateVal = updateVal || {};
                updateVal[key] = newStringVal;
            }
        }
    }
    // loop over keys in the new style object and find those that are not in the old one. These
    // will be added.
    for (let key in newStringStyleset) {
        let oldStringVal = oldStringStyleset[key];
        if (oldStringVal == null) {
            updateVal = updateVal || {};
            updateVal[key] = newStringStyleset[key];
        }
    }
    return updateVal;
};
// Sets style property on HTML or SVG element
HTMLElement.prototype.setStyleProp = SVGElement.prototype.setStyleProp =
    function (name, value, schedulerType) {
        setElementStyleProp(this, name, value, schedulerType);
    };
// Sets styleset on HTML or SVG element
HTMLElement.prototype.setStyleset = SVGElement.prototype.setStyleset =
    function (styleset, schedulerType) {
        setElementStyle(this, styleset, schedulerType);
    };
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// @media and @supports queries.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given media query value to the CSS media query string. This function can be used
 * by libraries that allow specifying [[MediaStatement]] for the `media` attribute of elements
 * such as `<link>`, `<style>` and `<source>`
 */
const mediaToString = (query) => (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__.media2s)(query);
/**
 * Converts the given supports query value to the CSS supports query string.
 */
const supportsToString = (query) => (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__.supports2s)(query);


/***/ }),

/***/ "./lib/api/StyleTypes.js":
/*!*******************************!*\
  !*** ./lib/api/StyleTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/Stylesets.js":
/*!******************************!*\
  !*** ./lib/api/Stylesets.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/impl/CoreImpl.js":
/*!******************************!*\
  !*** ./lib/impl/CoreImpl.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selector2s": () => (/* binding */ selector2s)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS selector.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns a string representation of a selector.
 */
const selector2s = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { sep: "", recursive: true });
// Converting attribute selector definition to string
_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["attr-sel"] = (v) => `[${v.ns ? (typeof v.ns === "string" ? v.ns : v.ns.prefix) + "|" : ""}${v.name}` +
    (v.val == null ? "]" : `${v.op ?? "="}"${v.val}"${v.cf ? " " + v.cf : ""}]`);
// Converting "nth" pseudo classes to string
_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-child"] = _Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-last-child"] = _Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-of-type"] = _Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-last-of-type"] = [
    ["p", {
            arr: [
                v => v + "n",
                v => !v ? "" : v > 0 ? "+" + v : "-" + -v
            ],
            sep: ""
        }]
];
// // Converting pseudo entities that accept CssSelector to string
// fdo[":is"] = fdo[":has"] = fdo[":host-context"] = fdo[":not"] = fdo[":where"] = fdo["::slotted"] = [
//     ["p", selector2s]
//     // ["p", {sep: ",", recursive: true}]
// ]


/***/ }),

/***/ "./lib/impl/MiscImpl.js":
/*!******************************!*\
  !*** ./lib/impl/MiscImpl.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "media2s": () => (/* binding */ media2s),
/* harmony export */   "supports2s": () => (/* binding */ supports2s),
/* harmony export */   "fontFace2s": () => (/* binding */ fontFace2s),
/* harmony export */   "counterStyleset2s": () => (/* binding */ counterStyleset2s)
/* harmony export */ });
/* harmony import */ var _StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @media rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given media query object to the CSS media query string
 */
const media2s = (statement) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(statement, {
    any: mediaQuery2s,
    sep: ","
});
/**
 * Converts the given media query object to the CSS media query string
 */
const mediaQuery2s = (query) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.propSet2s)(query, mediaFeatureInfos, {
    separator: " and ",
    propFunc: mediaFeature2s,
});
/**
 * Converts the given media feature to the CSS media query string
 */
const mediaFeature2s = (dashName, camelName, val, options) => {
    if (val == null)
        return "";
    // if defaultValue is defined and the property value is equal to it, no value should be returned.
    let defaultValue = mediaFeatureDefaultValues.get(camelName);
    if (defaultValue !== undefined && val === defaultValue)
        return dashName;
    let isRange = rangeMediaFeatures.has(camelName);
    if (isRange && Array.isArray(val)) {
        return `(${"min-" + dashName}:${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(val[0], options)}) and (${"max-" + dashName}:${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(val[1], options)})`;
        // this syntax is not widely supported yet
        // return `${s1} <= ${dashName} <= ${s2}`;
    }
    else
        return `(${dashName}:${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(val, options)})`;
};
const mediaFeatureInfos = {
    aspectRatio: {
        num: (v) => v + "/1"
    },
    height: 3 /* Length */,
    minHeight: 3 /* Length */,
    maxHeight: 3 /* Length */,
    resolution: 6 /* Resolution */,
    minResolution: 6 /* Resolution */,
    maxResolution: 6 /* Resolution */,
    width: 3 /* Length */,
    minWidth: 3 /* Length */,
    maxWidth: 3 /* Length */,
};
// Set of media features that allow range of values
const rangeMediaFeatures = new Set(["aspectRatio", "color", "colorIndex", "height", "monochrome", "resolution", "width"]);
// Map of media features to default values
const mediaFeatureDefaultValues = new Map([
    ["color", 0],
    ["colorIndex", 0],
    ["monochrome", 0]
]);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @supports rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/** Converts the given supports statement to its string representation */
const supports2s = (statement) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(statement, {
    any: supportsQuery2s,
    sep: " or "
});
/** Converts the given supports query to its string representation */
const supportsQuery2s = (query) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(query, {
    obj: (v) => {
        let propNames = Object.keys(v);
        if (propNames.length === 0)
            return "";
        return `(${propNames.map((propName) => `${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.camelToDash)(propName)}:${(0,_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(propName, query[propName])}`).join(") and (")})`;
    }
});
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @font-face rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given font face object to the CSS style string.
 */
const fontFace2s = (fontface) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.propSet2s)(fontface, fontFacePropertyInfos);
_Utils__WEBPACK_IMPORTED_MODULE_1__.wkf[24] = v => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(v, {
    num: v => `oblique ${_Utils__WEBPACK_IMPORTED_MODULE_1__.wkf[4](v)}`,
    arr: v => `oblique ${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.a2s)(v, 4 /* Angle */)}`
});
/**
 * Map of property names to the V2SOptions objects describing custom actions necessary to
 * convert the property value to the CSS-compliant string.
 */
const fontFacePropertyInfos = {
    ascentOverride: 2 /* Percent */,
    descentOverride: 2 /* Percent */,
    fontStretch: { any: 2 /* Percent */ },
    fontStyle: 24 /* FontStyle */,
    fontWeight: { any: 1 /* Number */ },
    lineGapOverride: 2 /* Percent */,
    src: {
        any: {
            obj: [
                ["local", v => `local(${v})`],
                ["url", v => `url(${v})`],
                ["format", {
                        any: v => `format(\"${v}\")`,
                        sep: ","
                    }]
            ]
        },
        sep: ","
    },
    sizeAdjust: 2 /* Percent */,
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @counter-style rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given counter styleset property to the CSS style string. Property name can be in
 * either dash or camel form.
 */
const counterStylesetProp2s = (propName, propVal, includeName) => {
    if (!propName)
        return "";
    // convert the value to string based on the information object for the property (if defined)
    let stringValue = (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(propVal, counterStylePropertyInfos[(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.dashToCamel)(propName)]);
    // if the resulting string is empty and the name should be included, then we return
    // "name:; otherwise we will return an empty string.
    if (!stringValue && includeName)
        stringValue = "";
    return includeName ? `${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.camelToDash)(propName)}:${stringValue}` : stringValue;
};
/**
 * Converts the given counter styleset object to the CSS media query string
 */
const counterStyleset2s = (counterStyleset) => {
    if (!counterStyleset)
        return "";
    let s = "";
    for (let name in counterStyleset)
        s += counterStylesetProp2s(name, counterStyleset[name], true) + ";";
    return s;
};
/**
* Map of property names to the V2SOptions objects describing custom actions necessary to
* convert the property value to the CSS-compliant string.
*/
const counterStylePropertyInfos = {
    system: {
        num: v => "fixed " + v,
        arr: v => "extends " + (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(v[0])
    },
    negative: {
        any: 23 /* Quoted */
    },
    prefix: 23 /* Quoted */,
    suffix: 23 /* Quoted */,
    range: {
        arr2: { sep: "," }
    },
    pad: {
        item: 23 /* Quoted */
    },
    symbols: {
        item: 23 /* Quoted */
    },
    additiveSymbols: {
        arr2: { item: { item: 23 /* Quoted */ }, sep: "," },
        any: 23 /* Quoted */
    },
};


/***/ }),

/***/ "./lib/impl/NumericImpl.js":
/*!*********************************!*\
  !*** ./lib/impl/NumericImpl.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NumericMath": () => (/* binding */ NumericMath),
/* harmony export */   "NumberMath": () => (/* binding */ NumberMath),
/* harmony export */   "PercentMath": () => (/* binding */ PercentMath),
/* harmony export */   "LengthMath": () => (/* binding */ LengthMath),
/* harmony export */   "AngleMath": () => (/* binding */ AngleMath),
/* harmony export */   "TimeMath": () => (/* binding */ TimeMath),
/* harmony export */   "ResolutionMath": () => (/* binding */ ResolutionMath),
/* harmony export */   "FrequencyMath": () => (/* binding */ FrequencyMath)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Numbers
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts a single numeric value to a CSS string optionally appending units that can be different
 * for integer and floating point numbers.
 * @param n Number to convert to string representation.
 * @param intUnit Units to append if the number is integer.
 * @param floatUnit Units to append if the number is floating point.
 */
const numberToString = (n, intUnit = "", floatUint = "") => n + (Number.isInteger(n) ? intUnit : floatUint);
/**
 * The NumericMath class contains methods that implement CSS mathematic functions on the
 * numeric CSS types. When arguments for these functions are of the number JavaScript type they
 * are converted to strings by calling a function specified in the constructor.
 */
class NumericMath {
    constructor(n2s) {
        this.n2s = n2s;
    }
    v2s(val) {
        return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { num: this.n2s });
    }
    mv2s(val, separator) {
        return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
            any: v => this.v2s(v),
            sep: separator
        });
    }
    /** Creates CssLength value from the number and the given unit. */
    units(n, unit) {
        return () => n + unit;
    }
    min(...params) {
        return () => this.m("min", params);
    }
    max(...params) {
        return () => this.m("max", params);
    }
    clamp(min, pref, max) {
        // return () => mathFunc( "clamp", [min, pref, max], this.n2s);
        return () => this.m("clamp", [min, pref, max]);
    }
    calc(formulaParts, ...params) {
        return () => `calc(${(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.tag2s)(formulaParts, params, (v) => this.v2s(v))})`;
    }
    m(name, params) {
        return `${name}(${this.mv2s(params, ",")})`;
    }
}
/**
 * The NumberMath object contains methods that implement CSS mathematic functions on the `<number>`
 * CSS type.
 */
const NumberMath = new NumericMath(n => n.toString());
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[1] = v => NumberMath.v2s(v);
/**
 * The PercentMath object contains methods that implement CSS mathematic functions on the
 * `<percentage>` CSS type by appending a "%" unit suffix. If the number is between -1 and 1 (non
 * inclusive), multiplies the number by 100.
 */
const PercentMath = new NumericMath(n => (n >= 1 || n <= -1 ? n : Math.round(n * 100)) + "%");
/**
 * Converts the given number to string using the following rules:
 * - if the number is between -1 and 1 (non inclusive), multiplies the number by 100 and appends "%"
 * - otherwise, converts the number to string without appending any units.
 */
const unitlessOrPercentToString = (n) => n >= 1 || n <= -1 ? n.toString() : (Math.round(n * 100) + "%");
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[2] = v => PercentMath.v2s(v);
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[17] = unitlessOrPercentToString;
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[27] = v => v + "%";
/**
 * The LengthMath object contains methods that implement CSS mathematic functions on the `<length>`
 * CSS type by appending a length unit suffix.
 * Integer numbers use "px"; floating point numbers use "em".
 */
const LengthMath = new NumericMath(n => numberToString(n, "px", "em"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[3] = v => LengthMath.v2s(v);
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[13] = v => LengthMath.mv2s(v, " ");
/**
 * The AngleMath object contains methods that implement CSS mathematic functions on the `<angle>`
 * CSS type by appending an angle unit suffix.
 * Integer numbers use "deg"; floating point numbers use "turn".
 */
const AngleMath = new NumericMath(n => numberToString(n, "deg", "turn"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[4] = v => AngleMath.v2s(v);
/**
 * The TimeMath object contains methods that implement CSS mathematic functions on the `<time>`
 * CSS type by appending a time unit suffix.
 * Integer numbers use "ms"; floating point numbers use "s".
 */
const TimeMath = new NumericMath(n => numberToString(n, "ms", "s"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[5] = v => TimeMath.v2s(v);
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[14] = v => TimeMath.mv2s(v, ",");
/**
 * The ResolutionMath object contains methods that implement CSS mathematic functions on the
 * `<resolution>` CSS type by appending a resolution unit suffix.
 * Integer numbers use "dpi"; floating point numbers use "x".
 */
const ResolutionMath = new NumericMath(n => numberToString(n, "dpi", "x"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[6] = v => ResolutionMath.v2s(v);
/**
 * The FrequencyMath object contains methods that implement CSS mathematic functions on the
 * `<frequency>` CSS type by appending a frequency unit suffix.
 * Integer numbers use "Hz"; floating point numbers use "kHz".
 */
const FrequencyMath = new NumericMath(n => numberToString(n, "Hz", "kHz"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[7] = v => FrequencyMath.v2s(v);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Size, Point, Position, Radius
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// // Converts single position style value to the CSS string.
// const pos2s = (val: Extended<CssPosition>): string => v2s( val, { any: WKF.Length });
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[8] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { any: 3 /* Length */ });
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[9] = (v) => v == null ? "" : "at " + _Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[8](v);
/**
 * Converts multi-position style value to the CSS string.
 */
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[12] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    arr2: { any: 8 /* Position */, sep: "," },
    any: 8 /* Position */
});
// Converts corner radius style value to the CSS string.
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[18] = (v) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, { any: 3 /* Length */ });
/**
 * Converts border radius style value to the CSS string.
 */
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[20] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    arr2: { any: { any: 3 /* Length */ }, sep: "/" },
    any: 3 /* Length */
});


/***/ }),

/***/ "./lib/impl/SchedulingImpl.js":
/*!************************************!*\
  !*** ./lib/impl/SchedulingImpl.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getActivator": () => (/* binding */ getActivator),
/* harmony export */   "setDefaultScheduler": () => (/* binding */ setDefaultScheduler),
/* harmony export */   "registerScheduler": () => (/* binding */ registerScheduler)
/* harmony export */ });
/* harmony import */ var _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules/RuleContainer */ "./lib/rules/RuleContainer.js");

/**
 * Set the value of either a single property or a set of properties in the given
 * CSS style object.
 */
const updateStyleProperty = (ruleOrElm, name, value, important) => {
    if (!name && value == null) {
        if (ruleOrElm instanceof CSSStyleRule)
            ruleOrElm.cssText = "";
        else
            ruleOrElm.removeAttribute("style");
    }
    else if (name) {
        if (value == null)
            ruleOrElm.style.removeProperty(name);
        else
            ruleOrElm.style.setProperty(name, value, important ? "important" : undefined);
    }
    else {
        let styleset = value;
        for (let propName in styleset)
            ruleOrElm.style[propName] = styleset[propName];
    }
};
/**
 * The SynchronousActivator class represents the synchronous activation mechanism, which writes
 * style changes to the DOM when the activate and deactivate functions are called.
 */
class SynchronousActivator {
    /**
     * Instructs to activate the given style definition instance. This method is called when the
     * activate function is called for this activation mechanism.
     * @param definition
     */
    activate(definition) {
        (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.activateSD)(definition);
    }
    /**
     * Instructs to deactivate the given style definition instance. This method is called when the
     * deactivate function is called for this activation mechanism.
     * @param definition
     */
    deactivate(definition) {
        (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.deactivateSD)(definition);
    }
    /**
     * Instructs to set the value of either a single property or a set of properties in the given
     * CSS style object.
     */
    updateStyle(ruleOrElm, name, value, important) {
        updateStyleProperty(ruleOrElm, name, value, important);
    }
    /**
     * Performs activation/deactivation for all style definitions accumulated since the last
     * activation/deactivation. This method is called when the forceDOMUpdate function is called
     * for this activation mechanism.
     */
    forceDOMUpdate() { }
    /**
     * Cancels activation/deactivation for all style definitions accumulated since the last
     * activation/deactivation. This method is called when the cancelDOMUpdate function is called
     * for this activation mechanism.
     */
    cancelDOMUpdate() { }
}
/**
 * The SchedulingActivator class keeps a map of StyleDefinition instances that are scheduled for
 * activation or deactivation. Each instance is mapped to a refernce count, which is incremented
 * upon the activate calls and decremented upon the deactivate calls. When the doActivation
 * method is called The style definition will be either activated or deactivated based on whether
 * the reference count is positive or negative.
 */
class SchedulingActivator {
    constructor(scheduler) {
        // Array of functions that will be invoked when the scheduled update runs.
        this.actions = [];
        if (scheduler) {
            scheduler.init(() => this.doDOMUpdate());
            this.scheduler = scheduler;
        }
    }
    /**
     * Instructs to activate the given style definition instance.
     */
    activate(definition) {
        if (this.isSchedulingNeeded)
            this.scheduler.scheduleDOMUpdate();
        this.actions.push(() => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.activateSD)(definition));
    }
    /**
     * Instructs to deactivate the given style definition instance.
     */
    deactivate(definition) {
        if (this.isSchedulingNeeded)
            this.scheduler.scheduleDOMUpdate();
        this.actions.push(() => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.deactivateSD)(definition));
    }
    /**
     * Instructs to set the value of either a single property or a set of properties in the given
     * CSS style object.
     */
    updateStyle(ruleOrElm, name, value, important) {
        if (this.isSchedulingNeeded)
            this.scheduler.scheduleDOMUpdate();
        this.actions.push(() => updateStyleProperty(ruleOrElm, name, value, important));
    }
    /**
     * Performs activation/deactivation for all style definitions in our internal map.
     */
    forceDOMUpdate() {
        if (this.actions.length > 0) {
            this.doDOMUpdate();
            this.scheduler && this.scheduler.cancelDOMUpdate();
        }
    }
    /**
     * Cancels activation/deactivation for all style definitions accumulated since the last
     * activation/deactivation.
     */
    cancelDOMUpdate() {
        if (this.actions.length > 0) {
            this.actions = [];
            this.scheduler && this.scheduler.cancelDOMUpdate();
        }
    }
    get isSchedulingNeeded() {
        return !!this.scheduler && !this.actions.length;
    }
    /**
     * Performs activation/deactivation and property set operations accumulated internally. This
     * method should be used by the derived classes when scheduled activations should be performed.
     */
    doDOMUpdate() {
        // update style properties
        for (let action of this.actions)
            action();
        this.actions = [];
    }
}
/**
 * The AnimationFrameScheduler implements scheduling using animation frames.
 */
class AnimationFrameScheduler {
    constructor() {
        // Handle returned by requestAnimationFrame function.
        this.h = 0;
        /**
         * Is invoked when animation frame should be executed.
         */
        this.onFrame = () => {
            this.h = 0;
            this.cb();
        };
    }
    /**
     * Initializes the scheduler object and provides the callback that should be invoked when the
     * scheduler decides to make changes to the DOM.
     */
    init(doDOMUpdate) {
        this.cb = doDOMUpdate;
    }
    /**
     * Is invoked when the scheduler needs to schedule its callback or event.
     */
    scheduleDOMUpdate() {
        this.h = requestAnimationFrame(this.onFrame);
    }
    /**
     * Is invoked when the scheduler needs to cancels its scheduled callback or event.
     */
    cancelDOMUpdate() {
        if (this.h > 0) {
            cancelAnimationFrame(this.h);
            this.h = 0;
        }
    }
}
/**
 * Returns the activator for the given scheduler type. If scheduler type is not specified returns
 * the activator currently set as default. If, for some reason, the default activator is not set,
 * returns the synchronous activator.
 */
const getActivator = (schedulerType) => (schedulerType == null ? s_defaultActivator : s_registeredActivators.get(schedulerType)) ?? s_synchronousActivator;
/**
 * Sets the default scheduling type that is used by activate and deactivate functions that are
 * called without explicitly providing value to the scheduling parameter. Returns the type of the
 * previous default activator or 0 if an error occurs (e.g. the given scheduler type ID is not
 * registered).
 */
const setDefaultScheduler = (schedulerType) => {
    // check that the given number is in our map of registered activators
    let activator = s_registeredActivators.get(schedulerType);
    if (!activator)
        return 0;
    let prevSchedulerType = s_defaultSchedulerType;
    s_defaultSchedulerType = schedulerType;
    s_defaultActivator = activator;
    return prevSchedulerType;
};
/**
 * Registers the given scheduler object and returns the scheduler type identifier, which
 * should be used when calling activate and deactivate functions.
 */
const registerScheduler = (scheduler) => {
    // get the registration ID for this scheduler
    let id = s_nextCustomSchedulerType++;
    s_registeredActivators.set(id, new SchedulingActivator(scheduler));
    return id;
};
/**
 * Current default scheduler. This scheduler will be used if scheduler type is not explicitly
 * specified in calls such as activate or IStyleRule.setProp.
 */
let s_defaultSchedulerType = 1 /* Sync */;
/**
 * Synchronous activator instance.
 */
const s_synchronousActivator = new SynchronousActivator();
/**
 * Current default activator. This activator will be used if scheduler type is not explicitly
 * specified in calls such as activate or IStyleRule.setProp.
 */
let s_defaultActivator = s_synchronousActivator;
/**
 * Scheduler type identifier to be assigned to the first custom scheduler to be registered.
 * All custom scheduler identifiers are greater or equal to this number.
 */
const s_firstCustomSchedulerType = 1001;
/**
 * Scheduler type identifier to be assigned to the next custom scheduler to be registered.
 */
let s_nextCustomSchedulerType = s_firstCustomSchedulerType;
/**
 * Map of registered built-in and custom activators.
 */
const s_registeredActivators = new Map();
/**
 * Register built-in and custom activators.
 */
s_registeredActivators.set(1 /* Sync */, s_synchronousActivator);
s_registeredActivators.set(2 /* AnimationFrame */, new SchedulingActivator(new AnimationFrameScheduler()));
s_registeredActivators.set(3 /* Manual */, new SchedulingActivator());


/***/ }),

/***/ "./lib/impl/StyleImpl.js":
/*!*******************************!*\
  !*** ./lib/impl/StyleImpl.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sp2s": () => (/* binding */ sp2s),
/* harmony export */   "s2s": () => (/* binding */ s2s),
/* harmony export */   "s2ss": () => (/* binding */ s2ss),
/* harmony export */   "s_registerSP": () => (/* binding */ s_registerSP)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules/RuleContainer */ "./lib/rules/RuleContainer.js");


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Functions for converting CSS property types to strings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
const borderImageToString = (val) => {
    // if width is specified, but slice is not, we need to set slice to the default 100% value;
    // if outset is specified but width is not. we need to set width to the default 1 value;
    let valCopy = Object.assign({}, val);
    if (val.slice == null && (val.width != null || val.outset != null))
        valCopy.slice = "100%";
    if (val.width == null && val.outset != null)
        valCopy.width = 1;
    return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.o2s)(valCopy, [
        "source",
        "slice",
        ["width", undefined, "/"],
        ["outset", undefined, "/"],
        "repeat",
        "mode"
    ]);
};
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[25] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    obj: [
        ["inset", (v) => v ? "inset" : ""],
        ["x", 3 /* Length */],
        ["y", 3 /* Length */],
        ["blur", 3 /* Length */],
        ["spread", 3 /* Length */],
        ["color", 11 /* Color */]
    ]
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[26] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    obj: 25 /* BoxShadowSingle */,
    item: 25 /* BoxShadowSingle */,
    sep: ","
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[19] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    num: 3 /* Length */,
    arr: arr => {
        let numbersProcessed = 0;
        return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(arr, item => typeof item === "number"
            ? (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(item, numbersProcessed++ ? 11 /* Color */ : 3 /* Length */)
            : (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(item));
    },
});
const gridTemplateAreasToString = (val) => 
// val can be array of strings or GridTemplateArea_Definition touples
(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    arr: v => typeof v[0] === "string" ? (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v, 23 /* Quoted */) : createGridTemplateAreasFromDefinitions(v)
});
/**
 * Converts the array of GridTemplateArea_Definition objects to a string that is suitable for
 * the grid-template-areas format.
 */
const createGridTemplateAreasFromDefinitions = (defs) => {
    // calculate total size of the matrix from the areas' sizes
    let rowCount = 0, colCount = 0;
    for (let def of defs) {
        rowCount = Math.max(rowCount, def[3]);
        colCount = Math.max(colCount, def[4]);
    }
    if (rowCount === 0 || colCount === 0)
        return "";
    // create array of rows where every element is an array of cells
    let matrix = new Array(rowCount);
    for (let i = 0; i < rowCount; i++)
        matrix[i] = new Array(colCount);
    // go over definitions and fill the appropriate places in the cells with area names
    for (let def of defs) {
        let name = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(def[0]);
        for (let i = def[1]; i <= def[3]; i++) {
            for (let j = def[2]; j <= def[4]; j++)
                matrix[i - 1][j - 1] = name;
        }
    }
    // go over our matrix and for every row create a quoted string. Since our cell arrays may be
    // sparse, use dot for the undefined cells
    let s = "";
    for (let i = 0; i < rowCount; i++) {
        let rowNames = [];
        for (let j = 0; j < rowCount; j++) {
            let name = matrix[i][j];
            rowNames.push(name ? name : ".");
        }
        s += `"${rowNames.join(" ")}"\n`;
    }
    return s;
};
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[22] = (v) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, {
    num: 3 /* Length */,
    arr: v => `[${(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v)}]`
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[21] = (v) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, {
    num: 3 /* Length */,
    item: 22 /* GridTrack */
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[29] = (val) => {
    return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
        obj: v => `url(#${v.name})`
    });
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Functions for handling Stylesets.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given style property to the CSS style string. Property name can be in either
 * dash or camel form.
 */
const sp2s = (propName, propVal) => {
    if (!propName)
        return "";
    // handle special properties "!" and "[]"
    let impFlag = false;
    if (typeof propVal === "object") {
        if ("!" in propVal) {
            // if the property value is an object with the "!" property, then the actual value is
            // the value of this property and we also need to set the "!important" flag.
            propVal = propVal["!"];
            impFlag = true;
        }
        else if ("[]" in propVal) {
            // If the property value is an object with the "[]" property, then we take the last
            // value from this property's array.
            let arr = propVal["[]"];
            if (!arr || arr.length === 0)
                return "";
            // recurse with the last value from the array
            return sp2s(propName, arr[arr.length - 1]);
        }
    }
    // convert the value to string based on the information object for the property (if defined)
    let stringValue = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(propVal, stylePropertyInfos[(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(propName)]);
    if (!stringValue)
        return "";
    if (impFlag)
        stringValue += " !important";
    return stringValue;
};
/** Converts the given styleset to its string representation */
const s2s = (styleset) => {
    if (!styleset)
        return "{}";
    let s = "{";
    // enumerate all styleset properties retrieving also vendor-prefixed variants
    forAllPropsInStylset(styleset, (name, value, isCustom, isPrefixed) => {
        s += isCustom
            ? `${name}:${value};`
            : `${isPrefixed ? "-" : ""}${(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.camelToDash)(name)}:${value};`;
    });
    return s + "}";
};
/**
 * Converts the given Styleset object into a StringStyleset object, where each Styleset's property
 * is converted to its string value.
 */
const s2ss = (styleset) => {
    // enumerate all styleset properties without retrieving vendor-prefixed variants
    let res = {};
    forAllPropsInStylset(styleset, (name, value) => { res[name] = value; });
    return res;
};
/**
 * Extracts name, template and string tuples from the given custom CSS property definition.
 * @param customVars
 */
const getVarsNTVs = (customVars) => {
    if (Array.isArray(customVars)) {
        let varName;
        let template;
        let value;
        if (customVars.length === 2) {
            varName = customVars[0].name;
            template = customVars[0].template;
            value = customVars[1];
        }
        else {
            varName = customVars[0];
            template = customVars[1];
            value = customVars[2];
        }
        if (!varName || !template)
            return [];
        if (!varName.startsWith("--"))
            varName = "--" + varName;
        return [[varName, template, sp2s(template, value)]];
    }
    else {
        let varRules = (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.getVarsFromSD)(customVars);
        return varRules.map(varRule => [varRule.cssName, varRule.template,
            sp2s(varRule.template, varRule.getValue())]);
    }
};
/**
 * For each property - regular and custom - in the given styleset invokes the appropriate
 * function that gets the property name and the value converted to string.
 * @param styleset
 * @param callback
 * @param getPrefixedVariants Flag indicating whether we need to retrieve property variants with
 * vendor prefixes
 */
const forAllPropsInStylset = (styleset, callback) => {
    for (let propName in styleset) {
        // special handling of the "--" property, which is an array where each item is
        // a two-item or three-item array
        if (propName === "--") {
            let customVars = styleset[propName];
            for (let customVar of customVars) {
                if (!customVar)
                    continue;
                // in each tuple, the first element is var name, the second is template property and
                // the third is the value;
                let ntvs = getVarsNTVs(customVar);
                for (let ntv of ntvs)
                    callback(ntv[0], ntv[2], true, false);
            }
        }
        else {
            let propVal = styleset[propName];
            if (propVal == null)
                continue;
            else {
                // check whether the property contains an array of values behind the object with
                // the "[]" property. If not, convert the single value to an array, so that we can
                // iterate over it.
                let propArray = propVal["[]"];
                if (!propArray)
                    propArray = [propVal];
                for (let propVal of propArray) {
                    // get the string representation of the property value
                    let propString = sp2s(propName, propVal);
                    if (!propString)
                        continue;
                    // get vendor-prefixed variants
                    let variants = getPrefixVariants(propName, propString);
                    if (variants) {
                        for (let variant of variants)
                            callback(variant[0], variant[1], false, variant[0] !== propName);
                    }
                    // invoke the callback for the originally found prop name and with (perhaps updated)
                    // value
                    callback(propName, propString, false, false);
                }
            }
        }
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Registry of CSS properties that specifies how their values should be converted to strings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
const s_registerSP = (name, toStringFunc) => name in stylePropertyInfos ? false : (stylePropertyInfos[name] = toStringFunc, true);
/**
 * Map of property names to the V2SOptions objects describing custom actions necessary to
 * convert the property value to the CSS-compliant string.
 */
const stylePropertyInfos = {
    accentColor: 11 /* Color */,
    animation: {
        any: { obj: [
                ["duration", 5 /* Time */],
                "func",
                ["delay", 5 /* Time */],
                ["count", 1 /* Number */],
                "direction",
                "mode",
                "state",
                "name"
            ] },
        sep: ",",
    },
    animationDelay: 14 /* MultiTimeWithComma */,
    animationDuration: 14 /* MultiTimeWithComma */,
    animationIterationCount: 15 /* OneOrManyWithComma */,
    animationFillMode: 15 /* OneOrManyWithComma */,
    animationName: 15 /* OneOrManyWithComma */,
    animationPlayState: 15 /* OneOrManyWithComma */,
    animationTimingFunction: 15 /* OneOrManyWithComma */,
    background: {
        num: 11 /* Color */,
        any: {
            num: 11 /* Color */,
            obj: [
                ["color", 11 /* Color */],
                "image",
                ["position", 8 /* Position */],
                ["size", 13 /* MultiLengthWithSpace */, "/"],
                "repeat",
                "attachment",
                "origin",
                "clip"
            ]
        },
        sep: ",",
    },
    backgroundAttachment: 15 /* OneOrManyWithComma */,
    backgroundBlendMode: 15 /* OneOrManyWithComma */,
    backgroundClip: 15 /* OneOrManyWithComma */,
    backgroundColor: 11 /* Color */,
    backgroundImage: 15 /* OneOrManyWithComma */,
    backgroundOrigin: 15 /* OneOrManyWithComma */,
    backgroundPosition: 12 /* MultiPosition */,
    backgroundPositionX: 12 /* MultiPosition */,
    backgroundPositionY: 12 /* MultiPosition */,
    backgroundRepeat: 15 /* OneOrManyWithComma */,
    backgroundSize: {
        num: 3 /* Length */,
        item: { any: 3 /* Length */ },
        sep: ","
    },
    baselineShift: 3 /* Length */,
    blockSize: 3 /* Length */,
    border: 19 /* Border */,
    borderBlock: 19 /* Border */,
    borderBlockColor: 30 /* Colors */,
    borderBlockEnd: 19 /* Border */,
    borderBlockEndColor: 11 /* Color */,
    borderBlockEndWidth: 3 /* Length */,
    borderBlockStart: 19 /* Border */,
    borderBlockStartColor: 11 /* Color */,
    borderBlockStartWidth: 3 /* Length */,
    borderBlockWidth: 3 /* Length */,
    borderBottom: 19 /* Border */,
    borderBottomColor: 11 /* Color */,
    borderBottomLeftRadius: 18 /* Radius */,
    borderBottomRightRadius: 18 /* Radius */,
    borderBottomWidth: 3 /* Length */,
    borderColor: 30 /* Colors */,
    borderEndEndRadius: 18 /* Radius */,
    borderEndStartRadius: 18 /* Radius */,
    borderImage: {
        obj: borderImageToString,
    },
    borderInline: 19 /* Border */,
    borderInlineColor: 30 /* Colors */,
    borderInlineEnd: 19 /* Border */,
    borderInlineEndColor: 11 /* Color */,
    borderInlineEndWidth: 3 /* Length */,
    borderInlineStart: 19 /* Border */,
    borderInlineStartColor: 11 /* Color */,
    borderInlineStartWidth: 3 /* Length */,
    borderInlineWidth: 3 /* Length */,
    borderLeft: 19 /* Border */,
    borderLeftColor: 11 /* Color */,
    borderLeftWidth: 3 /* Length */,
    borderRadius: 20 /* BorderRadius */,
    borderRight: 19 /* Border */,
    borderRightColor: 11 /* Color */,
    borderRightWidth: 3 /* Length */,
    borderSpacing: 13 /* MultiLengthWithSpace */,
    borderStartEndRadius: 18 /* Radius */,
    borderStartStartRadius: 18 /* Radius */,
    borderTop: 19 /* Border */,
    borderTopColor: 11 /* Color */,
    borderTopLeftRadius: 18 /* Radius */,
    borderTopRightRadius: 18 /* Radius */,
    borderTopWidth: 3 /* Length */,
    borderWidth: 13 /* MultiLengthWithSpace */,
    bottom: 3 /* Length */,
    boxShadow: 26 /* BoxShadow */,
    caretColor: 11 /* Color */,
    clip: {
        arr: v => `rect(${_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[13](v)}`
    },
    color: 11 /* Color */,
    columnGap: 3 /* Length */,
    columnRule: 19 /* Border */,
    columnRuleColor: 11 /* Color */,
    columnRuleWidth: 13 /* MultiLengthWithSpace */,
    columnWidth: 3 /* Length */,
    content: {
        str: 23 /* Quoted */,
        item: 23 /* Quoted */
    },
    cursor: 15 /* OneOrManyWithComma */,
    fill: 11 /* Color */,
    fillOpacity: 2 /* Percent */,
    flex: {
        num: 3 /* Length */,
        arr: {
            3: [1 /* Number */, 1 /* Number */, 3 /* Length */]
        }
    },
    flexBasis: 3 /* Length */,
    floodColor: 11 /* Color */,
    font: {
        item: 3 /* Length */,
        obj: [
            ["style", 24 /* FontStyle */],
            "variant",
            "weight",
            "stretch",
            ["size", 3 /* Length */],
            ["lineHeight", undefined, "/"],
            "family"
        ]
    },
    fontSize: 3 /* Length */,
    fontStretch: 2 /* Percent */,
    fontStyle: 24 /* FontStyle */,
    gap: 13 /* MultiLengthWithSpace */,
    gridColumnGap: 3 /* Length */,
    gridGap: 13 /* MultiLengthWithSpace */,
    gridRowGap: 3 /* Length */,
    gridArea: 16 /* OneOrManyWithSlash */,
    gridAutoColumns: 21 /* GridAxis */,
    gridAutoRows: 21 /* GridAxis */,
    gridColumn: 16 /* OneOrManyWithSlash */,
    gridRow: 16 /* OneOrManyWithSlash */,
    gridTemplateAreas: gridTemplateAreasToString,
    gridTemplateColumns: 21 /* GridAxis */,
    gridTemplateRows: 21 /* GridAxis */,
    height: 3 /* Length */,
    inlineSize: 3 /* Length */,
    inset: 13 /* MultiLengthWithSpace */,
    insetBlock: 13 /* MultiLengthWithSpace */,
    insetBlockEnd: 3 /* Length */,
    insetBlockStart: 3 /* Length */,
    insetInline: 13 /* MultiLengthWithSpace */,
    insetInlineEnd: 3 /* Length */,
    insetInlineStart: 3 /* Length */,
    left: 3 /* Length */,
    letterSpacing: 3 /* Length */,
    lightingColor: 11 /* Color */,
    margin: 13 /* MultiLengthWithSpace */,
    marginBlock: 13 /* MultiLengthWithSpace */,
    marginBlockEnd: 3 /* Length */,
    marginBlockStart: 3 /* Length */,
    marginBottom: 3 /* Length */,
    marginInline: 13 /* MultiLengthWithSpace */,
    marginInlineEnd: 3 /* Length */,
    marginInlineStart: 3 /* Length */,
    marginLeft: 3 /* Length */,
    marginRight: 3 /* Length */,
    marginTop: 3 /* Length */,
    markerEnd: 29 /* Marker */,
    markerMid: 29 /* Marker */,
    markerStart: 29 /* Marker */,
    maskBorder: {
        obj: borderImageToString,
    },
    maskClip: 15 /* OneOrManyWithComma */,
    maskComposite: 15 /* OneOrManyWithComma */,
    maskImage: 15 /* OneOrManyWithComma */,
    maskMode: 15 /* OneOrManyWithComma */,
    maskOrigin: 15 /* OneOrManyWithComma */,
    maskPosition: 12 /* MultiPosition */,
    maskRepeat: 15 /* OneOrManyWithComma */,
    maskSize: {
        num: 3 /* Length */,
        item: { any: 3 /* Length */ },
        sep: ","
    },
    maxBlockSize: 3 /* Length */,
    maxHeight: 3 /* Length */,
    maxInlineSize: 3 /* Length */,
    maxWidth: 3 /* Length */,
    minBlockSize: 3 /* Length */,
    minHeight: 3 /* Length */,
    minInlineSize: 3 /* Length */,
    minWidth: 3 /* Length */,
    objectPosition: 8 /* Position */,
    offset: {
        obj: [
            ["position", 8 /* Position */],
            "path",
            ["distance", 3 /* Length */],
            ["rotate", { any: 4 /* Angle */ }],
            ["anchor", 8 /* Position */, "/"],
        ]
    },
    offsetAnchor: 8 /* Position */,
    offsetDistance: 3 /* Length */,
    offsetPosition: 8 /* Position */,
    offsetRotate: {
        any: 4 /* Angle */
    },
    outline: 19 /* Border */,
    outlineColor: 11 /* Color */,
    outlineOffset: 3 /* Length */,
    overflowClipMargin: 3 /* Length */,
    padding: 13 /* MultiLengthWithSpace */,
    paddingBlock: 13 /* MultiLengthWithSpace */,
    paddingBlockEnd: 3 /* Length */,
    paddingBlockStart: 3 /* Length */,
    paddingBottom: 3 /* Length */,
    paddingInline: 13 /* MultiLengthWithSpace */,
    paddingInlineEnd: 3 /* Length */,
    paddingInlineStart: 3 /* Length */,
    paddingLeft: 3 /* Length */,
    paddingRight: 3 /* Length */,
    paddingTop: 3 /* Length */,
    perspective: 3 /* Length */,
    perspectiveOrigin: 13 /* MultiLengthWithSpace */,
    quotes: {
        item: {
            str: 23 /* Quoted */,
            item: 23 /* Quoted */,
        }
    },
    right: 3 /* Length */,
    rotate: {
        num: 4 /* Angle */,
        arr: {
            2: [0 /* Default */, 4 /* Angle */],
            any: [0 /* Default */, 0 /* Default */, 0 /* Default */, 4 /* Angle */],
        }
    },
    rowGap: 3 /* Length */,
    scrollMargin: 13 /* MultiLengthWithSpace */,
    scrollMarginBlock: 13 /* MultiLengthWithSpace */,
    scrollMarginBlockEnd: 3 /* Length */,
    scrollMarginBlockStart: 3 /* Length */,
    scrollMarginBottom: 3 /* Length */,
    scrollMarginInline: 13 /* MultiLengthWithSpace */,
    scrollMarginInlineEnd: 3 /* Length */,
    scrollMarginInlineStart: 3 /* Length */,
    scrollMarginLeft: 3 /* Length */,
    scrollMarginRight: 3 /* Length */,
    scrollMarginTop: 3 /* Length */,
    scrollPadding: 13 /* MultiLengthWithSpace */,
    scrollPaddingBlock: 13 /* MultiLengthWithSpace */,
    scrollPaddingBlockEnd: 3 /* Length */,
    scrollPaddingBlockStart: 3 /* Length */,
    scrollPaddingBottom: 3 /* Length */,
    scrollPaddingInline: 13 /* MultiLengthWithSpace */,
    scrollPaddingInlineEnd: 3 /* Length */,
    scrollPaddingInlineStart: 3 /* Length */,
    scrollPaddingLeft: 3 /* Length */,
    scrollPaddingRight: 3 /* Length */,
    scrollPaddingTop: 3 /* Length */,
    scrollbarColor: {
        item: 11 /* Color */
    },
    shapeMargin: 3 /* Length */,
    stopColor: 11 /* Color */,
    stroke: 11 /* Color */,
    textCombineUpright: {
        num: v => `digits ${v}`
    },
    textDecoration: {
        num: 11 /* Color */,
        obj: [
            "line",
            "style",
            ["color", 11 /* Color */],
            ["thickness", 3 /* Length */],
        ]
    },
    textDecorationColor: 11 /* Color */,
    textDecorationThickness: 3 /* Length */,
    textEmphasis: 11 /* Color */,
    textEmphasisColor: 11 /* Color */,
    textFillColor: 11 /* Color */,
    textIndent: 13 /* MultiLengthWithSpace */,
    textShadow: 26 /* BoxShadow */,
    textSizeAdjust: 2 /* Percent */,
    textStrokeColor: 11 /* Color */,
    textStrokeWidth: 3 /* Length */,
    top: 3 /* Length */,
    transformOrigin: 13 /* MultiLengthWithSpace */,
    transition: {
        any: { obj: [
                ["property", _Utils__WEBPACK_IMPORTED_MODULE_0__.camelToDash],
                ["duration", 5 /* Time */],
                "func",
                ["delay", 5 /* Time */]
            ] },
        sep: ",",
    },
    transitionDelay: 14 /* MultiTimeWithComma */,
    transitionDuration: 14 /* MultiTimeWithComma */,
    transitionTimingFunction: 15 /* OneOrManyWithComma */,
    translate: 13 /* MultiLengthWithSpace */,
    verticalAlign: 3 /* Length */,
    width: 3 /* Length */,
    willChange: {
        str: _Utils__WEBPACK_IMPORTED_MODULE_0__.camelToDash
    },
    wordSpacing: 3 /* Length */,
    zoom: 2 /* Percent */,
    // properties for CSS syntax values
    "<number>#": 15 /* OneOrManyWithComma */,
    "<length>": 3 /* Length */,
    "<length>+": 13 /* MultiLengthWithSpace */,
    "<length>#": { any: 3 /* Length */, sep: "," },
    "<percentage>": 2 /* Percent */,
    "<percentage>+": { any: 2 /* Percent */ },
    "<percentage>#": { any: 2 /* Percent */, sep: "," },
    "<length-percentage>": 3 /* Length */,
    "<length-percentage>+": 13 /* MultiLengthWithSpace */,
    "<length-percentage>#": { any: 3 /* Length */, sep: "," },
    "<angle>": 4 /* Angle */,
    "<angle>+": { any: 4 /* Angle */ },
    "<angle>#": { any: 4 /* Angle */, sep: "," },
    "<time>": 5 /* Time */,
    "<time>+": { any: 5 /* Time */ },
    "<time>#": 14 /* MultiTimeWithComma */,
    "<resolution>": 6 /* Resolution */,
    "<resolution>+": { any: 6 /* Resolution */ },
    "<resolution>#": { any: 6 /* Resolution */, sep: "," },
    "<color>": 11 /* Color */,
    "<color>+": { any: 11 /* Color */ },
    "<color>#": { any: 11 /* Color */, sep: "," },
    "<image>#": 15 /* OneOrManyWithComma */,
    "<custom-ident>#": 15 /* OneOrManyWithComma */,
    // special properties for IVarRule types
    "<string>": 23 /* Quoted */,
    "<frequency>": 7 /* Frequency */,
    "<size>": 3 /* Length */,
    "<point>": 13 /* MultiLengthWithSpace */,
    "<position>": 8 /* Position */,
    "<multi-position>": 12 /* MultiPosition */,
    "<radius>": 18 /* Radius */,
};
// Vendor prefixes with indexes from the VendorPrefix enumeration. The first one is only here to
// allow the first enumeration value to be 1 and not zero.
const vendorPrefixStrings = ["", "webkit", "moz", "ms"];
const getPrefixVariants = (name, value) => {
    let info = propPrefixInfos[name];
    if (!info)
        return null;
    if (typeof info === "string")
        return [[info, value]];
    if (typeof info === "number")
        return [[(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(`${vendorPrefixStrings[info]}-${name}`), value]];
    let variants = [];
    for (let item of info) {
        if (typeof item === "string")
            variants.push([item, value]);
        else if (typeof item === "number")
            variants.push([(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(`${vendorPrefixStrings[item]}-${name}`), value]);
        else {
            let prefixString = vendorPrefixStrings[item.p];
            // determine whether the property name should be prefixed. Note that even if we decide
            // here that it should not be prefixed, it can change when we go over property values.
            let shouldPrefixProperty = !item.valsOnly;
            // if property values are defined, try to replace them with prefixed versions. Note that
            // this can also set the flag indicating that the property name should be prefixed too.
            let newPropValue = "";
            if (value && item.vals) {
                for (let valueInfo of item.vals) {
                    let valueToSearch = valueInfo.val;
                    if (value.indexOf(valueToSearch) < 0)
                        continue;
                    if (valueInfo.mode !== 2 /* PropertyOnly */) {
                        newPropValue = value.split(valueToSearch).join(valueInfo.alt ? valueInfo.alt : `-${prefixString}-${valueToSearch}`);
                        value = newPropValue;
                    }
                    if (valueInfo.mode !== 1 /* ValueOnly */)
                        shouldPrefixProperty = true;
                }
            }
            let newPropName = "";
            if (shouldPrefixProperty)
                newPropName = item.alt ? item.alt : (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(`${prefixString}-${name}`);
            if (newPropName || newPropValue)
                variants.push([newPropName || name, newPropValue || value]);
        }
    }
    return variants.length > 0 ? variants : null;
};
// Prefix information for size-like properties that accept "stretch" value
const sizePrefixInfos = [
    { p: 1 /* webkit */, valsOnly: true, vals: [{ val: "stretch", mode: 1 /* ValueOnly */, alt: "-webkit-fill-available" }] },
];
// Prefix information for properties that accept "cross-fade" and "image-set" functions (that is, images)
const imageFuncsPrefixInfo = {
    p: 1 /* webkit */, valsOnly: true, vals: [
        { val: "cross-fade", mode: 1 /* ValueOnly */ },
        { val: "image-set", mode: 1 /* ValueOnly */ }
    ]
};
const imageFuncsPrefixInfos = [imageFuncsPrefixInfo];
const propPrefixInfos = {
    appearance: [1 /* webkit */, 2 /* moz */],
    backgroundClip: [
        { p: 1 /* webkit */, valsOnly: true, vals: [{ val: "text", mode: 2 /* PropertyOnly */ }] }
    ],
    blockSize: sizePrefixInfos,
    boxDecorationBreak: 1 /* webkit */,
    background: imageFuncsPrefixInfos,
    backgroundImage: imageFuncsPrefixInfos,
    borderImage: imageFuncsPrefixInfos,
    borderImageSource: imageFuncsPrefixInfos,
    clipPath: 1 /* webkit */,
    colorAdjust: "webkitPrintColorAdjust",
    content: imageFuncsPrefixInfos,
    height: sizePrefixInfos,
    hyphens: [1 /* webkit */, 2 /* moz */, 3 /* ms */],
    initialLetter: 1 /* webkit */,
    inlineSize: sizePrefixInfos,
    lineClamp: 1 /* webkit */,
    mask: 1 /* webkit */,
    maskBorder: ["webkitMaskBoxImage", imageFuncsPrefixInfo],
    maskBorderOutset: "webkitMaskBoxImageOutset",
    maskBorderRepeat: "webkitMaskBoxImageRepeat",
    maskBorderSlice: "webkitMaskBoxImageSlice",
    maskBorderSource: "webkitMaskBoxImageSource",
    maskBorderWidth: "webkitMaskBoxImageWidth",
    maskClip: 1 /* webkit */,
    maskComposite: 1 /* webkit */,
    maskImage: [1 /* webkit */, imageFuncsPrefixInfo],
    maskMode: 1 /* webkit */,
    maskOrigin: 1 /* webkit */,
    maskPosition: 1 /* webkit */,
    maskRepeat: 1 /* webkit */,
    maskSize: 1 /* webkit */,
    maskType: 1 /* webkit */,
    maxBlockSize: sizePrefixInfos,
    maxHeight: sizePrefixInfos,
    maxInlineSize: sizePrefixInfos,
    maxWidth: sizePrefixInfos,
    minBlockSize: sizePrefixInfos,
    minHeight: sizePrefixInfos,
    minInlineSize: sizePrefixInfos,
    minWidth: sizePrefixInfos,
    shapeOutside: imageFuncsPrefixInfos,
    scrollbarColor: 1 /* webkit */,
    scrollbarWidth: 1 /* webkit */,
    textEmphasis: 1 /* webkit */,
    textEmphasisColor: 1 /* webkit */,
    textEmphasisPosition: 1 /* webkit */,
    textEmphasisStyle: 1 /* webkit */,
    textFillColor: 1 /* webkit */,
    textOrientation: 1 /* webkit */,
    textSizeAdjust: [1 /* webkit */, 2 /* moz */, 3 /* ms */],
    textStroke: 1 /* webkit */,
    textStrokeColor: 1 /* webkit */,
    textStrokeWidth: 1 /* webkit */,
    userSelect: [
        { p: 1 /* webkit */, vals: [{ val: "none", mode: 2 /* PropertyOnly */ }] }
    ],
    width: sizePrefixInfos,
};


/***/ }),

/***/ "./lib/impl/Utils.js":
/*!***************************!*\
  !*** ./lib/impl/Utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dashToCamel": () => (/* binding */ dashToCamel),
/* harmony export */   "camelToDash": () => (/* binding */ camelToDash),
/* harmony export */   "symV2S": () => (/* binding */ symV2S),
/* harmony export */   "wkf": () => (/* binding */ wkf),
/* harmony export */   "v2s": () => (/* binding */ v2s),
/* harmony export */   "a2s": () => (/* binding */ a2s),
/* harmony export */   "t2s": () => (/* binding */ t2s),
/* harmony export */   "o2s": () => (/* binding */ o2s),
/* harmony export */   "mv2s": () => (/* binding */ mv2s),
/* harmony export */   "f2s": () => (/* binding */ f2s),
/* harmony export */   "tag2s": () => (/* binding */ tag2s),
/* harmony export */   "propSet2s": () => (/* binding */ propSet2s),
/* harmony export */   "fdo": () => (/* binding */ fdo),
/* harmony export */   "fdo2s": () => (/* binding */ fdo2s)
/* harmony export */ });
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Case conversions for property names.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts dashe-case to camelCase, e.g. font-size to fontSize.
 * @param dash
 */
const dashToCamel = (dash) => !dash ? dash : dash.replace(/-([a-zA-Z])/g, (x, $1) => $1.toUpperCase());
/**
 * Converts camelCase to dash-case, e.g. fontSize to font-size.
 * @param camel
 */
const camelToDash = (camel) => camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Conversion of values to strings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Symbol under which a function is defined that converts an object to a string. We need a special
 * symbol because the standard method toString exists on every object and we only want some to
 * explicitly provide this support.
 */
const symV2S = Symbol();
/**
 * Array of well known conversion functions. Indexes are the identifier of well known functions
 * from the WellKnownFunc enumeration
 */
let wkf = new Array(31 /* Last */);
/**
 * Converts a value of an arbitrary type to a single string. The options parameter
 * can define how specific types are converted.
 */
const v2s = (val, options) => {
    // if options is not specified, do standard processing
    if (options == null) {
        if (typeof val === "string")
            return val;
        else if (Array.isArray(val))
            return a2s(val);
        else if (typeof val === "function")
            return v2s(val());
        else if (val == null)
            return "";
        else if (typeof val[symV2S] === "function")
            return val[symV2S]();
        else if (typeof val.fn === "string")
            return fdo2s(val);
        else
            return val.toString();
    }
    // do different things for different types of options
    if (typeof options == "number")
        return wkf[options] ? wkf[options](val) : "";
    else if (typeof options == "function")
        return options(val);
    else {
        // processing with options. For all types except null and string, if the type-specific
        // property is not defined, use options.any if defined.
        let newOptions = undefined;
        if (val == null)
            return options.nil ? typeof options.nil === "string" ? options.nil : options.nil(val) : "";
        else if (typeof val === "number")
            newOptions = options.num ?? options.any;
        else if (typeof val === "function")
            return v2s(val());
        else if (Array.isArray(val)) {
            if (val.length === 0)
                return "";
            else if (typeof options.arr === "object") // this can also be an array
                return t2s(val, options.arr, options.sep);
            else if (options.arr2 && Array.isArray(val[0]))
                newOptions = options.arr2;
            else if (options.arr)
                newOptions = options.arr;
            else
                return a2s(val, options.item ?? options.any ?? (options.recursive ? options : undefined), options.sep);
        }
        else if (typeof val === "object") {
            if (typeof val[symV2S] === "function")
                return val[symV2S]();
            else if (typeof val.fn === "string")
                return fdo2s(val);
            else if (options.obj || options.any) {
                if (Array.isArray(options.obj))
                    return o2s(val, options.obj, options.sep);
                else
                    newOptions = options.obj ?? options.any;
            }
            else
                return val.toString();
        }
        else if (typeof val === "string")
            newOptions = options.str ?? options.any;
        else if (typeof val === "boolean")
            return options.bool ? options.bool(val) : val.toString();
        else
            return "";
        return v2s(val, newOptions);
    }
};
wkf[0 /* Default */] = v2s;
wkf[15 /* OneOrManyWithComma */] = v => v2s(v, { sep: "," });
wkf[16 /* OneOrManyWithSlash */] = v => v2s(v, { sep: "/" });
wkf[23 /* Quoted */] = v => typeof v === "string" ? `"${v}"` : v2s(v);
/**
 * Converts the given array to a single string by converting every item using the given otions
 * and joining the results with the given delimiter.
 */
const a2s = (val, options, separator = " ") => !val || val.length === 0
    ? ""
    : val.map(v => v2s(v, options)).filter(v => !!v).join(separator);
/**
 * Converts the given array to a single string by converting every item using the given otions
 * and joining the results with the given delimiter.
 */
const t2s = (val, options, separator = " ") => {
    let v2sOptions = Array.isArray(options) ? options : (options[val.length] ?? options.any);
    if (!v2sOptions)
        return a2s(val, undefined, separator);
    let buf = [];
    for (let i = 0; i < v2sOptions.length; i++)
        buf.push(v2s(val[i], v2sOptions[i]));
    return buf.filter(v => !!v).join(separator);
};
/**
 * Converts properties of the given object to string by converting each property from the options
 * array and joining them using the given separator.
 * @param val Object to convert to string
 * @param options array of property names or tuples with property names, options and prefixes.
 * @param separator Separator character.
 * @param defaultOptions - V2SOptions for those properties in the "params" array that don't
 * define their own. This should be used in the case when all function parameters are of the
 * same type
 * @param defaultPrefix - prefix to use for those properties in the "params" array that don't
 * define their own prefix
 */
const o2s = (val, options, separator, defaultOptions, defaultPrefix) => {
    if (val == null)
        return "";
    let params = [];
    for (let nameOrTuple of options) {
        // get the name of the property in the value to be converted and the corresponding value;
        // if the properties value is not defined, skip it.
        let propName = typeof nameOrTuple === "string" ? nameOrTuple : nameOrTuple[0];
        let propVal = val[propName];
        if (propVal == null)
            continue;
        // check whether we have a prefix
        let prefix = typeof nameOrTuple === "string" ? defaultPrefix : nameOrTuple[2];
        if (prefix)
            params.push(prefix);
        let options = typeof nameOrTuple === "string" ? defaultOptions : nameOrTuple[1];
        params.push(v2s(propVal, options));
    }
    return params.filter(v => !!v).join(separator ?? " ");
};
/**
 * Converts the given array of values to a single string according to the specified options and
 * using the given separator. For each item in the array, the v2s function is called to convert
 * it to string.
 * @param values
 * @param separator
 */
const mv2s = (values, separator = " ") => {
    if (values == null || values.length === 0)
        return "";
    let arr = [];
    for (let item of values) {
        let val;
        let options;
        if (Array.isArray(item)) {
            val = item[0];
            options = item[1];
        }
        else
            val = item;
        if (val || (options && options.nil))
            arr.push(v2s(val, options));
    }
    return arr.filter(v => !!v).join(separator);
};
/**
 * Converts the given values as parameters to the given CSS function invocation.
 * @param name
 * @param values
 * @param separator
 */
const f2s = (name, values, separator = ",") => `${name}(${mv2s(values, separator)})`;
/**
 * The tag2s is a tag function helper that converts the template string with
 * parameters to a string using the given options object.
 */
const tag2s = (parts, params, options) => {
    // number of parameters is always 1 less than the number of string parts
    let paramsLen = params.length;
    if (paramsLen === 0)
        return parts[0];
    let s = "";
    for (let i = 0; i < paramsLen; i++)
        s += parts[i] + v2s(params[i], options);
    // add the last part
    return s + parts[paramsLen];
};
/**
 * Converts the given property set object to the CSS style string.
 */
const propSet2s = (val, infos, options) => v2s(val, {
    obj: v => {
        let propNames = Object.keys(v);
        if (propNames.length === 0)
            return "";
        let func = options?.propFunc ?? propInPropSet2s;
        let arr = propNames.map((propName) => {
            let dashPropName = camelToDash(propName);
            let camelPropName = dashToCamel(propName);
            return func(dashPropName, camelPropName, v[propName], infos[camelPropName]);
        });
        return (options?.prefix ?? "") + `${arr.join(options?.separator ?? ";")}` + (options?.suffix ?? "");
    }
});
// convert the value to string based on the information object for the property (if defined)
const propInPropSet2s = (dashName, camelName, val, options) => `${dashName}:${v2s(val, options)}`;
// This object is filled in in the XxxAPI files where the functions corresponding to CSS functions
// are defined.
const fdo = {};
/**
 * Converts the given function definition object to string. Conversion is performed according
 * to the type found in the "fdo" object for the property name equal to the "fn" property of
 * the given value. If no such property exist in the "fdo" object, all object's properties except
 * "fn" will be converted to strings using v2s and concatenated with comma.
 *
 * @param val Function definition object that has the "fn" property defining the function name.
 * @returns String representation of CSS function invocation.
 */
const fdo2s = (val) => {
    let options = fdo[val.fn];
    if (!options)
        return goOverProps(val);
    else if (typeof options === "number")
        return goOverProps(val, options);
    else if (typeof options === "function")
        return options(val);
    else if (Array.isArray(options))
        return `${val.fn}(${o2s(val, options, ",")})`;
    else {
        let fn = options.fn;
        fn = !fn ? val.fn : typeof fn === "string" ? fn : fn(val);
        return options.p
            ? `${fn}(${o2s(val, options.p, options.s ?? ",", options.do, options.dp)})`
            : options.f
                ? `${fn}(${options.f(val)})`
                : "";
    }
};
/**
 * Helper function that goes over the props of the given object except the "fn" property,
 * serializes all the props using the given options and concatenates them with the given
 * separator (comma by default).
 * @param val
 * @param options
 * @param sep
 * @returns
 */
const goOverProps = (val, options, sep) => {
    let buf = [];
    for (let p in val) {
        if (p !== "fn")
            buf.push(v2s(val[p], options));
    }
    return `${val.fn}(${buf.filter(v => !!v).join(sep ?? ",")})`;
};


/***/ }),

/***/ "./lib/rules/AnimationRule.js":
/*!************************************!*\
  !*** ./lib/rules/AnimationRule.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationRule": () => (/* binding */ AnimationRule)
/* harmony export */ });
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _StyleRules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StyleRules */ "./lib/rules/StyleRules.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");



/**
 * The AnimationRule class describes a @keyframes CSS rule.
 */
class AnimationRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.Rule {
    constructor(sd, frames, nameOverride) {
        super(sd);
        if (frames)
            this.frameRules = frames.map(frame => new AnimationFrameRule(sd, frame[0], frame[1]));
        this.nameOverride = nameOverride;
    }
    // This function is called to convert an object to a string. Animation rule returns its name.
    toString() { return this.name; }
    // Processes the given rule.
    process(ruleName) {
        super.process(ruleName);
        this.name = this.rc.getScopedName(ruleName, this.nameOverride);
        for (let keyframeRule of this.frameRules)
            keyframeRule.process(null);
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(ruleBag) {
        if (!this.frameRules)
            return;
        let mimcssRule = ruleBag.addKeyframes(this.name);
        if (mimcssRule) {
            this.cssRule = mimcssRule?.cssRule;
            for (let frameRule of this.frameRules) {
                // although the cssRule in the frame is typed as CSSStyleRule, we know that in
                // practice, it is of the CSSKeyframeRule type.
                frameRule.cssRule = mimcssRule.addFrame(frameRule.toCss())?.cssRule;
            }
        }
    }
}
/**
 * The AnimationFrameRule class represents a single keyframe clause in the animation rule.
 */
class AnimationFrameRule extends _StyleRules__WEBPACK_IMPORTED_MODULE_1__.StyleRule {
    constructor(sd, waypoint, styleset) {
        super(sd, styleset);
        this.waypoint = waypoint;
    }
    // Returns the selector part of the style rule.
    getSel() {
        return (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.v2s)(this.waypoint, { any: 2 /* Percent */, sep: "," });
    }
    /**
     * SOM keyframe rule. Although the cssRule in the frame is typed as CSSStyleRule, we know that
     * in practice, it is of the CSSKeyframeRule type.
     */
    get cssKeyframeRule() { return this.cssRule; }
    ;
}


/***/ }),

/***/ "./lib/rules/CounterRules.js":
/*!***********************************!*\
  !*** ./lib/rules/CounterRules.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CounterRule": () => (/* binding */ CounterRule),
/* harmony export */   "CounterStyleRule": () => (/* binding */ CounterStyleRule)
/* harmony export */ });
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");


/**
 * The CounterRule class describes a named counter definition. Use this rule to create
 * counter objects that can be used in counter-increment, counter-reset and counter-set style
 * properties. No CSS rule is created for counters - they are needed only to provide type-safe
 * counter definitions.
 */
class CounterRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike {
    constructor(sd, nameOverride) {
        super(sd);
        this.nameOverride = nameOverride;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the counter name.
    toString() { return this.name; }
    // Processes the given rule.
    process(ruleName) {
        this.name = this.rc.getScopedName(ruleName, this.nameOverride);
    }
    /** Name of the counter */
    get counterName() { return this.name; }
}
/**
 * The CounterStyleRule class describes the CSS @nounter-style at-rule.
 */
class CounterStyleRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(sd, counterStyleset, nameOverride) {
        super(sd);
        this.counterStyleset = counterStyleset ?? {};
        this.nameOverride = nameOverride;
    }
    /** Name of the counter */
    get counterStyleName() { return this.name; }
    // This function is used when the object is specified as a value in a style property or in
    // another counter style rule. We return the counter style name.
    toString() { return this.name; }
    // Processes the given rule.
    process(ruleName) {
        this.name = this.rc.getScopedName(ruleName, this.nameOverride);
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(ruleBag) {
        let ruleText = `@counter-style ${this.name} {${(0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.counterStyleset2s)(this.counterStyleset)}}`;
        this.cssRule = ruleBag.add(ruleText)?.cssRule;
    }
    // Serializes this rule to a string.
    toCss() {
        return `@counter-style ${this.name} {${(0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.counterStyleset2s)(this.counterStyleset)}}`;
    }
}


/***/ }),

/***/ "./lib/rules/GridRules.js":
/*!********************************!*\
  !*** ./lib/rules/GridRules.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GridLineRule": () => (/* binding */ GridLineRule),
/* harmony export */   "GridAreaRule": () => (/* binding */ GridAreaRule)
/* harmony export */ });
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");

/**
 * The GridLineRule class describes a named grid line definition. No CSS rule is created for grid
 * lines - they are needed only to provide type-safe grid line definitions.
 */
class GridLineRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.RuleLike {
    // if the nameOverride is an area rule object, the isStartEndOrNone flag is always defined
    // because this constructor can only be invoked for the start and end lines of the GridAreaRule
    // object.
    constructor(sd, nameOverride, isStartEndOrNone) {
        super(sd);
        this.nameOverride = nameOverride;
        this.isStartEndOrNone = isStartEndOrNone;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the line name.
    toString() { return this.name; }
    // Processes the given rule.
    process(ruleName) {
        super.process(ruleName);
        let name;
        let areaName;
        let isStartEndOrNone = this.isStartEndOrNone;
        let nameOverride = this.nameOverride;
        if (nameOverride instanceof GridLineRule) {
            name = nameOverride.name;
            this.isStartEndOrNone = nameOverride.isStartEndOrNone;
            areaName = nameOverride.areaName;
        }
        else if (nameOverride instanceof GridAreaRule) {
            name = nameOverride.name + (isStartEndOrNone === true ? "-start" : isStartEndOrNone === false ? "-end" : "");
            areaName = nameOverride.name;
        }
        else {
            name = this.rc.getScopedName(ruleName, nameOverride);
            // if the obtained name doesn't have "-start" or "-end" but the isStartEndOrNone flag is
            // defined (that is, it is either start or end line), we need to append the suffix. If the
            // obtained name already has "-start" or "-end" and the isStartEndOrNone flag is not
            // defined, we set this flag to either true or false depending on the suffix. Note that if
            // the nameOverride is an area rule object, the isStartEndOrNone flag is always defined.
            let nameHasStart = name.endsWith("-start");
            let nameHasEnd = name.endsWith("-end");
            if (nameHasStart) {
                this.isStartEndOrNone = true;
                areaName = name.substr(0, name.length - 6 /* "-start".length */);
            }
            else if (nameHasEnd) {
                isStartEndOrNone = false;
                areaName = name.substr(0, name.length - 4 /* "-end".length */);
            }
            else if (isStartEndOrNone === true) {
                areaName = name;
                name += "-start";
            }
            else if (isStartEndOrNone === false) {
                areaName = name;
                name += "-end";
            }
        }
        this.name = name;
        this.areaName = areaName;
        this.isStartEndOrNone = isStartEndOrNone;
    }
}
/**
 * The GridAreaRule class describes a named grid area definition. No CSS rule is created for grid
 * areas - they are needed only to provide type-safe grid area definitions.
 */
class GridAreaRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.RuleLike {
    // if the nameOverride is an area rule object, the isStartEndOrNone flag is always defined
    // because this constructor can only be invoked for the start and end lines of the GridAreaRule
    // object.
    constructor(sd, nameOverride) {
        super(sd);
        this.nameOverride = nameOverride;
        // create line rules
        this.startLine = new GridLineRule(sd, this, true);
        this.endLine = new GridLineRule(sd, this, false);
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the area name.
    toString() { return this.name; }
    // Processes the given rule.
    process(ruleName) {
        super.process(ruleName);
        this.name = this.rc.getScopedName(ruleName, this.nameOverride);
        // process line rules
        this.startLine.process(null);
        this.endLine.process(null);
    }
}


/***/ }),

/***/ "./lib/rules/GroupRules.js":
/*!*********************************!*\
  !*** ./lib/rules/GroupRules.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GroupRule": () => (/* binding */ GroupRule),
/* harmony export */   "SupportsRule": () => (/* binding */ SupportsRule),
/* harmony export */   "MediaRule": () => (/* binding */ MediaRule)
/* harmony export */ });
/* harmony import */ var _RuleContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleContainer */ "./lib/rules/RuleContainer.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");



/**
 * The GroupRule class serves as a base class for all grouping CSS rules.
 */
class GroupRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(sd, rn, instOrClass) {
        super(sd);
        this.rn = rn;
        this.instOrClass = instOrClass;
    }
    // Processes the given rule.
    process(ruleName) {
        super.process(ruleName);
        // container to which our grouping rule belongs becomes the parent container for the
        // style definition instance
        this.gsd = (0,_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.processSD)(this.instOrClass, this.sd);
        this.grc = this.gsd[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC];
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(ruleBag) {
        let mimcssRule = ruleBag.addGroup(`@${this.rn} ${this.condition}`);
        if (mimcssRule) {
            this.cssRule = mimcssRule?.cssRule;
            // insert sub-rules
            this.grc.insert(mimcssRule);
        }
    }
    // Condition of this grouping rule.
    get condition() {
        if (!this._cond)
            this._cond = this.getCond();
        return this._cond ?? "";
    }
    // Clers the CSS rule object.
    clear() {
        super.clear();
        // clear sub-rules
        this.grc.clear();
    }
}
/**
 * The SupportRule class describes a CSS @supports rule.
 */
class SupportsRule extends GroupRule {
    constructor(sd, statement, instOrClass) {
        super(sd, "supports", instOrClass);
        this.stmt = statement;
    }
    /** Flag indicated whether the browser supports this rule's query */
    get isSupported() {
        return window && CSS.supports(this.condition);
    }
    // Returns the condition string of this grouping rule.
    getCond() {
        return (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__.supports2s)(this.stmt);
    }
}
/**
 * The MediaRule class describes a CSS @media rule.
 */
class MediaRule extends GroupRule {
    constructor(sd, statement, instOrClass) {
        super(sd, "media", instOrClass);
        this.stmt = statement;
    }
    // Returns the condition string of this grouping rule.
    getCond() {
        return (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__.media2s)(this.stmt);
    }
    /**
     * Returns `MediaQueryList` object that allows programmatic checking whether the document matches
     * the media statement and also allows listening to its `change` event.
     */
    get queryList() {
        return window && matchMedia(this.condition);
    }
}


/***/ }),

/***/ "./lib/rules/MiscRules.js":
/*!********************************!*\
  !*** ./lib/rules/MiscRules.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImportRule": () => (/* binding */ ImportRule),
/* harmony export */   "NamespaceRule": () => (/* binding */ NamespaceRule),
/* harmony export */   "FontFaceRule": () => (/* binding */ FontFaceRule),
/* harmony export */   "ClassNameRule": () => (/* binding */ ClassNameRule)
/* harmony export */ });
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");




/**
 * The MiscRule class serves as a base class for simple rules.
 */
class MiscRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(sd) {
        super(sd);
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(ruleBag) {
        this.cssRule = ruleBag.add(this.toCss())?.cssRule;
    }
}
/**
 * The ImportRule class describes a CSS @import rule.
 */
class ImportRule extends MiscRule {
    constructor(sd, url, mediaStatement, supportsStatement) {
        super(sd);
        this.url = url;
        this.mediaStatement = mediaStatement;
        this.supportsStatement = supportsStatement;
    }
    // Returns CSS string for this rule.
    toCss() {
        let url;
        if (this.url.startsWith("url") || this.url.startsWith("\"") || this.url.startsWith("'"))
            url = this.url;
        else
            url = `url(${this.url})`;
        let supportsQueryString = !this.supportsStatement ? "" : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.supports2s)(this.supportsStatement);
        if (supportsQueryString && !supportsQueryString.startsWith("supports"))
            supportsQueryString = `supports( ${supportsQueryString} )`;
        let mediaQueryString = !this.mediaStatement ? "" : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.media2s)(this.mediaStatement);
        return `@import ${url} ${supportsQueryString} ${mediaQueryString}`;
    }
}
/**
 * The NamespaceRule class describes a CSS @namespace rule.
 */
class NamespaceRule extends MiscRule {
    constructor(sd, namespace, prefix) {
        super(sd);
        this.namespace = namespace;
        this.prefix = prefix;
    }
    // Returns CSS string for this rule.
    toCss() {
        let url = this.namespace.startsWith("url(") ? this.namespace : `url(${this.namespace})`;
        return `@namespace ${this.prefix ? this.prefix : ""} ${url}`;
    }
}
/**
 * The FontFaceRule class describes a @font-face CSS rule.
 */
class FontFaceRule extends MiscRule {
    constructor(sd, fontface) {
        super(sd);
        this.fontface = fontface;
    }
    // Returns CSS string for this rule.
    toCss() {
        return `@font-face {${(0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.fontFace2s)(this.fontface)}}`;
    }
}
/**
 * The PageRule class represents the CSS @page rule.
 */
class ClassNameRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike {
    constructor(sd, classes) {
        super(sd);
        this.classes = classes;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the CSS class name.
    [_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.symV2S]() { return this.cssName; }
    /** CSS rule selector string */
    get selectorText() {
        return this.cssName;
    }
    // Processes the given rule.
    process(ruleName) {
        this.name = this.classes.map(v => typeof v === "string" ? v : v.name).join(" ");
        this.cssName = "." + this.name.replace(/ /g, ".");
    }
    // Implementation of the toString method returns the combined name of the classes (without
    // the CSS prefixes).
    toString() {
        return this.name;
    }
}


/***/ }),

/***/ "./lib/rules/Rule.js":
/*!***************************!*\
  !*** ./lib/rules/Rule.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symRC": () => (/* binding */ symRC),
/* harmony export */   "RuleLike": () => (/* binding */ RuleLike),
/* harmony export */   "Rule": () => (/* binding */ Rule)
/* harmony export */ });
/**
 * Symbol on the style definition instance pointing to the RuleContainer object that is
 * responsible for processing rules.
 */
const symRC = Symbol("rc");
/**
 * The RuleLike abstract class is a base for all "rules" defined in the style definition classes -
 * whether they correspond to real CSS rules (and thus derive from the Rule class) or not (such as
 * counters, grid lines and grid areas).
 */
class RuleLike {
    constructor(sd) {
        this.sd = sd;
        this.rc = sd[symRC];
    }
    /**
     * Processes the rule assigned to the property with the given name. Property name can be null
     * for rules not assigned to a property; e.g. dependent rules defined in the CombinedStyleset.
     */
    process(propName) { }
}
/**
 * The Rule class is used as a base class for all rules.
 */
class Rule extends RuleLike {
    // Clers the CSS rule object. This method is called when the style definition class, to which
    // this rule belongs, is deactivated.
    clear() { this.cssRule = null; }
}


/***/ }),

/***/ "./lib/rules/RuleContainer.js":
/*!************************************!*\
  !*** ./lib/rules/RuleContainer.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuleContainer": () => (/* binding */ RuleContainer),
/* harmony export */   "configNames": () => (/* binding */ configNames),
/* harmony export */   "processSD": () => (/* binding */ processSD),
/* harmony export */   "getVarsFromSD": () => (/* binding */ getVarsFromSD),
/* harmony export */   "activateSD": () => (/* binding */ activateSD),
/* harmony export */   "deactivateSD": () => (/* binding */ deactivateSD),
/* harmony export */   "embeddedDecorator": () => (/* binding */ embeddedDecorator),
/* harmony export */   "getCurrentTheme": () => (/* binding */ getCurrentTheme),
/* harmony export */   "s_startSSR": () => (/* binding */ s_startSSR),
/* harmony export */   "s_stopSSR": () => (/* binding */ s_stopSSR),
/* harmony export */   "s_startHydration": () => (/* binding */ s_startHydration),
/* harmony export */   "s_stopHydration": () => (/* binding */ s_stopHydration)
/* harmony export */ });
/* harmony import */ var _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/RuleAPI */ "./lib/api/RuleAPI.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _VarRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VarRule */ "./lib/rules/VarRule.js");
/* harmony import */ var _MiscRules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MiscRules */ "./lib/rules/MiscRules.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");





/** Symbol on the style definition class pointing to the singleton instance. */
const symInstance = Symbol("sd");
/**
 * Symbol on the style definition instance pointing to the StyleDefinition class for which
 * this instance was created.
 */
const symClass = Symbol("sdc");
/**
 * Flag indicating that a rule container is created not directly (as for styled components)
 * but from the processClass function. This variable is set to true before instantiating the
 * style definition class (and thus the RuleContainer object) and is set back to false after
 * it is used in the RuleContainer constructor.
 */
let s_processingStyleDefinitionClass = false;
/**
 * The RuleContainer class is a shadow structure that accompanies every processed style definition
 * object. Since StyleDefinition class is an exported class visible to developers, we don't want
 * to have a lot of functionality in it. The RuleContainer object is linked to the StyleDefinition
 * object via the [symContainer] symbol. It contains all the functionality for parsing rule
 * definitions, name assignment and activation/deactivation.
 */
class RuleContainer {
    constructor(sd) {
        // List of references to other style definitions creaed via the $use function.
        this.refs = [];
        // List of @import rules
        this.imports = [];
        // List of @namespace rules
        this.namespaces = [];
        // List of custom variable rules.
        this.vars = [];
        // List of rules that are not imports, namespaces, custom vars, references or grouping rules.
        this.rules = [];
        // Reference count of activation requests.
        this.refCount = 0;
        this.sd = sd;
        this.sdc = sd.constructor;
        this.psd = sd.$parent;
        this.ec = this.sdc[symEmbeddingContainer];
        // get parent and top level containers
        if (this.psd)
            this.pc = this.psd[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC];
        // set the name for our container. For optimized name generation mode, generate unique
        // name. Otherwise, if the container is created for a class from the
        // processClass function, then the flag s_processingStyleDefinitionClass is defined
        // and the name is generated depending on the current generation method. If this flag is
        // false, that means that the container is created from a direct "new" call on the style
        // definition class and the name is generated uniquely.
        if (s_nameGeneratonMethod === 2 /* Optimized */)
            this.name = generateUniqueName();
        else {
            let className = this.sdc.name;
            let name = className ? "" : generateUniqueName();
            if (s_processingStyleDefinitionClass) {
                s_processingStyleDefinitionClass = false;
                name = !className
                    ? generateUniqueName()
                    : s_nameGeneratonMethod === 1 /* UniqueScoped */
                        ? generateUniqueName(className + "_")
                        : className;
            }
            else {
                name = generateUniqueName();
                if (className)
                    name += "_" + className;
            }
            // if our container has parent container, prefix our name with the upper one
            this.name = this.pc ? `${this.pc.name}_${name}` : name;
        }
    }
    // ProxyHandler method, which virtualizes all RuleLike properties
    set(t, p, v, r) {
        if (typeof p !== "string" || typeof v !== "object")
            t[p] = v;
        else {
            // we only virtualize rule-like objects. We don't virtualize arrays because there
            // is no trap for isArray() method, which we use later in the processProperty()
            // method. We also don't virtualize primitive types because there is no trap for
            // typeof operation (needed when converting values to strings). We also don't
            // virtualize style definition instances (results of $use() method invocations).
            let isRuleLike = v instanceof _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike;
            if (p in t) {
                if (isRuleLike)
                    v.process(p);
                t[p] = v;
            }
            else {
                if (isRuleLike)
                    virtualize(t, p);
                t[p] = v;
                this.processProperty(p, t[p]);
            }
        }
        return true;
    }
    // Processes the properties of the style definition instance. This creates names for classes,
    // IDs, animations and custom variables.
    processProperty(propName, propVal) {
        if (propVal instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.StyleDefinition)
            this.refs.push(propVal);
        // else if (propVal instanceof Array)
        else if (Array.isArray(propVal)) {
            // loop over array elements and recursively process them. Index becomes part of the
            // rule name.
            let i = 0;
            for (let item of propVal)
                this.processProperty(`${propName}_${i++}`, item);
        }
        else {
            if (propVal instanceof _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike)
                propVal.process(propName);
            if (propVal instanceof _VarRule__WEBPACK_IMPORTED_MODULE_2__.VarRule)
                this.vars.push(propVal);
            else if (propVal instanceof _MiscRules__WEBPACK_IMPORTED_MODULE_3__.ImportRule)
                this.imports.push(propVal);
            else if (propVal instanceof _MiscRules__WEBPACK_IMPORTED_MODULE_3__.NamespaceRule)
                this.namespaces.push(propVal);
            else if (propVal instanceof _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule)
                this.rules.push(propVal);
        }
    }
    // Sets the given value for the custom CSS roperty with the given name.
    setVarValue(name, value, important, schedulerType) {
        if (this.varRootRule)
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.getActivator)(schedulerType).updateStyle(this.varRootRule, name, value, important);
    }
    /**
     * Generates a globally unique CSS name for the given rule name unless this rule name already
     * exists either in a base class or in the chain of parent grouping rules.
     */
    getScopedName(ruleName, nameOverride) {
        if (nameOverride)
            return typeof nameOverride === "string" ? nameOverride : nameOverride.name;
        else if (!ruleName)
            return generateUniqueName();
        else if (ruleName in this.sd && "name" in this.sd[ruleName])
            // this handles cases when a "named" rule already exists in the style definition;
            // for example when a derived class overrides the value of a base class
            return this.sd[ruleName].name;
        else {
            // find out if there is a rule with this name defined in a stylesheet instance created
            // for a class from the prototype chain of the style definition class. Otherwise, if
            // there is a parent container, recurse to it; otherwise, generate the name.
            let existingName = findNameForRuleInPrototypeChain(this.sdc, ruleName);
            if (existingName)
                return existingName;
            else if (this.pc)
                return this.pc.getScopedName(ruleName);
            else
                return generateName(this.name, ruleName);
        }
    }
    /** Inserts all rules defined in this container to either the style sheet or grouping rule. */
    insert(ruleBag) {
        // insert @import and @namespace rules as they must be before other rules. If the parent is a grouping
        // rule, don't insert @import and @namespace rules at all
        if (!this.psd) {
            this.imports.forEach(rule => rule.insert(ruleBag));
            this.namespaces.forEach(rule => rule.insert(ruleBag));
        }
        // activate referenced style definitions
        for (let ref of this.refs)
            ref[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC].activate(this.elm);
        // insert our custom variables into the ":root" rule
        if (this.vars.length > 0)
            this.varRootRule = ruleBag.add(getRootCssForVars(this.vars))?.cssRule;
        // insert all other rules
        this.rules.forEach(rule => rule.insert(ruleBag));
    }
    /** Clears all CSS rule objects defined in this container. */
    clear() {
        // import and namespace rules can only exist in the top-level style definition class
        if (!this.psd) {
            this.imports.forEach(rule => rule.clear());
            this.namespaces.forEach(rule => rule.clear());
        }
        this.varRootRule = undefined;
        this.rules.forEach(rule => rule.clear());
        // deactivate imported stylesheets
        for (let ref of this.refs)
            ref[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC].deactivate();
    }
    /**
     * Inserts this stylesheet into DOM.
     *
     * @param insertBefore Optional HTML element before which the new '<style>' element should be
     * inserted. If not specified, the new element will be inserted as the last element under the
     * '<head>' element.
     */
    activate(insertBefore) {
        // activation context may not exist if the code is executing on a server and SSR has
        // not been started
        if (!s_activationContext || ++this.refCount > 1)
            return;
        // only the top-level not-embedded style definitions create the `<style>` element
        if (!this.pc) {
            if (this.ec)
                this.elm = this.ec.elm;
            else {
                // themes are inserted before the special placeholder element, which is created
                // at the top of the '<head>' element
                if (this.sd instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition)
                    insertBefore = s_activationContext?.getThemePlaceholder();
                this.elm = s_activationContext?.createStyleElm(this.name, insertBefore);
            }
        }
        else
            this.elm = this.pc.elm;
        // if this is a theme class activation, check whether the instance is set as the current
        // one for its theme base class. If no, then deactivate the theme instance currently set
        // as active. In any case, set our new instance as the currently active one. We ignore
        // theme declaration classes - those that directly derive from ThemeDefinition
        if (this.sd instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition && Object.getPrototypeOf(this.sdc) !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition) {
            let themeClass = this.sd[symClass];
            if (themeClass) {
                let currInstance = getCurrentTheme(themeClass);
                if (currInstance && currInstance !== this.sd) {
                    let currContainer = currInstance[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC];
                    currContainer.deactivate();
                }
                setCurrentTheme(this.sd);
            }
        }
        this.insert(this.elm);
    }
    /** Removes this stylesheet from DOM. */
    deactivate() {
        // guard from extra deactivate calls
        if (this.refCount === 0) {
/////////////////////////
            console.error(`Extra call to deactivate() for style definition class '${this.name}'`);
//////////////////////
            return;
        }
        if (--this.refCount > 0)
            return;
        this.clear();
        // only the top-level not-embedded style defiitions create the `<style>` element
        if (!this.psd && !this.ec)
            this.elm.remove();
        this.elm = undefined;
        // if this is a theme class deactivation, check whether the instance is set as the current
        // one for its theme base class. If yes, remove it as the currently active one.
        if (this.sd instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition && Object.getPrototypeOf(this.sdc) !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition) {
            let themeClass = this.sd[symClass];
            if (themeClass) {
                let currInstance = getCurrentTheme(themeClass);
                if (currInstance === this.sd)
                    removeCurrentTheme(themeClass);
            }
        }
    }
    getVars() { return this.vars; }
}
const getRootCssForVars = (vars) => `:root {${vars.map(varObj => varObj.toCss()).filter(v => !!v).join(";")}}`;
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name generation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Sets the flag indicating whether to use optimized (short) rule names. If yes, the names
 * will be created by appending a unique number to the given prefix. If the prefix is not
 * specified, the standard prefix "n" will be used.
 * @param enable
 * @param prefix
 */
const configNames = (method, prefix) => {
    s_nameGeneratonMethod = method;
    s_uniqueStyleNamesPrefix = prefix ? prefix : "n";
};
/**
 * Flag indicating whether to use optimized names for style elements (classes,  animations, etc.)
 * By default this flag is true in the Release build of the library and false in the Debug build.
 */
let s_nameGeneratonMethod = 2 /* Optimized */;
/////////////
s_nameGeneratonMethod = 1 /* UniqueScoped */;
//////////
/**
 * Prefix to use when generating unique style names. If undefined, a standard prefix "n" will be used.
 */
let s_uniqueStyleNamesPrefix = "n";
/** Next number to use when generating unique identifiers. */
let s_nextUniqueID = 1;
/**
 * Generates name to use for the given rule from the given style sheet.
 */
const generateName = (sheetName, ruleName) => {
    switch (s_nameGeneratonMethod) {
        case 1 /* UniqueScoped */: return `${sheetName}_${ruleName}_${s_nextUniqueID++}`;
        case 2 /* Optimized */: return generateUniqueName();
        case 3 /* Scoped */: return `${sheetName}_${ruleName}`;
    }
};
/**
 * Generates a unique name, which can be used either for style element's ID or or class,
 * identifier or animation name. Names are generated using a simple incrementing number.
 */
const generateUniqueName = (prefix) => (prefix ? prefix : s_uniqueStyleNamesPrefix) + s_nextUniqueID++;
// Looks up a property with the given name in the prototype chain of the given style definition
// class. If found and if the property is a rule, then returns the name assigned for it.
const findNameForRuleInPrototypeChain = (definitionClass, ruleName) => {
    if (!definitionClass)
        return null;
    // loop over prototypes
    for (let baseClass = Object.getPrototypeOf(definitionClass); baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.StyleDefinition && baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition; baseClass = Object.getPrototypeOf(baseClass)) {
        // check if the base class already has an associated instance; if yes, check whether
        // it has a property with the given rule name. If yes, then use this rule's already
        // generated name (if exists).
        if (baseClass.hasOwnProperty(symInstance)) {
            let baseInst = baseClass[symInstance];
            if (baseInst && baseInst[ruleName] != null && "name" in baseInst[ruleName])
                return baseInst[ruleName].name;
        }
    }
    return null;
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Processing functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Processes the given stylesheet definition class or instance and assigns names to its rules.
 * If the parameter is a style definition class we check whether there is an instance already
 * created for it as a class will have only a single associated instane no matter how many times
 * this function is called.
 *
 * If the parameter is an object (an instance of the StyleDefinition class) then we check whether
 * it has already been processed. If yes, we just return it back; if no, we assign new unique names
 * to its rules.
 */
const processSD = (instOrClass, parent) => 
// instOrClass has type "object" if it is an instance and "function" if it is a class
typeof instOrClass === "object" ? instOrClass : processClass(instOrClass, parent);
/**
 * Processes the given style definition class by creating its instance and associating a
 * rule container object with it. The class will be associated with the instance using a
 * Symbol property. The parent parameter is a reference to the parent style defiition
 * object or null if the given class is itself a top-level class (that is, is not a class
 * that defines rules within nested grouping rules).
 */
const processClass = (sdc, parent) => {
    // check whether this definition class is already associated with an instance. Note that we
    // use hasOwnProperty() because otherwise, this could return instance for the base style
    // definition class.
    if (sdc.hasOwnProperty(symInstance))
        return sdc[symInstance];
    // recursively process all base classes so that rule names are generated. We don't activate styles
    // for these classes because derived classes will have all the rules from all the base classes
    // as their own and so these rules will be activated as part of the derived class.
    let baseClass = Object.getPrototypeOf(sdc);
    if (baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.StyleDefinition && baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition)
        processClass(baseClass, parent);
    try {
        // create the instance of the definition class
        s_processingStyleDefinitionClass = true;
        let sd = new sdc(parent);
        // associate the definition class with the created definition instance
        sdc[symInstance] = sd;
        sd[symClass] = sdc;
        return sd;
    }
    finally {
        s_processingStyleDefinitionClass = false;
    }
};
/**
 * Processes the given style definition instance and assigns names to its rules. If the
 * instance has already been processed, we do nothing; otherwise, we assign new unique names
 * to its rules.
 */
const getVarsFromSD = (instOrClass) => processSD(instOrClass)[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC].getVars();
/**
 * Activates the given style definition and inserts all its rules into DOM. If the input object is
 * not a style definition but a style definition class, obtain style definition by calling the $use
 * function. Note that each style definition object maintains a reference counter of how many times
 * it was activated and deactivated. The rules are inserted to DOM only when this reference counter
 * goes from 0 to 1.
 */
const activateSD = (instance) => {
    let ruleContainer = instance[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC];
    if (!ruleContainer)
        return;
    // if this container has an embedding container, activate the embedding container; otherwise,
    // activate the rule container itself.
    (ruleContainer.ec ?? ruleContainer).activate();
};
/**
 * Deactivates the given style definition by removing its rules from DOM. Note that each style
 * definition object maintains a reference counter of how many times it was activated and
 * deactivated. The rules are removed from DOM only when this reference counter goes from 1 to 0.
 */
const deactivateSD = (instance) => {
    let ruleContainer = instance[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC];
    if (!ruleContainer)
        return;
    // if this container has an embedding container, deactivate the embedding container; otherwise,
    // deactivate the rule container itself.
    (ruleContainer.ec ?? ruleContainer).deactivate();
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Embedding
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/** Symbol used in style definition classes to point to an embedding container */
let symEmbeddingContainer = Symbol("ec");
/**
 * The EmbeddingContainer class contains multiple style definition classes, which are activated and
 * deactivated together under a single `<style>` node. Style definition classes are added to the
 * embedding container by being decorated with the `@embedded` decorator.
 */
class EmbeddingContainer {
    constructor(id) {
        this.id = id;
        this.refCount = 0;
        this.sdcs = new Set();
    }
    /**
     * Adds the given style definition class to the list of embedded classes. If the container is
     * currently activated, the class will be activated too.
     */
    add(cls) {
        // add the class to our container
        this.sdcs.add(cls);
        // set the symbol on our class to point to the container
        cls[symEmbeddingContainer] = this;
        // if the embedding container is currently activated, we need to activate the added
        // style definition class using the currently default activator
        if (this.refCount > 0)
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.getActivator)().activate(processClass(cls));
    }
    /**
     * Inserts all stylesheets in this container into DOM.
     */
    activate() {
        // only if this is the first activation call, create the style element and insert all
        // rules from all the style definition classes.
        if (++this.refCount === 1) {
            this.elm = s_activationContext?.createStyleElm(this.id);
            for (let cls of this.sdcs) {
                // definition class may be already associated with an instance; if not -
                // process it now.
                let instance = cls.hasOwnProperty(symInstance)
                    ? cls[symInstance]
                    : processClass(cls);
                instance[_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC].activate();
            }
        }
    }
    /**
     * Removes all stylesheets in this container into DOM.
     */
    deactivate() {
        // only if this is the last deactivation call, remove the style element and remove all
        // rules from all the style definition classes.
        if (--this.refCount === 0) {
            this.elm?.remove();
            this.elm = undefined;
            for (let cls of this.sdcs) {
                // definition class must be already associated with an instance
                if (!cls.hasOwnProperty(symInstance))
                    continue;
                cls[symInstance][_Rule__WEBPACK_IMPORTED_MODULE_1__.symRC].deactivate();
            }
        }
    }
}
/**
 * Map of category names to embedding container objects containing style definitions for the given
 * category.
 */
let s_embeddingContainers = new Map();
/**
 * Decorator function for style definition classes that will be embedded into an embedding
 * container for the given category. All style definitions for a given category will be activated
 * and deactivated together and their rules will be inserted into a single `<style>` element.
 */
const embeddedDecorator = (category, target) => {
    // check whether we already have container for this category; if not, add it
    let ec = s_embeddingContainers.get(category);
    if (!ec) {
        // generate unique ID for our container, which will be the ID of the `<style>` element
        let id = `${category}_${s_nextUniqueID++}`;
        ec = new EmbeddingContainer(id);
        s_embeddingContainers.set(category, ec);
    }
    // add our class to the container
    ec.add(target);
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Rule virtualization.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Decorator that should be applied to a rule if it is defined and used in the same style
 * definition class but then is overridden in a derived style definition class. The problem
 * this solves is this: when a rule is defined in a base class and then overridden in a derived
 * class, when an instance of the derived class is created, the rules that are created in the
 * base and derived classes see different values of the rule. Since our rules are defined as
 * part of the constructor, the base class constructor's code only sees the value assigned in that
 * code. If another rule in the base class uses this first rule, this value is remembered.
 *
 * The `virtualize` function creates a Proxy object for the rule with the handler that keeps the
 * most recent value set. Thus when a rule in the base class's constructor uses a virtualized
 * rule, the first rule will see the overridden value of the rule when accessed in the
 * post-constructor code.
 */
const virtualize = (target, name) => {
    // we may directly create the handler and the proxy because this function will be invoked
    // for every StyleDefinition instance (as opposed to once per class).
    let handler = new VirtHandler();
    handler.x = new Proxy({}, handler);
    Object.defineProperty(target, name, {
        enumerable: true,
        // return the proxy object
        get() { return handler.x; },
        // set the new value to the handler so that it will use it from now on.
        set(v) { handler.t = v; }
    });
};
/**
 * Handler for the proxy created by the `virtualize` function. It keeps the current value of a
 * rule so that the most recent value is used whenever the proxy is accessed.
 */
class VirtHandler {
    // interesting things happen in the get method
    get(t, p, r) {
        // if our value is null or undefined and the requested property is a well-known symbol
        // toPrimitive we return a function that returns either null or undefined. This will help
        // if our proxy either participate in an arithmetic expression or is combined with a
        // string.
        if (this.t == null && p === Symbol.toPrimitive)
            return () => this.t;
        // get the value of the request property; if the value is null or undefined, an exception
        // will be thrown - which is expected.
        let pv = Reflect.get(this.t, p, r);
        // if the requested property is a function, bind the original method to the target object
        return typeof pv === "function" ? pv.bind(this.t) : pv;
    }
    // the rest of the methods mostly delegate the calls to the latest target instead of the
    // original target. In some cases, we check whether the target is null or undefined so that
    // we don't throw exceptions where we can avoid it.
    getPrototypeOf(t) { return this.t == null ? null : Reflect.getPrototypeOf(this.t); }
    // setPrototypeOf(t: any, v: any): boolean
    //     { return Reflect.setPrototypeOf( this.t, v); }
    // isExtensible(t: any): boolean
    //     { return this.t == null ? false : Reflect.isExtensible( this.t); }
    // preventExtensions(t: any): boolean
    //     { return this.t == null ? false : Reflect.preventExtensions( this.t); }
    getOwnPropertyDescriptor(t, p) { return Reflect.getOwnPropertyDescriptor(this.t, p); }
    has(t, p) { return this.t == null ? false : Reflect.has(this.t, p); }
    set(t, p, v, r) { return Reflect.set(this.t, p, v, r); }
    deleteProperty(t, p) { return Reflect.deleteProperty(this.t, p); }
    defineProperty(t, p, attrs) { return Reflect.defineProperty(this.t, p, attrs); }
    ownKeys(t) { return Reflect.ownKeys(this.t); }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Theming support.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Map of them definition classes to the instances that are currently active for these classes.
 */
let s_themeInstanceMap = new Map();
/**
 * Returns the theme base class for the given theme class.
 * @param themeClass ThemeDefinition-derived class
 * @returns Theme base class.
 */
const getThemeBaseClass = (themeClass) => {
    // make sure we are not passed the ThemeDefinition class itself
    if (themeClass === _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition)
        return undefined;
    // loop over prototypes until we find the class, which derives directly from ThemeDefinition.
    // This is the theme base class
    let themeBaseClass = themeClass;
    for (let cls = Object.getPrototypeOf(themeClass); cls !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition; cls = Object.getPrototypeOf(cls))
        themeBaseClass = cls;
    return themeBaseClass;
};
/**
 * Returns the theme definition object, which is currently activated for the given theme.
 * @param themeClass Theme definition class
 * @returns Theme instance, which is currently activated for the given theme class or null
 * if no istance is currently activated.
 */
const getCurrentTheme = (themeClass) => {
    let themeBaseClass = getThemeBaseClass(themeClass);
    return themeBaseClass && s_themeInstanceMap.get(themeBaseClass);
};
/**
 * Sets the theme definition object as the instance that is currently activated for the
 * corresponding base theme class.
 * @param theme theme instance to set as current for the corresponding base theme class
 */
const setCurrentTheme = (theme) => {
    let themeBaseClass = getThemeBaseClass(theme.constructor);
    themeBaseClass && s_themeInstanceMap.set(themeBaseClass, theme);
};
/**
 * Removes a theme definition object set as the instance that is currently activated for the
 * corresponding base theme class.
 * @param themeClass Theme definition class
 */
const removeCurrentTheme = (themeClass) => {
    let themeBaseClass = getThemeBaseClass(themeClass);
    themeBaseClass && s_themeInstanceMap.delete(themeBaseClass);
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Client-side rendering implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Style element that divides between theme and non-theme style elements. This is needed to always
 * place theme styles before the non-theme ones.
 */
let s_clientThemePlaceholderElm = undefined;
/**
 * ID of the style element that divides between theme and non-theme style elements.
 */
const s_themePlaceholderElmID = "__mimcss_themes__";
// Inserts the given rule into the given parent grouping rule or stylesheet.
const addDomRule = (ruleText, parent) => {
    try {
        let index = parent.insertRule(ruleText, parent.cssRules.length);
        return parent.cssRules[index];
    }
    catch (x) {
        console.error(`Cannot add CSS rule '${ruleText}'`, x);
        return null;
    }
};
/**
 * Client-side implementation of activation context.
 */
class ClientActivationContext {
    getThemePlaceholder() {
        if (!s_clientThemePlaceholderElm) {
            let domElm = document.createElement("style");
            domElm.id = s_themePlaceholderElmID;
            document.head.insertBefore(domElm, document.head.firstElementChild);
            s_clientThemePlaceholderElm = new ClientMimcssStyleElement(domElm);
        }
        return s_clientThemePlaceholderElm;
    }
    createStyleElm(id, insertBefore) {
        let domElm = document.createElement("style");
        domElm.id = id;
        document.head.insertBefore(domElm, insertBefore ? insertBefore.domElm : null);
        return new ClientMimcssStyleElement(domElm);
    }
}
/**
 * Client-side implementation of an object to which rules can be added.
 */
class ClientMimcssRuleBag {
    constructor(domRuleBag) {
        this.domRuleBag = domRuleBag;
    }
    add(ruleText) {
        let cssRule = addDomRule(ruleText, this.domRuleBag);
        return cssRule ? new ClientMimcssRule(cssRule) : null;
    }
    addGroup(selector) {
        let cssRule = addDomRule(`${selector} {}`, this.domRuleBag);
        return cssRule ? new ClientMimcssGroupingRule(cssRule) : null;
    }
    addKeyframes(name) {
        let cssRule = addDomRule(`@keyframes ${name} {}`, this.domRuleBag);
        return cssRule ? new ClientMimcssKeyframesRule(cssRule) : null;
    }
}
/**
 * Client-side implementation of a style element.
 */
class ClientMimcssStyleElement extends ClientMimcssRuleBag {
    constructor(domElm) {
        super(domElm.sheet);
        this.domElm = domElm;
    }
    remove() {
        this.domElm?.remove();
    }
}
/**
 * Client-side implementation of a base interface for CSS rule.
 */
class ClientMimcssRule {
    constructor(cssRule) {
        this.cssRule = cssRule;
    }
}
/**
 * Client-side implementation of a grouping rule to which rules can be added.
 */
class ClientMimcssGroupingRule extends ClientMimcssRuleBag {
    constructor(cssRule) {
        super(cssRule);
        this.cssRule = cssRule;
    }
}
/**
 * Client-side implementation of keyframes rule to which frames can be added.
 */
class ClientMimcssKeyframesRule extends ClientMimcssRule {
    addFrame(frameText) {
        try {
            this.cssRule.appendRule(frameText);
            let cssFrameRule = this.cssRule.cssRules.item(this.cssRule.cssRules.length - 1);
            return cssFrameRule ? new ClientMimcssRule(cssFrameRule) : null;
        }
        catch (x) {
            console.error("Cannot add CSS keyframe rule", x);
            return null;
        }
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Hydration-side rendering implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Hydration-side implementation of activation context.
 */
class HydrationActivationContext {
    getThemePlaceholder() {
        if (!s_clientThemePlaceholderElm) {
            let domElm = document.getElementById(s_themePlaceholderElmID);
            if (domElm)
                s_clientThemePlaceholderElm = new HydrationMimcssStyleElement(domElm);
            else
                throw new Error("Theme placeholder element was requested but was not found");
        }
        return s_clientThemePlaceholderElm;
    }
    createStyleElm(id, insertBefore) {
        let domElm = document.getElementById(id);
        if (domElm)
            return new HydrationMimcssStyleElement(domElm);
        else
            throw new Error(`Style element with ID '${id}' was requested but was not found`);
    }
}
/**
 * Hydration-side implementation of an object to which rules can be added.
 */
class HydrationMimcssRuleBag {
    constructor(domRuleBag) {
        this.domRuleBag = domRuleBag;
        // index of the rule in the list of rules under the stylesheet or grouping rule
        this.index = 0;
    }
    add(ruleText) {
        let cssRule = this.domRuleBag.cssRules[this.index++];
        return cssRule ? new HydrationMimcssRule(cssRule) : null;
    }
    addGroup(selector) {
        let cssRule = this.domRuleBag.cssRules[this.index++];
        return cssRule ? new HydrationMimcssGroupingRule(cssRule) : null;
    }
    addKeyframes(name) {
        let cssRule = this.domRuleBag.cssRules[this.index++];
        return cssRule ? new HydrationMimcssKeyframesRule(cssRule) : null;
    }
}
/**
 * Hydration-side implementation of a style element.
 */
class HydrationMimcssStyleElement extends HydrationMimcssRuleBag {
    constructor(domElm) {
        super(domElm.sheet);
        this.domElm = domElm;
    }
    remove() {
        this.domElm?.remove();
    }
}
/**
 * Hydration-side implementation of a base interface for CSS rule.
 */
class HydrationMimcssRule {
    constructor(cssRule) {
        this.cssRule = cssRule;
    }
}
/**
 * Hydration-side implementation of a grouping rule to which rules can be added.
 */
class HydrationMimcssGroupingRule extends HydrationMimcssRuleBag {
    constructor(cssRule) {
        super(cssRule);
        this.cssRule = cssRule;
    }
}
/**
 * Hydration-side implementation of keyframes rule to which frames can be added.
 */
class HydrationMimcssKeyframesRule extends HydrationMimcssRule {
    constructor() {
        super(...arguments);
        // index of the frame in the list of frames under the keyframes rule
        this.index = 0;
    }
    addFrame(frameText) {
        let cssFrameRule = this.cssRule.cssRules[this.index++];
        return cssFrameRule ? new HydrationMimcssRule(cssFrameRule) : null;
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Server-side rendering implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Server-side implementation of activation context.
 */
class ServerActivationContext {
    constructor() {
        this.elms = [];
    }
    getThemePlaceholder() {
        if (!this.themeElm)
            this.elms.splice(0, 0, this.themeElm = new ServerMimcssStyleElement(s_themePlaceholderElmID));
        return this.themeElm;
    }
    createStyleElm(id, insertBefore) {
        let elm = new ServerMimcssStyleElement(id);
        if (insertBefore)
            this.elms.splice(this.elms.indexOf(insertBefore), 0, elm);
        else
            this.elms.push(elm);
        return elm;
    }
    serialize() {
        return this.elms.map(elm => elm.serialize()).join("");
    }
}
/**
 * Server-side implementation of an object to which rules can be added.
 */
class ServerMimcssRuleBag {
    constructor() {
        this.rules = [];
    }
    add(ruleText) {
        let rule = new ServerMimcssRule(ruleText);
        this.rules.push(rule);
        return rule;
    }
    addGroup(selector) {
        let rule = new ServerMimcssGroupingRule(selector);
        this.rules.push(rule);
        return rule;
    }
    addKeyframes(name) {
        let rule = new ServerMimcssKeyframesRule(name);
        this.rules.push(rule);
        return rule;
    }
    serialize() {
        return this.rules.map(rule => rule.serialize()).join("");
    }
}
/**
 * Server-side implementation of a style element.
 */
class ServerMimcssStyleElement extends ServerMimcssRuleBag {
    constructor(id) {
        super();
        this.id = id;
        this.domElm = null;
    }
    remove() { }
    serialize() {
        return `<style id="${this.id}">${super.serialize()}</style>`;
    }
}
/**
 * Server-side implementation of a base interface for CSS rule.
 */
class ServerMimcssRule {
    constructor(ruleText) {
        this.ruleText = ruleText;
        this.cssRule = null;
    }
    serialize() {
        return this.ruleText;
    }
}
/**
 * Server-side implementation of a grouping rule to which rules can be added.
 */
class ServerMimcssGroupingRule extends ServerMimcssRuleBag {
    constructor(selector) {
        super();
        this.selector = selector;
        this.cssRule = null;
    }
    serialize() {
        return `${this.selector}{${super.serialize()}}`;
    }
}
/**
 * Server-side implementation of a keyframes rule to which frames can be added.
 */
class ServerMimcssKeyframesRule {
    constructor(name) {
        this.name = name;
        this.cssRule = null;
        this.frames = [];
    }
    addFrame(frameText) {
        let frame = new ServerMimcssRule(frameText);
        this.frames.push(frame);
        return frame;
    }
    serialize() {
        return `@keyframes ${this.name}{${this.frames.map(frame => frame.serialize()).join("")}}`;
    }
}
/**
 * Client activation context. In the client environment, it is ClientActivationContext instance;
 * in the server environment, it is undefined.
 */
const s_clientActivationContext = document?.head ? new ClientActivationContext() : undefined;
/**
 * Activation context to use. In the client environment, it is by default ClientActivationContext
 * but can be changed (temporarily) to HydrationActivationContext. In the server environment, it
 * is by default undefined, but can be changed to ServerActivationContext.
 */
let s_activationContext = s_clientActivationContext;
/**
 * Scheduler type remembered upon starting SSR or hydration process. This will be used to restore
 * the sceduler when SSR or hydration process is stopped.
 */
let s_rememberedSchedulerType = 0;
/**
 * Sets server-side activation context. Throws an error if non-default activation context is
 * already set.
 */
const s_startSSR = () => {
    if (s_activationContext !== s_clientActivationContext)
        throw new Error("SSR already started");
    else {
        s_activationContext = new ServerActivationContext();
        s_rememberedSchedulerType = (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.setDefaultScheduler)(1 /* Sync */);
    }
};
/**
 * Stops server-side activation functionality and returns a string with serialized styles. The
 * string should be added to the `<head>` element using `insertAdjacentHTML()` method.
 * Throws an error if SSR has not been started.
 * @returns String containing serialized styles
 */
const s_stopSSR = () => {
    if (!s_activationContext || !(s_activationContext instanceof ServerActivationContext))
        throw new Error("SSR not started");
    else {
        // restore scheduler type existed before we started SSR
        (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.setDefaultScheduler)(s_rememberedSchedulerType);
        s_rememberedSchedulerType = 0;
        let s = s_activationContext.serialize();
        s_activationContext = s_clientActivationContext;
        return s;
    }
};
/**
 * Sets hydration activation context. Throws an error if non-default activation context is
 * already set.
 */
const s_startHydration = () => {
    if (s_activationContext !== s_clientActivationContext)
        throw new Error("Hydration already started");
    else {
        s_activationContext = new HydrationActivationContext();
        s_rememberedSchedulerType = (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.setDefaultScheduler)(1 /* Sync */);
    }
};
/**
 * Stops hydration activation functionality and restore the default activation context.
 * @returns String containing serialized styles
 */
const s_stopHydration = () => {
    if (!s_activationContext || !(s_activationContext instanceof HydrationActivationContext))
        throw new Error("Hydration not started");
    else {
        // restore scheduler type existed before we started SSR
        (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.setDefaultScheduler)(s_rememberedSchedulerType);
        s_rememberedSchedulerType = 0;
        s_activationContext = s_clientActivationContext;
    }
};


/***/ }),

/***/ "./lib/rules/StyleRules.js":
/*!*********************************!*\
  !*** ./lib/rules/StyleRules.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleRule": () => (/* binding */ StyleRule),
/* harmony export */   "AbstractRule": () => (/* binding */ AbstractRule),
/* harmony export */   "ClassRule": () => (/* binding */ ClassRule),
/* harmony export */   "IDRule": () => (/* binding */ IDRule),
/* harmony export */   "SelectorRule": () => (/* binding */ SelectorRule),
/* harmony export */   "PageRule": () => (/* binding */ PageRule)
/* harmony export */ });
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");
/* harmony import */ var _impl_CoreImpl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../impl/CoreImpl */ "./lib/impl/CoreImpl.js");





/**
 * The StyleRule class is used as a base class for rules that contain a style rule. This class
 * implements the parsing of the CombinedStyleset object.
 */
class StyleRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.Rule {
    // The styleset can be an CombinedStyleset for many rules; however, for some it is just
    // of the Styleset type.
    constructor(sd, inputStyleset) {
        super(sd);
        // Selector string cached after it is first obtained. Needed to not invoke getSelectorString
        // multiple times in the presence of dependent rules.
        this._sel = null;
        this.styleset = {};
        this.dependentRules = {};
        if (inputStyleset) {
            if (Array.isArray(inputStyleset))
                inputStyleset.forEach(v => this.parse(sd, v));
            else
                this.parse(sd, inputStyleset);
        }
    }
    /**
     * This function allows the object to particpate in "v2s" serialization. Whenever the
     * StyleRule-derived object is encountered by the `v2s` function, the rule's selector will be
     * used.
     */
    [_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.symV2S]() { return this.selectorText; }
    /**
     * Goes over properties in the given styleset and parses them into proper styleset, set of
     * important properties and dependent rules.
     */
    parse(sd, inputStyleset) {
        for (let propName in inputStyleset) {
            let propVal = inputStyleset[propName];
            if (propVal == null)
                continue;
            else if (propName === "+") {
                // the value is a single StyleRule or an array of StyleRules to copy properties from
                let parentRules = propVal instanceof StyleRule ? [propVal] : propVal;
                for (let parent of parentRules) {
                    mergeStylesets(this.styleset, parent.styleset);
                    this.copyDepRules(parent);
                }
            }
            else if (propName === "--")
                mergeCustomProps(this.styleset, propVal);
            else if (propName.startsWith(":")) {
                // if the value is an array, then this is an array of tuples representing
                // parameterised pseudo entities where the first element is the parameter value
                // (string) and the second the CombinedStyleset. Otherwise, the value is just a
                // CombinedStyleset.
                if (Array.isArray(propVal)) {
                    this.dependentRules[propName] = propVal.map((tuple) => new DepRule(sd, propName, tuple[0], tuple[1], this));
                }
                else
                    this.dependentRules[propName] = new DepRule(sd, "&" + propName, undefined, propVal, this);
            }
            else if (propName.includes("&")) {
                // value is an array of two-element tuples with selector and styleset
                let tuples = propVal;
                if (tuples.length > 0) {
                    this.dependentRules[propName] = tuples.map(tuple => {
                        let newSelector = propName === "&"
                            ? tuple[0]
                            : propName.startsWith("&")
                                ? [propName, tuple[0]]
                                : [tuple[0], propName];
                        return new DepRule(sd, newSelector, undefined, tuple[1], this);
                    });
                }
            }
            else if (this.parseSP(propName, propVal)) {
                // this is a regular CSS property: copy the property value to our internal styleset
                mergePropValues(this.styleset, propName, propVal);
            }
        }
    }
    // Processes the given rule.
    process(ruleName) {
        this.forEachDepRule((depRule) => depRule.process(null));
    }
    // Converts the rule to CSS string representing the rule.
    toCss() {
        return this.selectorText + (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__.s2s)(this.styleset);
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(ruleBag) {
        if (Object.keys(this.styleset).length > 0)
            this.cssRule = ruleBag.add(this.toCss())?.cssRule;
        // insert dependent rules under the same parent
        this.forEachDepRule((depRule) => depRule.insert(ruleBag));
    }
    // Clers the CSS rule object.
    clear() {
        super.clear();
        // clear dependent rules
        this.forEachDepRule((depRule) => depRule.clear());
    }
    // Invoke the given function for each of the dependent rules.
    forEachDepRule(func) {
        for (let propName in this.dependentRules) {
            let propVal = this.dependentRules[propName];
            if (Array.isArray(propVal))
                for (let depRule of propVal)
                    func(depRule);
            else
                func(propVal);
        }
    }
    /** CSS rule selector string */
    get selectorText() {
        if (this._sel == null)
            this._sel = this.getSel();
        return this._sel;
    }
    // Copies dependent rules from another style rule object.
    copyDepRules(src) {
        let srsDepRules = src.dependentRules;
        let thisDepRules = this.dependentRules;
        for (let propName in srsDepRules) {
            let srcRuleOrArr = srsDepRules[propName];
            if (Array.isArray(srcRuleOrArr)) {
                if (srcRuleOrArr.length > 0) {
                    let thisArr = thisDepRules[propName];
                    if (!thisArr)
                        thisDepRules[propName] = thisArr = [];
                    for (let srcDepRule of srcRuleOrArr)
                        thisArr.push(srcDepRule.clone(this));
                }
            }
            else
                thisDepRules[propName] = srcRuleOrArr.clone(this);
        }
    }
    // Allows the derived classes to process style properties that the StyleRule doesn't know about.
    // If false is returned, the property with the given name will not be added to the styleset.
    parseSP(propName, propVal) { return true; }
    /**
     * Adds/replaces the value of the given CSS property in this rule.
     * @param name Name of the CSS property.
     * @param value New value of the CSS property.
     * @param important Flag indicating whether to set the "!important" flag on the property value.
     * @param schedulerType ID of a registered scheduler type that is used to write the property
     * value to the DOM. If undefined, the current default scheduler will be used.
     */
    setProp(name, value, important, schedulerType) {
        // first set/remove the value in our internal styleset object
        if (value == null)
            delete this.styleset[name];
        else
            this.styleset[name] = important ? { "!": value } : value;
        // second, if CSSRule alredy exists, set/remove the property value there
        if (this.cssRule) {
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_3__.getActivator)(schedulerType).updateStyle(this.cssRule, (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.camelToDash)(name), value == null ? null : (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__.sp2s)(name, value), important);
        }
    }
    /**
     * Adds/replaces the value of the given custom CSS property in this rule.
     * @param varObj IVarRule object defining a custom CSS property.
     * @param varValue New value of the custom CSS property.
     * @param important Flag indicating whether to set the "!important" flag on the property value.
     * @param schedulerType ID of a registered scheduler type that is used to write the property
     * value to the DOM. If undefined, the current default scheduler will be used.
     */
    setCustomProp(varObj, value, important, schedulerType) {
        if (!varObj)
            return;
        // first set/remove the value in our internal styleset object
        let currCustomProps = this.styleset["--"];
        if (currCustomProps || value != null) {
            if (value == null) {
                let index = currCustomProps.findIndex(item => item[0] === varObj);
                if (index >= 0)
                    currCustomProps.splice(index, 1);
            }
            else if (!currCustomProps)
                this.styleset["--"] = [[varObj, value]];
            else {
                let index = currCustomProps.findIndex(item => item[0] === varObj);
                if (index >= 0)
                    currCustomProps[index][1] = value;
                else
                    currCustomProps.push([varObj, value]);
            }
        }
        // second, if CSSRule alredy exists, set/remove the property value there
        if (this.cssRule) {
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_3__.getActivator)(schedulerType).updateStyle(this.cssRule, varObj.cssName, value == null ? null : (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__.sp2s)(varObj.template, value), important);
        }
    }
}
/**
 * The DependentRule class describes a styleset that depends on the containing style rule. This
 * is used for pseudo classes, pseudo elements, combinators and other selectors that combine the
 * containing rule's selector with additional selector items.
 */
class DepRule extends StyleRule {
    // for regular selectors, pseudo classes and pseudo elements, the selector already contains
    // the ampersand and the selectorParam is undefined. For parameterized pseudo classes, pseudo
    // elements and combinators, the selectorParam is defined and the selector is just the entity
    // name.
    constructor(sd, selector, param, styleset, parent) {
        super(sd, styleset);
        this.selector = selector;
        this.parent = parent;
        this.param = param;
    }
    // Creates a copy of the rule but with new parent (containing rule).
    clone(containingRule) {
        let newRule = new DepRule(this.sd, this.selector, this.param, undefined, containingRule);
        // this method is called on a newly created object so we don't have any properties in
        // our own styleset yet
        mergeStylesets(newRule.styleset, this.styleset);
        newRule.copyDepRules(this);
        return newRule;
    }
    // Returns the selector part of the style rule.
    getSel() {
        let parentSelector = this.parent.selectorText;
        if (this.param) {
            // the "param" value is only set for parameterized pseudo entities, so we convert it to
            // the "func" object form. We also know that the selector is a string - name of the entity.
            return `${parentSelector}${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.fdo2s)({ fn: this.selector, p: this.param })}`;
        }
        else {
            // convert selector to string.
            let selector = (0,_impl_CoreImpl__WEBPACK_IMPORTED_MODULE_4__.selector2s)(this.selector);
            // if the selector string doesn't have any occurrences of the ampersand symbol, we
            // simply append the selector to the parent selector; otherwise, we replace all
            // occurrences of the ampersand symbol in the selector string with the selector
            // string of the parent rule.
            return selector.indexOf("&") < 0
                ? `${parentSelector}${selector}`
                : selector.replace(/&/g, parentSelector);
        }
    }
}
/**
 * The AbstractRule class describes a styleset that can only be used as a base for other style
 * rules.
 */
class AbstractRule extends StyleRule {
    // Overrides the StyleRule's implementation to do nothing. No CSSStyleRule is created for
    // abstract rules.
    insert(ruleBag) { }
    // Overrides the StyleRule's implementation to do nothing.
    clear() { }
    // Returns the selector part of the style rule.
    getSel() { return ""; }
}
/**
 * The NamedStyleRule class is a base for style rule classes that are also named entities - such
 * as class rule and ID rule.
 */
class NamedStyleRule extends StyleRule {
    constructor(sd, styleset, nameOverride) {
        super(sd, styleset);
        this.nameOverride = nameOverride;
    }
    // Processes the given rule.
    process(ruleName) {
        super.process(ruleName);
        this.name = this.rc.getScopedName(ruleName, this.nameOverride);
        this.cssName = this.prefix + this.name;
    }
    // Returns the selector part of the style rule.
    getSel() {
        return this.cssName;
    }
    // Implementation of the toString method returns the name of the rule (without the CSS prefix).
    toString() {
        return this.name;
    }
}
/**
 * The ClassRule class describes a styleset that applies to elements identified by a CSS class.
 */
class ClassRule extends NamedStyleRule {
    constructor() {
        super(...arguments);
        // Prefix for CSS classes.
        this.prefix = ".";
    }
    // Allows the derived classes to process style properties that the StyleRule doesn't know about.
    // If returns false, the property with the given name will not be added to the styleset.
    parseSP(propName, propVal) {
        if (propName == "++") {
            let rules = propVal;
            if (rules)
                this.parents = Array.isArray(rules) ? rules : [rules];
            return false;
        }
        return super.parseSP(propName, propVal);
    }
    // Processes the given rule.
    process(ruleName) {
        super.process(ruleName);
        // by now our name and cssName properties have been set to reflect a single name. Now
        // look at the parent class rues defined using the "++" property and take names from the
        // referenced class rules and append them to the name.
        if (this.parents) {
            this.name += " " + this.parents.map(v => typeof v === "string" ? v : v.name).join(" ");
            this.cssName = "." + this.name.replace(/ /g, ".");
        }
    }
}
/**
 * The IDRule class describes a styleset that applies to elements identified by an ID.
 */
class IDRule extends NamedStyleRule {
    constructor() {
        super(...arguments);
        // Prefix for CSS element identifiers.
        this.prefix = "#";
    }
}
/**
 * The SelectorRule type describes a styleset that applies to elements identified by a CSS selector.
 */
class SelectorRule extends StyleRule {
    constructor(sd, selector, styleset) {
        super(sd, styleset);
        this.selector = selector;
    }
    // Returns the selector part of the style rule.
    getSel() {
        return (0,_impl_CoreImpl__WEBPACK_IMPORTED_MODULE_4__.selector2s)(this.selector);
    }
}
/**
 * The PageRule class represents the CSS @page rule.
 */
class PageRule extends StyleRule {
    constructor(sd, pseudoClass, style) {
        super(sd, style);
        this.pseudoClass = pseudoClass;
    }
    // Returns the selector part of the style rule.
    getSel() {
        return `@page ${this.pseudoClass ? this.pseudoClass : ""}`;
    }
}
/**
 * Merges properties from the source styleset to the target styleset. All regular properties are
 * replaced. The "--" property gets special treatment because it is an array.
 * @param target Target Styleset object - cannot be null or undefined;
 * @param source Source Styleset object - cannot be null or undefined.
 * @param source
 */
const mergeStylesets = (target, source) => {
    // copy all other properties from the source
    if (Object.keys(target).length === 0)
        Object.assign(target, source);
    else {
        for (let propName in source) {
            if (propName === "--")
                mergeCustomProps(target, source[propName]);
            else
                mergePropValues(target, propName, source[propName]);
        }
    }
};
/**
 * Merges "--" property from the source styleset to the target styleset.
 */
const mergeCustomProps = (target, sourceVars) => {
    let targetVars = target["--"];
    target["--"] = !targetVars ? sourceVars.slice() : targetVars.concat(sourceVars);
};
/**
 * Merges values of the given property from the source styleset to the target styleset. Note that
 * both source or target value can be either single value or an object with the `"[]"` property
 * that contains multiple values.
 * @param target Target Styleset object - cannot be null or undefined.
 * @param propName Name of the property.
 * @param sourceVal Value from the source styleset to merge with the target value - cannot be null
 * or undefined.
 */
const mergePropValues = (target, propName, sourceVal) => {
    let targetVal = target[propName];
    if (targetVal == null) {
        // if property doesn't exist in the target or its value is null or undefined, just
        // take the source's value
        target[propName] = sourceVal;
    }
    else {
        let targetArray = targetVal["[]"];
        if (!targetArray)
            target[propName] = { "[]": targetArray = [targetVal] };
        let sourceArray = sourceVal["[]"];
        if (!sourceArray)
            targetArray.push(sourceVal);
        else
            targetArray.push(...sourceArray);
    }
};


/***/ }),

/***/ "./lib/rules/VarRule.js":
/*!******************************!*\
  !*** ./lib/rules/VarRule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VarRule": () => (/* binding */ VarRule),
/* harmony export */   "PropertyRule": () => (/* binding */ PropertyRule),
/* harmony export */   "ConstRule": () => (/* binding */ ConstRule)
/* harmony export */ });
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");


/**
 * The VarBaseRule class contains functionality common for VarRule class describing a custom CSS
 * property definition in the `:root` rule and for PropertyRule class describing the `@property`
 * at-rule.
 */
class VarBaseRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(sd, template, value, nameOverride) {
        super(sd);
        // Prefix for CSS classes.
        this.prefix = "--";
        this.template = template;
        this.value = value;
        this.nameOverride = nameOverride;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the var(--name) expression.
    toString() {
        return `var(${this.cssName})`;
    }
    // Processes the given rule.
    process(ruleName) {
        this.name = this.rc.getScopedName(ruleName, this.nameOverride);
        this.cssName = "--" + this.name;
    }
    /**
     * Gets the value of the property.
     */
    getValue() {
        return this.value;
    }
    /**
     * Sets new value of this custom CSS property.
     * @param value New value for the CSS property.
     * @param schedulerType ID of a registered scheduler type that is used to write the property
     * value to the DOM. If undefined, the current default scheduler will be used.
     */
    setValue(value, schedulerType) {
        this.value = value;
        if (this.rc) {
            let important = false;
            if (value != null && typeof value === "object" && "!" in value) {
                important = true;
                value = value["!"];
            }
            this.rc.setVarValue(this.cssName, value == null
                ? null
                : (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(this.template, value), important, schedulerType);
        }
    }
}
/**
 * The VarRule class describes a custom CSS property. VarRule is not a real CSS rule; however, in
 * many aspects it repeats the Rule's functionality. In particular it has the process function that
 * allows it to obtain an actual name, which will be used when defining and using this custom
 * property in CSS.
 */
class VarRule extends VarBaseRule {
    constructor(sd, template, value, nameOverride) {
        super(sd, template, value, nameOverride);
    }
    // Inserts this rule into the given parent rule or stylesheet. This method is called when the
    // style definition class, to which this rule belongs, is activated.
    insert(ruleBag) { }
    // Converts the rule to CSS string.
    toCss() {
        return this.value == null ? null : `${this.cssName}: ${(0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(this.template, this.value)}`;
    }
}
/**
 * The PropertyRule class describes the `@property` at-rule.
 */
class PropertyRule extends VarBaseRule {
    constructor(sd, syntax, initValue, inherits = true, nameOverride) {
        if (Array.isArray(syntax)) {
            super(sd, "*", initValue, nameOverride);
            this.syntax = syntax[0];
        }
        else {
            super(sd, syntax, initValue, nameOverride);
            this.syntax = syntax;
        }
        this.inherits = inherits;
    }
    // Inserts this rule into the given parent rule or stylesheet. This method is called when the
    // style definition class, to which this rule belongs, is activated.
    insert(ruleBag) {
        let ruleText = `@property ${this.cssName}{syntax:'${this.syntax}';` +
            `inherits:${this.inherits};initial-value:${(0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(this.template, this.value)};}`;
        this.cssRule = ruleBag.add(ruleText)?.cssRule;
    }
}
/**
 * The IConstRule interface represents a "constant" that can be used anywhere the type defined by
 * the `template` parameter can be used. These are called constants, because they provide the
 * convenient and lightweight way of defining values that are unchanged during the application
 * lifetime. Although constants are defined very similarly to custom properties (see the
 * [[IVarRule]] function), they cannot participate in the cascade and cannot be redefined under
 * elements. Constant can, however, use any expression that satisfies the type defined by the
 * `template` parameter including other constants, custom properties and functions.
 * Objects implementing this interface are returned from the [[$const]] function.
 */
class ConstRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike {
    constructor(sd, template, value) {
        super(sd);
        this.template = template;
        this.value = value;
        this.s = (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(template, value);
    }
    // This function is used when the object is specified as a value of a style property.
    toString() { return this.s; }
    /**
     * Gets the value of the property.
     */
    getValue() {
        return this.value;
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attr": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.attr),
/* harmony export */   "counter": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.counter),
/* harmony export */   "counters": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.counters),
/* harmony export */   "cubicBezier": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.cubicBezier),
/* harmony export */   "cursor": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.cursor),
/* harmony export */   "media": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.media),
/* harmony export */   "nstag": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.nstag),
/* harmony export */   "raw": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.raw),
/* harmony export */   "sel": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.sel),
/* harmony export */   "selector": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.selector),
/* harmony export */   "steps": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.steps),
/* harmony export */   "supports": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.supports),
/* harmony export */   "url": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.url),
/* harmony export */   "usevar": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.usevar),
/* harmony export */   "Angle": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Angle),
/* harmony export */   "Frequency": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Frequency),
/* harmony export */   "Len": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Len),
/* harmony export */   "Num": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Num),
/* harmony export */   "Percent": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Percent),
/* harmony export */   "Q": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Q),
/* harmony export */   "Resolution": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Resolution),
/* harmony export */   "Time": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Time),
/* harmony export */   "ch": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ch),
/* harmony export */   "cm": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.cm),
/* harmony export */   "deg": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.deg),
/* harmony export */   "dpcm": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.dpcm),
/* harmony export */   "dpi": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.dpi),
/* harmony export */   "dppx": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.dppx),
/* harmony export */   "em": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.em),
/* harmony export */   "ex": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ex),
/* harmony export */   "fitContent": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.fitContent),
/* harmony export */   "fr": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.fr),
/* harmony export */   "grad": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.grad),
/* harmony export */   "hz": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.hz),
/* harmony export */   "ic": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ic),
/* harmony export */   "inch": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.inch),
/* harmony export */   "khz": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.khz),
/* harmony export */   "lh": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.lh),
/* harmony export */   "mm": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.mm),
/* harmony export */   "ms": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ms),
/* harmony export */   "pc": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.pc),
/* harmony export */   "percent": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.percent),
/* harmony export */   "pt": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.pt),
/* harmony export */   "px": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.px),
/* harmony export */   "rad": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rad),
/* harmony export */   "ratio": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ratio),
/* harmony export */   "rect": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rect),
/* harmony export */   "rem": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rem),
/* harmony export */   "rlh": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rlh),
/* harmony export */   "s": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.s),
/* harmony export */   "turn": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.turn),
/* harmony export */   "vb": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vb),
/* harmony export */   "vh": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vh),
/* harmony export */   "vi": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vi),
/* harmony export */   "vmax": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vmax),
/* harmony export */   "vmin": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vmin),
/* harmony export */   "vw": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vw),
/* harmony export */   "x": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.x),
/* harmony export */   "Colors": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.Colors),
/* harmony export */   "alpha": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.alpha),
/* harmony export */   "colorContrast": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.colorContrast),
/* harmony export */   "colorMix": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.colorMix),
/* harmony export */   "hsl": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.hsl),
/* harmony export */   "lab": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.lab),
/* harmony export */   "lch": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.lch),
/* harmony export */   "registerColor": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.registerColor),
/* harmony export */   "rgb": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.rgb),
/* harmony export */   "blur": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.blur),
/* harmony export */   "brightness": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.brightness),
/* harmony export */   "circle": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.circle),
/* harmony export */   "conicGradient": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.conicGradient),
/* harmony export */   "contrast": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.contrast),
/* harmony export */   "crossFade": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.crossFade),
/* harmony export */   "dropShadow": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.dropShadow),
/* harmony export */   "ellipse": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.ellipse),
/* harmony export */   "grayscale": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.grayscale),
/* harmony export */   "hueRotate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.hueRotate),
/* harmony export */   "imageSet": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.imageSet),
/* harmony export */   "inset": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.inset),
/* harmony export */   "invert": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.invert),
/* harmony export */   "linearGradient": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.linearGradient),
/* harmony export */   "matrix": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.matrix),
/* harmony export */   "matrix3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.matrix3d),
/* harmony export */   "minmax": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.minmax),
/* harmony export */   "opacity": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.opacity),
/* harmony export */   "paint": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.paint),
/* harmony export */   "path": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.path),
/* harmony export */   "perspective": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.perspective),
/* harmony export */   "polygon": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.polygon),
/* harmony export */   "radialGradient": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.radialGradient),
/* harmony export */   "ray": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.ray),
/* harmony export */   "registerPaintWorklet": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.registerPaintWorklet),
/* harmony export */   "repeat": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.repeat),
/* harmony export */   "rotate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotate),
/* harmony export */   "rotate3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotate3d),
/* harmony export */   "rotateX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotateX),
/* harmony export */   "rotateY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotateY),
/* harmony export */   "rotateZ": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotateZ),
/* harmony export */   "saturate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.saturate),
/* harmony export */   "scale": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scale),
/* harmony export */   "scale3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scale3d),
/* harmony export */   "scaleX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scaleX),
/* harmony export */   "scaleY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scaleY),
/* harmony export */   "scaleZ": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scaleZ),
/* harmony export */   "sepia": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.sepia),
/* harmony export */   "skew": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.skew),
/* harmony export */   "skewX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.skewX),
/* harmony export */   "skewY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.skewY),
/* harmony export */   "span": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.span),
/* harmony export */   "translate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translate),
/* harmony export */   "translate3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translate3d),
/* harmony export */   "translateX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translateX),
/* harmony export */   "translateY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translateY),
/* harmony export */   "translateZ": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translateZ),
/* harmony export */   "StyleDefinition": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.StyleDefinition),
/* harmony export */   "ThemeDefinition": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.ThemeDefinition),
/* harmony export */   "activate": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.activate),
/* harmony export */   "chooseClass": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.chooseClass),
/* harmony export */   "classes": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.classes),
/* harmony export */   "configNameGeneration": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.configNameGeneration),
/* harmony export */   "deactivate": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.deactivate),
/* harmony export */   "embedded": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.embedded),
/* harmony export */   "getActiveTheme": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.getActiveTheme),
/* harmony export */   "startHydration": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.startHydration),
/* harmony export */   "startSSR": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.startSSR),
/* harmony export */   "stopHydration": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.stopHydration),
/* harmony export */   "stopSSR": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.stopSSR),
/* harmony export */   "virtual": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.virtual),
/* harmony export */   "cancelDOMUpdate": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.cancelDOMUpdate),
/* harmony export */   "forceDOMUpdate": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.forceDOMUpdate),
/* harmony export */   "registerScheduler": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.registerScheduler),
/* harmony export */   "setDefaultScheduler": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.setDefaultScheduler),
/* harmony export */   "diffStylesets": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.diffStylesets),
/* harmony export */   "getStylePropValue": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.getStylePropValue),
/* harmony export */   "mediaToString": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.mediaToString),
/* harmony export */   "registerStyleProperty": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.registerStyleProperty),
/* harmony export */   "setElementStringStyle": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.setElementStringStyle),
/* harmony export */   "setElementStyle": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.setElementStyle),
/* harmony export */   "stylesetToString": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.stylesetToString),
/* harmony export */   "stylesetToStringStyleset": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.stylesetToStringStyleset),
/* harmony export */   "supportsToString": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.supportsToString)
/* harmony export */ });
/* harmony import */ var _api_CoreTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api/CoreTypes */ "./lib/api/CoreTypes.js");
/* harmony import */ var _api_NumericTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api/NumericTypes */ "./lib/api/NumericTypes.js");
/* harmony import */ var _api_ColorTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api/ColorTypes */ "./lib/api/ColorTypes.js");
/* harmony import */ var _api_ShapeTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api/ShapeTypes */ "./lib/api/ShapeTypes.js");
/* harmony import */ var _api_FontTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./api/FontTypes */ "./lib/api/FontTypes.js");
/* harmony import */ var _api_MediaTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./api/MediaTypes */ "./lib/api/MediaTypes.js");
/* harmony import */ var _api_RuleTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./api/RuleTypes */ "./lib/api/RuleTypes.js");
/* harmony import */ var _api_SchedulingTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./api/SchedulingTypes */ "./lib/api/SchedulingTypes.js");
/* harmony import */ var _api_StyleTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./api/StyleTypes */ "./lib/api/StyleTypes.js");
/* harmony import */ var _api_Stylesets__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./api/Stylesets */ "./lib/api/Stylesets.js");
/* harmony import */ var _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./api/CoreAPI */ "./lib/api/CoreAPI.js");
/* harmony import */ var _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./api/NumericAPI */ "./lib/api/NumericAPI.js");
/* harmony import */ var _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./api/ColorAPI */ "./lib/api/ColorAPI.js");
/* harmony import */ var _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./api/ShapeAPI */ "./lib/api/ShapeAPI.js");
/* harmony import */ var _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./api/RuleAPI */ "./lib/api/RuleAPI.js");
/* harmony import */ var _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./api/SchedulingAPI */ "./lib/api/SchedulingAPI.js");
/* harmony import */ var _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./api/StyleAPI */ "./lib/api/StyleAPI.js");
// Type definitions for mimcss


















})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW1jc3Mvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvQ29sb3JBUEkudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2FwaS9Db3JlQVBJLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvQ29yZVR5cGVzLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvTnVtZXJpY0FQSS50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvYXBpL051bWVyaWNUeXBlcy50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvYXBpL1J1bGVBUEkudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2FwaS9TY2hlZHVsaW5nQVBJLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvU2hhcGVBUEkudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2FwaS9TdHlsZUFQSS50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9Db3JlSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9NaXNjSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9OdW1lcmljSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9TY2hlZHVsaW5nSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9TdHlsZUltcGwudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2ltcGwvVXRpbHMudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL0FuaW1hdGlvblJ1bGUudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL0NvdW50ZXJSdWxlcy50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvcnVsZXMvR3JpZFJ1bGVzLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9ydWxlcy9Hcm91cFJ1bGVzLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9ydWxlcy9NaXNjUnVsZXMudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1J1bGUudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1J1bGVDb250YWluZXIudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1N0eWxlUnVsZXMudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1ZhclJ1bGUudHMiLCJ3ZWJwYWNrOi8vbWltY3NzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL21pbWNzcy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbWltY3NzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbWltY3NzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1A0RDtBQUk1RDs7Ozs7RUFLRTtBQUNLLE1BQU0sTUFBTSxHQUNuQjtJQUNJLEtBQUssRUFBbUIsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsSUFBSSxFQUFvQixRQUFRO0lBQ2hDLEtBQUssRUFBbUIsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsR0FBRyxFQUFxQixRQUFRO0lBQ2hDLE1BQU0sRUFBa0IsUUFBUTtJQUNoQyxPQUFPLEVBQWlCLFFBQVE7SUFDaEMsS0FBSyxFQUFtQixRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxLQUFLLEVBQW1CLFFBQVE7SUFDaEMsTUFBTSxFQUFrQixRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJ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Q0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFdEU7OztHQUdHO0FBQ0ksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXhFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFdEU7OztHQUdHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFdEU7Ozs7R0FJRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFdEU7Ozs7R0FJRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFdEU7OztHQUdHO0FBQ0ksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRXhFOzs7R0FHRztBQUNJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUV4RTs7O0dBR0c7QUFDSSxNQUFNLElBQUksR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFFMUU7OztHQUdHO0FBQ0ksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBRTFFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUl0RTs7Ozs7R0FLRztBQUNJLE1BQU0sS0FBSyxHQUFlLHdEQUFTLENBQUM7QUFFM0M7OztHQUdHO0FBQ0ksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFTLEVBQWUsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFdkU7OztHQUdHO0FBQ0ksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFTLEVBQWUsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFdkU7OztHQUdHO0FBQ0ksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFTLEVBQWUsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFFekU7OztHQUdHO0FBQ0ksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFTLEVBQWUsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFJekU7Ozs7R0FJRztBQUNLLE1BQU0sSUFBSSxHQUFjLHVEQUFRLENBQUM7QUFFeEM7OztFQUdFO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWMsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFcEU7OztHQUdHO0FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFTLEVBQWMsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFJbEU7Ozs7O0dBS0c7QUFDSyxNQUFNLFVBQVUsR0FBb0IsNkRBQWMsQ0FBQztBQUUxRDs7O0VBR0U7QUFDSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQVMsRUFBb0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFNUU7OztHQUdHO0FBQ0ksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFTLEVBQW9CLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBRTlFOzs7R0FHRztBQUNJLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBUyxFQUFvQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUU5RTs7O0dBR0c7QUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQVMsRUFBb0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsR0FB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QUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQSx3Rjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkEsOEJBQThCO0FBRUU7QUFDRztBQUNGO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDTTtBQUNMO0FBQ0Q7QUFFRjtBQUNHO0FBQ0Y7QUFDQTtBQUNEO0FBQ007QUFDTCIsImZpbGUiOiJtaW1jc3MuZGV2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibWltY3NzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIm1pbWNzc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIu+7v2ltcG9ydCB7RXh0ZW5kZWQsIE9uZU9yTWFueX0gZnJvbSBcIi4vQ29yZVR5cGVzXCI7XHJcbmltcG9ydCB7Q3NzQW5nbGUsIENzc1BlcmNlbnR9IGZyb20gXCIuL051bWVyaWNUeXBlc1wiO1xyXG5pbXBvcnQge0NvbG9yU3BhY2UsIENzc0NvbG9yLCBDc3NDb2xvclNlcGFyYXRpb24sIElBbHBoYUZ1bmMsIElDb2xvckNvbnRyYXN0RnVuYywgSUNvbG9yTWl4QnVpbGRlciwgSUhzbEZ1bmMsIElMYWJGdW5jLCBJTGNoRnVuYywgSU5hbWVkQ29sb3JzLCBJUmdiRnVuY30gZnJvbSBcIi4vQ29sb3JUeXBlc1wiO1xyXG5pbXBvcnQge2EycywgZmRvLCBtdjJzLCB2MnMsIHdrZiwgV0tGfSBmcm9tIFwiLi4vaW1wbC9VdGlsc1wiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogT2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSB0aGUgd2VsbC1rbm93biBXZWIgY29sb3IgbmFtZXMgd2hpbGUgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlXHJcbiAqIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSR0Igc2VwYXJhdGlvbnMgKHdpdGhvdXQgYW4gYWxwaGEgbWFzaykuIFRoZSBwcm9wZXJ0aWVzIG9mXHJcbiAqIHRoaXMgb2JqZWN0IGNhbiBiZSB1c2VkIHdoZXJldmVyIHRoZSBbW0Nzc0NvbG9yXV0gdHlwZSBjYW4gYmUgdXNlZC4gU2luY2UgdGhlIHByb3BlcnRpZXMgYXJlXHJcbiAqIG9mIHRoZSBgbnVtYmVyYCB0eXBlLCB0aGV5IGNhbiBiZSB1c2VkIGZvciBtYW5pcHVsYXRpbmcgdGhlIGNvbG9yIHZhbHVlLlxyXG4qL1xyXG5leHBvcnQgY29uc3QgQ29sb3JzOiBJTmFtZWRDb2xvcnMgPVxyXG57XHJcbiAgICBibGFjazogICAgICAgICAgICAgICAgICAweDAwMDAwMCxcclxuICAgIHNpbHZlcjogICAgICAgICAgICAgICAgIDB4YzBjMGMwLFxyXG4gICAgZ3JheTogICAgICAgICAgICAgICAgICAgMHg4MDgwODAsXHJcbiAgICB3aGl0ZTogICAgICAgICAgICAgICAgICAweGZmZmZmZixcclxuICAgIG1hcm9vbjogICAgICAgICAgICAgICAgIDB4ODAwMDAwLFxyXG4gICAgcmVkOiAgICAgICAgICAgICAgICAgICAgMHhmZjAwMDAsXHJcbiAgICBwdXJwbGU6ICAgICAgICAgICAgICAgICAweDgwMDA4MCxcclxuICAgIGZ1Y2hzaWE6ICAgICAgICAgICAgICAgIDB4ZmYwMGZmLFxyXG4gICAgZ3JlZW46ICAgICAgICAgICAgICAgICAgMHgwMDgwMDAsXHJcbiAgICBsaW1lOiAgICAgICAgICAgICAgICAgICAweDAwZmYwMCxcclxuICAgIG9saXZlOiAgICAgICAgICAgICAgICAgIDB4ODA4MDAwLFxyXG4gICAgeWVsbG93OiAgICAgICAgICAgICAgICAgMHhmZmZmMDAsXHJcbiAgICBuYXZ5OiAgICAgICAgICAgICAgICAgICAweDAwMDA4MCxcclxuICAgIGJsdWU6ICAgICAgICAgICAgICAgICAgIDB4MDAwMGZmLFxyXG4gICAgdGVhbDogICAgICAgICAgICAgICAgICAgMHgwMDgwODAsXHJcbiAgICBhcXVhOiAgICAgICAgICAgICAgICAgICAweDAwZmZmZixcclxuICAgIG9yYW5nZTogICAgICAgICAgICAgICAgIDB4ZmZhNTAwLFxyXG4gICAgYWxpY2VibHVlOiAgICAgICAgICAgICAgMHhmMGY4ZmYsXHJcbiAgICBhbnRpcXVld2hpdGU6ICAgICAgICAgICAweGZhZWJkNyxcclxuICAgIGFxdWFtYXJpbmU6ICAgICAgICAgICAgIDB4N2ZmZmQ0LFxyXG4gICAgYXp1cmU6ICAgICAgICAgICAgICAgICAgMHhmMGZmZmYsXHJcbiAgICBiZWlnZTogICAgICAgICAgICAgICAgICAweGY1ZjVkYyxcclxuICAgIGJpc3F1ZTogICAgICAgICAgICAgICAgIDB4ZmZlNGM0LFxyXG4gICAgYmxhbmNoZWRhbG1vbmQ6ICAgICAgICAgMHhmZmViY2QsXHJcbiAgICBibHVldmlvbGV0OiAgICAgICAgICAgICAweDhhMmJlMixcclxuICAgIGJyb3duOiAgICAgICAgICAgICAgICAgIDB4YTUyYTJhLFxyXG4gICAgYnVybHl3b29kOiAgICAgICAgICAgICAgMHhkZWI4ODcsXHJcbiAgICBjYWRldGJsdWU6ICAgICAgICAgICAgICAweDVmOWVhMCxcclxuICAgIGNoYXJ0cmV1c2U6ICAgICAgICAgICAgIDB4N2ZmZjAwLFxyXG4gICAgY2hvY29sYXRlOiAgICAgICAgICAgICAgMHhkMjY5MWUsXHJcbiAgICBjb3JhbDogICAgICAgICAgICAgICAgICAweGZmN2Y1MCxcclxuICAgIGNvcm5mbG93ZXJibHVlOiAgICAgICAgIDB4NjQ5NWVkLFxyXG4gICAgY29ybnNpbGs6ICAgICAgICAgICAgICAgMHhmZmY4ZGMsXHJcbiAgICBjcmltc29uOiAgICAgICAgICAgICAgICAweGRjMTQzYyxcclxuICAgIGN5YW46ICAgICAgICAgICAgICAgICAgIDB4MDBmZmZmLFxyXG4gICAgZGFya2JsdWU6ICAgICAgICAgICAgICAgMHgwMDAwOGIsXHJcbiAgICBkYXJrY3lhbjogICAgICAgICAgICAgICAweDAwOGI4YixcclxuICAgIGRhcmtnb2xkZW5yb2Q6ICAgICAgICAgIDB4Yjg4NjBiLFxyXG4gICAgZGFya2dyYXk6ICAgICAgICAgICAgICAgMHhhOWE5YTksXHJcbiAgICBkYXJrZ3JlZW46ICAgICAgICAgICAgICAweDAwNjQwMCxcclxuICAgIGRhcmtncmV5OiAgICAgICAgICAgICAgIDB4YTlhOWE5LFxyXG4gICAgZGFya2toYWtpOiAgICAgICAgICAgICAgMHhiZGI3NmIsXHJcbiAgICBkYXJrbWFnZW50YTogICAgICAgICAgICAweDhiMDA4YixcclxuICAgIGRhcmtvbGl2ZWdyZWVuOiAgICAgICAgIDB4NTU2YjJmLFxyXG4gICAgZGFya29yYW5nZTogICAgICAgICAgICAgMHhmZjhjMDAsXHJcbiAgICBkYXJrb3JjaGlkOiAgICAgICAgICAgICAweDk5MzJjYyxcclxuICAgIGRhcmtyZWQ6ICAgICAgICAgICAgICAgIDB4OGIwMDAwLFxyXG4gICAgZGFya3NhbG1vbjogICAgICAgICAgICAgMHhlOTk2N2EsXHJcbiAgICBkYXJrc2VhZ3JlZW46ICAgICAgICAgICAweDhmYmM4ZixcclxuICAgIGRhcmtzbGF0ZWJsdWU6ICAgICAgICAgIDB4NDgzZDhiLFxyXG4gICAgZGFya3NsYXRlZ3JheTogICAgICAgICAgMHgyZjRmNGYsXHJcbiAgICBkYXJrc2xhdGVncmV5OiAgICAgICAgICAweDJmNGY0ZixcclxuICAgIGRhcmt0dXJxdW9pc2U6ICAgICAgICAgIDB4MDBjZWQxLFxyXG4gICAgZGFya3Zpb2xldDogICAgICAgICAgICAgMHg5NDAwZDMsXHJcbiAgICBkZWVwcGluazogICAgICAgICAgICAgICAweGZmMTQ5MyxcclxuICAgIGRlZXBza3libHVlOiAgICAgICAgICAgIDB4MDBiZmZmLFxyXG4gICAgZGltZ3JheTogICAgICAgICAgICAgICAgMHg2OTY5NjksXHJcbiAgICBkaW1ncmV5OiAgICAgICAgICAgICAgICAweDY5Njk2OSxcclxuICAgIGRvZGdlcmJsdWU6ICAgICAgICAgICAgIDB4MWU5MGZmLFxyXG4gICAgZmlyZWJyaWNrOiAgICAgICAgICAgICAgMHhiMjIyMjIsXHJcbiAgICBmbG9yYWx3aGl0ZTogICAgICAgICAgICAweGZmZmFmMCxcclxuICAgIGZvcmVzdGdyZWVuOiAgICAgICAgICAgIDB4MjI4YjIyLFxyXG4gICAgZ2FpbnNib3JvOiAgICAgICAgICAgICAgMHhkY2RjZGMsXHJcbiAgICBnaG9zdHdoaXRlOiAgICAgICAgICAgICAweGY4ZjhmZixcclxuICAgIGdvbGQ6ICAgICAgICAgICAgICAgICAgIDB4ZmZkNzAwLFxyXG4gICAgZ29sZGVucm9kOiAgICAgICAgICAgICAgMHhkYWE1MjAsXHJcbiAgICBncmVlbnllbGxvdzogICAgICAgICAgICAweGFkZmYyZixcclxuICAgIGdyZXk6ICAgICAgICAgICAgICAgICAgIDB4ODA4MDgwLFxyXG4gICAgaG9uZXlkZXc6ICAgICAgICAgICAgICAgMHhmMGZmZjAsXHJcbiAgICBob3RwaW5rOiAgICAgICAgICAgICAgICAweGZmNjliNCxcclxuICAgIGluZGlhbnJlZDogICAgICAgICAgICAgIDB4Y2Q1YzVjLFxyXG4gICAgaW5kaWdvOiAgICAgICAgICAgICAgICAgMHg0YjAwODIsXHJcbiAgICBpdm9yeTogICAgICAgICAgICAgICAgICAweGZmZmZmMCxcclxuICAgIGtoYWtpOiAgICAgICAgICAgICAgICAgIDB4ZjBlNjhjLFxyXG4gICAgbGF2ZW5kZXI6ICAgICAgICAgICAgICAgMHhlNmU2ZmEsXHJcbiAgICBsYXZlbmRlcmJsdXNoOiAgICAgICAgICAweGZmZjBmNSxcclxuICAgIGxhd25ncmVlbjogICAgICAgICAgICAgIDB4N2NmYzAwLFxyXG4gICAgbGVtb25jaGlmZm9uOiAgICAgICAgICAgMHhmZmZhY2QsXHJcbiAgICBsaWdodGJsdWU6ICAgICAgICAgICAgICAweGFkZDhlNixcclxuICAgIGxpZ2h0Y29yYWw6ICAgICAgICAgICAgIDB4ZjA4MDgwLFxyXG4gICAgbGlnaHRjeWFuOiAgICAgICAgICAgICAgMHhlMGZmZmYsXHJcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogICAweGZhZmFkMixcclxuICAgIGxpZ2h0Z3JheTogICAgICAgICAgICAgIDB4ZDNkM2QzLFxyXG4gICAgbGlnaHRncmVlbjogICAgICAgICAgICAgMHg5MGVlOTAsXHJcbiAgICBsaWdodGdyZXk6ICAgICAgICAgICAgICAweGQzZDNkMyxcclxuICAgIGxpZ2h0cGluazogICAgICAgICAgICAgIDB4ZmZiNmMxLFxyXG4gICAgbGlnaHRzYWxtb246ICAgICAgICAgICAgMHhmZmEwN2EsXHJcbiAgICBsaWdodHNlYWdyZWVuOiAgICAgICAgICAweDIwYjJhYSxcclxuICAgIGxpZ2h0c2t5Ymx1ZTogICAgICAgICAgIDB4ODdjZWZhLFxyXG4gICAgbGlnaHRzbGF0ZWdyYXk6ICAgICAgICAgMHg3Nzg4OTksXHJcbiAgICBsaWdodHNsYXRlZ3JleTogICAgICAgICAweDc3ODg5OSxcclxuICAgIGxpZ2h0c3RlZWxibHVlOiAgICAgICAgIDB4YjBjNGRlLFxyXG4gICAgbGlnaHR5ZWxsb3c6ICAgICAgICAgICAgMHhmZmZmZTAsXHJcbiAgICBsaW1lZ3JlZW46ICAgICAgICAgICAgICAweDMyY2QzMixcclxuICAgIGxpbmVuOiAgICAgICAgICAgICAgICAgIDB4ZmFmMGU2LFxyXG4gICAgbWFnZW50YTogICAgICAgICAgICAgICAgMHhmZjAwZmYsXHJcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiAgICAgICAweDY2Y2RhYSxcclxuICAgIG1lZGl1bWJsdWU6ICAgICAgICAgICAgIDB4MDAwMGNkLFxyXG4gICAgbWVkaXVtb3JjaGlkOiAgICAgICAgICAgMHhiYTU1ZDMsXHJcbiAgICBtZWRpdW1wdXJwbGU6ICAgICAgICAgICAweDkzNzBkYixcclxuICAgIG1lZGl1bXNlYWdyZWVuOiAgICAgICAgIDB4M2NiMzcxLFxyXG4gICAgbWVkaXVtc2xhdGVibHVlOiAgICAgICAgMHg3YjY4ZWUsXHJcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogICAgICAweDAwZmE5YSxcclxuICAgIG1lZGl1bXR1cnF1b2lzZTogICAgICAgIDB4NDhkMWNjLFxyXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAgICAgICAgMHhjNzE1ODUsXHJcbiAgICBtaWRuaWdodGJsdWU6ICAgICAgICAgICAweDE5MTk3MCxcclxuICAgIG1pbnRjcmVhbTogICAgICAgICAgICAgIDB4ZjVmZmZhLFxyXG4gICAgbWlzdHlyb3NlOiAgICAgICAgICAgICAgMHhmZmU0ZTEsXHJcbiAgICBtb2NjYXNpbjogICAgICAgICAgICAgICAweGZmZTRiNSxcclxuICAgIG5hdmFqb3doaXRlOiAgICAgICAgICAgIDB4ZmZkZWFkLFxyXG4gICAgb2xkbGFjZTogICAgICAgICAgICAgICAgMHhmZGY1ZTYsXHJcbiAgICBvbGl2ZWRyYWI6ICAgICAgICAgICAgICAweDZiOGUyMyxcclxuICAgIG9yYW5nZXJlZDogICAgICAgICAgICAgIDB4ZmY0NTAwLFxyXG4gICAgb3JjaGlkOiAgICAgICAgICAgICAgICAgMHhkYTcwZDYsXHJcbiAgICBwYWxlZ29sZGVucm9kOiAgICAgICAgICAweGVlZThhYSxcclxuICAgIHBhbGVncmVlbjogICAgICAgICAgICAgIDB4OThmYjk4LFxyXG4gICAgcGFsZXR1cnF1b2lzZTogICAgICAgICAgMHhhZmVlZWUsXHJcbiAgICBwYWxldmlvbGV0cmVkOiAgICAgICAgICAweGRiNzA5MyxcclxuICAgIHBhcGF5YXdoaXA6ICAgICAgICAgICAgIDB4ZmZlZmQ1LFxyXG4gICAgcGVhY2hwdWZmOiAgICAgICAgICAgICAgMHhmZmRhYjksXHJcbiAgICBwZXJ1OiAgICAgICAgICAgICAgICAgICAweGNkODUzZixcclxuICAgIHBpbms6ICAgICAgICAgICAgICAgICAgIDB4ZmZjMGNiLFxyXG4gICAgcGx1bTogICAgICAgICAgICAgICAgICAgMHhkZGEwZGQsXHJcbiAgICBwb3dkZXJibHVlOiAgICAgICAgICAgICAweGIwZTBlNixcclxuICAgIHJvc3licm93bjogICAgICAgICAgICAgIDB4YmM4ZjhmLFxyXG4gICAgcm95YWxibHVlOiAgICAgICAgICAgICAgMHg0MTY5ZTEsXHJcbiAgICBzYWRkbGVicm93bjogICAgICAgICAgICAweDhiNDUxMyxcclxuICAgIHNhbG1vbjogICAgICAgICAgICAgICAgIDB4ZmE4MDcyLFxyXG4gICAgc2FuZHlicm93bjogICAgICAgICAgICAgMHhmNGE0NjAsXHJcbiAgICBzZWFncmVlbjogICAgICAgICAgICAgICAweDJlOGI1NyxcclxuICAgIHNlYXNoZWxsOiAgICAgICAgICAgICAgIDB4ZmZmNWVlLFxyXG4gICAgc2llbm5hOiAgICAgICAgICAgICAgICAgMHhhMDUyMmQsXHJcbiAgICBza3libHVlOiAgICAgICAgICAgICAgICAweDg3Y2VlYixcclxuICAgIHNsYXRlYmx1ZTogICAgICAgICAgICAgIDB4NmE1YWNkLFxyXG4gICAgc2xhdGVncmF5OiAgICAgICAgICAgICAgMHg3MDgwOTAsXHJcbiAgICBzbGF0ZWdyZXk6ICAgICAgICAgICAgICAweDcwODA5MCxcclxuICAgIHNub3c6ICAgICAgICAgICAgICAgICAgIDB4ZmZmYWZhLFxyXG4gICAgc3ByaW5nZ3JlZW46ICAgICAgICAgICAgMHgwMGZmN2YsXHJcbiAgICBzdGVlbGJsdWU6ICAgICAgICAgICAgICAweDQ2ODJiNCxcclxuICAgIHRhbjogICAgICAgICAgICAgICAgICAgIDB4ZDJiNDhjLFxyXG4gICAgdGhpc3RsZTogICAgICAgICAgICAgICAgMHhkOGJmZDgsXHJcbiAgICB0b21hdG86ICAgICAgICAgICAgICAgICAweGZmNjM0NyxcclxuICAgIHR1cnF1b2lzZTogICAgICAgICAgICAgIDB4NDBlMGQwLFxyXG4gICAgdmlvbGV0OiAgICAgICAgICAgICAgICAgMHhlZTgyZWUsXHJcbiAgICB3aGVhdDogICAgICAgICAgICAgICAgICAweGY1ZGViMyxcclxuICAgIHdoaXRlc21va2U6ICAgICAgICAgICAgIDB4ZjVmNWY1LFxyXG4gICAgeWVsbG93Z3JlZW46ICAgICAgICAgICAgMHg5YWNkMzIsXHJcbiAgICByZWJlY2NhcHVycGxlOiAgICAgICAgICAweDY2MzM5OSxcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIE9iamVjdCB3aGVyZSB3ZSBrZWVwIHRoZSByZWdpc3RlcmVkIGN1c3RvbSBjb2xvcnMuIFdlIG5lZWQgaXQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNvbG9yXHJcbiAqIGlzIGEgc3RhbmRhcmQgb3IgYSBjdXN0b20gb25lLlxyXG4gKi9cclxuY29uc3QgY3VzdG9tQ29sb3JzOiB7IFtQOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgbmV3IGN1c3RvbSBjb2xvciBvciBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiB0aGUgZXhpc3RpbmcgY3VzdG9tIGNvbG9yLiBUaGUgbmFtZSBvZiB0aGVcclxuICogY3VzdG9tIGNvbG9yIHNob3VsZCBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZCB0byB0aGUgW1tJTmFtZWRDb2xvcnNdXSBpbnRlcmZhY2UgdXNpbmcgdGhlIG1vZHVsZVxyXG4gKiBhdWdtZW50YXRpb24gdGVjaG5pcXVlLiBOb3RlIHRoYXQgdmFsdWVzIG9mIHN0YW5kYXJkIFdlYiBjb2xvcnMgY2Fubm90IGJlIGNoYW5nZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIENvbG9yIG5hbWUuIFRoaXMgbmFtZSBjYW5ub3QgYmUgYSBuYW1lIG9mIHRoZSBzdGFuZGFyZCBXZWIgY29sb3IuXHJcbiAqIEBwYXJhbSB2YWx1ZSBDb2xvciB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGdpdmVuIG5hbWVkIGNvbG9yLlxyXG4gKiBAcmV0dXJucyBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgb3BlcmF0aW9uIHdhcyBzdWNjZXNzZnVsLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQ29sb3IgPSAoIG5hbWU6IGtleW9mIElOYW1lZENvbG9ycywgdmFsdWU6IG51bWJlcik6IGJvb2xlYW4gPT5cclxue1xyXG4gICAgaWYgKCFuYW1lIHx8IHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vIHRyeSB0byByZXRyaWV2ZSB0aGlzIG5hbWUgZnJvbSB0aGUgQ3VzdG9tQ29sb3JzIG9iamVjdC4gTm9uLXVuZGVmaW5lZCB2YWx1ZSBtZWFucyB0aGF0XHJcbiAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgdGhpcyBjb2xvciByZWdpc3RlcmVkLlxyXG4gICAgbGV0IGN1c3RvbVZhbHVlID0gY3VzdG9tQ29sb3JzW25hbWVdO1xyXG5cclxuICAgIC8vIGlmIHRoZSBjb2xvciBuYW1lIGFscmVhZHkgZXhpc3RzIGluIHRoZSBDb2xvcnMgb2JqZWN0IHdlIHdpbGwgb25seSBhbGxvdyBjaGFuZ2luZyBpdHNcclxuICAgIC8vIHZhbHVlIGlmIHRoaXMgaXMgYSBjdXN0b20gY29sb3IuXHJcbiAgICBpZiAobmFtZSBpbiBDb2xvcnMgJiYgY3VzdG9tVmFsdWUgIT0gbnVsbClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgLy8gYWRkIHRoZSB2YWx1ZSB0byB0aGUgQ29sb3JzIGFuZCBDdXN0b21Db2xvcnMgb2JqZWN0c1xyXG4gICAgKENvbG9ycyBhcyBhbnkpW25hbWVdID0gdmFsdWU7XHJcbiAgICBjdXN0b21Db2xvcnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBjb2xvciB2YWx1ZSBmcm9tIHRoZSBudW1lcmljIHJlcHJlc2VudGF0aW9uIHRvIHRoZSBDU1MgY29sb3Igc3RyaW5nLlxyXG4gKi9cclxubGV0ICBjb2xvck51bWJlcjJzID0gKHZhbDogbnVtYmVyKTogc3RyaW5nID0+XHJcbntcclxuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgbmVnYXRpdmUsIHJlbWVtYmVyIHRoYXQgZmFjdCBhbmQgZ2V0IHRoZSBwb3NpdGl2ZSBudW1iZXJcclxuICAgIGxldCBpc05lZ2F0aXZlID0gdmFsIDwgMDtcclxuICAgIGxldCBuID0gaXNOZWdhdGl2ZSA/IC12YWwgOiB2YWw7XHJcblxyXG4gICAgLy8gaWYgdGhlIG51bWJlciBoYXMgYSBmbG9hdGluZyBwb2ludCBwYXJ0LCBzZXBhcmF0ZSBpdCBpbnRvIGFscGhhIGNoYW5uZWxcclxuICAgIGxldCBhID0gMDtcclxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihuKSlcclxuICAgIHtcclxuICAgICAgICBsZXQgayA9IE1hdGguZmxvb3Iobik7XHJcbiAgICAgICAgLy8gYSA9IE1hdGgucm91bmQoIChuIC0gaykgKiAxMDApO1xyXG4gICAgICAgIGEgPSBNYXRoLnJvdW5kKCAobiAtIGspICogMjU1KTtcclxuICAgICAgICBuID0gaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgbnVtYmVyIHdhcyBuZWdhdGl2ZSB3ZSByZXZlcnQgdGhlIGNvbG9yIGJ5IG5lZ2F0aW5nIGFsbCB0aGUgYml0cy4gSW4gYW55IGNhc2UsXHJcbiAgICAvLyB3ZSBjbGVhciBldmVyeXRoaW5nIGJleW9uZCB0aGUgZmlyc3QgdGhyZWUgYnl0ZXMuXHJcbiAgICBuID0gaXNOZWdhdGl2ZSA/IH4oMHhGRjAwMDAwMCB8IG4pIDogMHgwMEZGRkZGRiAmIG47XHJcblxyXG4gICAgbGV0IHMgPSBcIiNcIiArIG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KCA2LCBcIjBcIik7XHJcbiAgICByZXR1cm4gYSA/IHMgKyBhLnRvU3RyaW5nKDE2KS5wYWRTdGFydCggMiwgXCIwXCIpIDogcztcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgY29sb3Igc3R5bGUgdmFsdWUgdG8gdGhlIENTUyBzdHJpbmcuIFdlIGNvbnZlcnQgbnVtZXJpYyB2YWx1ZXMgdG8gdGhlICNSUkdHQkJBQVxyXG4gKiByZXByZXNlbnRhdGlvbi4gSWYgYSBzdHJpbmcgdmFsdWUgaXMgYSBjdXN0b20gY29sb3IgYWRkZWQgdmlhIElOYW1lZENvbG9ycyBtb2R1bGVcclxuICogYXVnbWVudGF0aW9uIHdlIGdldCBpdHMgbnVtYmVyIGZyb20gdGhlIGBjdXN0bUNvbG9yc2Agb2JqZWN0IGFuZCBhbHNvIGNvbnZlcnQgaXQgdG8gdGhlXHJcbiAqICNSUkdHQkJBQSByZXByZXNlbnRhdGlvbi4gU3RhbmRhcmQgbmFtZWQgY29sb3JzIGFzIHdlbGwgYXMgYXJlIHJldHVybmVkIGFzIGlzLlxyXG4gKi9cclxud2tmW1dLRi5Db2xvcl0gPSAodmFsOiBFeHRlbmRlZDxDc3NDb2xvcj4pOiBzdHJpbmcgPT5cclxuICAgIHYycyggdmFsLCB7XHJcbiAgICAgICAgc3RyOiB2ID0+IHYgaW4gY3VzdG9tQ29sb3JzID8gY29sb3JOdW1iZXIycyggY3VzdG9tQ29sb3JzW3ZdKSA6IHYsXHJcbiAgICAgICAgbnVtOiBjb2xvck51bWJlcjJzXHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBjb2xvciBzdHlsZSB2YWx1ZSB0byB0aGUgQ1NTIHN0cmluZy4gV2UgY29udmVydCBudW1lcmljIHZhbHVlcyB0byB0aGUgI1JSR0dCQkFBXHJcbiAqIHJlcHJlc2VudGF0aW9uLiBJZiBhIHN0cmluZyB2YWx1ZSBpcyBhIGN1c3RvbSBjb2xvciBhZGRlZCB2aWEgSU5hbWVkQ29sb3JzIG1vZHVsZVxyXG4gKiBhdWdtZW50YXRpb24gd2UgZ2V0IGl0cyBudW1iZXIgZnJvbSB0aGUgYGN1c3RtQ29sb3JzYCBvYmplY3QgYW5kIGFsc28gY29udmVydCBpdCB0byB0aGVcclxuICogI1JSR0dCQkFBIHJlcHJlc2VudGF0aW9uLiBTdGFuZGFyZCBuYW1lZCBjb2xvcnMgYXMgd2VsbCBhcyBhcmUgcmV0dXJuZWQgYXMgaXMuXHJcbiAqL1xyXG53a2ZbV0tGLkNvbG9yc10gPSAodmFsOiBPbmVPck1hbnk8Q3NzQ29sb3I+KTogc3RyaW5nID0+IHYycyggdmFsLCB7IGFueTogV0tGLkNvbG9yIH0pXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgY29sb3Igc2VwYXJhdGlvbiB2YWx1ZSB0byBhIENTUyBzdHJpbmcuXHJcbiAqL1xyXG53a2ZbV0tGLkNvbG9yU2VwYXJhdGlvbl0gPSAoYzogRXh0ZW5kZWQ8bnVtYmVyPik6IHN0cmluZyA9PlxyXG4gICAgdjJzKCBjLCB7XHJcbiAgICAgICAgbnVtOiBjID0+IHtcclxuICAgICAgICAgICAgYyA9IGMgPCAwID8gLWMgOiBjO1xyXG4gICAgICAgICAgICByZXR1cm4gKGMgPT09IDAgfHwgYyA+PSAxKSA/IFwiXCIgKyBjIDogKE1hdGgucm91bmQoIGMgKiAxMDApICsgXCIlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgY29sb3Igc3BlY2lmaWVkIGFzIHJlZCwgZ3JlZW4sIGJsdWUgc2VwYXJhdGlvbiB2YWx1ZXMgYW5kIGFuIG9wdGlvbmFsIGFscGhhXHJcbiAqIG1hc2sgdG8gYSBDU1MgY29sb3IgcmVwcmVzZW50YXRpb24uIEVhY2ggY29sb3Igc2VwYXJhdGlvbiBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBudW1iZXIgd2l0aFxyXG4gKiB0aGUgZm9sbG93aW5nIG1lYW5pbmc6XHJcbiAqICAgLSBJbnRlZ2VyIG51bWJlciAtMjU1IHRvIDI1NS4gTnVtYmVycyBiZXlvbmQgdGhpcyByYW5nZSB3aWxsIGJlIGNsYW1wZWQuIE5lZ2F0aXZlIG51bWJlcnNcclxuICogICAgIHdpbGwgYmUgaW52ZXJ0ZWQuXHJcbiAqICAgLSBGbG9hdGluZyBudW1iZXIgLTEuMCB0byAxLjAgbm9uLWluY2x1c2l2ZSwgd2hpY2ggaXMgbXVsdGlwbGllZCBieSAxMDAgdHJlYXRlZCBhcyBwZXJjZW50YWdlLlxyXG4gKiAgICAgRmxvYXRpbmcgbnVtYmVycyBiZXlvbmQgdGhpcyByYW5nZSB3aWxsIGJlIHJvdW5kZWQgYW5kIHRyZWF0ZWQgYXMgaW50ZWdlciBudW1iZXJzLiBOZWdhdGl2ZVxyXG4gKiAgICAgbnVtYmVycyB3aWxsIGJlIGludmVydGVkLlxyXG4gKlxyXG4gKiBUaGUgYWxwaGEgbWFzayBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XHJcbiAqICAgLSBGbG9hdGluZyBudW1iZXIgMCB0byAxIGluY2x1c2l2ZS5cclxuICogICAtIEludGVnZXIgb3IgZmxvYXRpbmcgbnVtYmVyIDEgdG8gMTAwLCB3aGljaCBpcyBkaXZpZGVkIGJ5IDEwMC4gRmxvYXRpbmcgbnVtYmVycyB3aWxsIGJlXHJcbiAqICAgICByb3VuZGVkLiBOdW1iZXJzIGJleW9uZCB0aGlzIHJhbmdlIHdpbGwgYmUgY2xhbXBlZC5cclxuICogICAtIFRoZSBzaWduIG9mIGFscGhhIGlzIGlnbm9yZWQ7IHRoYXQgaXMsIG9ubHkgdGhlIGFic29sdXRlIHZhbHVlIGlzIGNvbnNpZGVyZWQuXHJcbiAqXHJcbiAqIC0gTUROOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWUvcmdiKClcclxuICpcclxuICogQHBhcmFtIHIgUmVkIHNlcGFyYXRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSBnIEdyZWVuIHNlcGFyYXRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSBiIEJsdWUgc2VwYXJhdGlvbiB2YWx1ZS5cclxuICogQHBhcmFtIGEgT3B0aW9uYWwgYWxwaGEgbWFzayBhcyBhIHBlcmNlbnRhZ2UgdmFsdWUuXHJcbiAqIEByZXR1cm4gVGhlIGBJUmdiRnVuY2Agb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW52b2NhdGlvbiBvZiB0aGUgYHJnYigpYCBDU1MgZnVuY3Rpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCByZ2IgPSAocjogRXh0ZW5kZWQ8Q3NzQ29sb3JTZXBhcmF0aW9uPiwgZzogRXh0ZW5kZWQ8Q3NzQ29sb3JTZXBhcmF0aW9uPixcclxuICAgIGI6IEV4dGVuZGVkPENzc0NvbG9yU2VwYXJhdGlvbj4sIGE/OiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElSZ2JGdW5jID0+XHJcbntcclxuICAgIHJldHVybiB7IGZuOiBcInJnYlwiLCByLCBnLCBiLCBhIH07XHJcbn1cclxuXHJcbmZkby5yZ2IgPSB7XHJcbiAgICBwOiBbIFtcInJcIiwgV0tGLkNvbG9yU2VwYXJhdGlvbl0sIFtcImdcIiwgIFdLRi5Db2xvclNlcGFyYXRpb25dLCBbXCJiXCIsICBXS0YuQ29sb3JTZXBhcmF0aW9uXSwgW1wiYVwiLCAgV0tGLlBlcmNlbnQsIFwiL1wiXSBdLFxyXG4gICAgczogXCIgXCJcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBjb2xvciBzcGVjaWZpZWQgYXMgaHVlLXNhdHVyYXRpb24tbGlnaHRuZXNzIGNvbXBvbmVudHMgYW5kIGFuIG9wdGlvbmFsIGFscGhhXHJcbiAqIG1hc2sgdG8gYSBDU1MgY29sb3IgcmVwcmVzZW50YXRpb24uIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHdoZW4gZGVmaW5pbmcgQ1NTIGNvbG9yXHJcbiAqIHZhbHVlcyBpbiBzdHlsZXNldCBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBUaGUgSHVlIGNvbXBvbmVudCBpcyB0cmVhdGVkIGFzIHRoZSBDU1MgYDxhbmdsZT5gIHR5cGUuIE51bWJlcnMgYXJlIGNvbnNpZGVyZWQgZGVncmVlcy5cclxuICpcclxuICogVGhlIFNhdHVyYXRpb24gYW5kIExpZ2h0bmVzcyBjb21wb25lbnRzIGFyZSB0cmVhdGVkIGFzIHBlcmNlbnRhZ2VzOlxyXG4gKiAgIC0gVGhlIHNpZ24gaXMgaWdub3JlZDsgdGhhdCBpcywgb25seSB0aGUgYWJzb2x1dGUgdmFsdWUgaXMgY29uc2lkZXJlZC5cclxuICogICAtIEZsb2F0aW5nIG51bWJlciAwIHRvIDEgaW5jbHVzaXZlIGFyZSBtdWx0aXBsaWVkIGJ5IDEwMCBhbmQgdHJlYXRlZCBhcyBwZXJjZW50YWdlLlxyXG4gKiAgIC0gSW50ZWdlciBvciBmbG9hdGluZyBudW1iZXIgMSB0byAxMDAgYXJlIHRyZWF0ZWQgYXMgcGVyY2VudGFnZS4gRmxvYXRpbmcgbnVtYmVycyB3aWxsIGJlXHJcbiAqICAgICByb3VuZGVkLiBOdW1iZXJzIGJleW9uZCB0aGlzIHJhbmdlIHdpbGwgYmUgY2xhbXBlZCB0byAxMDAuXHJcbiAqXHJcbiAqIFRoZSBhbHBoYSBtYXNrIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcclxuICogICAtIEZsb2F0aW5nIG51bWJlciAwIHRvIDEgaW5jbHVzaXZlLlxyXG4gKiAgIC0gSW50ZWdlciBvciBmbG9hdGluZyBudW1iZXIgMSB0byAxMDAsIHdoaWNoIGlzIGRpdmlkZWQgYnkgMTAwLiBGbG9hdGluZyBudW1iZXJzIHdpbGwgYmVcclxuICogICAgIHJvdW5kZWQuIE51bWJlcnMgYmV5b25kIHRoaXMgcmFuZ2Ugd2lsbCBiZSBjbGFtcGVkLlxyXG4gKiAgIC0gVGhlIHNpZ24gb2YgYWxwaGEgaXMgaWdub3JlZDsgdGhhdCBpcywgb25seSB0aGUgYWJzb2x1dGUgdmFsdWUgaXMgY29uc2lkZXJlZC5cclxuICpcclxuICogLSBNRE46IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZS9oc2woKVxyXG4gKlxyXG4gKiBAcGFyYW0gaCBIdWUgY29tcG9uZW50IGFzIGFuIGFuZ2xlIHZhbHVlLlxyXG4gKiBAcGFyYW0gcyBTYXR1cmF0aW9uIGNvbXBvbmVudCBhcyBhIHBlcmNlbnRhZ2UgdmFsdWUuXHJcbiAqIEBwYXJhbSBsIExpZ2h0bmVzcyBjb21wb25lbnQgYXMgYSBwZXJjZW50YWdlIHZhbHVlLlxyXG4gKiBAcGFyYW0gYSBPcHRpb25hbCBhbHBoYSBtYXNrIGFzIGEgcGVyY2VudGFnZSB2YWx1ZS5cclxuICogQHJldHVybiBUaGUgYElIc2xGdW5jYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgaHNsKClgIENTUyBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGhzbCA9IChoOiBFeHRlbmRlZDxDc3NBbmdsZT4sIHM6IEV4dGVuZGVkPENzc1BlcmNlbnQ+LCBsOiBFeHRlbmRlZDxDc3NQZXJjZW50PixcclxuICAgIGE/OiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElIc2xGdW5jID0+XHJcbntcclxuICAgIHJldHVybiB7IGZuOiBcImhzbFwiLCBoLCBzLCBsLCBhIH07XHJcbn1cclxuXHJcbmZkby5oc2wgPSB7XHJcbiAgICBwOiBbIFtcImhcIiwgV0tGLkFuZ2xlXSwgW1wic1wiLCBXS0YuUGVyY2VudF0sIFtcImxcIiwgV0tGLlBlcmNlbnRdLCBbXCJhXCIsIFdLRi5QZXJjZW50LCBcIi9cIl0gXSxcclxuICAgIHM6IFwiIFwiXHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgY29sb3Igc3BlY2lmaWVkIGFzIExcXCphXFwqYlxcKiBjb21wb25lbnRzIGFuZCBhbiBvcHRpb25hbCBhbHBoYVxyXG4gKiBtYXNrIHRvIGEgQ1NTIGNvbG9yIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB3aGVuIGRlZmluaW5nIENTUyBjb2xvclxyXG4gKiB2YWx1ZXMgaW4gc3R5bGVzZXQgcHJvcGVydGllcy5cclxuICpcclxuICogLSBNRE46IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZS9sYWIoKVxyXG4gKlxyXG4gKiBAcGFyYW0gbCBDSUUgTGlnaHRuZXNzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gZGEgRGlzdGFuY2UgYWxvbmcgdGhlIGEgYXhpcyBpbiB0aGUgTGFiIGNvbG9yc3BhY2VcclxuICogQHBhcmFtIGRiIERpc3RhbmNlIGFsb25nIHRoZSBiIGF4aXMgaW4gdGhlIExhYiBjb2xvcnNwYWNlXHJcbiAqIEBwYXJhbSBhIE9wdGlvbmFsIGFscGhhIG1hc2sgYXMgYSBwZXJjZW50YWdlIHZhbHVlLlxyXG4gKiBAcmV0dXJucyBUaGUgYElMYWJGdW5jYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgbGFiKClgIENTUyBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxhYiA9IChsOiBFeHRlbmRlZDxDc3NQZXJjZW50PiwgZGE6IEV4dGVuZGVkPG51bWJlcj4sIGRiOiBFeHRlbmRlZDxudW1iZXI+LFxyXG4gICAgYT86IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSUxhYkZ1bmMgPT5cclxue1xyXG4gICAgcmV0dXJuIHsgZm46IFwibGFiXCIsIGwsIGRhLCBkYiwgYSB9O1xyXG59XHJcblxyXG5mZG8ubGFiID0ge1xyXG4gICAgcDogWyBbXCJsXCIsIFdLRi5BbHdheXNQZXJjZW50XSwgXCJkYVwiLCBcImRiXCIsIFtcImFcIiwgV0tGLlBlcmNlbnQsIFwiL1wiXSBdLFxyXG4gICAgczogXCIgXCJcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBjb2xvciBzcGVjaWZpZWQgYXMgbGlnaHRuZXNzLWNocm9tYS1odWUgY29tcG9uZW50cyBhbmQgYW4gb3B0aW9uYWwgYWxwaGFcclxuICogbWFzayB0byBhIENTUyBjb2xvciByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgd2hlbiBkZWZpbmluZyBDU1MgY29sb3JcclxuICogdmFsdWVzIGluIHN0eWxlc2V0IHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIC0gTUROOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWUvbGNoKClcclxuICpcclxuICogQHBhcmFtIGwgQ0lFIExpZ2h0bmVzcyBjb21wb25lbnRcclxuICogQHBhcmFtIGMgQ2hyb21hIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gaCBIdWUgY29tcG9uZW50IGFzIGFuIGFuZ2xlIHZhbHVlLlxyXG4gKiBAcGFyYW0gYSBPcHRpb25hbCBhbHBoYSBtYXNrIGFzIGEgcGVyY2VudGFnZSB2YWx1ZS5cclxuICogQHJldHVybnMgVGhlIGBJTGNoRnVuY2Agb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW52b2NhdGlvbiBvZiB0aGUgYGxjaCgpYCBDU1MgZnVuY3Rpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBsY2ggPSAobDogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4sIGM6IEV4dGVuZGVkPG51bWJlcj4sIGg6IEV4dGVuZGVkPENzc0FuZ2xlPixcclxuICAgIGE/OiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElMY2hGdW5jID0+XHJcbntcclxuICAgIHJldHVybiB7IGZuOiBcImxjaFwiLCBsLCBjLCBoLCBhIH07XHJcbn1cclxuXHJcbmZkby5sY2ggPSB7XHJcbiAgICBwOiBbIFtcImxcIiwgV0tGLkFsd2F5c1BlcmNlbnRdLCBcImNcIiwgW1wiaFwiLCBXS0YuQW5nbGVdLCBbXCJhXCIsIFdLRi5QZXJjZW50LCBcIi9cIl0gXSxcclxuICAgIHM6IFwiIFwiXHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHRoZSBgY29sb3ItY29udHJhc3QoKWAgQ1NTIHByb3BlcnR5LlxyXG4gKlxyXG4gKiAtIE1ETjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlL2NvbG9yLWNvbnRyYXN0KClcclxuICpcclxuICogQHBhcmFtIGMgQ29sb3IgdG8gd2hpY2ggdGhlIGxpc3Qgb2YgY29sb3JzIGluIHRoZSBgdnNgIHByb3BlcnR5IHdpbGwgYmUgY29tcGFyZWRcclxuICogQHBhcmFtIHZzIExpc3Qgb2YgY29sb3JzIGZyb20gd2hpY2ggdG8gc2VsZWN0IHRoZSBtb3N0IGNvbnRyYXN0aW5nIHRvIHRoZSBiYXNlIGNvbG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgYElDb2xvckNvbnRyYXN0RnVuY2Agb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW52b2NhdGlvbiBvZiB0aGUgYGNvbG9yLWNvbnRyYXN0KClgXHJcbiAqIENTUyBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbG9yQ29udHJhc3QgPSAoYzogRXh0ZW5kZWQ8Q3NzQ29sb3I+LCAuLi52czogRXh0ZW5kZWQ8Q3NzQ29sb3I+W10pOiBJQ29sb3JDb250cmFzdEZ1bmMgPT5cclxuICAgICh7IGZuOiBcImNvbG9yLWNvbnRyYXN0XCIsIGMsIHZzIH0pO1xyXG5cclxuZmRvW1wiY29sb3ItY29udHJhc3RcIl0gPSB7XHJcbiAgICBwOiBbXHJcbiAgICAgICAgW1wiY1wiLCAodjogRXh0ZW5kZWQ8Q3NzQ29sb3I+KSA9PiB2MnMoIHYsIFdLRi5Db2xvcikgKyBcIiB2c1wiXSxcclxuICAgICAgICBbXCJ2c1wiLCAodjogRXh0ZW5kZWQ8Q3NzQ29sb3I+W10pID0+IGEycyggdiwgV0tGLkNvbG9yLCBcIixcIildXHJcbiAgICBdLFxyXG4gICAgczogXCIgXCJcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiB0aGUgQ1NTIGBjb2xvci1taXgoKWAgZnVuY3Rpb24uIFRoaXMgaW50ZXJmYWNlIGlzIHJldHVybmVkIGZyb20gdGhlXHJcbiAqIFtbY29sb3JNaXhdXSBmdW5jdGlvbi4gRGV2ZWxvcGVycyBjYW4gdXNlIHRoaXMgc3RydWN0dXJlIHdoZXJldmVyIFtbQ3NzQ29sb3JdXSBpcyBhY2NlcHRlZC5cclxuICovXHJcbmNsYXNzIENvbG9yTWl4RnVuYyBpbXBsZW1lbnRzIElDb2xvck1peEJ1aWxkZXJcclxue1xyXG4gICAgZm46IFwiY29sb3ItbWl4XCIgPSBcImNvbG9yLW1peFwiO1xyXG5cclxuICAgIGNzPzogRXh0ZW5kZWQ8Q29sb3JTcGFjZT47XHJcbiAgICBjMTogW0V4dGVuZGVkPENzc0NvbG9yPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD4/XTtcclxuICAgIGMyOiBbRXh0ZW5kZWQ8Q3NzQ29sb3I+LCBFeHRlbmRlZDxDc3NQZXJjZW50Pj9dO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCBjOiBFeHRlbmRlZDxDc3NDb2xvcj4sIHA/OiBFeHRlbmRlZDxDc3NQZXJjZW50PikgeyB0aGlzLmMxID0gW2MsIHBdOyB9XHJcblxyXG4gICAgd2l0aCggYzogRXh0ZW5kZWQ8Q3NzQ29sb3I+LCBwPzogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4pOiB0aGlzICB7IHRoaXMuYzIgPSBbYywgcF07IHJldHVybiB0aGlzOyB9XHJcbiAgICBpbiggY3M6IEV4dGVuZGVkPENvbG9yU3BhY2U+KTogdGhpcyB7IHRoaXMuY3MgPSBjczsgcmV0dXJuIHRoaXM7IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGBjb2xvci1taXgoKWAgQ1NTIHByb3BlcnR5LlxyXG4gKlxyXG4gKiAtIE1ETjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlL2NvbG9yLW5peCgpXHJcbiAqXHJcbiAqICoqRXhhbXBsZXMqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGNvbG9yLW1peCggXCJibHVlXCIsIFwicmVkXCIpXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gKiAgICAgICAgIGNvbG9yOiBjc3MuY29sb3JNaXgoXCJibHVlXCIpLndpdGgoXCJyZWRcIik7XHJcbiAqICAgICB9KVxyXG4gKlxyXG4gKiAgICAgLy8gY29sb3ItbWl4KCBpbiBzcmdiLCBcImJsdWUgMzAlXCIsIFwicmVkXCIgNjAlKVxyXG4gKiAgICAgY2xzMiA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICBjb2xvcjogY3NzLmNvbG9yTWl4KFwiYmx1ZVwiLCAzMCkud2l0aChcInJlZFwiLCA2MCkuaW4oXCJzcmdiXCIpO1xyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGNzIENvbG9yIHNwYWNlLiBEZWZhdWx0IGlzIFwibGNoXCIuXHJcbiAqIEByZXR1cm5zIFRoZSBgSUNvbG9yTWl4QnVpbGRlcmAgb2JqZWN0IHRoYXQgYWxsb3dzIGFkZGluZyBjb2xvcnMgYW5kIG9wdGlvbmFsIHBlcmNlbnRhZ2VzIHRvIG1peFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbG9yTWl4ID0gKGM6IEV4dGVuZGVkPENzc0NvbG9yPiwgcD86IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSUNvbG9yTWl4QnVpbGRlciA9PiBuZXcgQ29sb3JNaXhGdW5jKCBjLCBwKTtcclxuXHJcbmZkb1tcImNvbG9yLW1peFwiXSA9IFtcclxuICAgIFtcImNzXCIsICh2OiBFeHRlbmRlZDxDb2xvclNwYWNlPikgPT4gdiA/IFwiaW4gXCIgKyB2MnModikgOiBcIlwiXSxcclxuICAgIFtcImMxXCIsIHYgPT4gbXYycyggW1t2WzBdLCBXS0YuQ29sb3JdLCBbdlsxXSwgV0tGLlBlcmNlbnRdXSldLFxyXG4gICAgW1wiYzJcIiwgdiA9PiBtdjJzKCBbW3ZbMF0sIFdLRi5Db2xvcl0sIFt2WzFdLCBXS0YuUGVyY2VudF1dKV0sXHJcbl07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gY29sb3IgYW5kIHRoZSBhbHBoYSBtYXNrIHRvIHRoZSBDU1MgQ29sb3IgcmVwcmVzZW50YXRpb24uIFRoaXNcclxuICogbWV0aG9kIHNob3VsZCBiZSB1c2VkIHdoZW4gZGVmaW5pbmcgQ1NTIGNvbG9yIHZhbHVlcyBpbiBzdHlsZXNldCBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBUaGUgY29sb3IgY2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgdmFsdWUgb3IgYXMgYSBjb2xvciBuYW1lIGZyb20gdGhlIFtbSU5hbWVkQ29sb3JzXV1cclxuICogaW50ZXJmYWNlIC0gaW5jbHVkaW5nIGNvbG9ycyBhZGRlZCB1c2luZyB0aGUgbW9kdWxlIGF1Z21lbnRhdGlvbiB0ZWNobmlxdWUuXHJcbiAqXHJcbiAqIFRoZSBhbHBoYSBtYXNrIGlzIHNwZWNpZmllZCBhcyBhIG51bWJlcjpcclxuICogICAtIFRoZSBzaWduIGlzIGlnbm9yZWQ7IHRoYXQgaXMsIG9ubHkgdGhlIGFic29sdXRlIHZhbHVlIGlzIGNvbnNpZGVyZWQuXHJcbiAqICAgLSBOdW1iZXIgMCB0byAxIGluY2x1c2l2ZSwgd2hpY2ggaXMgdHJlYXRlZCBhcyBwZXJjZW50YWdlLlxyXG4gKiAgIC0gTnVtYmVyIDEgdG8gMTAwIGluY2x1c2l2ZSwgd2hpY2ggaXMgdHJlYXRlZCBhcyBwZXJjZW50YWdlLlxyXG4gKiAgIC0gTnVtYmVycyBncmVhdGVyIHRoYW4gMTAwIGFyZSBjbGFtcGVkIHRvIDEwMDtcclxuICpcclxuICogKipFeGFtcGxlcyoqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGFwcGx5aW5nIGFscGhhIHRvIGEgbnVtZXJpYyBjb2xvclxyXG4gKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHsgY29sb3I6IGNzcy5hbHBoYSggMHhBQTAwQUEsIDAuNSkgfSlcclxuICpcclxuICogICAgIC8vIGFwcGx5aW5nIGFscGhhIHRvIGEgbmFtZWQgY29sb3JcclxuICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiBjc3MuYWxwaGEoIFwiZGFya29saXZlZ3JlZW5cIiwgMC41KSB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBAcGFyYW0gYyBDb2xvciB2YWx1ZSBhcyBlaXRoZXIgYSBudW1iZXIgb3IgYSBuYW1lZCBjb2xvclxyXG4gKiBAcGFyYW0gYSBBbHBoYSBjaGFubmVsIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWxwaGEgPSAoYzogbnVtYmVyIHwga2V5b2YgSU5hbWVkQ29sb3JzLCBhOiBudW1iZXIpOiBJQWxwaGFGdW5jID0+ICh7IGZuOiBcImFscGhhXCIsIGMsIGEgfSk7XHJcblxyXG5jb25zdCBhbHBoYTJzID0gKGM6IG51bWJlciB8IGtleW9mIElOYW1lZENvbG9ycywgYTogbnVtYmVyKTogc3RyaW5nID0+XHJcbntcclxuICAgIC8vIGlmIHRoZSBhbHBoYSBpcyAwLCByZXR1cm4gdHJhbnNwYXJlbnQgY29sb3JcclxuICAgIGlmIChhID09PSAwKVxyXG4gICAgICAgIHJldHVybiBcIiMwMDAwXCI7XHJcblxyXG4gICAgLy8gY29udmVydCBjb2xvciB0byBudW1lcmljIHZhbHVlIChpZiBpdCdzIG5vdCBhIG51bWJlciB5ZXQpLiBJZiB0aGUgY29sb3Igd2FzIGdpdmVuIGFzIGFcclxuICAgIC8vIHN0cmluZyB0aGF0IHdlIGNhbm5vdCBmaW5kIGluIHRoZSBDb2xvcnMgb2JqZWN0LCByZXR1cm4gcHVyZSB3aGl0ZS5cclxuICAgIGxldCBuID0gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIgPyBDb2xvcnNbY10gOiBjO1xyXG4gICAgaWYgKG4gPT0gbnVsbClcclxuICAgICAgICByZXR1cm4gXCIjRkZGXCI7XHJcblxyXG4gICAgLy8gbmVnYXRpdmUgYW5kIHBvc2l0aXZlIHZhbHVlcyBvZiBhbHBoYSBhcmUgdHJlYXRlZCBpZGVudGljYWxseSwgc28gY29udmVydCB0byBwb3NpdGl2ZVxyXG4gICAgaWYgKGEgPCAwKVxyXG4gICAgICAgIGEgPSAtYTtcclxuXHJcbiAgICAvLyBjb252ZXJ0IGFscGhhIHRvIGEgbnVtYmVyIHdpdGggYWJzb2x1dGUgdmFsdWUgbGVzcyB0aGFuIDEgKGlmIGl0IGlzIG5vdCB5ZXQpLiBJZiBhbHBoYVxyXG4gICAgLy8gaXMgMSBvciAxMDAsIHRoZW4gc2V0IGl0IHRvIDAgYmVjYXVzZSAwIGluIHRoZSBjb2xvck51bWJlclRvU3RyaW5nIG1lYW5zIFwibm8gYWxwaGFcIi5cclxuICAgIGEgPSBhID09PSAxIHx8IGEgPj0gMTAwID8gMCA6IGEgPiAxID8gYSAvIDEwMCA6IGE7XHJcblxyXG4gICAgLy8gbWFrZSB0aGUgbmV3IGFscGhhXHJcbiAgICByZXR1cm4gY29sb3JOdW1iZXIycyggbiA+PSAwID8gbiArIGEgOiBuIC0gYSk7XHJcbn1cclxuXHJcbmZkby5hbHBoYSA9ICh2OiBJQWxwaGFGdW5jKSA9PiBhbHBoYTJzKCB2LmMsIHYuYSlcclxuXHJcblxyXG4iLCLvu79pbXBvcnQge1xyXG4gICAgQ3NzU2VsZWN0b3IsIElTZWxlY3RvclByb3h5LCBJUmF3UHJveHksIEV4dGVuZGVkLCBJVXJsRnVuYywgSUN1cnNvckZ1bmMsIElTdHJpbmdQcm94eSxcclxuICAgIElTZWxlY3RvckJ1aWxkZXIsIE50aEV4cHJlc3Npb24sIEF0dHJDb21wYXJpc29uT3BlcmF0aW9uLCBUaW1pbmdGdW5jdGlvbkp1bXBUZXJtLFxyXG4gICAgSUN1YmljQmV6aWVyRnVuYywgSVN0ZXBzRnVuYywgSU5TVGFnRnVuYywgRWxlbWVudFRhZ05hbWUsIFNlbGVjdG9yQ29tYmluYXRvcixcclxufSBmcm9tIFwiLi9Db3JlVHlwZXNcIlxyXG5pbXBvcnQge0lDb3VudGVyUnVsZSwgSUlEUnVsZSwgSU5hbWVzcGFjZVJ1bGUsIElWYXJSdWxlfSBmcm9tIFwiLi9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHtBdHRyVHlwZUtleXdvcmQsIEF0dHJVbml0S2V5d29yZCwgTGlzdFN0eWxlVHlwZV9TdHlsZVR5cGV9IGZyb20gXCIuL1N0eWxlVHlwZXNcIjtcclxuaW1wb3J0IHtFeHRlbmRlZFZhclZhbHVlLCBTdHlsZXNldCwgVmFyVGVtcGxhdGVOYW1lfSBmcm9tIFwiLi9TdHlsZXNldHNcIjtcclxuaW1wb3J0IHtFeHRlbmRlZE1lZGlhRmVhdHVyZXNldCwgSU1lZGlhUXVlcnlQcm94eSwgSVN1cHBvcnRzUXVlcnlQcm94eX0gZnJvbSBcIi4vTWVkaWFUeXBlc1wiO1xyXG5pbXBvcnQge3NwMnN9IGZyb20gXCIuLi9pbXBsL1N0eWxlSW1wbFwiO1xyXG5pbXBvcnQge21lZGlhMnMsIHN1cHBvcnRzMnN9IGZyb20gXCIuLi9pbXBsL01pc2NJbXBsXCI7XHJcbmltcG9ydCB7YTJzLCBjYW1lbFRvRGFzaCwgZjJzLCBmZG8sIG12MnMsIHRhZzJzLCBXS0Z9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBTZWxlY3RvciBmdW5jdGlvbnNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdG9yLiBUaGlzIGZ1bmN0aW9uIGlzIGEgdGFnIGZ1bmN0aW9uIGFuZCBtdXN0IGJlXHJcbiAqIGludm9rZWQgd2l0aCB0aGUgdGVtcGxhdGUgc3RyaW5nIHdpdGhvdXQgcGFyZW50aGVzZXMuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgd2hlcmV2ZXIgdGhlXHJcbiAqIFtbQ3NzU2VsZWN0b3JdXSB0eXBlcyBhcmUgYWxsb3dlZC4gVGhlIHBhcmFtZXRlcnMgZW1iZWRkZWQgaW50byB0aGUgc3RyaW5nXHJcbiAqIG11c3QgY29uZm9ybSB0byB0aGUgW1tDc3NTZWxlY3Rvcl1dIHR5cGUuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBjc3M6IHVsID4gbGkgey4uLn1cclxuICogICAgIHMxID0gdGhpcy4kc3R5bGUoIGNzcy5zZWxlY3RvcmB1bCA+IGxpYCwgey4uLn0pXHJcbiAqXHJcbiAqICAgICAvLyBjc3M6IHVsLmMxOmhvdmVyIHsuLi59XHJcbiAqICAgICBjMSA9IHRoaXMuJGNsYXNzKHsuLi59KVxyXG4gKiAgICAgczIgPSB0aGlzLiRzdHlsZSggY3NzLnNlbGVjdG9yYHVsLiR7dGhpcy5jMX06aG92ZXJgLCB7Li4ufSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjb25zdCBzZWxlY3RvciA9IChwYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnBhcmFtczogQ3NzU2VsZWN0b3JbXSk6IElTZWxlY3RvclByb3h5ID0+XHJcbiAgICAoKSA9PiB0YWcycyggcGFydHMsIHBhcmFtcyk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBcnJheSBvZiBhdHRyaWJ1dGUgY29tcGFyaXNvbiBvcGVyYXRpb24gc3RyaW5ncyAtIG5lZWRlZCB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nIGlzIGFuXHJcbiAqIGF0dHJpYnV0ZSBjb21wYXJpc29uIG9wZXJhdGlvbi5cclxuICovXHJcbmNvbnN0IGF0dHJDb21wYXJpc29uT3BlcmF0aW9uczogQXR0ckNvbXBhcmlzb25PcGVyYXRpb25bXSA9IFtcIj1cIiwgIFwifj1cIiwgXCJ8PVwiLCBcIl49XCIsIFwiJD1cIiwgXCIqPVwiXTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGUgbnVtZXJpYyB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBpZGVudGlmeSB3aGF0IHRvIGRvIHdoZW4gYW4gYXBwcm9wcmlhdGUgcHJvcGVydHkgb3JcclxuICogbWV0aG9kIGZyb20gdGhlIElTZWxlY3RvckJ1aWxkZXIgaW50ZXJmYWNlIGlzIGludm9rZWQuXHJcbiAqL1xyXG5jb25zdCBlbnVtIFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGVcclxue1xyXG4gICAgU2ltcGxlUHNldWRvRWxlbWVudCA9IDEsXHJcbiAgICBQYXJhbWV0ZXJpemVkUHNldWRvQ2xhc3MsXHJcbiAgICBQYXJhbWV0ZXJpemVkUHNldWRvRWxlbWVudCxcclxufVxyXG5cclxuLyoqXHJcbiAqIFR5cGUgdGhhdCBkZXRlcm1pbmVzIGhvdyBhIHByb3BlcnR5IG9yIGEgbWV0aG9kIG9mIHRoZSBJU2VsZWN0b3JCdWlsZGVyIGludGVyZmFjZSBzaG91bGQgYmVcclxuICogY29udmVydGVkIHRvIENzc1NlbGVjdG9yIHZhbHVlczogVGhlIHR5cGUgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxyXG4gKiAgIC0gbnVtYmVyIC0gb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgU2VsZWN0b3JQcm9jZXNzaW5nVHlwZSBlbnVtZXJhdGlvblxyXG4gKiAgIC0gRnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gd2lsbCBiZSBib3VuZCB0byB0aGUgU2VsZWN0b3JCdWlsZGVySGFuZGxlciBpbnN0YW5jZSBhbmQgdGhlXHJcbiAqICAgICBwcm9wZXJ0eSBuYW1lLlxyXG4gKiAgIC0gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBmaWVkczpcclxuICogICAgIC0gZiAtIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGJvdW5kIHRvIHRoZSBTZWxlY3RvckJ1aWxkZXJIYW5kbGVyIGluc3RhbmNlLCB0aGVcclxuICogICAgICAgcHJvcGVydHkgbmFtZSBhbmQgd2hhdGV2ZXIgYXJndW1lbnRzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIFwiYVwiIGZpZWxkLlxyXG4gKiAgICAgLSBhIC0gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHdoaWNoIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgYnkgdGhlIFwiZlwiIGZpZWxkIHdpbCBiZSBib3VuZCB0b1xyXG4gKiAgICAgICBpbiBhZGRpdGlvbiB0byB0aGUgU2VsZWN0b3JCdWlsZGVySGFuZGxlciBpbnN0YW5jZSBhbmQgdGhlIHByb3BlcnR5IG5hbWUuXHJcbiAqICAgICAtIHAgLSBvcHRpb25hbCBwcmVmaXggdG8gYmUgYWRkZWQgdG8gdGhlIHByb3BlcnR5IG5hbWUgZm9yIHBzZXVkbyBjbGFzc2VzIGFuZCBlbGVtZW50cy5cclxuICogICAgIC0gbiAtIG9wdGlvbmFsIG5hbWUgb2YgdGhlIGVudGl0eSB0byBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG5hbWUuXHJcbiAqL1xyXG50eXBlIFNlbGVjdG9yUHJvY2Vzc2luZ0luZm8gPSBTZWxlY3RvclByb2Nlc3NpbmdUeXBlIHwgRnVuY3Rpb24gfFxyXG4gICAgeyBmOiBGdW5jdGlvbiwgYTogYW55W10sIHA/OiBcIjpcIiB8IFwiOjpcIiwgbj86IHN0cmluZyB9O1xyXG5cclxuLy8gU2VsZWN0b3JQcm9jZXNzaW5nSW5mbyBvYmplY3QgdGhhdCB1c2VkIHNldmVyYWwgdGltZXMsIHNvIGl0IGlzIFwiY2FjaGVkXCIgaGVyZVxyXG5jb25zdCBwc2V1ZG9DbGFzc1dpdGhTZWxlY3RvcnNJbmZvOiBTZWxlY3RvclByb2Nlc3NpbmdJbmZvID0geyBmOiB3cmFwQW5kQWRkU2VsZWN0b3JzLCBhOiBbXCIsXCJdLCBwOiBcIjpcIiB9O1xyXG5cclxuLyoqXHJcbiAqIE9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGhvdyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSBJU2VsZWN0b3JCdWlsZGVyIGludGVyZmFjZVxyXG4gKiBzaG91bGQgYmUgY29udmVydGVkIHRvIENzc1NlbGVjdG9yIHZhbHVlcy4gSWYgYSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpcyBub3QgaW4gdGhpcyBvYmplY3QsIGl0XHJcbiAqIGlzIHRyZWF0ZWQgYXMgYSBub24tcGFyYW1ldGVyaXplZCBwc2V1ZG8gY2xhc3MuXHJcbiAqL1xyXG5jb25zdCBzZWxlY3RvckluZm9zOiB7IFtQIGluIHN0cmluZ106IFNlbGVjdG9yUHJvY2Vzc2luZ0luZm8gfSA9XHJcbntcclxuICAgIC8vIGhlbHBlciBtZXRob2RzXHJcbiAgICBcImF0dHJcIjogYWRkQXR0clNlbGVjdG9yLFxyXG4gICAgXCJhbmRcIjogeyBmOiBhZGRTZWxlY3RvcnNXaXRoQ29tYmluYXRvcnMsIGE6IFtcIlwiXSB9LFxyXG4gICAgXCJvclwiOiB7IGY6IGFkZFNlbGVjdG9yc1dpdGhDb21iaW5hdG9ycywgYTogW1wiLFwiXSB9LFxyXG4gICAgXCJjaGlsZFwiOiB7IGY6IGFkZFNlbGVjdG9yc1dpdGhDb21iaW5hdG9ycywgYTogW1wiPlwiXSB9LFxyXG4gICAgXCJkZXNjXCI6IHsgZjogYWRkU2VsZWN0b3JzV2l0aENvbWJpbmF0b3JzLCBhOiBbXCIgXCJdIH0sXHJcbiAgICBcInNpYlwiOiB7IGY6IGFkZFNlbGVjdG9yc1dpdGhDb21iaW5hdG9ycywgYTogW1wiflwiXSB9LFxyXG4gICAgXCJhZGpcIjogeyBmOiBhZGRTZWxlY3RvcnNXaXRoQ29tYmluYXRvcnMsIGE6IFtcIitcIl0gfSxcclxuXHJcbiAgICAvLyBzaW1wbGUgcHNldWRvIGVsZW1lbnRzXHJcbiAgICBcImFmdGVyXCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuU2ltcGxlUHNldWRvRWxlbWVudCxcclxuICAgIFwiYmFja2Ryb3BcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJiZWZvcmVcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJjdWVcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJmaXJzdExldHRlclwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcbiAgICBcImZpcnN0TGluZVwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcbiAgICBcImdyYW1tYXJFcnJvclwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcbiAgICBcIm1hcmtlclwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcbiAgICBcInBsYWNlaG9sZGVyXCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuU2ltcGxlUHNldWRvRWxlbWVudCxcclxuICAgIFwic2VsZWN0aW9uXCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuU2ltcGxlUHNldWRvRWxlbWVudCxcclxuICAgIFwic3BlbGxpbmdFcnJvclwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcblxyXG4gICAgLy8gcGFyYW1ldGVyaXplZCBwc2V1ZG8gY2xhc3Nlc1xyXG4gICAgXCJkaXJcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5QYXJhbWV0ZXJpemVkUHNldWRvQ2xhc3MsXHJcbiAgICAvLyBcImhhc1wiOiBwc2V1ZG9DbGFzc1dpdGhTZWxlY3RvcnNJbmZvLFxyXG4gICAgXCJob3N0JFwiOiB7IGY6IHdyYXBBbmRBZGRTZWxlY3RvcnMsIGE6IFtcIixcIl0sIHA6IFwiOlwiLCBuOiBcIjpob3N0XCIgfSxcclxuICAgIFwiaG9zdENvbnRleHRcIjogcHNldWRvQ2xhc3NXaXRoU2VsZWN0b3JzSW5mbyxcclxuICAgIFwiaXNcIjogcHNldWRvQ2xhc3NXaXRoU2VsZWN0b3JzSW5mbyxcclxuICAgIFwibGFuZ1wiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlBhcmFtZXRlcml6ZWRQc2V1ZG9DbGFzcyxcclxuICAgIFwibm90XCI6IHBzZXVkb0NsYXNzV2l0aFNlbGVjdG9yc0luZm8sXHJcbiAgICBcIm50aENoaWxkXCI6IGFkZE50aFBzZXVkb0NsYXNzLFxyXG4gICAgXCJudGhMYXN0Q2hpbGRcIjogYWRkTnRoUHNldWRvQ2xhc3MsXHJcbiAgICBcIm50aE9mVHlwZVwiOiBhZGROdGhQc2V1ZG9DbGFzcyxcclxuICAgIFwibnRoTGFzdE9mVHlwZVwiOiBhZGROdGhQc2V1ZG9DbGFzcyxcclxuICAgIFwid2hlcmVcIjogcHNldWRvQ2xhc3NXaXRoU2VsZWN0b3JzSW5mbyxcclxuXHJcbiAgICAvLyBwYXJhbWV0ZXJpemVkIHBzZXVkbyBlbGVtZW50c1xyXG4gICAgXCJwYXJ0XCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuUGFyYW1ldGVyaXplZFBzZXVkb0VsZW1lbnQsXHJcbiAgICBcInNsb3R0ZWRcIjogeyBmOiB3cmFwQW5kQWRkU2VsZWN0b3JzLCBhOiBbXCIsXCJdLCBwOiBcIjo6XCIgfSxcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUHJveHkgaGFuZGxlciB0aGF0IHNlcnZlcyBhcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSVNlbGVjdG9yQnVpbGRlciBpbnRlcmZhY2UuXHJcbiAqL1xyXG5jbGFzcyBTZWxlY3RvckJ1aWxkZXJIYW5kbGVyIGltcGxlbWVudHMgUHJveHlIYW5kbGVyPElTZWxlY3RvckJ1aWxkZXI+XHJcbntcclxuICAgIGl0ZW1zOiBDc3NTZWxlY3RvcltdID0gW107XHJcblxyXG4gICAgLy8gYXJyYXkgb2Yga2V5cyB0aGF0IGFyZSBjb25zaWRlcmVkIFwib3duXCI6IHRoZXNlIGFyZSB0aGUga2V5cyBmcm9tIHRoZSBJU2VsZWN0b3JGdW5jIGludGVyZmFjZVxyXG4gICAgc3RhdGljIGtleXMgPSBbXCJmblwiLCBcIml0ZW1zXCJdO1xyXG5cclxuICAgIGdldCggdDogYW55LCBwcm9wTmFtZTogUHJvcGVydHlLZXksIHI6IGFueSk6IGFueVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcE5hbWUgIT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgbWFrZXMgb3VyIG9iamVjdCB0byBpbXBsZW1lbnQgdGhlIElTZWxlY3RvckZ1bmMgaW50ZXJmYWNlXHJcbiAgICAgICAgaWYgKHByb3BOYW1lID09PSBcImZuXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBcInNlbFwiO1xyXG4gICAgICAgIGVsc2UgaWYgKHByb3BOYW1lID09PSBcIml0ZW1zXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xyXG5cclxuICAgICAgICBsZXQgaW5mbyA9IHNlbGVjdG9ySW5mb3NbcHJvcE5hbWVdO1xyXG4gICAgICAgIGlmICghaW5mbylcclxuICAgICAgICAgICAgcmV0dXJuIHB1c2hTZWxlY3Rvci5jYWxsKCB0aGlzLCBwc2V1ZG9DYW1lbFRvZERhc2goIFwiOlwiLCBwcm9wTmFtZSkpO1xyXG4gICAgICAgIGVsc2UgaWYgKGluZm8gPT09IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuU2ltcGxlUHNldWRvRWxlbWVudClcclxuICAgICAgICAgICAgcmV0dXJuIHB1c2hTZWxlY3Rvci5jYWxsKCB0aGlzLCBwc2V1ZG9DYW1lbFRvZERhc2goIFwiOjpcIiwgcHJvcE5hbWUpKTtcclxuICAgICAgICBlbHNlIGlmIChpbmZvID09PSBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlBhcmFtZXRlcml6ZWRQc2V1ZG9DbGFzcylcclxuICAgICAgICAgICAgcmV0dXJuIGFkZFBhcmFtZXRlcml6ZWRQc2V1ZG9FbnRpdHkuYmluZCggdGhpcywgcHNldWRvQ2FtZWxUb2REYXNoKCBcIjpcIiwgcHJvcE5hbWUpKTtcclxuICAgICAgICBlbHNlIGlmIChpbmZvID09PSBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlBhcmFtZXRlcml6ZWRQc2V1ZG9FbGVtZW50KVxyXG4gICAgICAgICAgICByZXR1cm4gYWRkUGFyYW1ldGVyaXplZFBzZXVkb0VudGl0eS5iaW5kKCB0aGlzLCBwc2V1ZG9DYW1lbFRvZERhc2goIFwiOjpcIiwgcHJvcE5hbWUpKTtcclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5mbyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICByZXR1cm4gaW5mby5iaW5kKCB0aGlzLCBwcm9wTmFtZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJvcE5hbWUgPSBpbmZvLm4gPz8gKGluZm8ucCA/IHBzZXVkb0NhbWVsVG9kRGFzaCggaW5mby5wLCBwcm9wTmFtZSkgOiBwcm9wTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvLmYuYmluZCggdGhpcywgcHJvcE5hbWUsIC4uLmluZm8uYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG93bktleXMoIHQ6IGFueSk6IEFycmF5TGlrZTxzdHJpbmcgfCBzeW1ib2w+IHsgcmV0dXJuIFNlbGVjdG9yQnVpbGRlckhhbmRsZXIua2V5czsgfVxyXG4gICAgaGFzKCB0OiBhbnksIHA6IHN0cmluZyk6IGJvb2xlYW4geyByZXR1cm4gU2VsZWN0b3JCdWlsZGVySGFuZGxlci5rZXlzLmluY2x1ZGVzKHApOyB9XHJcblxyXG5cclxuXHJcbiAgICAvLyByZWZlcmVuY2UgdG8gdGhlIHByb3h5IG9iamVjdCB0aGF0IHRoaXMgaGFuZGxlciBzZXJ2ZXMuIFdlIG5lZWQgaXQgdG8gcmV0dXJuIGZyb21cclxuICAgIC8vIG91ciBmdW5jdGlvbnMgaW4gb3JkZXIgdG8gbWFrZSB0aGUgY2FsbCBjaGFpbmluZyB3b3JrLlxyXG4gICAgcHJveHk6IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciggaXRlbXM6IENzc1NlbGVjdG9yW10pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8vIGFkZHMgYW4gYXR0cmlidXRlIHNlbGVjdG9yXHJcbmZ1bmN0aW9uIGFkZEF0dHJTZWxlY3RvciggdGhpczogU2VsZWN0b3JCdWlsZGVySGFuZGxlciwgcHJvcE5hbWU6IHN0cmluZyxcclxuICAgIGF0dHJOYW1lOiBzdHJpbmcsIHAyPzogYW55LCBwMz86IGFueSwgcDQ/OiBhbnksIHA1PzogYW55KTogYW55XHJcbntcclxuICAgIHJldHVybiBwdXNoU2VsZWN0b3IuY2FsbCggdGhpcyxcclxuICAgICAgICBhdHRyQ29tcGFyaXNvbk9wZXJhdGlvbnMuaW5jbHVkZXMocDIpXHJcbiAgICAgICAgICAgID8ge2ZuOiBcImF0dHItc2VsXCIsIG5hbWU6IGF0dHJOYW1lLCB2YWw6IHAzLCBvcDogcDIsIGNmOiBwNCwgbnM6IHA1fVxyXG4gICAgICAgICAgICA6IHtmbjogXCJhdHRyLXNlbFwiLCBuYW1lOiBhdHRyTmFtZSwgdmFsOiBwMiwgY2Y6IHAzLCBuczogcDR9XHJcbiAgICApO1xyXG59XHJcblxyXG4vLyBQdXNoZXMgYSBzZWxlY3RvciBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcml6ZWQgcHNldWRvIGVudGl0eSB0byB0aGUgbGlzdCBvZiBpdGVtc1xyXG5mdW5jdGlvbiBhZGRQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5KCB0aGlzOiBTZWxlY3RvckJ1aWxkZXJIYW5kbGVyLCBlbnRpdHk6IHN0cmluZywgcGFyYW06IGFueSk6IGFueVxyXG57XHJcbiAgICByZXR1cm4gcHVzaFNlbGVjdG9yLmNhbGwoIHRoaXMsIHsgZm46IGVudGl0eSwgcDogcGFyYW0gfSk7XHJcbn1cclxuXHJcbi8vIEFkZHMgdGhlIGdpdmVuIHNlbGVjdG9ycyBpbnRlcm1pbmdsZWQgd2l0aCB0aGUgZ2l2ZW4gY29tYmluYXRvciB0byB0aGUgbGlzdCBvZiBpdGVtcy5cclxuZnVuY3Rpb24gYWRkU2VsZWN0b3JzV2l0aENvbWJpbmF0b3JzKCB0aGlzOiBTZWxlY3RvckJ1aWxkZXJIYW5kbGVyLCBlbnRpdHk6IHN0cmluZyxcclxuICAgIGNvbWJpbmF0b3I6IHN0cmluZywgLi4ubmV3SXRlbXM6IENzc1NlbGVjdG9yW10pOiBhbnlcclxue1xyXG4gICAgcmV0dXJuIHB1c2hTZWxlY3RvcnNXaXRoQ29tYmluYXRvcnMuY2FsbCggdGhpcywgY29tYmluYXRvciwgdHJ1ZSwgLi4ubmV3SXRlbXMpO1xyXG59XHJcblxyXG4vLyBXcmFwcyB0aGUgZ2l2ZW4gc2VsZWN0b3JzIHdpdGggdGhlIGludm9jYXRpb24gb2YgdGhlIGdpdmVuIHBzZXVkbyBlbnRpdHkgYW5kIHB1c2hlcyB0aGVtXHJcbi8vIHRvIHRoZSBsaXN0IG9mIGl0ZW1zXHJcbmZ1bmN0aW9uIHdyYXBBbmRBZGRTZWxlY3RvcnMoIHRoaXM6IFNlbGVjdG9yQnVpbGRlckhhbmRsZXIsIG5hbWU6IHN0cmluZywgY29tYmluYXRvcjogc3RyaW5nLCAuLi5uZXdJdGVtczogQ3NzU2VsZWN0b3JbXSk6IGFueVxyXG57XHJcbiAgICB0aGlzLml0ZW1zLnB1c2goIG5hbWUgKyBcIihcIik7XHJcbiAgICBwdXNoU2VsZWN0b3JzV2l0aENvbWJpbmF0b3JzLmNhbGwoIHRoaXMsIGNvbWJpbmF0b3IsIGZhbHNlLCAuLi5uZXdJdGVtcylcclxuICAgIHRoaXMuaXRlbXMucHVzaCggXCIpXCIpO1xyXG4gICAgcmV0dXJuIHRoaXMucHJveHk7XHJcbn1cclxuXHJcbi8vIFB1c2hlcyB0aGUgXCJudGhcIiBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycyB0byB0aGUgbGlzdCBvZiBpdGVtc1xyXG5mdW5jdGlvbiBhZGROdGhQc2V1ZG9DbGFzcyggdGhpczogU2VsZWN0b3JCdWlsZGVySGFuZGxlciwgcHJvcE5hbWU6IHN0cmluZywgcDE6IE50aEV4cHJlc3Npb24sIHAyPzogbnVtYmVyKTogYW55XHJcbntcclxuICAgIHJldHVybiBwdXNoU2VsZWN0b3IuY2FsbCggdGhpcywgeyBmbjogcHNldWRvQ2FtZWxUb2REYXNoKCBcIjpcIiwgcHJvcE5hbWUpLCBwOiBwMiAhPSBudWxsID8gW3AxIGFzIG51bWJlciwgcDJdIDogcDEgfSk7XHJcbn1cclxuXHJcbi8vIFB1c2hlcyB0aGUgZ2l2ZW4gc2VsZWN0b3JzIGludGVybWluZ2xlZCB3aXRoIHRoZSBnaXZlbiBjb21iaW5hdG9yIHRvIHRoZSBsaXN0IG9mIGl0ZW1zLiBUaGVcclxuLy8gXCJpbnNlcnRCZWZvcmVcIiBwYXJhbWV0ZXIgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbWJpbmF0b3Igc2hvdWxkIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgZmlyc3RcclxuLy8gc2VsZWN0b3IgaXRlbS5cclxuZnVuY3Rpb24gcHVzaFNlbGVjdG9yc1dpdGhDb21iaW5hdG9ycyggdGhpczogU2VsZWN0b3JCdWlsZGVySGFuZGxlciwgY29tYmluYXRvcjogc3RyaW5nLFxyXG4gICAgaW5zZXJ0QmVmb3JlOiBib29sZWFuLCAuLi5uZXdJdGVtczogQ3NzU2VsZWN0b3JbXSk6IGFueVxyXG57XHJcbiAgICBpZiAoaW5zZXJ0QmVmb3JlICYmIGNvbWJpbmF0b3IpXHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKCBjb21iaW5hdG9yKTtcclxuXHJcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IG5ld0l0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChpID4gMCAmJiBjb21iaW5hdG9yKVxyXG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goIGNvbWJpbmF0b3IpO1xyXG5cclxuICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3SXRlbXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnByb3h5O1xyXG59XHJcblxyXG4vLyBQdXNoZXMgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIHRoZSBsaXN0IG9mIGl0ZW1zXHJcbmZ1bmN0aW9uIHB1c2hTZWxlY3RvciggdGhpczogU2VsZWN0b3JCdWlsZGVySGFuZGxlciwgaXRlbTogQ3NzU2VsZWN0b3IpOiBhbnlcclxue1xyXG4gICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgcmV0dXJuIHRoaXMucHJveHk7XHJcbn1cclxuXHJcbi8vIGNvbWJpbmVzIHRoZSBnaXZlbiBwcmVmaXggd2l0aCB0aGUgcHNldWRvIGVudGl0eSBjYW1lbCBuYW1lIGNvbnZlcnRlZCB0byBkYXNoIGZvcm1cclxuY29uc3QgcHNldWRvQ2FtZWxUb2REYXNoID0gKHByZWZpeDogXCI6XCIgfCBcIjo6XCIsIG5hbWU6IHN0cmluZykgPT4gcHJlZml4ICsgY2FtZWxUb0Rhc2gobmFtZSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHNlbGVjdG9yIGJ1aWxkZXIgb2JqZWN0IHRoYXQgcHJvdmlkZXMgbWVhbnMgdG8gYnVpbGQgY29tcGxleCBzZWxlY3RvcnMgZnJvbSBtdWx0aXBsZVxyXG4gKiBzZWxlY3RvciBpdGVtcyBvZiBhbGwgcG9zc2libGUga2luZHMgaW5jbHVkaW5nIHRhZ3MsIGNsYXNzZXNzLCBJRHMsIGF0dHJpYnV0ZXMsIHBzZXVkbyBjbGFzc2VzXHJcbiAqIGFuZCBwc2V1ZG8gZWxlbWVudHMgY29tYmluZWQgd2l0aCBDU1MgY29tYmluYXRvcnMuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgW1tJU2VsZWN0b3JCdWlsZGVyXV1cclxuICogaW50ZXJmYWNlLCB3aGljaCBoYXMgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBmb3IgYWxsIHNlbGVjdG9yIGl0ZW1zLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgY2xzID0gdGhpcy4kY2xhc3Moey4uLn0pXHJcbiAqICAgICBteUlEID0gdGhpcy4kaWQoey4uLn0pXHJcbiAqXHJcbiAqICAgICAvLyBwcm9kdWNlcyBDU1M6IGxhYmVsLmNsczFbZm9yPVwibXlJRFwiXTpob3ZlciB7Li4ufVxyXG4gKiAgICAgczEgPSB0aGlzLiRzdHlsZSggY3NzLnNlbChcImxhYmVsXCIpLmFuZCh0aGlzLmNsczEpKS5hdHRyKFwiZm9yXCIsIHRoaXMubXlJRCkuaG92ZXIsIHsuLi59KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBAcGFyYW0gaXRlbXMgTGlzdCBvZiBzZWxlY3RvciBpdGVtcyB0byBpbml0aWFsaXplIHRoZSBjb21wbGV4IHNlbGVjdG9yLiBJZiBtdWx0aXBsZSBpdGVtcyBhcmVcclxuICogc3BlY2lmaWVkLCB0aGV5IGFyZSB0cmVhdGVkIGFzIGxpc3Q7IHRoYXQgaXMsIHRoZXkgYXJlIGNvbWJpbmVkIHdpdGggdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBjb25zdCBzZWwgPSAoLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiBJU2VsZWN0b3JCdWlsZGVyID0+XHJcbntcclxuICAgIGxldCBoYW5kbGVyID0gbmV3IFNlbGVjdG9yQnVpbGRlckhhbmRsZXIoaXRlbXMpO1xyXG4gICAgbGV0IHByb3h5ID0gbmV3IFByb3h5KCB7fSwgaGFuZGxlcik7XHJcblxyXG4gICAgLy8gdGhlIGhhbmRsZXIgc2hvdWxkIHJlZmVyZW5jZSB0aGUgcHJveHkgaW4gb3JkZXIgdG8gcmV0dXJuIGl0IGZyb20gbWV0aG9kcyAoYW5kIHByb3BlcnRpZXMpXHJcbiAgICAvLyB0byBhbGxvdyBjaGFpbiBjYWxscy5cclxuICAgIGhhbmRsZXIucHJveHkgPSBwcm94eTtcclxuICAgIHJldHVybiBwcm94eSBhcyBJU2VsZWN0b3JCdWlsZGVyO1xyXG59XHJcblxyXG5mZG9bXCJzZWxcIl0gPSB2ID0+IGEycyggdi5pdGVtcywgeyBzZXA6IFwiXCIsIHJlY3Vyc2l2ZTogdHJ1ZSB9LCBcIlwiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgc2VsZWN0b3IgZm9yIHRoZSBnaXZlbiBlbGVtZW50IHRhZ3Mgd2l0aCB0aGUgZ2l2ZW4gbmFtZXNwYWNlIHByZWZpeC4gVGhlXHJcbiAqIGBuc2AgcGFyYW1ldGVyIHNwZWNpZmllcyB0aGUgbmFtZXNwYWNlIHByZWZpeCBhcyBlaXRoZXIgYSBzdHJpbmcgb3IgYSByZWZlcmVuY2UgdG8gdGhlXHJcbiAqIG5hbWVzcGFjZSBydWxlLiBUaGUgYHRhZ3NgIHBhcmFtZXRlciBzcGVjaWZpZXMgZWl0aGVyIGEgc2luZ2xlIHRhZyBvciBhbiBhcnJheSBvZiB0YWdzLiBJblxyXG4gKiBhZGRpdGlvbiwgYW4gYXN0ZXJpc2sgc3ltYm9sIChgXCIqXCJgKSBjYW4gYmUgc3BlY2lmaWVkIHRvIHRhcmdldCBhbGwgZWxlbWVudHMuXHJcbiAqXHJcbiAqIFdoZW4gbXVsdGlwbGUgdGFncyBhcmUgc3BlY2lmaWVkLCB0aGV5IHdpbGwgYmUgY29tYmllZCB1c2luZyB0aGUgc2VsZWN0b3IgY29tYmluYXRvcnNcclxuICogc3BlY2lmaWVkIGJ5IHRoZSBgY29tYmAgcGFyYW1ldGVyLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGVzOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGRlZmluZSBIVE1MIGFzIGRlZmF1bHQgbmFtZXNwYWNlIGFuZCBcInN2Z1wiIGFzIGEgcHJlZml4IGZvciBTVkcgbmFtZXNwYWNlXHJcbiAqICAgICBodG1sTlMgPSB0aGlzLiRuYW1lc3BhY2UoIGNzcy5XZWJOYW1lc3BhY2VzLkhUTUwpXHJcbiAqICAgICBzdmdOUyA9IHRoaXMuJG5hbWVzcGFjZSggY3NzLldlYk5hbWVzcGFjZXMuU1ZHLCBcInN2Z1wiKVxyXG4gKlxyXG4gKiAgICAgLy8gcHJvZHVjZXMgQ1NTIFwic3ZnfGEge31cIiwgd2hpY2ggd2lsbCBtYXRjaCBvbmx5IFNWRyBgPGE+YCBlbGVtZW50c1xyXG4gKiAgICAgcnVsZTEgPSB0aGlzLiRzdHlsZSggY3NzLm5zdGFnKCB0aGlzLnN2Z05TLCBcImFcIiksIHt9KVxyXG4gKlxyXG4gKiAgICAgLy8gcHJvZHVjZXMgQ1NTIFwiKnxhIHt9XCIsIHdoaWNoIHdpbGwgbWF0Y2ggYm90aCBIVE1MIGFuZCBTVkcgYDxhPmAgZWxlbWVudHNcclxuICogICAgIHJ1bGUyID0gdGhpcy4kc3R5bGUoIGNzcy5uc3RhZyggXCIqXCIsIFwiYVwiKSwge30pXHJcbiAqXHJcbiAqICAgICAvLyBwcm9kdWNlcyBDU1MgXCJzdmd8Y2lyY2xlLCBzdmd8ZWxsaXBzZSB7fVwiXHJcbiAqICAgICBydWxlMyA9IHRoaXMuJHN0eWxlKCBjc3MubnN0YWcoIHRoaXMuc3ZnTlMsIFtcImNpcmNsZVwiLCBcImVsbGlwc2VcIl0pLCB7fSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIG5zIE5hbWVzcGFjZSBwcmVmaXggc3RyaW5nIG9yIHJlZmVyZW5jZSB0byBhIG5hbWVzcGFjZSBydWxlLiBUaGlzIGNhbiBhbHNvIGJlIGBcIipcImAsXHJcbiAqIGluIHdoaWNoIGNhc2UgdGFncyBvZiBhbGwgbmFlc3BhY2VzIGFyZSBzZWxlY3RlZFxyXG4gKiBAcGFyYW0gdGFncyBPbmUgb3IgbW9yZSBlbGVtZW50IHRhZyBuYW1lcy5cclxuICogQHBhcmFtIGNvbWIgT3B0aW9uYWwgc2VsZWN0b3IgY29tYmluYXRvciBpZiBtb3JlIHRoYW4gb25lIHRhZyBpcyBnaXZlbi4gRGVmYXVsdCBpcyBgXCIsXCJgLlxyXG4gKiBAcmV0dXJucyBPYmplY3QgcmVwcmVzZW50aW5nIHBhcmFtZXRlcnMgZnJvbSB3aGljaCBuYW1lc3BhY2VkIHRhZyBzZWxlY3RvciBpcyBjcmVhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG5zdGFnID0gKG5zOiBzdHJpbmcgfCBJTmFtZXNwYWNlUnVsZSwgdGFnczogXCIqXCIgfCBFbGVtZW50VGFnTmFtZSB8IEVsZW1lbnRUYWdOYW1lW10sXHJcbiAgICBjb21iOiBTZWxlY3RvckNvbWJpbmF0b3IgPSBcIixcIik6IElOU1RhZ0Z1bmMgPT4gKHtmbjogXCJuc3RhZ1wiLCBucywgdGFncywgY29tYn0pXHJcblxyXG5mZG9bXCJuc3RhZ1wiXSA9ICh2OiBJTlNUYWdGdW5jKSA9PiB7XHJcbiAgICBsZXQgcHJlZml4ID0gdHlwZW9mIHYubnMgPT09IFwic3RyaW5nXCIgPyB2Lm5zICsgXCJ8XCIgOiB2Lm5zLnByZWZpeCA/IHYubnMucHJlZml4ICsgXCJ8XCIgOiBcIlwiO1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2LnRhZ3MgPT09IFwic3RyaW5nXCIgPyBwcmVmaXggKyB2LnRhZ3MgOiB2LnRhZ3MubWFwKCB0YWcgPT4gcHJlZml4ICsgdGFnKS5qb2luKHYuY29tYik7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEFuaW1hdGlvbiBhbmQgdHJhbnNpdGlvbiB0aW1pbmcgZnVuY3Rpb25zLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIGFuIGludm9jYXRpb24gb2YgdGhlIENTUyBgc3RlcHMoKWAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2l0aW9uIGFuZCBBbmltYXRpb25cclxuICovXHJcbiBleHBvcnQgY29uc3Qgc3RlcHMgPSAobjogRXh0ZW5kZWQ8bnVtYmVyPiwgaj86IFRpbWluZ0Z1bmN0aW9uSnVtcFRlcm0pOiBJU3RlcHNGdW5jID0+XHJcbiAoeyBmbjogXCJzdGVwc1wiLCBuLCBqIH0pO1xyXG5cclxuZmRvLnN0ZXBzID0gW1wiblwiLCBcImpcIl1cclxuXHJcblxyXG5cclxuLyoqXHJcbiogUmV0dXJucyBhIGZ1bmN0aW9uIHJlcHJlc2VudGluZyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBDU1MgYGN1YmljLWJlemllcigpYCBmdW5jdGlvbi5cclxuKlxyXG4qIEBjYXRlZ29yeSBUcmFuc2l0aW9uIGFuZCBBbmltYXRpb25cclxuKi9cclxuZXhwb3J0IGNvbnN0IGN1YmljQmV6aWVyID0gKG4xOiBFeHRlbmRlZDxudW1iZXI+LCBuMjogRXh0ZW5kZWQ8bnVtYmVyPiwgbjM6IEV4dGVuZGVkPG51bWJlcj4sXHJcbiBuNDogRXh0ZW5kZWQ8bnVtYmVyPik6IElDdWJpY0JlemllckZ1bmMgPT4gKHsgZm46IFwiY3ViaWMtYmV6aWVyXCIsIG4xLCBuMiwgbjMsIG40IH0pO1xyXG5cclxuZmRvW1wiY3ViaWMtYmV6aWVyXCJdID0gW1wibjFcIiwgXCJuMlwiLCBcIm4zXCIsIFwibjRcIl1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEBtZWRpYSBhbmQgQHN1cHBvcnRzIHF1ZXJpZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFRhZyBmdW5jdGlvbiB0aGF0IHJlcHJlc2VudHMgYSBtZWRpYSBxdWVyeS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgZXhwcmVzc2luZyBtZWRpYSBxdWVyaWVzIGluXHJcbiAqIGEgbmF0dXJhbCBzdHJpbmcgZm9ybSB3aGlsZSBlbWJlZGRpbmcgbWVkaWEgZmVhdHVyZSB2YWx1ZXMgaW4gdHlwZSBzYWZlIG1hbm5lci4gVGhlIHN0cmluZyBjYW5cclxuICogY29udGFpbiBhbnkgbWVkaWEgZXhwcmVzc2lvbnMgd2hpbGUgdGhlIGVtYmVkZGVkIG9iamVjdHMgbXVzdCBiZSBvZiB0eXBlIFtbSU1lZGlhRmVhdHVyZXNldF1dLlxyXG4gKiBNdWx0aXBsZSBmZWF0dXJlcyBpbiB0aGUgZmVhdHVyZSBzZXQgd2lsbCBiZSBleHBhbmRlZCBpbnRvIGNsYXVzZXMgY29tYmluZWQgd2l0aCB0aGUgXCJhbmRcIlxyXG4gKiBvcGVyYXRvci5cclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBTdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MDBweCkgYW5kIChtYXgtd2lkdGg6IDYwMHB4KSBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcclxuICogICAgIGlmTmFycm93RGV2aWNlID0gdGhpcy4kbWVkaWEoXHJcbiAqICAgICAgICAgY3NzLm1lZGlhYHNjcmVlbiBhbmQgJHt7d2lkdGg6WzQwMCw2MDBdLCBvcmllbnRhdGlvbjogXCJwb3J0cmFpdFwifX1gLCAuLi4pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWVkaWEgPSAocGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5wYXJhbXM6IEV4dGVuZGVkTWVkaWFGZWF0dXJlc2V0W10pOiBJTWVkaWFRdWVyeVByb3h5ID0+XHJcbiAgICAoKSA9PiB0YWcycyggcGFydHMsIHBhcmFtcywgdiA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYgOiBtZWRpYTJzKHYpKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRhZyBmdW5jdGlvbiB0aGF0IHJlcHJlc2VudHMgYSBzdXBwb3J0cyBxdWVyeS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgZXhwcmVzc2luZyBzdXBwb3J0c1xyXG4gKiBxdWVyaWVzIGluIGEgbmF0dXJhbCBzdHJpbmcgZm9ybSB3aGlsZSBlbWJlZGRpbmcgbWVkaWEgZmVhdHVyZSB2YWx1ZXMgaW4gdHlwZSBzYWZlIG1hbm5lci4gVGhlXHJcbiAqIHN0cmluZyBjYW4gY29udGFpbiBhbnkgc3VwcG9ydHMgZXhwcmVzc2lvbnMgd2hpbGUgdGhlIGVtYmVkZGVkIG9iamVjdHMgbXVzdCBiZSBvZiB0eXBlXHJcbiAqIFN0eWxlc2V0LiBNdWx0aXBsZSBwcm9wZXJ0aWVzIGluIHRoZSBzdHlsZXNldCB3aWxsIGJlIGV4cGFuZGVkIGludG8gY2xhdXNlcyBjb21iaW5lZCB3aXRoIHRoZVxyXG4gKiBcIm9yXCIgb3BlcmF0b3IuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIG5vdCAodHJhbnNmb3JtLW9yaWdpbjogMzBweCAzMHB4IDMwcHgpXHJcbiAqICAgICBpZk5vVHJhbnNmb3JtT3JpZ2luID0gdGhpcy4kc3VwcG9ydHMoXHJcbiAqICAgICAgICAgY3NzLnN1cHBvcnRzYG5vdCAoJHt7dHJhbnNmb3JtLW9yaWdpbjogWzMwLCAzMCwgMzBdfX0pYCwgLi4uKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN1cHBvcnRzID0gKHBhcnRzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4ucGFyYW1zOiBTdHlsZXNldFtdKTogSVN1cHBvcnRzUXVlcnlQcm94eSA9PlxyXG4gICAgKCkgPT4gdGFnMnMoIHBhcnRzLCBwYXJhbXMsIHYgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyB2IDogc3VwcG9ydHMycyh2KSk7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUaGUgYHJhd2AgZnVuY3Rpb24gYWxsb3dzIHNwZWNpZnlpbmcgYXJiaXRyYXJ5IHRleHQgZm9yIHByb3BlcnRpZXMgd2hvc2UgdHlwZSBub3JtYWxseSBkb2Vzbid0XHJcbiAqIGFsbG93IHN0cmluZ3MuVGhpcyBmdW5jdGlvbiBpcyBhIHRhZyBmdW5jdGlvbiBhbmQgbXVzdCBiZSBpbnZva2VkIHdpdGggdGhlIHRlbXBsYXRlIHN0cmluZ1xyXG4gKiB3aXRob3V0IHBhcmVudGhlc2VzLiBUaGUgYHJhd2AgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yIGFueSBzdHlsZSBwcm9wZXJ0eS4gTm90ZSwgaG93ZXZlciwgdGhhdFxyXG4gKiBubyB2YWxpZGF0aW9uIGNoZWNrcyBhcmUgcGVyZm9ybWVkIG9uIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHN0cmluZy4gSWYgdGhlIHN0cmluZyBpc24ndCB2YWxpZFxyXG4gKiBmb3IgdGhlIHN0eWxlIHByb3BlcnR5LCB0aGUgcHJvcGVydHkgd2lsbCBub3QgYmVjb21lIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUgaW5zZXJ0ZWQgaW50byB0aGVcclxuICogRE9NLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgcG9seSA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICBjbGlwUGF0aDogY3NzLnJhd2Bwb2x5Z29uKDUwJSAyMCUsIDkwJSA4MCUsIDEwJSA4MCUpYFxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjb25zdCByYXcgPSAocGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5wYXJhbXM6IGFueVtdKTogSVJhd1Byb3h5ID0+XHJcbiAgICAoKSA9PiB0YWcycyggcGFydHMsIHBhcmFtcyk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBDU1MgYHVybCgpYCBmdW5jdGlvbi4gVGhlIHN0cmluZyBwYXJhbWV0ZXJcclxuICogd2lsbCBiZSB3cmFwcGVkIGluIGEgYHVybCgpYCBpbnZvY2F0aW9uLiBUaGUgZnVuY3Rpb24gY2FuIGFsc28gYWNjZXB0IHRoZSBJSURSdWxlIG9iamVjdCB0b1xyXG4gKiBjcmVhdGUgdXJsKCNlbGVtZW50KSBpbnZvY2F0aW9uLCB3aGljaCBpcyBvZnRlbiB1c2VkIHRvIGFkZHJlc3MgU1ZHIGVsZW1lbnRzIGJ5IHRoZWlyIElEcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCB1cmwgPSAocDogRXh0ZW5kZWQ8c3RyaW5nIHwgSUlEUnVsZT4pOiBJVXJsRnVuYyA9PiAoeyBmbjogXCJ1cmxcIiwgcCB9KTtcclxuXHJcbmZkby51cmwgPSBbIFtcInBcIiwge3N0cjogV0tGLlF1b3RlZH0gXV1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIENTUyBgdXJsKClgIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGN1cnNvciggcDogRXh0ZW5kZWQ8c3RyaW5nIHwgSUlEUnVsZT4pOiBJQ3Vyc29yRnVuYztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBDU1MgYHVybCgpYCBmdW5jdGlvbiBmb2xsb3dlZCBieSB0d28gbnVtYmVyc1xyXG4gKiBpbmRpY2F0aW5nIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjdXJzb3IoIHA6IEV4dGVuZGVkPHN0cmluZyB8IElJRFJ1bGU+LCB4OiBudW1iZXIsIHk6IG51bWJlcik6IElDdXJzb3JGdW5jO1xyXG5cclxuLy8gSW1wbGVtZW50YXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGN1cnNvciggdXJsOiBFeHRlbmRlZDxzdHJpbmcgfCBJSURSdWxlPiwgeD86IG51bWJlciwgeT86IG51bWJlcik6IElDdXJzb3JGdW5jXHJcbntcclxuICAgIHJldHVybiB7IGZuOiBcImN1cnNvclwiLCB1cmwsIHgsIHkgfTtcclxufVxyXG5cclxuZmRvLmN1cnNvciA9ICh2OiBJQ3Vyc29yRnVuYykgPT4gbXYycyggW3VybCh2LnVybCksIHYueCwgdi55XSlcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBhdHRyKClgIENTUyBmdW5jdGlvbi4gSXQgcmV0dXJucyBbW0lTdHJpbmdQcm94eV1dIGFuZFxyXG4gKiB0aGVvcmV0aWNhbGx5IGNhbiBiZSB1c2VkIGluIGFueSBzdHlsZSBwcm9wZXJ0eSB3aGVyZXZlciB0aGUgQ1NTIGA8c3RyaW5nPmAgdHlwZSBpcyBhY2NlcHRlZDtcclxuICogaG93ZXZlciwgaXRzIHVzZSBieSBicm93c2VycyBpcyBjdXJyZW50bHkgbGltaXRlZCB0byB0aGUgYGNvbnRlbnRgIHByb3BlcnR5LiBBbHNvIG5vdCBhbGxcclxuICogYnJvd3NlcnMgY3VycmVudGx5IHN1cHBvcnQgdHlwZSwgdW5pdHMgb3IgZmFsbGJhY2sgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXR0ck5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZC5cclxuICogQHBhcmFtIHR5cGVPclVuaXQgT3B0aW9uYWwgdHlwZSBvciB1bml0IGtleXdvcmQgdGhhdCBkZXRlcm1pbmVzIHRoZSByZXR1cm5lZCBDU1MgdHlwZS5cclxuICogQHBhcmFtIGZhbGxiYWNrIE9wdGlvbmFsIHZhbHVlIHRoYXQgaXMgdXNlZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBmb3VuZCBvbiB0aGUgZWxlbWVudC5cclxuICogQHJldHVybnNcclxuICovXHJcbiBleHBvcnQgY29uc3QgYXR0ciA9IChhdHRyTmFtZTogRXh0ZW5kZWQ8c3RyaW5nPiwgdHlwZU9yVW5pdD86IEV4dGVuZGVkPEF0dHJUeXBlS2V5d29yZCB8IEF0dHJVbml0S2V5d29yZD4sXHJcblx0ZmFsbGJhY2s/OiBFeHRlbmRlZDxzdHJpbmc+KTogSVN0cmluZ1Byb3h5ID0+XHJcbiAgICAoKSA9PiBgYXR0cigke212MnMoIFttdjJzKCBbYXR0ck5hbWUsIHR5cGVPclVuaXRdKSwgZmFsbGJhY2tdLCBcIixcIil9KWA7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIENTUyBgY291bnRlcigpYCBmdW5jdGlvbiB3aXRoIGFuIG9wdGlvbmFsIGNvdW50ZXIgc3R5bGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjIENvdW50ZXIgbmFtZSBvciBjb3VudGVyIHJ1bGUgb2JqZWN0XHJcbiAqIEByZXR1cm5zIElDb3VudGVyRnVuYyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgY291bnRlcigpYCBDU1MgZnVuY3Rpb25cclxuICovXHJcbiBleHBvcnQgY29uc3QgY291bnRlciA9IChjb3VudGVyT2JqOiBFeHRlbmRlZDxJQ291bnRlclJ1bGUgfCBzdHJpbmc+LFxyXG5cdHN0eWxlPzogRXh0ZW5kZWQ8TGlzdFN0eWxlVHlwZV9TdHlsZVR5cGU+KTogSVN0cmluZ1Byb3h5ID0+XHJcbiAgICAoKSA9PiBmMnMoIFwiY291bnRlclwiLCBbY291bnRlck9iaiwgc3R5bGVdKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ1NTIGBjb3VudGVycygpYCBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBzZXBhcmF0b3IgYW5kXHJcbiAqIGFuIG9wdGlvbmFsIGNvdW50ZXIgc3R5bGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb3VudGVyT2JqIENvdW50ZXIgbmFtZSBvciBjb3VudGVyIHJ1bGUgb2JqZWN0XHJcbiAqIEBwYXJhbSBzZXAgU2VwYXJhdG9yIHN0cmluZyBiZXR3ZWVuIG11bHRpcGxlIGNvdW50ZXJzXHJcbiAqIEBwYXJhbSBzdHlsZSBDb3VudGVyIHN0eWxlXHJcbiAqIEByZXR1cm5zIElDb3VudGVyRnVuYyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgY291bnRlcigpYCBDU1MgZnVuY3Rpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBjb3VudGVycyA9IChjb3VudGVyT2JqOiBFeHRlbmRlZDxJQ291bnRlclJ1bGUgfCBzdHJpbmc+LFxyXG5cdHNlcDogRXh0ZW5kZWQ8c3RyaW5nPiwgc3R5bGU/OiBFeHRlbmRlZDxMaXN0U3R5bGVUeXBlX1N0eWxlVHlwZT4pOiBJU3RyaW5nUHJveHkgPT5cclxuICAgICgpID0+IGYycyggXCJjb3VudGVyc1wiLCBbY291bnRlck9iaiwgW3NlcCwgV0tGLlF1b3RlZF0sIHN0eWxlXSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgdmFyKClgIENTUyBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIGN1c3RvbVxyXG4gKiBDU1MgcHJvcGVydHkgd2l0aCBvcHRpb25hbCBmYWxsYmFja3MuIFVzdWFsbHksIHdoZW4geW91IHdhbnQgdG8gcmVmZXIgdG8gYSBjdXN0b20gQ1NTIHByb3BlcnR5XHJcbiAqIGluIHN0eWxlIHJ1bGVzLCBpdCBpcyBlbm91Z2ggdG8ganVzdCByZWZlciB0byB0aGUgc3R5bGUgZGVmaW5pdGlvbiBwcm9wZXJ0eSBjcmVhdGVkIHVzaW5nIHRoZVxyXG4gKiBbWyR2YXJdXSBmdW5jdGlvbjsgaG93ZXZlciwgaWYgeW91IHdhbnQgdG8gcHJvdmlkZSBhIGZhbGxiYWNrIHZhbHVlLCB5b3UgbXVzdCB1c2UgdGhpcyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBTdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gY3JlYXRlIGN1c3RvbSBDU1MgcHJvcGVydHkgYnV0IHdpdGhvdXQgYW4gYXNzaWduZWQgdmFsdWU7IGl0IGNhbiBiZSBhc3NpZ25lZFxyXG4gKiAgICAgLy8gbGF0ZXIgcHJvZ3JhbW1hdGljYWxseVxyXG4gKiAgICAgYmdDb2xvciA9IHRoaXMuJHZhciggXCJjb2xvclwiKVxyXG4gKlxyXG4gKiAgICAgZGl2ID0gdGhpcy4kdGFnKCBcImRpdlwiLCB7XHJcbiAqICAgICAgICAgLy8gdXNlIHRoZSBjdXN0b20gQ1NTIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGZhbGxiYWNrIHZhbHVlXHJcbiAqICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjc3MudXNldmFyKCB0aGlzLmJnQ29sb3IsIFwiYmVpZ2VcIilcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gSyBLZXkgb2YgdGhlIFtbSVZhclRlbXBsYXRlU3R5bGVzZXRdXSBpbnRlcmZhY2UgdGhhdCBkZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRoZVxyXG4gKiBjdXN0b20gQ1NTIHByb3BlcnR5IGFuZCBvZiB0aGUgZmFsbGJhY2sgdmFsdWUuXHJcbiAqIEBwYXJhbSB2YXJPYmogQ3VzdG9tIENTUyBwcm9wZXJ0eSBvYmplY3QgY3JlYXRlZCB1c2luZyB0aGUgW1skdmFyXV0gZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCBpZiB0aGUgY3VzdG9tIENTUyBwcm9wZXJ0eSBpc250IHNldC5cclxuICogQHJldHVybnMgVGhlIGBJUmF3UHJveHlgIGNhbGxhYmxlIGludGVyZmFjZSwgd2hjaWggYWxsb3dzIHRoZSBgdXNldmFyYCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICogaW4gYW55IGNvbnRleHQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXNldmFyID0gPEsgZXh0ZW5kcyBWYXJUZW1wbGF0ZU5hbWU+KCB2YXJPYmo6IElWYXJSdWxlPEs+LCBmYWxsYmFjaz86IEV4dGVuZGVkVmFyVmFsdWU8Sz4pOiBJUmF3UHJveHkgPT5cclxuICAgICgpID0+IGYycyggXCJ2YXJcIiwgW3Zhck9iai5jc3NOYW1lLCBzcDJzKCB2YXJPYmoudGVtcGxhdGUsIGZhbGxiYWNrKV0pO1xyXG5cclxuXHJcblxyXG4iLCLvu78vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQmFzaWMgdHlwZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuaW1wb3J0IHtJSURSdWxlLCBJTmFtZXNwYWNlUnVsZX0gZnJvbSBcIi4vUnVsZVR5cGVzXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTdHlsZSB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYW55IENTUyBwcm9wZXJ0eS5cclxuICovXHJcbmV4cG9ydCB0eXBlIEdsb2JhbF9TdHlsZVR5cGUgPSBcImluaGVyaXRcIiB8IFwiaW5pdGlhbFwiIHwgXCJ1bnNldFwiIHwgXCJyZXZlcnRcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJR2VuZXJpY1Byb3h5IGludGVyZmFjZSByZXByZXNlbnRzIGEgY2FsbGFibGUgaW50ZXJmYWNlIGltcGxlbWVudGVkIGJ5IGZ1bmN0aW9ucyB0aGF0XHJcbiAqIGFjY2VwdCBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgb2YgYSBnZW5lcmljIHR5cGUgYW5kIHJldHVybiBhIHN0cmluZy4gVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCBhcyBhXHJcbiAqIGJhc2UgZm9yIHByb3h5IGludGVyZmFjZXMgZGVmaW5pbmcgdHlwZXMgYWNjZXB0YWJsZSBieSBjZXJ0YWluIHN0eWxlIHByb3BlcnRpZXMuIFRoZSB0eXBlXHJcbiAqIHBhcmFtZXRlciBoZWxwcyBkaWZmZXJlbnRpYXRlIHRoZXNlIGludGVyZmFjZXMgc28gdGhhdCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gb25lXHJcbiAqIHR5cGUgb2Ygc3R5bGUgcHJvcGVydGllcyAoZS5nLiBgdHJhbnNmb3JtYCkgY2Fubm90IGJlIGFzc2lnbmVkIHRvIGFuIGluY29tcGF0aWJsZSBzdHlsZSBwcm9wZXJ0eVxyXG4gKiAoZS5nLiBgZmlsdGVyYCkuXHJcbiAqXHJcbiAqIERldmVsb3BlcnMgZG9uJ3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlIGRpcmVjdGx5OyBpbnN0ZWFkLCB0aGUgaW50ZXJmYWNlcyBkZXJpdmVkIGZyb20gdGhpc1xyXG4gKiBpbnRlcmZhY2UgYXJlIGltcGxlbWVudGVkIGJ5IGRpZmZlcmVudCBNaW1jc3MgZnVuY3Rpb25zLiBGb3IgZXhhbXBsZSwgW1tJUmF3UHJveHldXSBpbnRlcmZhY2VcclxuICogaXMgaW1wbGVtZW50ZWQgYnkgdGhlIFtbcmF3XV0gZnVuY3Rpb24sIFtbSVN0cmluZ1Byb3h5XV0gaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHRoZVxyXG4gKiBbW2F0dHJdXSwgW1tjb3VudGVyXV0gYW5kIFtbY291bnRlcnNdXSBmdW5jdGlvbnMsIGFuZCBzbyBvbi5cclxuICpcclxuICogQHR5cGVQYXJhbSBUIFN0cmluZyBjb25zdGFudCB0aGF0IGlzIHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHByb3hpZXMgdXNlZCBmb3IgZGlmZmVyZW50XHJcbiAqIHB1cnBvc2VzLiBUaGUgcGFyYW1ldGVyIGBwYCBvZiB0aGlzIGNhbGxhYmxlIGludGVyZmFjZSBpcyBvZiB0eXBlIFQgYnV0IGl0IGlzIG5vdCB1c2VkXHJcbiAqIGluIGFueSB3YXkuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHZW5lcmljUHJveHk8VCBleHRlbmRzIHN0cmluZyA9IGFueT5cclxue1xyXG4gICAgKHA/OiBUKTogc3RyaW5nO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgSUNzc0Z1bmNPYmplY3QgaW50ZXJmYWNlIGlzIGEgYmFzZSBmb3IgYWxsIGludGVyZmFjZXMgcmVwcmVzZW50aW5nIG9iamVjdHMgdGhhdCBkZXNjcmliZVxyXG4gKiBjYWxscyB0byBhIENTUyBmdW5jdGlvbi4gRXZlcnkgc3VjaCBpbnRlcmZhY2UgZ2l2ZXMgYSB1bmlxdWUgdmFsdWUgKG9yIGEgdW5pcXVlIHNldCBvZiB2YWx1ZXMpXHJcbiAqIHRvIHRoZSBgZm5gIG1lbWJlci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNzc0Z1bmNPYmplY3Rcclxue1xyXG4gICAgZm46IHN0cmluZztcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBJUmF3UHJveHlgIGludGVyZmFjZSByZXByZXNlbnRzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nLCB3aGljaCBpcyByZWFkeSB0byBiZVxyXG4gKiB1c2VkIGluIENTUyBydWxlcy4gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHR5cGUgZGVmaW5pdGlvbiBmb3IgYWxsIENTUyBwcm9wZXJ0aWVzIC0gZXZlbiBmb3JcclxuICogdGhvc2UgdGhhdCBkb24ndCBoYXZlIGBzdHJpbmdgIGFzIHBhcnQgb2YgdGhlaXIgdHlwZS5cclxuICpcclxuICogQWxsIENTUyBwcm9wZXJ0aWVzIHNob3VsZCBhY2NlcHQgc3RyaW5nIGFzIHRoZSB0eXBlIG9mIHRoZWlyIHZhbHVlIGV2ZW4gaWYgbm9ybWFsbHlcclxuICogdGhleSBhY2NlcHQgb3RoZXIgdHlwZXMgKGUuZyBhIHNldCBvZiBzdHJpbmcgbGl0ZXJhbHMgYXMgYFwicmVkXCIgfCBcImdyZWVuXCIgfCAuLi5gIGZvciB0aGVcclxuICogY29sb3IpIHByb3BlcnR5LiBUaGlzIGlzIGJlY2F1c2UgaW4gYWRkaXRpb24gdG8gdGhlaXIgbm9ybWFsIHZhbHVlcyBhbnkgcHJvcGVydHlcclxuICogY2FuIHVzZSBjdXN0b20gQ1NTIHByb3BlcnR5IGluIHRoZSBmb3JtIGB2YXIoLS1wcm9wbmFtZSlgLiBIb3dldmVyLCBpZiB3ZSBhZGQgc3RyaW5nIHR5cGVcclxuICogdG8gdGhlIHNldCBvZiBzdHJpbmcgbGl0ZXJhbHMgKGUuZy4gYFwicmVkXCIgfCBcImdyZWVuXCIgfCBzdHJpbmdgKSwgdGhpcyB0aHJvd3Mgb2ZmIHRoZVxyXG4gKiBJbnRlbGxpc2Vuc2UgYW5kIGl0IGRvZXNuJ3QgcHJvbXB0IGRldmVsb3BlcnMgZm9yIHRoZSBwb3NzaWJsZSB2YWx1ZXMuIFRoZSBgSVJhd1Byb3h5YFxyXG4gKiBpbnRlcmZhY2UgaXMgdXNlZCBpbnN0ZWFkIG9mIHN0cmluZyBhbmQgdGhpcyBzb2x2ZXMgdGhlIEludGVsbGlzZW5zZSBpc3N1ZS5cclxuICpcclxuICogSW4gYWRkaXRpb24sIHNvbWV0aW1lcyBpdCBjYW4gYmUgZWFzaWVyIGZvciB0aGUgZGV2ZWxvcGVycyB0byBzcGVjaWZ5IGFuIGFscmVhZHkgcHJlLWZvcm1hdHRlZFxyXG4gKiBDU1Mgc3RyaW5nIGFzIHByb3BlcnR5IHZhbHVlIC0gbWF5YmUgYmVjYXVzZSBpdCBpcyBvYnRhaW5lZCBmcm9tIHNvbWUgZXh0ZXJuYWwgc291cmNlLiBUaGVcclxuICogYElSYXdQcm94eWAgY2FsbGFiY2xlIGludGVyZmFjZSBpcyByZXR1cm5lZCBmcm9tIHRoZSBbW3Jhd11dIGZ1bmN0aW9uLCB3aGljaCBhbGxvd3MgYnktcGFzc2luZ1xyXG4gKiB0aGUgcHJvcGVydHkgdHlwaW5nIHJ1bGVzIGFuZCBzcGVjaWZ5aW5nIGEgc3RyaW5nIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBEZXZlbG9wZXJzIGNhbiBjcmVhdGUgdGhlaXIgb3duIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGlzIGNhbGxhYmxlIGludGVyZmFjZSBhbmQgdGhlbiBpbnZva2VcclxuICogdGhlc2UgZnVuY3Rpb25zIHRvIGFzc2lnbiB2YWx1ZXMgdG8gc3R5bGUgcHJvcGVydGllcy4gSnVzdCBtYWtlIHN1cmUgdGhhdCB0aGUgcmV0dXJuZWQgc3RyaW5nXHJcbiAqIGlzIHRoZSBjb3JyZWN0IENTUyBzdHJpbmcuIE1pbWNzcyB3aWxsIHVzZSB0aGUgc3RyaW5nIHJldHVybmVkIGZyb20gY3VzdG9tIGZ1bmN0aW9ucyB3aXRob3V0XHJcbiAqIGNoZWNraW5nIGl0cyBjb3JyZWN0bmVzcy4gSWYgdGhlIHN0cmluZyBpcyBpbnZhbGlkIGZvciB0aGUgcHJvcGVydHkgaXQgaXMgYXNzaWduZWQgdG8sIHRoZVxyXG4gKiByZXN1bHRpbmcgQ1NTIHJ1bGUgd2lsbCBub3QgaGF2ZSB0aGF0IHByb3BlcnR5LlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIHVzaW5nIGByYXdgIGZ1bmN0aW9uXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3MoeyBib3JkZXI6IGNzcy5yYXdgMXB4IHNvbGlkIGJyb3duYCB9KVxyXG4gKlxyXG4gKiAgICAgLy8gdXNpbmcgY3VzdG9tIGZ1bmN0aW9uXHJcbiAqICAgICBjbHMyID0gdGhpcy4kY2xhc3MoeyBjbGlwLXBhdGg6IHJhbmRvbUNpcmNsZSgpfSlcclxuICogfVxyXG4gKlxyXG4gKiAvLyBjcmVhdGUgQ1NTIGNpcmNsZSBmdW5jdGlvbiB3aXRoIHJhbmRvbSByYWRpdXMgYmV0d2VlbiAzMCBhbmQgNTAgcGl4ZWxzXHJcbiAqIGZ1bmN0aW9uIHJhbmRvbUNpcmNsZSgpOiBjc3MuSVJhd1Byb3h5XHJcbiAqIHtcclxuICogICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmdcclxuICogICAgIHJldHVybiAoKSA9PiBgY2lyY2xlKCR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjEpICsgMzB9KWA7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElSYXdQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJyYXdcIj4ge31cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjYWxsYWJsZSBpbnRlcmZhY2UgdGhhdCBpcyByZXR1cm5lZCBieSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiBzdHJpbmdcclxuICogY29udGV4dCwgc3VjaCBhcyBbW2F0dHJdXSBhbmQgW1tjb3VudGVyXV0uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTdHJpbmdQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJzdHJpbmdcIj4ge31cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGA8c3RyaW5nPmAgQ1NTIHR5cGUsIHdoaWNoIGlzIGVpdGhlciBhIHF1YXRlZCBzdHJpbmcgb3IgZnVuY3Rpb25zIHRoYXQgY2FuIGJlXHJcbiAqIHVzZWQgaW4gc3RyaW5nIGNvbnRleHQsIHN1Y2ggYXMgYGF0dHIoKWAgYW5kIGBjb3VudGVyKClgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDc3NTdHJpbmcgPSBzdHJpbmcgfCBJU3RyaW5nUHJveHk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYElDdXN0b21WYXJgIGludGVyZmFjZSByZXByZXNlbnRzIGEgY3VzdG9tIHByb3BlcnR5IHdpdGggdmFsdWVzIG9mIHRoZSBnaXZlbiB0eXBlLiBFdmVyeVxyXG4gKiBzdHlsZSBwcm9wZXJ0eSBjYW4gYWNjZXB0IGEgY3VzdG9tIENTUyBwcm9wZXJ0eSB2YWx1ZSBpbiB0aGUgZm9ybSBvZiB0aGUgYHZhcigpYCBDU1NcclxuICogZnVuY3Rpb24uIE1pbWNzcyBhbHNvIGFsbG93cyBkZWZpbmluZyBcImNvbnN0YW50c1wiLCB3aGljaCBhcmUgYSBtb3JlIGxpZ2h0d2VpZ2h0IHdheSB0byBwcm92aWRlXHJcbiAqIHZhbHVlcyB0aGF0IGFyZSB1c2VkIGluIG90aGVyIHJ1bGVzIGFuZCBwcm9wZXJ0aWVzLiBTZWUgdGhlIFtbSUNvbnN0YW50XV0gaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBUaGUgYElDdXN0b21WYXJgIGludGVyZmFjZSBpcyBleHRlbmRlZCBieSB0aGUgW1tJVmFyUnVsZV1dIGludGVyZmFjZSB0aGF0IGlzIHJldHVybmVkXHJcbiAqIGZyb20gdGhlIFtbJHZhcl1dIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFQgQmFzaWMgdHlwZSBvZiB0aGUgdmFsdWUgb2YgdGhlIGN1c3RvbSBDU1MgdmFyaWFibGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElDdXN0b21WYXI8VCA9IGFueT5cclxue1xyXG4gICAgLyoqXHJcblx0ICogU2V0cyBuZXcgdmFsdWUgb2YgdGhpcyBjdXN0b20gQ1NTIHByb3BlcnR5IGF0IHRoZSBnbG9iYWwgbGV2ZWw7IHRoYXQgaXMsIHVuZGVyIGA6cm9vdGAuIFRvXHJcbiAgICAgKiBzZXQgYSB2YWx1ZSBvZiB0aGUgQ1NTIGN1c3RvbSBwcm9wZXJ0eSB1bmRlciBhIGNlcnRhaW4gQ1NTIHJ1bGUsIHVzZSB0aGVcclxuICAgICAqIFtbSVN0eWxlUnVsZS5zZXRDdXN0b21Qcm9wXV0gbWV0aG9kLlxyXG5cdCAqIEBwYXJhbSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRoZSBDU1MgcHJvcGVydHkuXHJcblx0ICogQHBhcmFtIHNjaGVkdWxlclR5cGUgSUQgb2YgYSByZWdpc3RlcmVkIHNjaGVkdWxlciB0eXBlIHRoYXQgaXMgdXNlZCB0byB3cml0ZSB0aGUgcHJvcGVydHlcclxuXHQgKiB2YWx1ZSB0byB0aGUgRE9NLiBJZiB1bmRlZmluZWQsIHRoZSBjdXJyZW50IGRlZmF1bHQgc2NoZWR1bGVyIHdpbGwgYmUgdXNlZC5cclxuXHQgKi9cclxuXHRzZXRWYWx1ZSggdmFsdWU6IEV4dGVuZGVkUHJvcDxUPiwgc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQ7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgSUNvbnN0YW50YCBpbnRlcmZhY2UgcmVwcmVzZW50cyBhIGNvbnN0YW50IHdpdGggdmFsdWVzIG9mIHRoZSBnaXZlbiB0eXBlLiBNaW1jc3MgYWxsb3dzXHJcbiAqIGRlZmluaW5nIFwiY29uc3RhbnRzXCIsIHdoaWNoIGFyZSBhIGxpZ2h0d2VpZ2h0IHdheSAoY29tcGFyZWQgdG8gY3VzdG9tIENTUyBwcm9wZXJ0aWVzKSB0byBwcm92aWRlXHJcbiAqIHZhbHVlcyB0aGF0IGFyZSB1c2VkIGluIG90aGVyIHJ1bGVzIGFuZCBwcm9wZXJ0aWVzLiBFdmVyeSBzdHlsZSBwcm9wZXJ0eSBjYW4gYWNjZXB0IGEgY29uc3RhbnRcclxuICogdmFsdWUuXHJcbiAqXHJcbiAqIFRoZSBgSUNvbnN0YW50YCBpbnRlcmZhY2UgaXMgZXh0ZW5kZWQgYnkgdGhlIFtbSUNvbnN0UnVsZV1dIGludGVyZmFjZSB0aGF0IGlzIHJldHVybmVkIGZyb20gdGhlXHJcbiAqIFtbJGNvbnN0XV0gZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVCBCYXNpYyB0eXBlIG9mIHRoZSB2YWx1ZSBvZiB0aGUgY29uc3RhbnQuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElDb25zdGFudDxUID0gYW55PlxyXG57XHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbnN0YW50LlxyXG5cdCAqL1xyXG5cdGdldFZhbHVlKCk6IEV4dGVuZGVkUHJvcDxUPjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSB0aGF0IGV4dGVuZHMgdGhlIGdpdmVuIHR5cGUgd2l0aCB0aGUgZm9sbG93aW5nIHR5cGVzOlxyXG4gKiAtIFtbSUN1c3RvbVZhcl1dIGludGVyZmFjZSB0aGF0IGFsbG93cyB1c2luZyBhIENTUyBjdXN0b20gcHJvcGVydHkgcnVsZSB2YWx1ZS5cclxuICogLSBbW0lDb25zdGFudF1dIGludGVyZmFjZSB0aGF0IGFsbG93cyB1c2luZyBhIGNvbnN0YW50IHJ1bGUgdmFsdWUuXHJcbiAqIC0gW1tJUmF3UHJveHldXSBpbnRlcmZhY2UgdGhhdCBhbGxvd3Mgc3BlY2lmeWluZyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHJhdyBzdHJpbmcgdmFsdWUuXHJcbiAqXHJcbiAqIERldmVsb3BlcnMgZG9uJ3QgdXN1YWxseSB1c2UgdGhpcyB0eXBlIGRpcmVjdGx5IC0gaXQgaXMgdXNlZCBieSBNaW1jc3MgdG8gZGVmaW5lIHN0eWxlIHByb3BlcnR5XHJcbiAqIHR5cGVzIGFzIHdlbGwgYXMgZnVuY3Rpb24gcGFyYW1ldGVyIHR5cGVzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRXh0ZW5kZWQ8VD4gPSBUIHwgSUN1c3RvbVZhcjxUPiB8IElDb25zdGFudDxUPiB8IElSYXdQcm94eTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIHR5cGUgb2YgcHJvcGVydHkgaW4gYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUgXCIhXCIgcHJvcGVydHkuIFRoaXNcclxuICogdHlwZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhlIHByb3BlcnR5IHZhbHVlIG11c3QgYmUgZmxhZ2dlZCBhcyBcIiFpbXBvcnRhbnRcIi5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIFN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBwcm9kdWNlcyBDU1M6IC5jbHMxIHsgY29sb3I6IHJlZDsgYmFja2dyb3VuZC1jb2xvcjogYmVpZ2UgIWltcG9ydGFudDsgfVxyXG4gKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICBjb2xvcjogXCJyZWRcIixcclxuICogICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHsgXCIhXCI6IFwiYmVpZ2VcIiB9XHJcbiAqICAgICB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgSW1wb3J0YW50UHJvcDxUPiA9IHsgXCIhXCI6IEV4dGVuZGVkPFQ+IHwgR2xvYmFsX1N0eWxlVHlwZSB9O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSB0aGF0IGFsbG93cyBzcGVjaWZ5aW5nIG11bHRpcGxlIHZhbHVlcyBvZiBhIGdpdmVuIHR5cGUgdXNpbmcgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUgXCJbXVwiXHJcbiAqIHByb3BlcnR5LiBUaGlzIHR5cGUgaXMgdXNlZCB0byBpbmNsdWRlIG11bHRpcGxlIG9jY3VycmVuY2llcyBvZiB0aGUgc2FtZSBzdHlsZSBwcm9wZXJ0eSBpbiBhXHJcbiAqIHN0eWxlc2V0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRhcmdldGluZyBhZHZhbmNlZCBmZWF0dXJlcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMgYW5kXHJcbiAqIHByb3ZpZGluZyBhIGZhbGxiYWNrLCB3aGljaCBpcyBzdXBwb3J0ZWQgZXZlcnl3aGVyZS5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIFN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gKiAgICAgICAgIGJhY2tncm91bmRJbWFnZToge1wiW11cIjogW1xyXG4gKiAgICAgICAgICAgICAvLyBmaXJzdCwgc3BlY2lmeSBhIHN0YXRpYyBpbWFnZSAoc3VwcG9ydGVkIGV2ZXJ5d2hlcmUpXHJcbiAqICAgICAgICAgICAgIHVybChcImltYWdlLnBuZ1wiKSxcclxuICogICAgICAgICAgICAgLy8gc2Vjb25kLCB1c2UgcGFpbnQgd29ya2xldCAobm90IHN1cHBvcnRlZCBldmVyeXdoZXJlIHlldClcclxuICogICAgICAgICAgICAgcGFpbnQoXCJteVBhaW50V29ya2xldFwiKSxcclxuICogICAgICAgICBdfVxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyB3aWxsIHByb2R1Y2UgdGhlIGZvbGxvd2luZyBDU1M6XHJcbiAqXHJcbiAqIGBgYGNzc1xyXG4gKiAuY2xzMSB7XHJcbiAqICAgICBiYWNrZ3JvdW5kSW1hZ2U6IHVybChcImltYWdlLnBuZ1wiKTtcclxuICogICAgIGJhY2tncm91bmRJbWFnZTogcGFpbnQoXCJteVBhaW50V29ya2xldFwiKTtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICovXHJcbmV4cG9ydCB0eXBlIE11bHRpUHJvcDxUPiA9IHsgXCJbXVwiOiAoRXh0ZW5kZWQ8VD4gfCBJbXBvcnRhbnRQcm9wPFQ+IHwgR2xvYmFsX1N0eWxlVHlwZSlbXSB9O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIEV4dGVuZGVkUHJvcCBleHRlbmRzIHRoZSBnaXZlbiBnZW5lcmljIHR5cGUgd2l0aCB0aGUgZm9sbG93aW5nIGVsZW1lbnRzOlxyXG4gKiAtIFtbSUN1c3RvbVZhcl1dIGludGVyZmFjZSB0aGF0IGFsbG93cyB1c2luZyBhIENTUyBjdXN0b20gcHJvcGVydHkgcnVsZSB2YWx1ZS5cclxuICogLSBbW0lDb25zdGFudF1dIGludGVyZmFjZSB0aGF0IGFsbG93cyB1c2luZyBhIGNvbnN0YW50IHJ1bGUgdmFsdWUuXHJcbiAqIC0gW1tJUmF3UHJveHldXSBpbnRlcmZhY2UgdGhhdCBhbGxvd3Mgc3BlY2lmeWluZyByYXcgc3RyaW5nIHZhbHVlLlxyXG4gKiAtIE9iamVjdCB3aXRoIGEgc2luZ2xlIHByb3BlcnR5IFwiIVwiLCB3aGljaCBpcyB1c2VkIHRvIG1hcmsgYSBwcm9wZXJ0eSBhcyBcIiFpbXBvcnRhbnRcIi5cclxuICogLSBbW0dsb2JhbF9TdHlsZVR5cGVdXSwgd2hpY2ggYWxsb3dzIGFueSBwcm9wZXJ0eSB0byBiZSBhc3NpZ25lZCB0aGUgZ2xvYmFsIHZhbHVlcyBzdWNoIGFzXHJcbiAqICAgXCJpbml0aWFsXCIsIFwiaW5oZXJpdFwiLCBcInVuc2V0XCIgYW5kIFwicmV2ZXJ0XCIuXHJcbiAqXHJcbiAqICBEZXZlbG9wZXJzIGRvbid0IHVzdWFsbHkgdXNlIHRoaXMgdHlwZSBkaXJlY3RseSAtIGl0IGlzIHVzZWQgYnkgTWltY3NzIHRvIGRlZmluZSB0eXBlc1xyXG4gKiBvZiBwcm9wZXJ0aWVzIGluIHRoZSBbW1N0eWxlc2V0XV0gaW50ZXJmYWNlLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRXh0ZW5kZWRQcm9wPFQ+ID0gRXh0ZW5kZWQ8VD4gfCBJbXBvcnRhbnRQcm9wPFQ+IHwgTXVsdGlQcm9wPFQ+IHwgR2xvYmFsX1N0eWxlVHlwZTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFV0aWxpdHkgdHlwZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgZm9yIHBhaXItbGlrZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGhhdmUgMSBvciAyIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gVGhpcyB0eXBlIGlzIHVzZWRcclxuICogZm9yIHN0eWxlIHByb3BlcnRpZXMgdGhhdCBjYW4gc3BlY2lmeSB2YWx1ZXMgZm9yIHR3byBkaW1lbnNpb25zICh4IGFuZCB5KSwgYnV0IGFsc28gYWxsb3cgZm9yIGFcclxuICogc2luZ2xlIHZhbHVlLCBpbiB3aGljaCBjYXNlIGl0IGFwcGxpZXMgdG8gYm90aCBkaW1lbnNpb25zLiBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBzdHlsZVxyXG4gKiBwcm9wZXJ0aWVzIHN1Y2ggYXMgYG92ZXJmbG93YCwgYGJvcmRlci1yYWRpdXNgLCBgYmFja2dyb3VuZC1yZXBlYXRgIGFuZCBvdGhlcnMuXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVCBUeXBlIG9mIHRoZSB2YWx1ZXNcclxuICpcclxuICogKipFeGFtcGxlczoqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBzaW5nbGUgdmFsdWVcclxuICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7IG92ZXJmbG93OiBcImF1dG9cIiB9KVxyXG5cclxuICogICAgIC8vIHR3byB2YWx1ZXNcclxuICogICAgIGNsczIgPSB0aGlzLiRjbGFzcyh7IG92ZXJmbG93OiBbXCJzY3JvbGxcIiwgXCJoaWRkZW5cIl0gfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB0eXBlIE9uZU9yUGFpcjxUPiA9IFQgfCBbRXh0ZW5kZWQ8VD4sIEV4dGVuZGVkPFQ+P107XHJcblxyXG4vKipcclxuICogVHlwZSBmb3IgYm94LWxpa2UgcHJvcGVydGllcyB0aGF0IGNhbiBoYXZlIDEgdG8gNCB2YWx1ZXMgb2YgdGhlIGdpdmVuIHR5cGUuIFRoaXMgdHlwZSBpcyB1c2VkXHJcbiAqIGZvciBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc3BlY2lmeSB2YWx1ZXMgZm9yIHRoZSBmb3VyIHNpZGVzIG9mIGFuIGVsZW1lbnQgYm94IGFuZCBoYXZlIHJ1bGVzIGhvd1xyXG4gKiBzcGVjaWZ5aW5nIDEsIDIgb3IgMyB2YWx1ZXMgZGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYXBwbGllZCB0byBhbGwgZm91ciBzaWRlcy4gRm9yIGV4YW1wbGUsIGl0IGlzXHJcbiAqIHVzZWQgYnkgc3R5bGUgcHJvcGVydGllcyBzdWNoIGFzIGBtYXJnaW5gLCBgcGFkZGluZ2AsIGBib3JkZXItY29sb3JgIGFuZCBvdGhlcnMuXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVCBUeXBlIG9mIHRoZSB2YWx1ZXNcclxuICpcclxuICogKipFeGFtcGxlczoqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBzaW5nbGUgdmFsdWVcclxuICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7IG1hcmdpbjogNCB9KVxyXG4gKlxyXG4gKiAgICAgLy8gdHdvIHZhbHVlc1xyXG4gKiAgICAgY2xzMiA9IHRoaXMuJGNsYXNzKHsgbWFyZ2luOiBbMCwgOF0gfSlcclxuICpcclxuICogICAgIC8vIHRocmVlIHZhbHVlc1xyXG4gKiAgICAgY2xzMyA9IHRoaXMuJGNsYXNzKHsgbWFyZ2luOiBbNiwgNiwgOF0gfSlcclxuICpcclxuICogICAgIC8vIGZvdXIgdmFsdWVzXHJcbiAqICAgICBjbHM0ID0gdGhpcy4kY2xhc3MoeyBtYXJnaW46IFs0LCA2LCA4LCAxMl0gfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB0eXBlIE9uZU9yQm94PFQ+ID0gVCB8IFtFeHRlbmRlZDxUPiwgRXh0ZW5kZWQ8VD4/LCBFeHRlbmRlZDxUPj8sIEV4dGVuZGVkPFQ+P107XHJcblxyXG4vKipcclxuICogVHlwZSBmb3IgcHJvcGVydGllcyB0aGF0IGNhbiBoYXZlIDEgb3IgbW9yZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIHR5cGUuIEl0IGlzIHVzZWQgYnkgbWFueSBzdHlsZVxyXG4gKiBwcm9wZXJ0aWVzIHN1Y2ggYXMgYGFuaW1hdGlvbmAgYW5kIGFsbCBpdHMgbG9uZ2hhbmRzLCBgYmFja2dyb3VuZGAgYW5kIGFsbCBpdHMgbG9uZ2hhbmRzLFxyXG4gKiBgdHJhbnNpdGlvbmAgYW5kIGFsbCBpdHMgbG9uZ2hhbmRzLCBgYm94LXNoYWRvd2AsIGB0cmFuc2Zvcm1gLCBgZmlsdGVyYCBhbmQgb3RoZXJzLlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFQgVHlwZSBvZiB0aGUgdmFsdWVzXHJcbiAqXHJcbiAqICoqRXhhbXBsZXM6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gc2luZ2xlIHZhbHVlXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3MoeyB0cmFuc2Zvcm06IHNjYWxlKDAuNSkgfSlcclxuICpcclxuICogICAgIC8vIHNldmVyYWwgdmFsdWVzXHJcbiAqICAgICBjbHMyID0gdGhpcy4kY2xhc3MoeyB0cmFuc2Zvcm06IFtzY2FsZSgwLjUsIHJvdGF0ZSg5MCksIHRyYW5zbGF0ZVgoMjAwKSldIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBPbmVPck1hbnk8VD4gPSBUIHwgRXh0ZW5kZWQ8VD5bXTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFNlbGVjdG9yc1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUeXBlIHRoYXQgY29tYmluZXMgbmFtZXMgb2YgYWxsIEhUTUwgYW5kIFNWRyB0YWdzXHJcbiAqL1xyXG4gZXhwb3J0IHR5cGUgRWxlbWVudFRhZ05hbWUgPSAoa2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwKSB8IChrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcCkgfCBcIipcIjtcclxuXHJcblxyXG5cclxuIC8qKlxyXG4gKiBUaGUgYElSdWxlV2l0aFNlbGVjdG9yYCBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbiBlbnRpdHkgdGhhdCBoYXMgYSBzZWxlY3RvciBzdHJpbmcuIFRoZXNlIGluY2x1ZGVcclxuICogYWxsIHN0eWxlIHJ1bGVzIChbW0lTdHlsZVJ1bGVdXSBpbnRlcmZhY2UpIGFuZCBjbGFzcyBuYW1lIHJ1bGUgKFtbSUNsYXNzTmFtZVJ1bGVdXSBpbnRlcmZhY2UpLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUnVsZVdpdGhTZWxlY3RvclxyXG57XHJcbiAgICAvKiogQ1NTIHJ1bGUgc2VsZWN0b3Igc3RyaW5nICovXHJcbiAgICByZWFkb25seSBzZWxlY3RvclRleHQ6IHN0cmluZztcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBJU2VsZWN0b3JQcm94eWAgZnVuY3Rpb24gcmV0dXJucyBhIENTUyBzZWxlY3RvciBzdHJpbmcuIFRoaXMgdHlwZSBpcyByZXR1cm5lZCBmcm9tIHRoZVxyXG4gKiBbW3NlbGVjdG9yXV0gZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTZWxlY3RvclByb3h5IGV4dGVuZHMgSUdlbmVyaWNQcm94eTxcInNlbGVjdG9yXCI+IHt9O1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgQ1NTIHNlbGVjdG9yIGNvbWJpbmF0b3JzIHVzZWQgd2hlbiBjcmVhdGluZyBjb21wbGV4IENTUyBzZWxlY3RvcnMuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTZWxlY3RvckNvbWJpbmF0b3IgPSBcIixcIiB8IFwiIFwiIHwgXCI+XCIgfCBcIitcIiB8IFwiflwiIHwgXCJ8fFwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgcHJvcGVydGllcyB1c2VkIGluIHRoZSBbW0NvbWJpbmVkU3R5bGVzZXRdXSB3aGljaCBhcmUgdXNlZCB0byBkZWZpbmUgZGVwZW5kZW50IHJ1bGVzLlxyXG4gKiBQcm9wZXJ0eSB2YWx1ZXMgYXJlIGRlZmluZWQgYXMgYXJyYXlzIG9mIHR3by1lbGVtZW50IHR1cGxlcyBlYWNoIGRlZmluaW5nIGEgc2VsZWN0b3IgYW5kIGFcclxuICogc3R5bGVzZXQgY29ycmVzcG9uZGluZyB0byB0aGlzIHNlbGVjdG9yLiBTZWxlY3RvcnMgY2FuIHVzZSB0aGUgYW1wZXJzYW5kIHN5bWJvbCB0byByZWZlciB0byB0aGVcclxuICogcGFyZW50IHN0eWxlIHNlbGVjdG9yLiBJZiB0aGUgYW1wZXJzYW5kIHN5bWJvbCBpcyBub3QgdXNlZCwgdGhlIHNlbGVjdG9yIHdpbGwgYmUgc2ltcGx5IGFwcGVuZGVkXHJcbiAqIHRvIHRoZSBwYXJlbnQgc2VsZWN0b3IuXHJcbiAqXHJcbiAqIFRoZSBhbXBlcnNhbmQgc3ltYm9sIGNhbiBiZSBlaXRoZXIgcHJlY2VlZGVkIG9yIGZvbG93ZWQgYnkgYSBjb21iaW5hdG9yIGNoYXJhY3Rlciwgd2hpY2ggYWxsb3dzXHJcbiAqIGVhc3ktdG8tdXNlIGNvbWJpbmF0aW9uIG9mIGEgcGFyZW50IHNlbGVjdG9yIHdpdGggdGhlIHNwZWNpZmllZCBzZWxlY3RvciB1c2luZyB0aGUgZ2l2ZW5cclxuICogY29tYmluYXRvci5cclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGNsYXNzIHRoYXQgZG9lc24ndCBkZWZpbmUgaXRzIG93biBzdHlsZXMgYW5kIGlzIG9ubHkgdXNlZCBpbiBjb21iaW5hdGlvbnNcclxuICogICAgIGNsYXNzMSA9IHRoaXMuJGNsYXNzKClcclxuICpcclxuICogICAgIC8vIFwicGFyZW50IGNsYXNzXCJcclxuICogICAgIGNsYXNzMiA9IHRoaXMuJGNsYXNzKHtcclxuICpcclxuICogICAgICAgICAvLyBjc3M6IC5jbGFzczIgeyBiYWNrZ3JvdW5kQ29sb3I6IHdoaXRlOyB9XHJcbiAqICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcbiAqXHJcbiAqICAgICAgICAgLy8gY3NzOiBsaSAuY2xhc3MyOmhvdmVyIHsgYmFja2dyb3VuZENvbG9yOiB5ZWxsb3c7IH1cclxuICogICAgICAgICBcIiZcIjogIFsgW1wibGkgJjpob3ZlclwiLCB7IGJhY2tncm91bmRDb2xvcjogXCJ5ZWxsb3dcIiB9XSBdLFxyXG4gKlxyXG4gKiAgICAgICAgIC8vIGNzczogLmNsYXNzMi5jbGFzczEgeyBiYWNrZ3JvdW5kQ29sb3I6IGN5YW47IH1cclxuICogICAgICAgICBcIiZcIjogIFsgW3RoaXMuY2xhc3MxLCB7IGJhY2tncm91bmRDb2xvcjogXCJjeWFuXCIgfV0gXSxcclxuICpcclxuICogICAgICAgICAvLyBjc3M6IC5jbGFzczIgPiAuY2xhc3MxIHsgYmFja2dyb3VuZENvbG9yOiBncmVlbjsgfVxyXG4gKiAgICAgICAgIFwiJj5cIjogWyBbdGhpcy5jbGFzczEsIHsgYmFja2dyb3VuZENvbG9yOiBcImdyZWVuXCIgfV0gXSxcclxuICpcclxuICogICAgICAgICAvLyBjc3M6IC5jbGFzczEgKyAuY2xhc3MyIHsgYmFja2dyb3VuZENvbG9yOiBvcmFuZ2U7IH1cclxuICogICAgICAgICBcIismXCI6IFsgW3RoaXMuY2xhc3MxLCB7IGJhY2tncm91bmRDb2xvcjogXCJvcmFuZ2VcIiB9XSBdLFxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB0eXBlIERlcGVuZGVudFJ1bGVDb21iaW5hdG9yID0gXCImXCIgfCBcIiYsXCIgfCBcIiYgXCIgfCBcIiY+XCIgfCBcIiYrXCIgfCBcIiZ+XCIgfCBcIiwmXCIgfCBcIiAmXCIgfCBcIj4mXCIgfCBcIismXCIgfCBcIn4mXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHByaW50LXJlbGF0ZWQgcHNldWRvIGNsYXNzZXMgLSB0aG9zZSB0aGF0IGNhbiBiZSBzcGVjaWZpZWQgd2l0aCB0aGUgYEBwYWdlYCBDU1MgcnVsZVxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgcGFnZSA9IHRoaXMuJHBhZ2UoIFwiOmZpcnN0XCIsIHsgbWFyZ2luOiBcImF1dG9cIiB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUGFnZVBzZXVkb0NsYXNzID0gXCI6YmxhbmtcIiB8IFwiOmZpcnN0XCIgfCBcIjpsZWZ0XCIgfCBcIjpyaWdodFwiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBwc2V1ZG8gY2xhc3NlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIHByb3BlcnRpZXMgaW4gdGhlIFtbQ29tYmluZWRTdHlsZXNldF1dIG9iamVjdCB0b1xyXG4gKiBkZWZpbmUgZGVwZW5kZW50IHJ1bGVzLiBOb3RlIHRoYXQgdGhpcyB0eXBlIG9ubHkgY29udGFpbnMgcHNldWRvIGNsYXNzZXMgdGhhdCBkb24ndCByZXF1aXJlXHJcbiAqIHBhcmFtZXRlcnMuIEZvciBwYXJhbWV0ZXJpemVkIHBzZXVkbyBjbGFzc2VzLCBzZWUgdGhlIFtbSVBhcmFtZXRlcml6ZWRQc2V1ZG9DbGFzc11dIGludGVyZmFjZS5cclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIGNsYXNzMSA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiLFxyXG4gKiAgICAgICAgIFwiOmhvdmVyXCI6IHsgb3BhY2l0eTogMC43IH0sXHJcbiAqICAgICB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUHNldWRvQ2xhc3MgPSBQYWdlUHNldWRvQ2xhc3MgfFxyXG5cdFwiOmFjdGl2ZVwiIHwgXCI6YW55LWxpbmtcIiB8IFwiOmF1dG9maWxsXCIgfCBcIjpibGFua1wiIHwgXCI6Y2hlY2tlZFwiIHwgXCI6ZGVmYXVsdFwiIHwgXCI6ZGVmaW5lZFwiIHwgXCI6ZGlzYWJsZWRcIiB8XHJcblx0XCI6ZW1wdHlcIiB8IFwiOmVuYWJsZWRcIiB8IFwiOmZpcnN0LWNoaWxkXCIgfCBcIjpmaXJzdC1vZi10eXBlXCIgfCBcIjpmdWxsc2NyZWVuXCIgfCBcIjpmb2N1c1wiIHxcclxuXHRcIjpmb2N1cy12aXNpYmxlXCIgfCBcIjpmb2N1cy13aXRoaW5cIiB8IFwiOmhvc3RcIiB8IFwiOmhvdmVyXCIgfCBcIjppbmRldGVybWluYXRlXCIgfCBcIjppbi1yYW5nZVwiIHwgXCI6aW52YWxpZFwiIHxcclxuXHRcIjpsYXN0LWNoaWxkXCIgfCBcIjpsYXN0LW9mLXR5cGVcIiB8IFwiOmxlZnRcIiB8IFwiOmxpbmtcIiB8IFwiOm9ubHktY2hpbGRcIiB8IFwiOm9ubHktb2YtdHlwZVwiIHwgXCI6b3B0aW9uYWxcIiB8XHJcblx0XCI6b3V0LW9mLXJhbmdlXCIgfCBcIjpwYXVzZWRcIiB8IFwiOnBsYWNlaG9sZGVyLXNob3duXCIgfCBcIjpyZWFkLW9ubHlcIiB8IFwiOnJlYWQtd3JpdGVcIiB8IFwiOnJlcXVpcmVkXCIgfFxyXG4gICAgXCI6cmlnaHRcIiB8IFwiOnJvb3RcIiB8IFwiOnNjb3BlXCIgfCBcIjp0YXJnZXRcIiB8IFwiOnZhbGlkXCIgfCBcIjp2aXNpdGVkXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHBzZXVkbyBlbGVtZW50cyB0aGF0IGNhbiBiZSB1c2VkIGFzIHByb3BlcnRpZXMgaW4gdGhlIFtbQ29tYmluZWRTdHlsZXNldF1dIG9iamVjdCB0b1xyXG4gKiBkZWZpbmUgZGVwZW5kZW50IHJ1bGVzLiBOb3RlIHRoYXQgdGhpcyB0eXBlIG9ubHkgY29udGFpbnMgcHNldWRvIGVsZW1lbnRzIHRoYXQgZG9uJ3QgcmVxdWlyZVxyXG4gKiBwYXJhbWV0ZXJzLiBGb3IgcGFyYW1ldGVyaXplZCBwc2V1ZG8gZWxlbWVudHMsIHNlZSB0aGUgW1tJUGFyYW1ldGVyaXplZFBzZXVkb0VsZW1lbnRdXSBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICBleGNpdGluZyA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICBcIjo6YWZ0ZXJcIjoge1xyXG4gKiAgICAgICAgICAgICBjb250ZW50OiBcIiA8LSBFWENJVElORyFcIlxyXG4gKiAgICAgICAgICAgICBjb2xvcjogXCJncmVlblwiXHJcbiAqICAgICAgICAgfSxcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBQc2V1ZG9FbGVtZW50ID0gXCI6OmFmdGVyXCIgfCBcIjo6YmFja2Ryb3BcIiB8IFwiOjpiZWZvcmVcIiB8IFwiOjpjdWVcIiB8IFwiOjpmaXJzdC1sZXR0ZXJcIiB8XHJcblx0XCI6OmZpcnN0LWxpbmVcIiB8IFwiOjpncmFtbWFyLWVycm9yXCIgfCBcIjo6bWFya2VyXCIgfCBcIjo6cGxhY2Vob2xkZXJcIiB8IFwiOjpzZWxlY3Rpb25cIiB8IFwiOjpzcGVsbGluZy1lcnJvclwiO1xyXG5cclxuXHJcblxyXG4vKiogQ29tYmluZXMgbmFtZXMgb2Ygbm9uLXBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzZXMgYW5kIHBzZXVkbyBlbGVtZW50cyAqL1xyXG5leHBvcnQgdHlwZSBQc2V1ZG9FbnRpdHkgPSBQc2V1ZG9DbGFzcyB8IFBzZXVkb0VsZW1lbnQ7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIGZvciBleHByZXNzaW9uIEFuK0IsIHdoaWNoIGlzIHVzZWQgZm9yIHBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzZXMgbGlrZSBgOm50aC1jaGlsZGAuIEl0XHJcbiAqIGNhbiBiZSBhIHN0cmluZywgYSBzaW5nbGUgbnVtYmVyIG9yIGEgdHVwbGUgd2l0aCBvbmUgb3IgdHdvIG51bWJlcnMuIElmIGl0IGlzIGEgc2luZ2xlIG51bWJlcixcclxuICogdGhlICduJyBpbiBBbitCIHdpbGwgbm90IGJlIHVzZWQgLSBhcyBpbiBgbnRoLWNoaWxkKDIpYC4gSWYgaXQgaXMgYSB0dXBsZSwgdGhlICduJyB3aWxsIGJlIHVzZWRcclxuICogZXZlbiBpZiB0aGUgdHVwbGUncyBzZWNvbmQgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICBwID0gdGhpcy4kdGFnKCBcInBcIiwge1xyXG4gKiAgICAgICAgIFwiOm50aC1vZi10eXBlXCI6IFtcclxuICpcclxuICogICAgICAgICAgICAgLy8gY3NzOiBwOm50aC1vZi10eXBlKDEpXHJcbiAqICAgICAgICAgICAgIFsxLCB7IGNvbG9yOiBcInJlZFwiIH1dLFxyXG4gKlxyXG4gKiAgICAgICAgICAgICAvLyBjc3M6IHA6bnRoLW9mLXR5cGUoM24pXHJcbiAqICAgICAgICAgICAgIFtbM10sIHsgY29sb3I6IFwiZ3JlZW5cIiB9XSxcclxuICpcclxuICogICAgICAgICAgICAgLy8gY3NzOiBwOm50aC1vZi10eXBlKDJuKzEpXHJcbiAqICAgICAgICAgICAgIFtbMiwxXSwgeyBjb2xvcjogXCJibHVlXCIgfV0sXHJcbiAqXHJcbiAqICAgICAgICAgICAgIC8vIGNzczogcDpudGgtb2YtdHlwZShvZGQpXHJcbiAqICAgICAgICAgICAgIFtcIm9kZFwiLCB7IGNvbG9yOiBcInllbGxvd1wiIH1dLFxyXG4gKlxyXG4gKiAgICAgICAgICAgICAvLyBjc3M6IHA6bnRoLW9mLXR5cGUoMm4tMSlcclxuICogICAgICAgICAgICAgW1syLC0xXSwgeyBjb2xvcjogXCJvcmFuZ2VcIiB9XSxcclxuICogICAgICAgICBdLFxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB0eXBlIE50aEV4cHJlc3Npb24gPSBcIm9kZFwiIHwgXCJldmVuXCIgfCBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXI/XSB8IHN0cmluZyB8IElSYXdQcm94eTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIERlZmluZXMgdGhlIHR5cGUgZm9yIHRoZSB0ZXh0IGRpcmVjdGlvbiB1c2VkIGZvciB0aGUgYFwiOmRpclwiYCBwc2V1ZG8gY2xhc3NcclxuICovXHJcbmV4cG9ydCB0eXBlIERpcmVjdGlvbiA9IFwicnRsXCIgfCBcImx0clwiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBJUGFyYW1ldGVyaXplZFBzZXVkb0NsYXNzYCBpbnRlcmZhY2UgbWFwcyBuYW1lcyBvZiBwc2V1ZG8gY2xhc3NlcyB0aGF0IHJlcXVpcmUgcGFyYW1ldGVyc1xyXG4gKiB0byB0aGUgdHlwZXMgdGhhdCBhcmUgdXNlZCB0byBzcGVjaWZ5IHRoZXNlIHBhcmFtZXRlcnMuIFdoZW4gYSBwYXJhbWV0ZXJpemVkIHBzZXVkbyBjbGFzcyBpc1xyXG4gKiB1c2VkIGFzIGEgcHJvcGVydHkgaW4gdGhlIFtbQ29tYmluZWRTdHlsZXNldF1dIG9iamVjdCwgdGhlIHZhbHVlIHNob3VsZCBiZSBvZiB0aGUgdHlwZSBmcm9tXHJcbiAqIHRoaXMgaW50ZXJmYWNlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGFyYW1ldGVyaXplZFBzZXVkb0NsYXNzXHJcbntcclxuXHRcIjpkaXJcIjogRGlyZWN0aW9uO1xyXG5cdFwiOmhhc1wiOiBDc3NTZWxlY3RvciB8IFtTZWxlY3RvckNvbWJpbmF0b3IsIENzc1NlbGVjdG9yXTtcclxuXHRcIjpob3N0XCI6IHN0cmluZztcclxuXHRcIjpob3N0LWNvbnRleHRcIjogc3RyaW5nO1xyXG5cdFwiOmlzXCI6IENzc1NlbGVjdG9yO1xyXG5cdFwiOmxhbmdcIjogc3RyaW5nO1xyXG5cdFwiOm5vdFwiOiBDc3NTZWxlY3RvcjtcclxuXHRcIjpudGgtY2hpbGRcIjogTnRoRXhwcmVzc2lvbjtcclxuXHRcIjpudGgtb2YtdHlwZVwiOiBOdGhFeHByZXNzaW9uO1xyXG5cdFwiOm50aC1sYXN0LWNoaWxkXCI6IE50aEV4cHJlc3Npb247XHJcblx0XCI6bnRoLWxhc3Qtb2YtdHlwZVwiOiBOdGhFeHByZXNzaW9uO1xyXG5cdFwiOndoZXJlXCI6IENzc1NlbGVjdG9yO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYElQYXJhbWV0ZXJpemVkUHNldWRvRWxlbWVudGAgaW50ZXJmYWNlIG1hcHMgbmFtZXMgb2YgcHNldWRvIGVsZW1lbnRzIHRoYXQgcmVxdWlyZSBwYXJhbWV0ZXJzXHJcbiAqIHRvIHRoZSB0eXBlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlc2UgcGFyYW1ldGVycy4gV2hlbiBhIHBhcmFtZXRlcml6ZWQgcHNldWRvIGVsZW1lbnRcclxuICogaXMgdXNlZCBhcyBhIHByb3BlcnR5IGluIHRoZSBbW0NvbWJpbmVkU3R5bGVzZXRdXSBvYmplY3QsIHRoZSB2YWx1ZSBzaG91bGQgYmUgb2YgdGhlIHR5cGUgZnJvbVxyXG4gKiB0aGlzIGludGVyZmFjZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBhcmFtZXRlcml6ZWRQc2V1ZG9FbGVtZW50XHJcbntcclxuXHRcIjo6cGFydFwiOiBzdHJpbmc7XHJcblx0XCI6OnNsb3R0ZWRcIjogQ3NzU2VsZWN0b3I7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgSVBhcmFtZXRlcml6ZWRQc2V1ZG9FbnRpdHlgIGludGVyZmFjZSBjb21iaW5lcyBbW0lQYXJhbWV0ZXJpemVkUHNldWRvQ2xhc3NdXSBhbmRcclxuICogW1tJUGFyYW1ldGVyaXplZFBzZXVkb0VsZW1lbnRdXSBpbnRlcmZhY2VzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGFyYW1ldGVyaXplZFBzZXVkb0VudGl0eSBleHRlbmRzIElQYXJhbWV0ZXJpemVkUHNldWRvQ2xhc3MsIElQYXJhbWV0ZXJpemVkUHNldWRvRWxlbWVudCB7fVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHNlbGVjdG9yIGZvciBvbmUgb3IgbW9yZSBuYW1lc3BhY2VkIHRhZ3M7IHRoYXQgaXMsIHRhZ3MgYWNjb21wYW5pZWQgYnkgYSBuYW1lc3BhY2VcclxuICogcHJlZml4LiBUaGlzIGludGVyZmFjZSBpcyByZXR1cm5lZCBmcm9tIHRoZSBbW3RhZ05TXV0gZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElOU1RhZ0Z1bmMgZXh0ZW5kcyBJQ3NzRnVuY09iamVjdFxyXG57XHJcbiAgICBmbjogXCJuc3RhZ1wiO1xyXG5cclxuICAgIC8qKiBOYW1lc3BhY2UgcHJlZml4IHN0cmluZyBvciByZWZlcmVuY2UgdG8gYSBuYW1lc3BhY2UgcnVsZSAqL1xyXG4gICAgbnM6IHN0cmluZyB8IElOYW1lc3BhY2VSdWxlO1xyXG5cclxuICAgIC8qKiBPbmUgb3IgbW9yZSBlbGVtZW50IHRhZyBuYW1lcyAqL1xyXG4gICAgdGFnczogXCIqXCIgfCBFbGVtZW50VGFnTmFtZSB8IEVsZW1lbnRUYWdOYW1lW107XHJcblxyXG4gICAgLyoqIE9wdGlvbmFsIHNlbGVjdG9yIGNvbWJpbmF0b3IgaWYgbW9yZSB0aGFuIG9uZSB0YWcgaXMgZ2l2ZW4uIERlZmF1bHQgaXMgYFwiLFwiYC4gKi9cclxuICAgIGNvbWI/OiBTZWxlY3RvckNvbWJpbmF0b3I7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiBhIHBhcmFtZXRlcml6ZWQgcHNldWRvIGVudGl0eSB3aXRoIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGFyYW1ldGVyaXplZFBzZXVkb0VudGl0eUZ1bmM8VCBleHRlbmRzIGtleW9mIElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5PiBleHRlbmRzIElDc3NGdW5jT2JqZWN0XHJcbntcclxuICAgIC8qKiBQc2V1ZG8gZW50aXR5IG5hbWUgKi9cclxuICAgIGZuOiBUO1xyXG5cclxuICAgIC8qKiBQYXJhbWV0ZXIgb2YgdGhlIHBzZXVkbyBlbnRpdHkgKi9cclxuICAgIHA6IElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5W1RdO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBmb3Igb3BlcmF0aW9ucyBkZWZpbmluZyB0aGUgYmVoYXZpb3Igb2YgYXR0cmlidXRlIHNlbGVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQXR0ckNvbXBhcmlzb25PcGVyYXRpb24gPSBcIj1cIiB8IFwifj1cIiB8IFwifD1cIiB8IFwiXj1cIiB8IFwiJD1cIiB8IFwiKj1cIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gYXR0cmlidXRlIHNlbGVjdG9yIGRlZmluaW5nIGl0cyBuYW1lLCB2YWx1ZSBhbmQgY29tcGFyaXNvbiBvcGVyYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElBdHRyU2VsZWN0b3JGdW5jIGV4dGVuZHMgSUNzc0Z1bmNPYmplY3Rcclxue1xyXG4gICAgZm46IFwiYXR0ci1zZWxcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZSB0byB3aGljaCB0aGUgYXR0cmlidXRlIHZhbHVlIGlzIGNvbXBhcmVkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgc2VsZWN0b3Igb25seSBsb29rc1xyXG4gICAgICogZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICB2YWw/OiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyO1xyXG5cclxuICAgIC8qKiBOYW1lc3BhY2Ugb2YgdGhlIGF0dHJpYnV0ZSAqL1xyXG4gICAgbnM/OiBzdHJpbmcgfCBJTmFtZXNwYWNlUnVsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdGlvbiB0aGF0IGRlZmluZXMgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBjb21wYXJpc29uIGJlaGF2aW9yLiBUaGUgZGVmYXVsdCB2YWx1ZSBpc1xyXG4gICAgICogW1tBdHRyU2VsZWN0b3JPcGVyYXRpb24uRXF1YWxdXS5cclxuICAgICAqL1xyXG4gICAgb3A/OiBBdHRyQ29tcGFyaXNvbk9wZXJhdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhc2UgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSB2YWx1ZSBjb21wYXJpc29uIGlzIGNhc2Utc2Vuc2l0aXZlLiBUaGVcclxuICAgICAqIHVuZGVmaW5lZCB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgY2FzZS1zZW5zaXRpdmUgY29tcGFyaXNvbnMuXHJcbiAgICAgKi9cclxuICAgIGNmPzogXCJpXCIgfCBcInNcIjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNvbXBvdW5kIHNlbGVjdG9yIGFzIGFuIGFycmF5IG9mIHNlbGVjdG9ycy4gVGhpcyBpbnRlcmZhY2UgaXMgZXh0ZW5kZWQgYnkgdGhlXHJcbiAqIFtbSVNlbGVjdG9yQnVpbGRlcl1dIGludGVyZmFjZSwgd2hpY2ggYWxsb3dzIGJ1aWxkaW5nIGEgY29tcG91bmQgc2VsZWN0b3IgdXNpbmcgY2hhaW4gY2FsbHMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTZWxlY3RvckZ1bmMgZXh0ZW5kcyBJQ3NzRnVuY09iamVjdFxyXG57XHJcbiAgICBmbjogXCJzZWxcIjtcclxuXHJcbiAgICAvKiogQXJyYXkgb2Ygc2VsZWN0b3IgaXRlbXMgdGhhdCBhcmUgY29tYmluZWQgdG9nZXRoZXIgdG8gcHJvZHVjZSBhIGNvbXBvdW5kIHNlbGVjdG9yICovXHJcbiAgICBpdGVtczogQ3NzU2VsZWN0b3JbXTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgbWVhbnMgdG8gYnVpbGQgY29tcGxleCBzZWxlY3RvcnMgZnJvbSBtdWx0aXBsZSBzZWxlY3RvciBpdGVtcyBvZiBhbGwgcG9zc2libGUga2luZHNcclxuICogaW5jbHVkaW5nIHRhZ3MsIGNsYXNzZXNzLCBJRHMsIGF0dHJpYnV0ZXMsIHBzZXVkbyBjbGFzc2VzIGFuZCBwc2V1ZG8gZWxlbWVudHMgY29tYmluZWQgd2l0aFxyXG4gKiBDU1MgY29tYmluYXRvcnMuIFRoaXMgaW50ZXJmYWNlIGlzIHJldHVybmVkIGZyb20gdGhlIFtbc2VsXV0gZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTZWxlY3RvckJ1aWxkZXIgZXh0ZW5kcyBJU2VsZWN0b3JGdW5jXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBzZWxlY3RvciBpdGVtcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yIGFuZCBlYWNoIG90aGVyLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB3aXRob3V0IGFueSBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgZG9lc24ndCBoYXZlIGFueSBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBzZWN0aW9uLmMxLmMyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwic2VjdGlvblwiKS5hbmQoIHRoaXMuYzEsIHRoaXMuYzIpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIExpc3Qgb2Ygc2VsZWN0b3JzIHRvIGJlIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIGFuZCggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBzZWxlY3RvciBpdGVtcyB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgYXMgYSBsaXN0IG9mIHNlbGVjdG9ycy4gQWxsIGl0ZW1zXHJcbiAgICAgKiBhcmUgIGNvbmNhdGVuYXRlZCBhbmQgYXR0YWNoZWQgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIHVzaW5nIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuIENhbGxpbmdcclxuICAgICAqIHRoaXMgbWV0aG9kIHdpdGhvdXQgYW55IGFyZ3VtZW50cyBpbnNlcnRzIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBzZWN0aW9uLCAuYzEsIC5jMiB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikub3IoIHRoaXMuYzEsIHRoaXMuYzIpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIExpc3Qgb2Ygc2VsZWN0b3JzIHRvIGJlIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIG9yKCAuLi5pdGVtczogQ3NzU2VsZWN0b3JbXSk6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIHNlbGVjdG9yIGl0ZW1zIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciBhcyBjb25zZWN1dGl2ZSBpbW1lZGlhdGUgY2hpbGRyZW4uXHJcbiAgICAgKiBBbGwgaXRlbXMgYXJlIGNvbmNhdGVuYXRlZCBhbmQgYXR0YWNoZWQgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIHVzaW5nIHRoZSBgXCI+XCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGhvdXQgYW55IGFyZ3VtZW50cyBpbnNlcnRzIHRoZSBgXCI+XCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBzZWN0aW9uID4gLmMxID4gLmMyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwic2VjdGlvblwiKS5jaGlsZCggdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgTGlzdCBvZiBzZWxlY3RvcnMgdG8gYmUgYWRkZWRcclxuICAgICAqL1xyXG4gICAgY2hpbGQoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgc2VsZWN0b3IgaXRlbXMgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIGFzIGNvbnNlY3V0aXZlIGRlc2NlbmRhbnRzLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB1c2luZyB0aGUgYFwiIFwiYCBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgaW5zZXJ0cyB0aGUgYFwiIFwiYCBjb21iaW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGMxID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqICAgICBjMiA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogc2VjdGlvbiAuYzEgLmMyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwic2VjdGlvblwiKS5kZXNjKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBkZXNjKCAuLi5pdGVtczogQ3NzU2VsZWN0b3JbXSk6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIHNlbGVjdG9yIGl0ZW1zIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciBhcyBjb25zZWN1dGl2ZSBnZW5lcmFsIHNpYmxpbmdzLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB1c2luZyB0aGUgYFwiflwiYCBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgaW5zZXJ0cyB0aGUgYFwiflwiYCBjb21iaW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGMxID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqICAgICBjMiA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogc2VjdGlvbiB+IC5jMSB+IC5jMiB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuc2liKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBzaWIoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgc2VsZWN0b3IgaXRlbXMgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIGFzIGNvbnNlY3V0aXZlIGFkamFjZW50IHNpYmxpbmdzLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB1c2luZyB0aGUgYFwiK1wiYCBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgaW5zZXJ0cyB0aGUgYFwiK1wiYCBjb21iaW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGMxID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqICAgICBjMiA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogc2VjdGlvbiArIC5jMSArIC5jMiB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuYWRqKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBhZGooIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gYXR0cmlidXRlIHNlbGVjdG9yIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IuIFRoaXMgdmFyaWFudCBkb2Vzbid0XHJcbiAgICAgKiBhY2NlcHQgY29tcGFyaXNvbiBvcGVyYXRpb24gYW5kLCB0aGVyZWZvcmUsIHBlcmZvcm1zIHJlZ3VsYXIgZXF1YWxpdHkgY29tcGFyaXNvbi4gSXQgYWxzb1xyXG4gICAgICogYWxsb3dzIG9taXR0aW5nIHRoZSB2YWx1ZSwgaW4gd2hpY2ggY2FzZSwgb25seSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGF0dHJpYnV0ZSBpcyBjaGVja2VkLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogZGl2Olt0aXRsZV0gey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJkaXZcIikuYXR0ciggXCJ0aXRsZVwiKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogYTpbaHJlZj1cImh0dHBzOi8vd3d3LmV4YW1wbGUuY29tXCJdIHsuLi59XHJcbiAgICAgKiAgICAgczIgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwiYVwiKS5hdHRyKCBcImhyZWZcIiwgXCJodHRwczovL3d3dy5leGFtcGxlLmNvbVwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIHZhbCBBdHRyaWJ1dGUgdmFsdWUgLSBpZiBvbWl0dGVkLCBvbmx5IGF0dHJpYnV0ZSBwcmVzZW5jZSBpcyBjaGVja2VkLlxyXG4gICAgICogQHBhcmFtIGNmIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgY29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlLiBVbmRlZmluZWRcclxuICAgICAqIHZhbHVlIG1lYW5zIHRoZSBjb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLlxyXG4gICAgICogQHBhcmFtIG5zIEF0dHJpYnV0ZSdzIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgYXR0ciggbmFtZTogc3RyaW5nLCB2YWw/OiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyLCBjZj86IFwiaVwiIHwgXCJzXCIsIG5zPzogc3RyaW5nIHwgSU5hbWVzcGFjZVJ1bGUpOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogYTpbaHJlZl49XCJodHRwczovL1wiXSB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcImFcIikuYXR0ciggXCJocmVmXCIsIFwiXj1cIiwgXCJodHRwczovL1wiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG9wIEF0dHJidXRlIGNvbXBhcmlzb24gb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHZhbCBBdHRyaWJ1dGUgdmFsdWUgLSBpZiBvbWl0dGVkLCBvbmx5IGF0dHJpYnV0ZSBwcmVzZW5jZSBpcyBjaGVja2VkLlxyXG4gICAgICogQHBhcmFtIGNmIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgY29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlLiBVbmRlZmluZWRcclxuICAgICAqIHZhbHVlIG1lYW5zIHRoZSBjb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLlxyXG4gICAgICogQHBhcmFtIG5zIEF0dHJpYnV0ZSdzIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgYXR0ciggbmFtZTogc3RyaW5nLCBvcDogQXR0ckNvbXBhcmlzb25PcGVyYXRpb24sIHZhbDogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcixcclxuICAgICAgICBjZj86IFwiaVwiIHwgXCJzXCIsIG5zPzogc3RyaW5nIHwgSU5hbWVzcGFjZVJ1bGUpOiB0aGlzO1xyXG5cclxuXHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjphY3RpdmVcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGFjdGl2ZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmFueS1saW5rXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBhbnlMaW5rOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6YXV0b2ZpbGxcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGF1dG9maWxsOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6YmxhbmtcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGJsYW5rOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6Y2hlY2tlZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgY2hlY2tlZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmRlZmF1bHRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGRlZmF1bHQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpkZWZpbmVkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBkZWZpbmVkOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmRpcigpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBkaXJlY3Rpb24gdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZVxyXG4gICAgICogZXhpc3Rpbmcgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGRpciggZGlyZWN0aW9uOiBEaXJlY3Rpb24pOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZGlzYWJsZWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGRpc2FibGVkOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZW1wdHlcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGVtcHR5OiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZW5hYmxlZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZW5hYmxlZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmZpcnN0LWNoaWxkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBmaXJzdENoaWxkOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6Zmlyc3Qtb2YtdHlwZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZmlyc3RPZlR5cGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpmaXJzdFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZmlyc3Q6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpmb2N1cy12aXNpYmxlXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBmb2N1c1Zpc2libGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpmb2N1cy13aXRoaW5cImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGZvY3VzV2l0aGluOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6Zm9jdXNcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGZvY3VzOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZnVsbHNjcmVlblwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZnVsbHNjcmVlbjogdGhpcztcclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8gVGhlIFwiaGFzXCIgbWV0aG9kIGlzIGNvbW1lbnRlZCBvdXQgYmVjYXVzZSBpdCBpcyBub3QgY2xlYXIgeWV0IGhvdyB0b1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vIGltcGxlbWVudCBpdCBpbiBhbiBlbGVnYW50IHdheSwgYW5kIGJlY2F1c2UgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBpdC5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gICogQWRkcyB0aGUgYFwiOmhhcygpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZiBtdWx0aXBsZVxyXG4gICAgLy8gICogaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZCB1c2luZ1xyXG4gICAgLy8gICogdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiAqKkV4YW1wbGU6KipcclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAvLyAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgIC8vICAqIHtcclxuICAgIC8vICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAvLyAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgLy8gICpcclxuICAgIC8vICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHNlY3Rpb246aGFzKC5jMSwgLmMyKSB7Li4ufVxyXG4gICAgLy8gICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuaGFzKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAvLyAgKiB9XHJcbiAgICAvLyAgKiBgYGBcclxuICAgIC8vICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgLy8gICovXHJcbiAgICAvLyBoYXMoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuICAgIC8vIC8qKlxyXG4gICAgLy8gICogQWRkcyB0aGUgYFwiOmhhcygpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHBhcnRpYWwgc2VsZWN0b3IgdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gY29tYmluYXRvci5cclxuICAgIC8vICAqIElmIG11bHRpcGxlIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIGNvbmNhdGVuYXRlZCB1c2luZyB0aGUgZ2l2ZW4gY29tYmluYXRvci4gQVxyXG4gICAgLy8gICogc3BlY2lhbCB2YWx1ZSBgXCJcImAgKGVtcHR5IHN0cmluZykgb2YgdGhlIGBjb21iaW5hdG9yYCBwYXJhbWV0ZXIgYWxsb3dzIHRvIGNvbmNhdGVuYXRlIHRoZVxyXG4gICAgLy8gICogaXRlbXMgd2l0aG91dCBhbnkgY29tYmluYXRvci5cclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiAqKkV4YW1wbGU6KipcclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAvLyAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgIC8vICAqIHtcclxuICAgIC8vICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAvLyAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgLy8gICpcclxuICAgIC8vICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHNlY3Rpb246aGFzKD4gLmMxID4gLmMyKSB7Li4ufVxyXG4gICAgLy8gICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuaGFzKCBcIj5cIiwgdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgLy8gICpcclxuICAgIC8vICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHNlY3Rpb246aGFzKC5jMS5jMikgey4uLn1cclxuICAgIC8vICAqICAgICBzMiA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJzZWN0aW9uXCIpLmhhcyggXCJcIiwgdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgLy8gICogfVxyXG4gICAgLy8gICogYGBgXHJcbiAgICAvLyAgKiBAcGFyYW0gY29tYmluYXRvciBDb21iaW5hdG9yIHRvIHVzZSB0byBjb25jYXRlbmF0ZSB0aGUgaXRlbXMgYW5kIHRvIGF0dGFjaCB0aGVtIHRvIHRoZVxyXG4gICAgLy8gICogZXhpc3Rpbmcgc2VsZWN0b3IuXHJcbiAgICAvLyAgKiBAcGFyYW0gaXRlbXMgTGlzdCBvZiBzZWxlY3RvcnMgdG8gYmUgYWRkZWRcclxuICAgIC8vICAqL1xyXG4gICAgLy8gaGFzKCBjb21iaW5hdG9yOiBTZWxlY3RvckNvbWJpbmF0b3IgfCBcIlwiLCAuLi5pdGVtczogQ3NzU2VsZWN0b3JbXSk6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpob3N0XCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBob3N0OiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmhvc3QoKVwiYCBwYXJhbWV0ZXJpemVkIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLlxyXG4gICAgICogVGhlIG1ldGhvZCBoYXMgdGhlIGRvbGxhci1zaWduIGluIGl0cyBuYW1lIHRvIGRpZmZlcmVudGlhdGUgaXQgZnJvbSB0aGUgcHJvcGVydHkgW1tob3N0XV0uXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiA6aG9zdCguYzEsIC5jMikgey4uLn1cclxuICAgICAqICAgICBzID0gY3NzLiRzdHlsZSggY3NzLnNlbCgpLmhvc3QkKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBob3N0JCggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmhvc3QtY29udGV4dCgpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZlxyXG4gICAgICogbXVsdGlwbGUgaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZFxyXG4gICAgICogdXNpbmcgdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IDpob3N0LWNvbnRleHQoLmMxLCAuYzIpIHsuLi59XHJcbiAgICAgKiAgICAgcyA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoKS5ob3N0Q29udGV4dCggdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgTGlzdCBvZiBzZWxlY3RvcnMgdG8gYmUgYWRkZWRcclxuICAgICAqL1xyXG4gICAgaG9zdENvbnRleHQoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmhvdmVyXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBob3ZlcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmluLXJhbmdlXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBpblJhbmdlOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6aW5kZXRlcm1pbmF0ZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgaW5kZXRlcm1pbmF0ZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmludmFsaWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGludmFsaWQ6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBgXCI6aXMoKVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3Rvci4gSWYgbXVsdGlwbGVcclxuICAgICAqIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIGludGVycHJldGVkIGFzIGEgbGlzdDsgdGhhdCBpcywgdGhleSBhcmUgY29tYmluZWQgdXNpbmdcclxuICAgICAqIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiA6aXMoLmMxLCAuYzIpID4gcDpob3ZlciB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbCgpLmlzKCB0aGlzLmMxLCB0aGlzLmMyKS5jaGlsZFwicDpob3ZlclwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBpcyggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmxhbmcoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBsYW5nKCBsYW5nQ29kZTogc3RyaW5nKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmxhc3QtY2hpbGRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGxhc3RDaGlsZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmxhc3Qtb2YtdHlwZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgbGFzdE9mVHlwZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmxlZnRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGxlZnQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpsaW5rXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBsaW5rOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm5vdCgpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZiBtdWx0aXBsZVxyXG4gICAgICogaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZCB1c2luZ1xyXG4gICAgICogdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBmYW5jeSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogdGguZmFuY3k6bm90KDpudGgtb2YtdHlwZSgxKSkgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJ0aFwiKS5hbmQodGhpcy5mYW5jeSkubm90KCBcIjpudGgtb2YtdHlwZSgxKVwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBub3QoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjpudGgtY2hpbGQoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWNoaWxkKFwib2RkXCIpIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhDaGlsZChcIm9kZFwiKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtY2hpbGQoMykgey4uLn1cclxuICAgICAqICAgICBzMiA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aENoaWxkKDMpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1jaGlsZCgzbikgey4uLn1cclxuICAgICAqICAgICBzMyA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aENoaWxkKFszXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWNoaWxkKDNuKzEpIHsuLi59XHJcbiAgICAgKiAgICAgczQgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhDaGlsZChbMywxXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWNoaWxkKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczUgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhDaGlsZChbMywtMV0pLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIG50aEV4cHIgU3RyaW5nLCBudW1iZXIgb3IgdHVwbGUgcHJvdmlkaW5nIHRoZSB2YWx1ZSBmb3IgdGhlIGBcIm50aFwiYCBleHByZXNzaW9uXHJcbiAgICAgKi9cclxuICAgIG50aENoaWxkKCBudGhFeHByOiBOdGhFeHByZXNzaW9uKTogdGhpcztcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm50aC1jaGlsZCgpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtY2hpbGQoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aENoaWxkKDMsIDEpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1jaGlsZCgzbi0xKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoQ2hpbGQoMywgLTEpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGEgTnVtYmVyIGJlZm9yZSB0aGUgYFwiblwiYCBpbiB0aGUgYFwiQW4rQlwiYCBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gYiBOdW1iZXIgYWZ0ZXIgdGhlIGBcIitcImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvbi4gVXNlIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICAgKiB0byBjcmVhdGUgYSBgXCJBbi1CXCJgIGV4cHJlc3Npb24uXHJcbiAgICAgKi9cclxuICAgIG50aENoaWxkKCBhOiBudW1iZXIsIGI6IG51bWJlcik6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBgXCI6bnRoLWxhc3QtY2hpbGQoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3QtY2hpbGQoXCJvZGRcIikgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RDaGlsZChcIm9kZFwiKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1jaGlsZCgzKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdENoaWxkKDMpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LWNoaWxkKDNuKSB7Li4ufVxyXG4gICAgICogICAgIHMzID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdENoaWxkKFszXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3QtY2hpbGQoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzNCA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RDaGlsZChbMywxXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3QtY2hpbGQoM24tMSkgey4uLn1cclxuICAgICAqICAgICBzNSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RDaGlsZChbMywtMV0pLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIG50aEV4cHIgU3RyaW5nLCBudW1iZXIgb3IgdHVwbGUgcHJvdmlkaW5nIHRoZSB2YWx1ZSBmb3IgdGhlIGBcIm50aFwiYCBleHByZXNzaW9uXHJcbiAgICAgKi9cclxuICAgIG50aExhc3RDaGlsZCggbnRoRXhwcjogTnRoRXhwcmVzc2lvbik6IHRoaXM7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjpudGgtbGFzdC1jaGlsZCgpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1jaGlsZCgzbisxKSB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdENoaWxkKDMsIDEpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LWNoaWxkKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczIgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhMYXN0Q2hpbGQoMywgLTEpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGEgTnVtYmVyIGJlZm9yZSB0aGUgYFwiblwiYCBpbiB0aGUgYFwiQW4rQlwiYCBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gYiBOdW1iZXIgYWZ0ZXIgdGhlIGBcIitcImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvbi4gVXNlIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICAgKiB0byBjcmVhdGUgYSBgXCJBbi1CXCJgIGV4cHJlc3Npb24uXHJcbiAgICAgKi9cclxuICAgIG50aExhc3RDaGlsZCggYTogbnVtYmVyLCBiOiBudW1iZXIpOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm50aC1vZi10eXBlKClcImAgcHNldWRvIGNsYXNzIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1vZi10eXBlKFwib2RkXCIpIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhPZlR5cGUoXCJvZGRcIiksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLW9mLXR5cGUoMykgey4uLn1cclxuICAgICAqICAgICBzMiA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aE9mVHlwZSgzKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtb2YtdHlwZSgzbikgey4uLn1cclxuICAgICAqICAgICBzMyA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aE9mVHlwZShbM10pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1vZi10eXBlKDNuKzEpIHsuLi59XHJcbiAgICAgKiAgICAgczQgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhPZlR5cGUoWzMsMV0pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1vZi10eXBlKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczUgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhPZlR5cGUoWzMsLTFdKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBudGhFeHByIFN0cmluZywgbnVtYmVyIG9yIHR1cGxlIHByb3ZpZGluZyB0aGUgdmFsdWUgZm9yIHRoZSBgXCJudGhcImAgZXhwcmVzc2lvblxyXG4gICAgICovXHJcbiAgICBudGhPZlR5cGUoIG50aEV4cHI6IE50aEV4cHJlc3Npb24pOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBgXCI6bnRoLW9mLXR5cGUoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLW9mLXR5cGUoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aE9mVHlwZSgzLCAxKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtb2YtdHlwZSgzbi0xKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoT2ZUeXBlKDMsIC0xKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBhIE51bWJlciBiZWZvcmUgdGhlIGBcIm5cImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIGIgTnVtYmVyIGFmdGVyIHRoZSBgXCIrXCJgIGluIHRoZSBgXCJBbitCXCJgIGV4cHJlc3Npb24uIFVzZSBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICogdG8gY3JlYXRlIGEgYFwiQW4tQlwiYCBleHByZXNzaW9uLlxyXG4gICAgICovXHJcbiAgICBudGhPZlR5cGUoIGE6IG51bWJlciwgYjogbnVtYmVyKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjpudGgtbGFzdC1vZi10eXBlKClcImAgcHNldWRvIGNsYXNzIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LW9mLXR5cGUoXCJvZGRcIikgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RPZlR5cGUoXCJvZGRcIiksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3Qtb2YtdHlwZSgzKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdE9mVHlwZSgzKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1vZi10eXBlKDNuKSB7Li4ufVxyXG4gICAgICogICAgIHMzID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdE9mVHlwZShbM10pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LW9mLXR5cGUoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzNCA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RPZlR5cGUoWzMsMV0pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LW9mLXR5cGUoM24tMSkgey4uLn1cclxuICAgICAqICAgICBzNSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RPZlR5cGUoWzMsLTFdKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBudGhFeHByIFN0cmluZywgbnVtYmVyIG9yIHR1cGxlIHByb3ZpZGluZyB0aGUgdmFsdWUgZm9yIHRoZSBgXCJudGhcImAgZXhwcmVzc2lvblxyXG4gICAgICovXHJcbiAgICBudGhMYXN0T2ZUeXBlKCBudGhFeHByOiBOdGhFeHByZXNzaW9uKTogdGhpcztcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm50aC1sYXN0LW9mLXR5cGUoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3Qtb2YtdHlwZSgzbisxKSB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdE9mVHlwZSgzLCAxKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1vZi10eXBlKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczIgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhMYXN0T2ZUeXBlKDMsIC0xKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBhIE51bWJlciBiZWZvcmUgdGhlIGBcIm5cImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIGIgTnVtYmVyIGFmdGVyIHRoZSBgXCIrXCJgIGluIHRoZSBgXCJBbitCXCJgIGV4cHJlc3Npb24uIFVzZSBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICogdG8gY3JlYXRlIGEgYFwiQW4tQlwiYCBleHByZXNzaW9uLlxyXG4gICAgICovXHJcbiAgICBudGhMYXN0T2ZUeXBlKCBhOiBudW1iZXIsIGI6IG51bWJlcik6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvbmx5LWNoaWxkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBvbmx5Q2hpbGQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvbmx5LW9mLXR5cGVcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IG9ubHlPZlR5cGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvcHRpb25hbFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgb3B0aW9uYWw6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvdXQtb2YtcmFuZ2VcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IG91dE9mUmFuZ2U6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpwYXVzZWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHBhdXNlZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnBpY3R1cmUtaW4tcGljdHVyZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcGljdHVyZUluUGljdHVyZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnBsYWNlaG9sZGVyLXNob3duXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBwbGFjZWhvbGRlclNob3duOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6cGxheWluZ1wiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcGxheWluZzogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnJlYWQtb25seVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcmVhZE9ubHk6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyZWFkLXdyaXRlXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSByZWFkV3JpdGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyZXF1aXJlZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcmVxdWlyZWQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyaWdodFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcmlnaHQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyb290XCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSByb290OiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6c2NvcGVcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHNjb3BlOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6dGFyZ2V0XCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSB0YXJnZXQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjp2YWxpZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgdmFsaWQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjp2aXNpdGVkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSB2aXNpdGVkOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6dXNlci1pbnZhbGlkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSB1c2VySW52YWxpZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnVzZXItdmFsaWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHVzZXJWYWxpZDogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjp3aGVyZSgpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZiBtdWx0aXBsZVxyXG4gICAgICogaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZCB1c2luZ1xyXG4gICAgICogdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IDp3aGVyZSguYzEsIC5jMikgPiBwOmhvdmVyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKCkud2hlcmUoIHRoaXMuYzEsIHRoaXMuYzIpLmNoaWxkKFwicDpob3ZlclwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICB3aGVyZSggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuXHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjo6YWZ0ZXJcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgYWZ0ZXI6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjo6YmFja2Ryb3BcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgYmFja2Ryb3A6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjo6YmVmb3JlXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGJlZm9yZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpjdWUtcmVnaW9uXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGN1ZVJlZ2lvbjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpjdWVcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgY3VlOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6OmZpcnN0LWxldHRlclwiYCBwc2V1ZG8gZWxlbWVudCB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBmaXJzdExldHRlcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpmaXJzdC1saW5lXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGZpcnN0TGluZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpncmFtbWFyLWVycm9yXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGdyYW1tYXJFcnJvcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjptYXJrZXJcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgbWFya2VyOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOjpwYXJ0KClcImAgcHNldWRvIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVyLlxyXG4gICAgICovXHJcbiAgICBwYXJ0KCBwYXJ0TmFtZTogc3RyaW5nKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpwbGFjZWhvbGRlclwiYCBwc2V1ZG8gZWxlbWVudCB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBwbGFjZWhvbGRlcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpzZWxlY3Rpb25cImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgc2VsZWN0aW9uOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOjpzbG90dGVkKClcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3Rvci4gSWZcclxuICAgICAqIG11bHRpcGxlIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIGludGVycHJldGVkIGFzIGEgbGlzdDsgdGhhdCBpcywgdGhleSBhcmUgY29tYmluZWRcclxuICAgICAqIHVzaW5nIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiA6OnNsb3R0ZWQoLmMxLCAuYzIpIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKCkuc2xvdHRlZCggdGhpcy5jMSwgdGhpcy5jMikpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIExpc3Qgb2Ygc2VsZWN0b3JzIHRvIGJlIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIHNsb3R0ZWQoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpzcGVsbGluZy1lcnJvclwiYCBwc2V1ZG8gZWxlbWVudCB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBzcGVsbGluZ0Vycm9yOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6OnRhcmdldC10ZXh0XCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHRhcmdldFRleHQ6IHRoaXM7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgZm9yIGEgQ1NTIHNlbGVjdG9yLiBUaGlzIHR5cGUgaXMgdXNlZCB0byBwcm9kdWNlIGFyYml0cmFyeSBjb21wbGV4IHNlbGVjdG9ycyB1c2VkIGJ5IHRoZVxyXG4gKiBbWyRzdHlsZV1dIGZ1bmN0aW9uLiBJZiBhcnJheSBpcyBzcGVjaWZpZWQsIGFsbCBpdGVtcyBhcmUgY29udmVydGVkIHRvIHN0cmluZ3MgYW5kIGNvbmNhdGVuYXRlZC5cclxuICovXHJcbmV4cG9ydCB0eXBlIENzc1NlbGVjdG9yID0gRWxlbWVudFRhZ05hbWUgfCBJTlNUYWdGdW5jIHwgUHNldWRvRW50aXR5IHwgSVJ1bGVXaXRoU2VsZWN0b3IgfFxyXG4gICAgSVNlbGVjdG9yUHJveHkgfCBJU2VsZWN0b3JGdW5jIHwgSUF0dHJTZWxlY3RvckZ1bmMgfCBJUGFyYW1ldGVyaXplZFBzZXVkb0VudGl0eUZ1bmM8YW55PiB8XHJcbiAgICBTZWxlY3RvckNvbWJpbmF0b3IgfCBJUmF3UHJveHkgfCBzdHJpbmcgfCBDc3NTZWxlY3RvcltdO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gTWlzY2VsbGFuZW91cyBDU1MgdHlwZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgZm9yIHNpbXBsZSBhbmltYXRpb24gdGltaW5nIGZ1bmN0aW9ucyAtIHRob3NlIHRoYXQgZG9uJ3QgaGF2ZSBwYXJhbWV0ZXJzXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBUaW1pbmdGdW5jdGlvbktleXdvcmRzID0gXCJsaW5lYXJcIiB8IFwiZWFzZVwiIHwgXCJlYXNlLWluXCIgfCBcImVhc2Utb3V0XCIgfCBcImVhc2UtaW4tb3V0XCIgfCBcInN0ZXAtc3RhcnRcIiB8IFwic3RlcC1lbmRcIjtcclxuXHJcblxyXG5cclxuLyoqIFR5cGUgZm9yIHN0ZXAgYW5pbWF0aW9uIHRpbWluZyBmdW5jdGlvbiBqdW1wLXRlcm0gKi9cclxuZXhwb3J0IHR5cGUgVGltaW5nRnVuY3Rpb25KdW1wVGVybSA9IFwianVtcC1zdGFydFwiIHwgXCJqdW1wLWVuZFwiIHwgXCJqdW1wLW5vbmVcIiB8IFwianVtcC1ib3RoXCIgfCBcInN0YXJ0XCIgfCBcImVuZFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBJU3RlcHNGdW5jIGludGVyZmFjZSByZXByZXNlbnRzIGFuIGludm9jYXRpb24gb2YgdGhlIENTUyBgc3RlcHMoKWAgZnVuY3Rpb24uIEl0IGlzIHJldHVybmVkXHJcbiAqIGZyb20gdGhlIFtbc3RlcHNdXSBmdW5jdGlvbi5cclxuICogQGNhdGVnb3J5IFRyYW5zaXRpb24gYW5kIEFuaW1hdGlvblxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJU3RlcHNGdW5jIGV4dGVuZHMgSUNzc0Z1bmNPYmplY3Rcclxue1xyXG4gICAgZm46IFwic3RlcHNcIjtcclxuXHJcbiAgICAvKiogTnVtYmVyIG9mIHN0b3BzICovXHJcbiAgICBuOiBFeHRlbmRlZDxudW1iZXI+O1xyXG5cclxuICAgIC8qKiBKdW1wIHRlcm0gKi9cclxuICAgIGo/OiBUaW1pbmdGdW5jdGlvbkp1bXBUZXJtO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgSUN1YmljQmV6aWVyRnVuYyBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBDU1MgYGN1YmljLWJlemllcigpYCBmdW5jdGlvbi5cclxuICogSXQgaXMgcmV0dXJuZWQgZnJvbSB0aGUgW1tjdWJpY0Jlemllcl1dIGZ1bmN0aW9uLlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNpdGlvbiBhbmQgQW5pbWF0aW9uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElDdWJpY0JlemllckZ1bmMgZXh0ZW5kcyBJQ3NzRnVuY09iamVjdFxyXG57XHJcbiAgICBmbjogXCJjdWJpYy1iZXppZXJcIjtcclxuXHJcbiAgICBuMTogRXh0ZW5kZWQ8bnVtYmVyPjtcclxuICAgIG4yOiBFeHRlbmRlZDxudW1iZXI+O1xyXG4gICAgbjM6IEV4dGVuZGVkPG51bWJlcj4sXHJcbiAgICBuNDogRXh0ZW5kZWQ8bnVtYmVyPjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSBmb3Igc2luZ2xlIGFuaW1hdGlvbiB0aW1pbmcgZnVuY3Rpb25cclxuICpcclxuICovXHJcbmV4cG9ydCB0eXBlIFRpbWluZ0Z1bmN0aW9uID0gVGltaW5nRnVuY3Rpb25LZXl3b3JkcyB8IElTdGVwc0Z1bmMgfCBJQ3ViaWNCZXppZXJGdW5jO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIElVcmxGdW5jIGludGVyZmFjZSByZXByZXNlbnRzIGFuIGludm9jYXRpb24gb2YgdGhlIENTUyBgdXJsKClgIGZ1bmN0aW9uLiBJdCBpcyByZXR1cm5lZCBmcm9tXHJcbiAqIHRoZSBbW3VybF1dIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJVXJsRnVuYyBleHRlbmRzIElDc3NGdW5jT2JqZWN0XHJcbntcclxuICAgIGZuOiBcInVybFwiO1xyXG5cclxuICAgIC8qKiBVUkwgb3IgcmVmZXJlbmNlIHRvIHRoZSBJRCBydWxlIGlkZW50aWZ5aW5nIGFuIFNWRyBlbGVtZW50ICovXHJcbiAgICBwOiBFeHRlbmRlZDxzdHJpbmcgfCBJSURSdWxlPjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIElDdXJzb3JGdW5jIGludGVyZmFjZSByZXByZXNlbnRzIGFuIGludm9jYXRpb24gb2YgdGhlIENTUyBgdXJsKClgIGZ1bmN0aW9uIHdpdGggdHdvIG9wdGlvbmFsXHJcbiAqIG51bWJlcnMgaW5kaWNhdGluZyB0aGUgY3Vyc29yJ3MgaG90c3BvdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUN1cnNvckZ1bmMgZXh0ZW5kcyBJQ3NzRnVuY09iamVjdFxyXG57XHJcbiAgICBmbjogXCJjdXJzb3JcIjtcclxuXHJcbiAgICAvKiogQ3Vyc29yIFVSTCBvciByZWZlcmVuY2UgdG8gdGhlIElEIHJ1bGUgaWRlbnRpZnlpbmcgYW4gU1ZHIGVsZW1lbnQgKi9cclxuICAgIHVybDogRXh0ZW5kZWQ8c3RyaW5nIHwgSUlEUnVsZT47XHJcblxyXG4gICAgLyoqIFgtY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIGhvdHNwb3QgKi9cclxuICAgIHg/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFktY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIGhvdHNwb3QgKi9cclxuICAgIHk/OiBudW1iZXI7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEltYWdlIGFuZCBncmFkaWVudCBDU1MgZnVuY3Rpb25zLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUeXBlIHJlcHJlc2VudGluZyBleHRlbnQgZm9yIHRoZSBbW3JhZGlhbEdyYWRpZW50XV0gb3IgW1tyYXldXSBmdW5jdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBFeHRlbnRLZXl3b3JkID0gXCJjbG9zZXN0LWNvcm5lclwiIHwgXCJjbG9zZXN0LXNpZGVcIiB8IFwiZmFydGhlc3QtY29ybmVyXCIgfCBcImZhcnRoZXN0LXNpZGVcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gb2JqZWN0IHRoYXQgcHJvZHVjZXMgb25lIG9mIENTUyBncmFkaWVudCBmdW5jdGlvbi4gSXQgY2FuIGJlIGRpcmVjdGx5IGFzc2lnbmVkIHRvXHJcbiAqIGEgc3VpdGFibGUgc3R5bGUgcHJvcGVydHkgKGUuZy4gYmFja2dyb3VuZC1pbWFnZSkuIE9iamVjdHMgaW1wbGVtZW50aW5nIHRoaXMgaW50ZXJmYWNlIGNhbiBiZVxyXG4gKiB1c2VkIHdoZXJlZXZlciBncmFkaWVudHMgYXJlIHVzZWQuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElDc3NJbWFnZUZ1bmMgZXh0ZW5kcyBJQ3NzRnVuY09iamVjdFxyXG57XHJcbiAgICBmbjogXCJsaW5lYXItZ3JhZGllbnRcIiB8IFwicmFkaWFsLWdyYWRpZW50XCIgfCBcImNvbmljLWdyYWRpZW50XCIgfFxyXG4gICAgICAgIFwiY3Jvc3MtZmFkZVwiIHwgXCJpbWFnZS1zZXRcIiB8IFwicGFpbnRcIjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIENzc0ltYWdlIHR5cGUgcmVwcmVzZW50cyBhIHR5cGUgdXNlZCBmb3IgQ1NTIHByb3BlcnRpZXMgdGhhdCBhY2NlcHQgdGhlIGA8aW1hZ2U+YCB0eXBlLlxyXG4gKiBJbWFnZSBjYW4gYmUgc3BlY2lmaWVkIGVpdGhlciB1c2luZyB0aGUgW1t1cmxdXSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIFtbSVVybEZ1bmNdXVxyXG4gKiBpbnRlcmZhY2Ugb3IgYW55IG9mIHRoZSBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdGhlIFtbSUltYWdlUHJveHldXSBvciBbW0lDc3NJbWFnZUZ1bmNdXVxyXG4gKiBpbnRlcmZhY2Ugc3VjaCBhcyBbW2xpbmVhckdyYWRpZW50XV0gYW5kIFtbY3Jvc3NGYWRlXV0uXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDc3NJbWFnZSA9IElVcmxGdW5jIHwgSUNzc0ltYWdlRnVuYztcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFdlYiBOYW1lc3BhY2VzLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUaGUgV2ViTmFtZXNwYWNlcyBlbnVtZXJhdGlvbiBwcm92aWRlcyBpZGVudGlmaWVycyBmb3IgdGhlIGtub3duIFdlYi1yZWxhdGVkIG5hbWVzcGFjZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZW51bSBXZWJOYW1lc3BhY2VzXHJcbntcclxuICAgIEhUTUwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcclxuICAgIFNWRyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcclxuICAgIFhMaW5rID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXHJcbiAgICBYTUwgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxyXG4gICAgWE1MTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCIsXHJcbiAgICBNYXRoTUwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixcclxufVxyXG5cclxuXHJcblxyXG4iLCLvu79pbXBvcnQge0V4dGVuZGVkLCBJR2VuZXJpY1Byb3h5fSBmcm9tIFwiLi9Db3JlVHlwZXNcIlxyXG5pbXBvcnQge1xyXG4gICAgSUxlbmd0aFByb3h5LCBJUGVyY2VudFByb3h5LCBJQW5nbGVQcm94eSwgSVRpbWVQcm94eSwgSVJlc29sdXRpb25Qcm94eSwgSUZyZXF1ZW5jeVByb3h5LFxyXG4gICAgQ3NzTGVuZ3RoLCBJRml0Q29udGVudFByb3h5LCBDc3NOdW1iZXIsIElBc3BlY3RSYXRpb1Byb3h5LCBJTnVtYmVyTWF0aCwgSVBlcmNlbnRNYXRoLFxyXG4gICAgSUxlbmd0aE1hdGgsIElBbmdsZU1hdGgsIElUaW1lTWF0aCwgSVJlc29sdXRpb25NYXRoLCBJRnJlcXVlbmN5TWF0aCwgSVJlY3RQcm94eSxcclxufSBmcm9tIFwiLi9OdW1lcmljVHlwZXNcIlxyXG5pbXBvcnQge051bWJlck1hdGgsIFBlcmNlbnRNYXRoLCBMZW5ndGhNYXRoLCBBbmdsZU1hdGgsIFRpbWVNYXRoLCBSZXNvbHV0aW9uTWF0aCwgRnJlcXVlbmN5TWF0aH0gZnJvbSBcIi4uL2ltcGwvTnVtZXJpY0ltcGxcIlxyXG5pbXBvcnQge2YycywgV0tGLCBhMnN9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcblxyXG5cclxuXHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHVuaXRzIGNvbnZlcnNpb25cclxuY29uc3QgdG9Vbml0c1Byb3h5ID0gKCBuOiBudW1iZXIsIHVuaXQ6IHN0cmluZyk6IElHZW5lcmljUHJveHkgPT4gKCkgPT4gbiArIHVuaXQ7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYE51bWAgb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZSBgPG51bWJlcj5gXHJcbiAqIENTUyB0eXBlLiBJdCBpbXBsZW1lbnRzIHRoZSBbW0lOdW1lcmljTWF0aF1dIGludGVyZmFjZSBhbmQgdGh1cyBhbGxvd3MgdXNpbmcgdGhlIG1ldGhvZHMgc3VjaFxyXG4gKiBhcyBbW21pbl1dLCBbW21heF1dLCBbW2NhbGNdXSBhbmQgW1tjbGFtcF1dIHdpdGggcGFyYW1ldGVycyBvZiB0aGUgW1tDc3NOdW1iZXJdXSB0eXBlLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gZGVmaW5lIGN1c3RvbSBDU1MgcHJvcGVydHkgLSBub3RlIHRoYXQgaXRzIHZhbHVlIGNhbiBiZSBjaGFuZ2VkXHJcbiAqICAgICAvLyBwcm9ncmFtbWF0aWNhbGx5XHJcbiAqICAgICBjb2x1bW5RdHkgPSB0aGlzLiR2YXIoIFwiQ3NzTnVtYmVyXCIsIDMpXHJcbiAqXHJcbiAqICAgICAvLyBtYXgoIDUsIHZhcigtLWNvbHVtblF0eSkpXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gKiAgICAgICAgIGNvbHVtbnM6IGNzcy5OdW0ubWF4KCA1LCB0aGlzLmNvbHVtblF0eSlcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTnVtOiBJTnVtYmVyTWF0aCA9IE51bWJlck1hdGg7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFBlcmNlbnRgIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxwZXJjZW50YWdlPmAgQ1NTIHR5cGUuIEl0IGltcGxlbWVudHMgdGhlIFtbSU51bWVyaWNNYXRoXV0gaW50ZXJmYWNlIGFuZCB0aHVzIGFsbG93cyB1c2luZ1xyXG4gKiB0aGUgbWV0aG9kcyBzdWNoIGFzIFtbbWluXV0sIFtbbWF4XV0sIFtbY2FsY11dIGFuZCBbW2NsYW1wXV0gd2l0aCBwYXJhbWV0ZXJzIG9mIHRoZVxyXG4gKiBbW0Nzc1BlcmNlbnRdXSB0eXBlLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgaW5pdGlhbFpvb20gPSBjc3MudmFyKCBcIkNzc1BlcmNlbnRcIiwgMS41KVxyXG4gKlxyXG4gKiAgICAgLy8gbWluKCAwLjUsIHZhcigtLWluaXRpYWxab29tKSlcclxuICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7XHJcbiAqICAgICAgICAgem9vbTogY3NzLlBlcmNlbnQubWluKCAwLjUsIHRoaXMuaW5pdGlhbFpvb20pXHJcbiAqICAgICB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFBlcmNlbnQ6IElQZXJjZW50TWF0aCA9IFBlcmNlbnRNYXRoO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgcGVyY2VudCB2YWx1ZSBieSBhcHBlbmZpbmcgdGhlIGBcIiVcImAgc2lnbiB0byB0aGUgZ2l2ZW4gbnVtYmVyLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZVxyXG4gKiB1c2VkIHdoZW5ldmVyIGEgYDxwZXJjZW50YWdlPmAgQ1NTIHR5cGUgaXMgdXNlZCBmb3IgYSBzdHlsZSBwcm9wZXJ0eSBvciB2YWx1ZS5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGVyY2VudCA9IChuOiBudW1iZXIpOiBJUGVyY2VudFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCIlXCIpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBMZW5gIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZS4gSXQgaW1wbGVtZW50cyB0aGUgW1tJTnVtZXJpY01hdGhdXSBpbnRlcmZhY2UgYW5kIHRodXNcclxuICogYWxsb3dzIHVzaW5nIHRoZSBtZXRob2RzIHN1Y2ggYXMgW1ttaW5dXSwgW1ttYXhdXSwgW1tjYWxjXV0gYW5kIFtbY2xhbXBdXSB3aXRoIHBhcmFtZXRlcnNcclxuICogb2YgdGhlIFtbQ3NzTGVuZ3RoXV0gdHlwZS5cclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIGRlZmF1bHRQYWRkaW5nID0gY3NzLnZhciggXCJDc3NMZW5ndGhcIiwgOClcclxuICpcclxuICogICAgIC8vIGNhbGMoIDIwMHB4IC0gKDIgKiB2YXIoLS1kZWZhdWx0UGFkZGluZykpKVxyXG4gKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICB3aWR0aDogY3NzLkxlbi5jYWxjYCAyMDBweCAtICgyICogJHt0aGlzLmRlZmF1bHRQYWRkaW5nfSlgXHJcbiAqICAgICB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExlbjogSUxlbmd0aE1hdGggPSBMZW5ndGhNYXRoO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIHF1YXJ0ZXJzIG9mIGFuIGluY2guXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFEgPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJRXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIGNoIHVuaXRzLCB3aGljaCBpcyBlcXVhbCB0byB0aGUgdXNlZCBhZHZhbmNlIG1lYXN1cmUgb2YgdGhlIGDigJww4oCdYCAoWkVSTyxcclxuICogVSswMDMwKSBnbHlwaCBmb3VuZCBpbiB0aGUgZm9udCB1c2VkIHRvIHJlbmRlciBpdC4gKFRoZSBhZHZhbmNlIG1lYXN1cmUgb2YgYSBnbHlwaCBpcyBpdHNcclxuICogYWR2YW5jZSB3aWR0aCBvciBoZWlnaHQsIHdoaWNoZXZlciBpcyBpbiB0aGUgaW5saW5lIGF4aXMgb2YgdGhlIGVsZW1lbnQuKVxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBjaCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImNoXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIGNhbnRpbWV0ZXJzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBjbSA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImNtXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIGNhbGN1bGF0ZWQgZm9udC1zaXplcyBvZiB0aGUgZWxlbWVudC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZW0gPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJlbVwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiBoZWlnaHRzIG9mIGxvd2VyY2FzZSBsZXR0ZXIgJ3gnIGluIHRoZSBmb250LlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBleCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImV4XCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIGljIHVuaXRzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBpYyA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImljXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIGluY2hlcy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW5jaCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImluXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIGxpbmUtaGVpZ2h0cyBvZiB0aGUgZWxlbWVudC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGggPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJsaFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiBtaWxsaW1ldGVycy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbW0gPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJtbVwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiBwaWNhcy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGMgPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJwY1wiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiBwb2ludHMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHB0ID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwicHRcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gcGl4ZWxzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBweCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInB4XCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIDElIG9mIHRoZSBzaXplIG9mIHRoZSBpbml0aWFsIGNvbnRhaW5pbmcgYmxvY2ssIGluIHRoZSBkaXJlY3Rpb25cclxuICogb2YgdGhlIHJvb3QgZWxlbWVudOKAmXMgYmxvY2sgYXhpcy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdmIgPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJ2YlwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiAxJSBvZiB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCdzIGluaXRpYWwgY29udGFpbmluZyBibG9jay5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdmggPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJ2aFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiAxJSBvZiB0aGUgc2l6ZSBvZiB0aGUgaW5pdGlhbCBjb250YWluaW5nIGJsb2NrLCBpbiB0aGUgZGlyZWN0aW9uXHJcbiAqIG9mIHRoZSByb290IGVsZW1lbnTigJlzIGlubGluZSBheGlzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCB2aSA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInZpXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIDElIG9mIHRoZSB3aWR0aCBvZiB0aGUgdmlld3BvcnQncyBpbml0aWFsIGNvbnRhaW5pbmcgYmxvY2suXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZ3ID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwidndcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gZm9udC1zaXplcyBvZiB0aGUgcm9vdCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCByZW0gPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJyZW1cIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gbGluZS1oZWlnaHRzIG9mIHRoZSByb290IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJsaCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInJsaFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiB0aGUgdW5pdHMgd2hpY2ggYXJlIGEgc21hbGxlciB2YWx1ZSBiZXR3ZWVuIHZ3IGFuZCB2aC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgdm1pbiA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInZtaW5cIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gdGhlIHVuaXRzIHdoaWNoIGFyZSBhIGxhcmdlciB2YWx1ZSBiZXR3ZWVuIHZ3IGFuZCB2aC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgdm1heCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInZtYXhcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgZm9yIGZsZXguXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZyID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiZnJcIik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYEFuZ2xlYCBvYmplY3QgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIGA8YW5nbGU+IHwgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZS4gSXQgaW1wbGVtZW50cyB0aGUgW1tJTnVtZXJpY01hdGhdXSBpbnRlcmZhY2UgYW5kIHRodXNcclxuICogYWxsb3dzIHVzaW5nIHRoZSBtZXRob2RzIHN1Y2ggYXMgW1ttaW5dXSwgW1ttYXhdXSwgW1tjYWxjXV0gYW5kIFtbY2xhbXBdXSB3aXRoIHBhcmFtZXRlcnNcclxuICogb2YgdGhlIFtbQ3NzQW5nbGVdXSB0eXBlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEFuZ2xlOiBJQW5nbGVNYXRoID0gQW5nbGVNYXRoO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5nbGUgdmFsdWUgaW4gZGVncmVlcy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGVnID0gKG46IG51bWJlcik6IElBbmdsZVByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJkZWdcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbmdsZSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCByYWQgPSAobjogbnVtYmVyKTogSUFuZ2xlUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInJhZFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZ2xlIHZhbHVlIGluIGdyYWRpYW5zLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBncmFkID0gKG46IG51bWJlcik6IElBbmdsZVByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJncmFkXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5nbGUgdmFsdWUgaW4gdHVybnMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHR1cm4gPSAobjogbnVtYmVyKTogSUFuZ2xlUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInR1cm5cIik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFRpbWVgIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGUgYDx0aW1lPmBcclxuICogQ1NTIHR5cGUuIEl0IGltcGxlbWVudHMgdGhlIFtbSU51bWVyaWNNYXRoXV0gaW50ZXJmYWNlIGFuZCB0aHVzIGFsbG93cyB1c2luZyB0aGUgbWV0aG9kcyBzdWNoXHJcbiAqIGFzIFtbbWluXV0sIFtbbWF4XV0sIFtbY2FsY11dIGFuZCBbW2NsYW1wXV0gd2l0aCBwYXJhbWV0ZXJzIG9mIHRoZSBbW0Nzc1RpbWVdXSB0eXBlLlxyXG4gKi9cclxuIGV4cG9ydCBjb25zdCBUaW1lOiBJVGltZU1hdGggPSBUaW1lTWF0aDtcclxuXHJcbiAvKipcclxuICogQ3JlYXRlcyB0aW1lIHZhbHVlIGluIG1pbGxpc2Vjb25kcy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbXMgPSAobjogbnVtYmVyKTogSVRpbWVQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwibXNcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aW1lIHZhbHVlIGluIHNlY29uZHMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHMgPSAobjogbnVtYmVyKTogSVRpbWVQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwic1wiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgUmVzb2x1dGlvbmAgb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHJlc29sdXRpb24+YCBDU1MgdHlwZS4gSXQgaW1wbGVtZW50cyB0aGUgW1tJTnVtZXJpY01hdGhdXSBpbnRlcmZhY2UgYW5kIHRodXMgYWxsb3dzIHVzaW5nXHJcbiAqIHRoZSBtZXRob2RzIHN1Y2ggYXMgW1ttaW5dXSwgW1ttYXhdXSwgW1tjYWxjXV0gYW5kIFtbY2xhbXBdXSB3aXRoIHBhcmFtZXRlcnMgb2YgdGhlXHJcbiAqIFtbQ3NzUmVzb2x1dGlvbl1dIHR5cGUuXHJcbiAqL1xyXG4gZXhwb3J0IGNvbnN0IFJlc29sdXRpb246IElSZXNvbHV0aW9uTWF0aCA9IFJlc29sdXRpb25NYXRoO1xyXG5cclxuIC8qKlxyXG4gKiBDcmVhdGVzIHJlc29sdXRpb24gdmFsdWUgaW4gRFBJLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBkcGkgPSAobjogbnVtYmVyKTogSVJlc29sdXRpb25Qcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiZHBpXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVzb2x1dGlvbiB2YWx1ZSBpbiBEUENNLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBkcGNtID0gKG46IG51bWJlcik6IElSZXNvbHV0aW9uUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImRwY21cIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyByZXNvbHV0aW9uIHZhbHVlIGluIERQUFguXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRwcHggPSAobjogbnVtYmVyKTogSVJlc29sdXRpb25Qcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiZHBweFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlc29sdXRpb24gdmFsdWUgaW4gWC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgeCA9IChuOiBudW1iZXIpOiBJUmVzb2x1dGlvblByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJ4XCIpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBGcmVxdWVuY3lgIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGUgYDxmcmVxdWVuY3k+YFxyXG4gKiBDU1MgdHlwZS4gSXQgaW1wbGVtZW50cyB0aGUgW1tJTnVtZXJpY01hdGhdXSBpbnRlcmZhY2UgYW5kIHRodXMgYWxsb3dzIHVzaW5nIHRoZSBtZXRob2RzIHN1Y2hcclxuICogYXMgW1ttaW5dXSwgW1ttYXhdXSwgW1tjYWxjXV0gYW5kIFtbY2xhbXBdXSB3aXRoIHBhcmFtZXRlcnMgb2YgdGhlIFtbQ3NzRnJlcXVlbmN5XV0gdHlwZS5cclxuICovXHJcbiBleHBvcnQgY29uc3QgRnJlcXVlbmN5OiBJRnJlcXVlbmN5TWF0aCA9IEZyZXF1ZW5jeU1hdGg7XHJcblxyXG4gLyoqXHJcbiAqIENyZWF0ZXMgZnJlcXVlbmN5IHZhbHVlIGluIEhlcnR6LlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBoeiA9IChuOiBudW1iZXIpOiBJRnJlcXVlbmN5UHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImh6XCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgZnJlcXVlbmN5IHZhbHVlIGluIEtpbG8tSGVydHouXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGtoeiA9IChuOiBudW1iZXIpOiBJRnJlcXVlbmN5UHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImtoelwiKTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb25zXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJRml0Q29udGVudFByb3h5XV0gZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgZml0LWNvbnRlbnQoKWAgQ1NTIGZ1bmN0aW9uXHJcbiAqIChbTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZml0LWNvbnRlbnQoKSkpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZpdENvbnRlbnQgPSAoc2l6ZTogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElGaXRDb250ZW50UHJveHkgPT5cclxuICAgICgpID0+IGYycyggXCJmaXQtY29udGVudFwiLCBbW3NpemUsIFdLRi5MZW5ndGhdXSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFtbSUFzcGVjdFJhdGlvUHJveHldXSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGA8cmF0aW8+YCBDU1MgdHlwZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCByYXRpbyA9ICh3OiBDc3NOdW1iZXIsIGg/OiBDc3NOdW1iZXIpOiBJQXNwZWN0UmF0aW9Qcm94eSA9PiAoKSA9PiBbdyxoXS5qb2luKFwiL1wiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJUmVjdFByb3h5XV0gZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgcmVjdCgpYCBDU1MgZnVuY3Rpb24gdXNlZCBmb3IgdGhlIGBjbGlwYFxyXG4gKiBzdHlsZSBwcm9wZXJ0eS5cclxuICogQGRlcHJlY2F0ZWQgVGhlIENTUyBgY2xpcGAgcHJvcGVydHkgYW5kIGByZWN0KClgIGZ1bmN0aW9uIGFyZSBkZXByZWNhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlY3QgPSAodG9wOiBDc3NMZW5ndGgsIHJpZ2h0OiBDc3NMZW5ndGgsIGJvdHRvbTogQ3NzTGVuZ3RoLCBsZWZ0OiBDc3NMZW5ndGgpOiBJUmVjdFByb3h5ID0+XHJcbiAgICAoKSA9PiBgcmVjdCgke2EycyggW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0sIFdLRi5MZW5ndGgsIFwiLFwiKX0pYDtcclxuXHJcblxyXG5cclxuIiwi77u/aW1wb3J0IHtFeHRlbmRlZCwgSUdlbmVyaWNQcm94eSwgT25lT3JCb3gsIE9uZU9yUGFpcn0gZnJvbSBcIi4vQ29yZVR5cGVzXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYElOdW1iZXJCYXNlTWF0aGAgaW50ZXJmYWNlIGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWNhbCBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIG51bWVyaWMgQ1NTIHR5cGVzLiBUaGlzIGludGVyZmFjZSBpcyBleHRlbmRlZCBieSBkaW1lbnNpb24tc3BlY2lmaWMgaW50ZXJmYWNlcyBzdWNoIGFzXHJcbiAqIFtbSU51bWJlck1hdGhdXSwgW1tJTGVuZ3RoTWF0aF1dLCBbW0lBbmdsZU1hdGhdXSwgZXRjLlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFQgVHlwZSBvZiB2YWx1ZXMgcGFydGljaXBhdGluZyBpbiB0aGUgbWF0aGVtYXRpY2FsIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGUsIHRoZVxyXG4gKiBbW0lMZW5ndGhNYXRoXV0gaW50ZXJmYWNlIHNwZWNpZmllcyBpdCBhcyBbW0Nzc0xlbmd0aF1dLlxyXG4gKiBAdHlwZXBhcmFtIFUgVHlwZSB0aGF0IGNvbnRhaW5zIHN0cmluZyBsaXRlcmFscyBkZWZpbmluZyB1bml0cyBhdmFpbGFibGUgZm9yIHRoZSBnaXZlbiBudW1lcmljXHJcbiAqIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElOdW1lcmljTWF0aDxULCBVIGV4dGVuZHMgc3RyaW5nPlxyXG57XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gbnVtYmVyIGFuZCB1bml0LiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBkeW5hbWljYWxseVxyXG4gICAgICogY29uc3RydWN0IHRoZSBuZWVkZWQgZGltZW5zaW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuIE51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gdW5pdCBVbml0IHRvIGFwcGVuZCB0byB0aGUgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uIGltcGxlbWVudGluZyB0aGUgYElHZW5lcmljUHJveHk8VT5gIGNhbGxhYmxlIGludGVyZmFjZS4gVGhpcyBhbGxvd3MgdGhlXHJcbiAgICAgKiByZXN1bHQgb2YgdGhlIGB1bml0c2AgbWV0aG9kIHRvIGJlIGFzc2lnbmVkIG9ubHkgdG8gdGhlIHByb3BlcnRpZXMgb2YgY29tcGF0aWJsZSBudW1lcmljXHJcbiAgICAgKiB0eXBlLlxyXG4gICAgICovXHJcbiAgICB1bml0cyggbjogbnVtYmVyLCB1bml0OiBVKTogSUdlbmVyaWNQcm94eTxVPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgcHJvcGVydHkgdmFsdWUgdXNpbmcgdGhlIENTUyBgbWluKClgIGZ1bmN0aW9uLiBQYXJhbWV0ZXJzIGFyZSBvZiB0aGUgdHlwZVxyXG4gICAgICogYEV4dGVuZGVkPFQ+YDsgdGhhdCBpcywgdGhleSBjYW4gYmUgZWl0aGVyIG9mIHRoZSBnZW5lcmljIHR5cGUgYFRgLCBvciBhIENTUyBjdXN0b20gdmFyaWFibGVcclxuICAgICAqIG9yIGNvbnN0YW50IG9mIHR5cGUgYFRgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbXMgT25lIG9yIG1vcmUgdmFsdWVzIHRvIGNob29zZSB0aGUgbWluaW11bSBmcm9tLlxyXG4gICAgICogQHJldHVybnMgRnVuY3Rpb24gaW1wbGVtZW50aW5nIHRoZSBgSUdlbmVyaWNQcm94eTxVPmAgY2FsbGFibGUgaW50ZXJmYWNlLiBUaGlzIGFsbG93cyB0aGVcclxuICAgICAqIHJlc3VsdCBvZiB0aGUgYG1pbmAgbWV0aG9kIHRvIGJlIGFzc2lnbmVkIG9ubHkgdG8gdGhlIHByb3BlcnRpZXMgb2YgYSBjb21wYXRpYmxlIG51bWVyaWNcclxuICAgICAqIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gbWluKCAyMDBweCwgMjUuNWVtLCA0NSUpXHJcbiAgICAgKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgd2lkdGg6IGNzcy5MZW4ubWluKCAyMDAsIDI1LjUsIGNzcy5wZXJjZW50KDQ1KSlcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIG1pbiggLi4ucGFyYW1zOiBFeHRlbmRlZDxUPltdKTogSUdlbmVyaWNQcm94eTxVPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgcHJvcGVydHkgdmFsdWUgdXNpbmcgdGhlIENTUyBgbWF4KClgIGZ1bmN0aW9uLiBQYXJhbWV0ZXJzIGFyZSBvZiB0aGUgdHlwZVxyXG4gICAgICogYEV4dGVuZGVkPFQ+YDsgdGhhdCBpcywgdGhleSBjYW4gYmUgZWl0aGVyIG9mIHRoZSBnZW5lcmljIHR5cGUgYFRgLCBvciBhIENTUyBjdXN0b20gdmFyaWFibGVcclxuICAgICAqIG9yIGNvbnN0YW50IG9mIHR5cGUgYFRgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbXMgT25lIG9yIG1vcmUgdmFsdWVzIHRvIGNob29zZSB0aGUgbWF4aW11bSBmcm9tLlxyXG4gICAgICogQHJldHVybnMgRnVuY3Rpb24gaW1wbGVtZW50aW5nIHRoZSBgSUdlbmVyaWNQcm94eTxVPmAgY2FsbGFibGUgaW50ZXJmYWNlLiBUaGlzIGFsbG93cyB0aGVcclxuICAgICAqIHJlc3VsdCBvZiB0aGUgYG1heGAgbWV0aG9kIHRvIGJlIGFzc2lnbmVkIG9ubHkgdG8gdGhlIHByb3BlcnRpZXMgb2YgYSBjb21wYXRpYmxlIG51bWVyaWNcclxuICAgICAqIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gbWF4KCAyMDBweCwgMjUuNWVtLCA0NSUpXHJcbiAgICAgKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgd2lkdGg6IGNzcy5MZW4ubWF4KCAyMDAsIDI1LjUsIGNzcy5wZXJjZW50KDQ1KSlcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIG1heCggLi4ucGFyYW1zOiBFeHRlbmRlZDxUPltdKTogSUdlbmVyaWNQcm94eTxVPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgcHJvcGVydHkgdmFsdWUgdXNpbmcgdGhlIENTUyBgY2xhbXAoKWAgZnVuY3Rpb24uIFBhcmFtZXRlcnMgYXJlIG9mIHRoZSB0eXBlXHJcbiAgICAgKiBgRXh0ZW5kZWQ8VD5gOyB0aGF0IGlzLCB0aGV5IGNhbiBiZSBlaXRoZXIgb2YgdGhlIGdlbmVyaWMgdHlwZSBgVGAsIG9yIGEgQ1NTIGN1c3RvbSB2YXJpYWJsZVxyXG4gICAgICogb3IgY29uc3RhbnQgb2YgdHlwZSBgVGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1pbiBMb3dlciBib3VuZCBmb3IgdGhlIHJldHVybiB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSBwcmVmIFByZWZlcnJlZCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSBtYXggVXBwZXIgYm91bmQgZm9yIHRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyBGdW5jdGlvbiBpbXBsZW1lbnRpbmcgdGhlIGBJR2VuZXJpY1Byb3h5PFU+YCBjYWxsYWJsZSBpbnRlcmZhY2UuIFRoaXMgYWxsb3dzIHRoZVxyXG4gICAgICogcmVzdWx0IG9mIHRoZSBgY2xhbXBgIG1ldGhvZCB0byBiZSBhc3NpZ25lZCBvbmx5IHRvIHRoZSBwcm9wZXJ0aWVzIG9mIGEgY29tcGF0aWJsZSBudW1lcmljXHJcbiAgICAgKiB0eXBlLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIGNsYW1wKCAyMDBweCwgMjUuNWVtLCA0NSUpXHJcbiAgICAgKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgd2lkdGg6IGNzcy5MZW4uY2xhbXAoIDIwMCwgMjUuNSwgY3NzLnBlcmNlbnQoNDUpKVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgY2xhbXAoIG1pbjogRXh0ZW5kZWQ8VD4sIHByZWY6IEV4dGVuZGVkPFQ+LCBtYXg6IEV4dGVuZGVkPFQ+KTogSUdlbmVyaWNQcm94eTxVPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgcHJvcGVydHkgdmFsdWUgdXNpbmcgdGhlIENTUyBgY2FsYygpYCBmdW5jdGlvbi4gVGhpcyBtZXRob2QgaXMgYSB0YWcgZnVuY3Rpb24gYW5kIG11c3RcclxuICAgICAqIGJlIGludm9rZWQgd2l0aCBhIHRlbXBsYXRlIHN0cmluZyB3aXRob3V0IHBhcmVudGhlc2VzLiBQYXJhbWV0ZXJzIGluIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcclxuICAgICAqIGFyZSBvZiB0aGUgdHlwZSBgRXh0ZW5kZWQ8VD5gOyB0aGF0IGlzLCB0aGV5IGNhbiBiZSBlaXRoZXIgb2YgdGhlIGdlbmVyaWMgdHlwZSBgVGAsIG9yIGFcclxuICAgICAqIENTUyBjdXN0b20gdmFyaWFibGUgb3IgY29uc3RhbnQgb2YgdHlwZSBgVGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZvcm11bGFyUGFydHMgQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHBhcnQgb2YgdGhlIHRlbXBsYXRlIHN0cmluZyBhbmQgd2hpY2ggYXJlXHJcbiAgICAgKiBub3QgcGFyYW1ldGVycy5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgQXJyYXkgb2YgcGFyYW1ldGVycyBmcm9tIHRoZSB0ZW1wbGF0ZSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBGdW5jdGlvbiBpbXBsZW1lbnRpbmcgdGhlIGBJR2VuZXJpY1Byb3h5PFU+YCBjYWxsYWJsZSBpbnRlcmZhY2UuIFRoaXMgYWxsb3dzIHRoZVxyXG4gICAgICogcmVzdWx0IG9mIHRoZSBgY2FsY2AgbWV0aG9kIHRvIGJlIGFzc2lnbmVkIG9ubHkgdG8gdGhlIHByb3BlcnRpZXMgb2YgYSBjb21wYXRpYmxlIG51bWVyaWNcclxuICAgICAqIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgZGVmYXVsdFBhZGRpbmcgPSBjc3MudmFyKCBcIkNzc0xlbmd0aFwiLCA4KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBjYWxjKCAyMDBweCAtICgyICogdmFyKC0tZGVmYXVsdFBhZGRpbmcpKSlcclxuICAgICAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICB3aWR0aDogY3NzLkxlbi5jYWxjYCAyMDBweCAtICgyICogJHt0aGlzLmRlZmF1bHRQYWRkaW5nfSlgXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBjYWxjKCBmb3JtdWxhUGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5wYXJhbXM6IEV4dGVuZGVkPFQ+W10pOiBJR2VuZXJpY1Byb3h5PFU+O1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgYDxudW1iZXI+YCB0eXBlLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBQcm94eSBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHZhbHVlcyBvZiB0aGUgYDxwZXJjZW50PmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJTnVtYmVyUHJveHkgZXh0ZW5kcyBJR2VuZXJpY1Byb3h5PFwiXCI+IHt9O1xyXG5cclxuLyoqIFR5cGUgZm9yIGEgdmFsdWUgb2YgdGhlIGA8bnVtYmVyPmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IHR5cGUgQ3NzTnVtYmVyID0gbnVtYmVyIHwgSUdlbmVyaWNQcm94eTxcIlwiPjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYElOdW1iZXJNYXRoYCBpbnRlcmZhY2UgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIGA8bnVtYmVyPmAgQ1NTIHR5cGVzLiBUaGlzIGludGVyZmFjZSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgW1tOdW1dXSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElOdW1iZXJNYXRoIGV4dGVuZHMgSU51bWVyaWNNYXRoPENzc051bWJlcixcIlwiPiB7fVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gUGVyY2VudFxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBVbml0cyBvZiBwZXJjZW50ICovXHJcbmV4cG9ydCB0eXBlIFBlcmNlbnRVbml0cyA9IFwiJVwiO1xyXG5cclxuLyoqIFByb3h5IGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdmFsdWVzIG9mIHRoZSBgPHBlcmNlbnQ+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElQZXJjZW50UHJveHkgZXh0ZW5kcyBJR2VuZXJpY1Byb3h5PFBlcmNlbnRVbml0cz4ge307XHJcblxyXG4vKipcclxuICogVHlwZSBmb3Igc3R5bGUgcHJvcGVydGllcyBvZiB0aGUgYDxwZXJjZW50YWdlPmAgQ1NTIHR5cGUuIFZhbHVlcyBvZiB0aGlzIHR5cGUgY2FuIGJlIHNwZWNpZmVkIGFzOlxyXG4gKiAtIG9uZSBvZiBwcmUtZGVmaW5lZCBzdHJpbmdzIGxpa2UgYFwiMTAwJVwiYFxyXG4gKiAtIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBbW3BlcmNlbnRdXSBmdW5jdGlvblxyXG4gKiAtIGEgbnVtYmVyOlxyXG4gKiAgIC0gaWYgdGhlIG51bWJlciBpcyBhbiBpbnRlZ2VyLCBpdCBpcyB0YWtlbiBhcyBpcyBhbmQgYSBwZXJjZW50IHNpZ24gaXMgYXBwZW5kZWQgdG8gaXRcclxuICogICAtIGlmIHRoZSBudW1iZXIgaXMgYSBmbG9hdGluZyBwb2ludCwgaXQgaXMgbXVsdGlwbGllZCBieSAxMDAgYW5kIGEgcGVyY2VudCBzaWduIGlzIGFwcGVuZGVkIHRvIGl0XHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDc3NQZXJjZW50ID0gbnVtYmVyIHwgSVBlcmNlbnRQcm94eSB8XHJcbiAgICBcIjUlXCIgfCBcIjEwJVwiIHwgXCIxNSVcIiB8IFwiMjAlXCIgfCBcIjI1JVwiIHwgXCIzMCVcIiB8IFwiMzUlXCIgfCBcIjQwJVwiIHwgXCI0NSVcIiB8IFwiNTAlXCIgfFxyXG4gICAgXCI1NSVcIiB8IFwiNjAlXCIgfCBcIjY1JVwiIHwgXCI3MCVcIiB8IFwiNzUlXCIgfCBcIjgwJVwiIHwgXCI4NSVcIiB8IFwiOTAlXCIgfCBcIjk1JVwiIHwgXCIxMDAlXCI7XHJcblxyXG4vKipcclxuICogVGhlIGBJUGVyY2VudE1hdGhgIGludGVyZmFjZSBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxwZXJjZW50PmAgQ1NTIHR5cGVzLiBUaGlzIGludGVyZmFjZSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgW1tQZXJjZW50XV0gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGVyY2VudE1hdGggZXh0ZW5kcyBJTnVtZXJpY01hdGg8Q3NzUGVyY2VudCwgUGVyY2VudFVuaXRzPlxyXG57XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIENTUyBgPGxlbmd0aD5gIHR5cGUuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqIFVuaXRzIG9mIGxlbmd0aCAqL1xyXG5leHBvcnQgdHlwZSBMZW5ndGhVbml0cyA9IFwiUVwiIHwgXCJjaFwiIHwgXCJjbVwiIHwgXCJlbVwiIHwgXCJleFwiIHwgXCJpY1wiIHwgXCJpblwiIHwgXCJsaFwiIHwgXCJtbVwiIHwgXCJwY1wiIHxcclxuICAgICAgICAgICAgICAgIFwicHRcIiB8IFwicHhcIiB8IFwidmJcIiB8IFwidmhcIiB8IFwidmlcIiB8IFwidndcIiB8IFwicmVtXCIgfCBcInJsaFwiIHwgXCJ2bWF4XCIgfCBcInZtaW5cIiB8IFwiZnJcIjtcclxuXHJcbi8qKiBQcm94eSBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHZhbHVlcyBvZiB0aGUgYDxsZW5ndGg+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElMZW5ndGhQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8TGVuZ3RoVW5pdHM+IHt9O1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgZm9yIHNpbmdsZSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgYDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZS4gVmFsdWVzIG9mIHRoaXMgdHlwZVxyXG4gKiBjYW4gYmUgc3BlY2lmZWQgYXM6XHJcbiAqIC0gb25lIG9mIHByZS1kZWZpbmVkIHN0cmluZ3MgbGlrZSBgXCIxMDB2aFwiYCBvciBgXCIxZnJcImBcclxuICogLSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGVuZ3RoIHVuaXQgZnVuY3Rpb25zIHN1Y2ggYXMgW1tyZW1dXSwgW1t2aF1dLCBbW3ZtaW5dXSwgW1twZXJjZW50XV0sIGV0Yy5cclxuICogLSBhIG51bWJlcjpcclxuICogICAtIGlmIHRoZSBudW1iZXIgaXMgYW4gaW50ZWdlciwgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYFwicHhcImAgdW5pdHNcclxuICogICAtIGlmIHRoZSBudW1iZXIgaXMgYSBmbG9hdGluZyBwb2ludCwgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYFwiZW1cImAgdW5pdHNcclxuICovXHJcbmV4cG9ydCB0eXBlIENzc0xlbmd0aCA9IENzc1BlcmNlbnQgfCBJTGVuZ3RoUHJveHkgfFxyXG4gICAgXCIxMDB2aFwiIHwgXCIxMDB2d1wiIHxcclxuICAgIFwiMWZyXCIgfCBcIjJmclwiIHwgXCIzZnJcIiB8IFwiNGZyXCIgfCBcIjVmclwiIHwgXCI2ZnJcIiB8IFwiN2ZyXCIgfCBcIjhmclwiIHwgXCI5ZnJcIiB8IFwiMTBmclwiIHwgXCIxMWZyXCIgfCBcIjEyZnJcIjtcclxuXHJcbi8qKlxyXG4gKiBUeXBlIHRoYXQgY29tYmluZXMgW1tDc3NMZW5ndGhdXSBhbmQgdGhlIHN0cmluZyBsaXRlcmFsIGBcImF1dG9cImAuIFRoaXMgdHlwZSBpcyBvZnRlbiB1c2VkIHdoZW4gYVxyXG4gKiBwcm9wZXJ0eSBhY2NlcHRzIHRoZSBgPGxlbmd0aD5gIHR5cGUgYW5kIHRoZSBgXCJhdXRvXCJgIGxpdGVyYWwgLSBmb3IgZXhhbXBsZSwgd2hlbiBzcGVjaWZ5aW5nXHJcbiAqIG1hcmdpbnMuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDc3NMZW5ndGhPckF1dG8gPSBDc3NMZW5ndGggfCBcImF1dG9cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYElMZW5ndGhNYXRoYCBpbnRlcmZhY2UgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIGA8bGVuZ3RoPmAgQ1NTIHR5cGVzLiBUaGlzIGludGVyZmFjZSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgW1tMZW5dXSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElMZW5ndGhNYXRoIGV4dGVuZHMgSU51bWVyaWNNYXRoPENzc0xlbmd0aCwgTGVuZ3RoVW5pdHMgfCBQZXJjZW50VW5pdHM+XHJcbntcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIGA8YW5nbGU+YCB0eXBlLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBVbml0cyBvZiBhbmdsZSAqL1xyXG5leHBvcnQgdHlwZSBBbmdsZVVuaXRzID0gXCJkZWdcIiB8IFwicmFkXCIgfCBcImdyYWRcIiB8IFwidHVyblwiO1xyXG5cclxuLyoqIFByb3h5IGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdmFsdWVzIG9mIHRoZSBgPGFuZ2xlPmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQW5nbGVQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8QW5nbGVVbml0cz4ge307XHJcblxyXG4vKiogVHlwZSBmb3Igc2luZ2xlIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBgPGFuZ2xlPmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IHR5cGUgQ3NzQW5nbGUgPSBudW1iZXIgfCBJQW5nbGVQcm94eTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYElBbmdsZU1hdGhgIGludGVyZmFjZSBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxhbmdsZT5gIENTUyB0eXBlcy4gVGhpcyBpbnRlcmZhY2UgaXMgaW1wbGVtZW50ZWQgYnkgdGhlIFtbQW5nbGVdXSBvYmplY3QuXHJcbiAqIFR5cGUgZm9yIHNpbmdsZSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgYDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZS4gVmFsdWVzIG9mIHRoaXMgdHlwZVxyXG4gKiBjYW4gYmUgc3BlY2lmZWQgYXM6XHJcbiAqIC0gb25lIG9mIHByZS1kZWZpbmVkIHN0cmluZ3MgbGlrZSBgXCIxMDB2aFwiYCBvciBgXCIxZnJcImBcclxuICogLSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGVuZ3RoIHVuaXQgZnVuY3Rpb25zIHN1Y2ggYXMgW1tyZW1dXSwgW1t2aF1dLCBbW3ZtaW5dXSwgW1twZXJjZW50XV0sIGV0Yy5cclxuICogLSBhIG51bWJlcjpcclxuICogICAtIGlmIHRoZSBudW1iZXIgaXMgYW4gaW50ZWdlciwgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYFwiZGVnXCJgIHVuaXRzXHJcbiAqICAgLSBpZiB0aGUgbnVtYmVyIGlzIGEgZmxvYXRpbmcgcG9pbnQsIGl0IGlzIGludGVycHJldGVkIGFzIGBcInR1cm5cImAgdW5pdHNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFuZ2xlTWF0aCBleHRlbmRzIElOdW1lcmljTWF0aDxDc3NBbmdsZSwgQW5nbGVVbml0cyB8IFBlcmNlbnRVbml0cz5cclxue1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgYDx0aW1lPmAgdHlwZS5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKiogVW5pdHMgb2YgdGltZSAqL1xyXG5leHBvcnQgdHlwZSBUaW1lVW5pdHMgPSBcInNcIiB8IFwibXNcIjtcclxuXHJcbi8qKiBQcm94eSBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHZhbHVlcyBvZiB0aGUgYDx0aW1lPmAgQ1NTIHR5cGUqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElUaW1lUHJveHkgZXh0ZW5kcyBJR2VuZXJpY1Byb3h5PFRpbWVVbml0cz4ge307XHJcblxyXG4vKiogVHlwZSBmb3Igc2luZ2xlIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBgPHRpbWU+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgdHlwZSBDc3NUaW1lID0gbnVtYmVyIHwgSVRpbWVQcm94eTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYElUaW1lTWF0aGAgaW50ZXJmYWNlIGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHRpbWU+YCBDU1MgdHlwZXMuIFRoaXMgaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBbW1RpbWVdXSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElUaW1lTWF0aCBleHRlbmRzIElOdW1lcmljTWF0aDxDc3NUaW1lLCBUaW1lVW5pdHM+XHJcbntcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIGA8cmVzb2x1dGlvbj5gIHR5cGUuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqIFVuaXRzIG9mIHJlc29sdXRpb24gKi9cclxuZXhwb3J0IHR5cGUgUmVzb2x1dGlvblVuaXRzID0gXCJkcGlcIiB8IFwiZHBjbVwiIHwgXCJkcHB4XCIgfCBcInhcIjtcclxuXHJcbi8qKiBQcm94eSBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHZhbHVlcyBvZiB0aGUgYDxyZXNvbHV0aW9uPmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUmVzb2x1dGlvblByb3h5IGV4dGVuZHMgSUdlbmVyaWNQcm94eTxSZXNvbHV0aW9uVW5pdHM+IHt9O1xyXG5cclxuLyoqIFR5cGUgZm9yIHNpbmdsZSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgYDxyZXNvbHV0aW9uPmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IHR5cGUgQ3NzUmVzb2x1dGlvbiA9IG51bWJlciB8IElSZXNvbHV0aW9uUHJveHkgfFxyXG4gICAgXCIxeFwiIHwgXCIyeFwiIHwgXCIzeFwiIHwgXCI0eFwiIHwgXCI1eFwiIHwgXCI2eFwiIHwgXCI3eFwiIHwgXCI4eFwiIHwgXCI5eFwiIHwgXCIxMHhcIiB8XHJcbiAgICBcIjFkcHB4XCIgfCBcIjJkcHB4XCIgfCBcIjNkcHB4XCIgfCBcIjRkcHB4XCIgfCBcIjVkcHB4XCIgfCBcIjZkcHB4XCIgfCBcIjdkcHB4XCIgfCBcIjhkcHB4XCIgfCBcIjlkcHB4XCIgfCBcIjEwZHBweFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgSVJlc29sdXRpb25NYXRoYCBpbnRlcmZhY2UgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIGA8cmVzb2x1dGlvbj5gIENTUyB0eXBlcy4gVGhpcyBpbnRlcmZhY2UgaXMgaW1wbGVtZW50ZWQgYnkgdGhlIFtbUmVzb2x1dGlvbl1dIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVJlc29sdXRpb25NYXRoIGV4dGVuZHMgSU51bWVyaWNNYXRoPENzc1Jlc29sdXRpb24sIFJlc29sdXRpb25Vbml0cz5cclxue1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgYDxmcmVxdWVuY3k+YCB0eXBlLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBVbml0cyBvZiBmcmVxdWVuY3kgKi9cclxuZXhwb3J0IHR5cGUgRnJlcXVlbmN5VW5pdHMgPSBcIkh6XCIgfCBcImtIelwiO1xyXG5cclxuLyoqIFByb3h5IGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdmFsdWVzIG9mIHRoZSBgPGZyZXF1ZW5jeT5gIENTUyB0eXBlICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUZyZXF1ZW5jeVByb3h5IGV4dGVuZHMgSUdlbmVyaWNQcm94eTxGcmVxdWVuY3lVbml0cz4ge307XHJcblxyXG4vKiogVHlwZSBmb3Igc2luZ2xlIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBgPGZyZXF1ZW5jeT5gIENTUyB0eXBlICovXHJcbmV4cG9ydCB0eXBlIENzc0ZyZXF1ZW5jeSA9IG51bWJlciB8IElGcmVxdWVuY3lQcm94eTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYElGcmVxdWVuY3lNYXRoYCBpbnRlcmZhY2UgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIGA8ZnJlcXVlbmN5PmAgQ1NTIHR5cGVzLiBUaGlzIGludGVyZmFjZSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgW1tGcmVxdWVuY3ldXSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElGcmVxdWVuY3lNYXRoIGV4dGVuZHMgSU51bWVyaWNNYXRoPENzc0ZyZXF1ZW5jeSwgRnJlcXVlbmN5VW5pdHM+XHJcbntcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gU2l6ZSwgUG9pbnQsIFBvc2l0aW9uLCBSYWRpdXNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKiogVHlwZSBmb3IgYHdpZHRoYCwgYGhlaWdodGAsIGBibG9jay1zaXplYCBhbmQgYGlubGluZS1zaXplYCBzdHlsZSBwcm9wZXJ0aWVzICovXHJcbmV4cG9ydCB0eXBlIENzc1NpemUgPSBcImF1dG9cIiB8IFwibWF4LWNvbnRlbnRcIiB8IFwibWluLWNvbnRlbnRcIiB8IFwiZml0LWNvbnRlbnRcIiB8IFwic3RyZXRjaFwiIHxcclxuICAgIENzc0xlbmd0aCB8IElGaXRDb250ZW50UHJveHk7XHJcblxyXG4vKipcclxuICogVGhlIElGaXRDb250ZW50UHJveHkgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiB0aGUgQ1NTIGBmaXQtY29udGVudCgpYCBmdW5jdGlvbi4gSXRcclxuICogaXMgcmV0dXJuZWQgZnJvbSB0aGUgW1tmaXRDb250ZW50XV0gZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElGaXRDb250ZW50UHJveHkgZXh0ZW5kcyBJR2VuZXJpY1Byb3h5PFwiZml0LWNvbnRlbnRcIj4ge31cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgcmVwcmVzZW50aW5nIGEgcG9pbnQgYXMgYSB0d28gZWxlbWVudCB0dXBsZSB3aGVyZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGFyZSBzcGVjaWZpZWQgdXNpbmdcclxuICogdGhlIFtbQ3NzTGVuZ3RoXV0gdHlwZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIENzc1BvaW50ID0gW0V4dGVuZGVkPENzc0xlbmd0aD4sIEV4dGVuZGVkPENzc0xlbmd0aD5dO1xyXG5cclxuXHJcblxyXG4vKiogSG9yaXpvbnRhbCBwb3NpdGlvbiBrZXl3b3JkcyAqL1xyXG5leHBvcnQgdHlwZSBIb3Jpem9udGFsUG9zaXRpb25LZXl3b3JkID0gXCJsZWZ0XCIgfCBcImNlbnRlclwiIHwgXCJyaWdodFwiO1xyXG5cclxuLyoqIFR5cGUgb2YgYSB2YWx1ZSBzcGVjaWZ5aW5nIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uICovXHJcbmV4cG9ydCB0eXBlIEhvcml6b250YWxQb3NpdGlvbiA9IEhvcml6b250YWxQb3NpdGlvbktleXdvcmQgfCBDc3NMZW5ndGg7XHJcblxyXG4vKiogVHlwZSBkZXNjcmliaW5nIGhvcml6b250YWwgcG9zaXRpb24gQ1NTIHR5cGUgY29uc2lzdGluZyBvZiAyIHZhbHVlcyB1c2luZyBhIHR1cGxlICovXHJcbmV4cG9ydCB0eXBlIEhvcml6b250YWxQb3NpdGlvblR1cGxlID0gW0V4dGVuZGVkPEhvcml6b250YWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxDc3NMZW5ndGg+XTtcclxuXHJcbi8qKiBWZXJ0aWNhbCBwb3NpdGlvbiBrZXl3b3JkcyAqL1xyXG5leHBvcnQgdHlwZSBWZXJ0aWNhbFBvc2l0aW9uS2V5d29yZCA9IFwidG9wXCIgfCBcImNlbnRlclwiIHwgXCJib3R0b21cIjtcclxuXHJcbi8qKiBUeXBlIG9mIGEgdmFsdWUgc3BlY2lmeWluZyB0aGUgdmVydGljYWwgcG9zaXRpb24gKi9cclxuZXhwb3J0IHR5cGUgVmVydGljYWxQb3NpdGlvbiA9IFZlcnRpY2FsUG9zaXRpb25LZXl3b3JkIHwgQ3NzTGVuZ3RoO1xyXG5cclxuLyoqIFR5cGUgZGVzY3JpYmluZyB2ZXJ0aWNhbCBwb3NpdGlvbiBDU1MgdHlwZSBjb25zaXN0aW5nIG9mIDIgdmFsdWVzIHVzaW5nIGEgdHVwbGUgKi9cclxuZXhwb3J0IHR5cGUgVmVydGljYWxQb3NpdGlvblR1cGxlID0gW0V4dGVuZGVkPFZlcnRpY2FsUG9zaXRpb25LZXl3b3JkPiwgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPl07XHJcblxyXG5cclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgYDxwb3NpdGlvbi14PmAgQ1NTIHR5cGUgY29uc2lzdGluZyBvZiB1cCB0byAyIHZhbHVlcyAqL1xyXG5leHBvcnQgdHlwZSBDc3NQb3NpdGlvblggPSBIb3Jpem9udGFsUG9zaXRpb24gfCBIb3Jpem9udGFsUG9zaXRpb25UdXBsZTtcclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgbXVsdGlwbGUgYDxwb3NpdGlvbi14PmAgQ1NTIHR5cGVzIGNvbnNpc3Rpbmcgb2YgdXAgdG8gMiB2YWx1ZXMgKi9cclxuZXhwb3J0IHR5cGUgQ3NzTXVsdGlQb3NpdGlvblggPSBDc3NQb3NpdGlvblggfCAoW0V4dGVuZGVkPEhvcml6b250YWxQb3NpdGlvbj5dIHwgRXh0ZW5kZWQ8SG9yaXpvbnRhbFBvc2l0aW9uVHVwbGU+KVtdO1xyXG5cclxuXHJcblxyXG4vKiogVHlwZSBkZXNjcmliaW5nIGA8cG9zaXRpb24teT5gIENTUyB0eXBlIGNvbnNpc3Rpbmcgb2YgdXAgdG8gMiB2YWx1ZXMgKi9cclxuZXhwb3J0IHR5cGUgQ3NzUG9zaXRpb25ZID0gVmVydGljYWxQb3NpdGlvbiB8IFZlcnRpY2FsUG9zaXRpb25UdXBsZTtcclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgbXVsdGlwbGUgYDxwb3NpdGlvbi15PmAgQ1NTIHR5cGVzIGNvbnNpc3Rpbmcgb2YgdXAgdG8gMiB2YWx1ZXMgKi9cclxuZXhwb3J0IHR5cGUgQ3NzTXVsdGlQb3NpdGlvblkgPSBDc3NQb3NpdGlvblkgfCAoW0V4dGVuZGVkPFZlcnRpY2FsUG9zaXRpb24+XSB8IEV4dGVuZGVkPFZlcnRpY2FsUG9zaXRpb25UdXBsZT4pW107XHJcblxyXG5cclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgYSBzaW5nbGUgaXRlbSBpbiB0aGUgYDxwb3NpdGlvbj5gIENTUyB0eXBlICovXHJcbmV4cG9ydCB0eXBlIENzc1Bvc2l0aW9uSXRlbSA9IEhvcml6b250YWxQb3NpdGlvbktleXdvcmQgfCBWZXJ0aWNhbFBvc2l0aW9uS2V5d29yZCB8IENzc0xlbmd0aDtcclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgYDxwb3NpdGlvbj5gIENTUyB0eXBlIGNvbnNpc3Rpbmcgb2YgMSB0byA0IHZhbHVlcyB1c2luZyB0b3VwbGVzICovXHJcbmV4cG9ydCB0eXBlIENzc1Bvc2l0aW9uVHVwbGUgPVxyXG4gICAgW0V4dGVuZGVkPEhvcml6b250YWxQb3NpdGlvbj4sIEV4dGVuZGVkPFZlcnRpY2FsUG9zaXRpb24+XSB8XHJcbiAgICBbRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvbj4sIEV4dGVuZGVkPEhvcml6b250YWxQb3NpdGlvbj5dIHxcclxuICAgIFtFeHRlbmRlZDxIb3Jpem9udGFsUG9zaXRpb25LZXl3b3JkPiwgRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxDc3NMZW5ndGg+XSB8XHJcbiAgICBbRXh0ZW5kZWQ8SG9yaXpvbnRhbFBvc2l0aW9uS2V5d29yZD4sIEV4dGVuZGVkPENzc0xlbmd0aD4sIEV4dGVuZGVkPFZlcnRpY2FsUG9zaXRpb25LZXl3b3JkPiwgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPj9dIHxcclxuICAgIFtFeHRlbmRlZDxWZXJ0aWNhbFBvc2l0aW9uS2V5d29yZD4sIEV4dGVuZGVkPEhvcml6b250YWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxDc3NMZW5ndGg+XSB8XHJcbiAgICBbRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxDc3NMZW5ndGg+LCBFeHRlbmRlZDxIb3Jpem9udGFsUG9zaXRpb25LZXl3b3JkPiwgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPj9dO1xyXG5cclxuLyoqIFR5cGUgZGVzY3JpYmluZyBgPHBvc2l0aW9uPmAgQ1NTIHR5cGUgY29uc2lzdGluZyBvZiB1cCB0byA0IHZhbHVlcyAqL1xyXG5leHBvcnQgdHlwZSBDc3NQb3NpdGlvbiA9IENzc1Bvc2l0aW9uSXRlbSB8IENzc1Bvc2l0aW9uVHVwbGU7XHJcblxyXG4vKiogVHlwZSBkZXNjcmliaW5nIG11bHRpcGxlIGA8cG9zaXRpb24+YCBDU1MgdHlwZXMgY29uc2lzdGluZyBvZiB1cCB0byA0IHZhbHVlcyAqL1xyXG5leHBvcnQgdHlwZSBDc3NNdWx0aVBvc2l0aW9uID0gQ3NzUG9zaXRpb24gfCAoW0V4dGVuZGVkPENzc1Bvc2l0aW9uSXRlbT5dIHwgRXh0ZW5kZWQ8Q3NzUG9zaXRpb25UdXBsZT4pW107XHJcblxyXG5cclxuXHJcbi8qKiBUeXBlIGZvciBhIHNpbmdsZSBjb3JuZXIgcmFkaXVzICovXHJcbmV4cG9ydCB0eXBlIENzc1JhZGl1cyA9IE9uZU9yUGFpcjxDc3NMZW5ndGg+O1xyXG5cclxuXHJcblxyXG4vKiogVHlwZSBmb3IgYm9yZGVyLXJhZGl1cyBzdHlsZSBwcm9wZXJ0eSAqL1xyXG5leHBvcnQgdHlwZSBCb3JkZXJSYWRpdXNJdGVtID0gW0V4dGVuZGVkPENzc0xlbmd0aD4sIEV4dGVuZGVkPENzc0xlbmd0aD4/LCBFeHRlbmRlZDxDc3NMZW5ndGg+PywgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPj9dO1xyXG5cclxuLyoqIFR5cGUgZm9yIGJvcmRlci1yYWRpdXMgc3R5bGUgcHJvcGVydHkgKi9cclxuZXhwb3J0IHR5cGUgQm9yZGVyUmFkaXVzID0gT25lT3JCb3g8Q3NzTGVuZ3RoPiB8IFtCb3JkZXJSYWRpdXNJdGVtLCBCb3JkZXJSYWRpdXNJdGVtXTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEFzcGVjdCBSYXRpb1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUaGUgSUFzcGVjdFJhdGlvUHJveHkgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiB0aGUgW1tyYXRpb11dIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQXNwZWN0UmF0aW9Qcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJhc3BlY3QtcmF0aW9cIj4ge31cclxuXHJcbi8qKlxyXG4gKiBUaGUgYENzc0FzcGVjdFJhdGlvYCB0eXBlIHJlcHJlc2VudHMgdGhlIENTUyBgPHJhdGlvPmAgdHlwZS4gVGhpcyB0eXBlIGNhbiBiZSB1c2VkIGZvciB0aGVcclxuICogYGFzcGVjdC1yYXRpb2AgQ1NTIHByb3BlcnR5IGFuZCBieSB0aGUgYGFzcGVjdC1yYXRpb2AgbWVkaWEgZmVhdHVyZSBpbiBhIGBAbWVkaWFgIHJ1bGUuXHJcbiAqXHJcbiAqICoqRXhhbXBsZXM6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gdXNpbmcgcHJlLWRlZmluZWQgc3RyaW5nIGxpdGVyYWwgdmFsdWVcclxuICogICAgIGNsYXNzMSA9IHRoaXMuJGNsYXNzKCB7YXNwZWN0UmF0aW86IFwiNC8zXCJ9KVxyXG4gKlxyXG4gKiAgICAgLy8gdXNpbmcgdGhlIGByYXRpbygpYCBmdW5jdGlvblxyXG4gKiAgICAgY2xhc3MyID0gdGhpcy4kY2xhc3MoIHthc3BlY3RSYXRpbzogY3NzLnJhdGlvKCA0LCAzKX0pXHJcbiAqXHJcbiAqICAgICAvLyB1c2luZyBhIHNpbmdsZSBudW1iZXJcclxuICogICAgIG1lZGlhUnVsZTEgPSB0aGlzLiRtZWRpYSgge2FzcGVjdFJhdGlvOiAxLjMzfSwgLi4uKVxyXG4gKlxyXG4gKiAgICAgLy8gdXNpbmcgYSB0dXBsZSB0byBzcGVjaWZ5IHJhbmdlOyB0aGlzIHdpbGwgcmVzdWx0IGluIHRoZSBmb2xsb3dpbmcgbWVkaWEgY29uZGl0aW9uOlxyXG4gKiAgICAgLy8gKG1pbi1hc3BlY3QtcmF0aW86IDQvMykgYW5kIChtYXgtYXNwZWN0LXJhdGlvOjE2LzkpXHJcbiAqICAgICBtZWRpYVJ1bGUyID0gdGhpcy4kbWVkaWEoIHthc3BlY3RSYXRpbzogW1wiNC8zXCIsXCIxNi85XCJdfSwgLi4uKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ3NzQXNwZWN0UmF0aW8gPSBDc3NOdW1iZXIgfCBJQXNwZWN0UmF0aW9Qcm94eSB8IFwiMS8xXCIgfCBcIjQvM1wiIHwgXCIxNi85XCIgfCBcIjE4NS8xMDBcIiB8IFwiMjM5LzEwMFwiO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gcmVjdCgpIGZ1bmN0aW9uIGZvciBjbGlwIHByb3BlcnR5XHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgSVJlY3RQcm94eWAgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiB0aGUgW1tyZWN0XV0gZnVuY3Rpb24gdXNlZCBmb3IgdGhlIGBjbGlwYFxyXG4gKiBzdHlsZSBwcm9wZXJ0eS5cclxuICogQGRlcHJlY2F0ZWQgVGhlIENTUyBgY2xpcGAgcHJvcGVydHkgYW5kIGByZWN0KClgIGZ1bmN0aW9uIGFyZSBkZXByZWNhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUmVjdFByb3h5IGV4dGVuZHMgSUdlbmVyaWNQcm94eTxcInJlY3RcIj4ge31cclxuXHJcbiIsIu+7v2ltcG9ydCB7Q3NzU2VsZWN0b3IsIFBhZ2VQc2V1ZG9DbGFzcywgRWxlbWVudFRhZ05hbWUsIEV4dGVuZGVkUHJvcH0gZnJvbSBcIi4vQ29yZVR5cGVzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBJU3R5bGVSdWxlLCBJQ2xhc3NSdWxlLCBJSURSdWxlLCBBbmltYXRpb25GcmFtZSwgSUFuaW1hdGlvblJ1bGUsIElWYXJSdWxlLFxyXG4gICAgSUNvdW50ZXJSdWxlLCBJR3JpZExpbmVSdWxlLCBJR3JpZEFyZWFSdWxlLCBJSW1wb3J0UnVsZSwgSUZvbnRGYWNlUnVsZSwgSU5hbWVzcGFjZVJ1bGUsIElQYWdlUnVsZSxcclxuICAgIElTdHlsZURlZmluaXRpb25DbGFzcywgSVN1cHBvcnRzUnVsZSwgSU1lZGlhUnVsZSwgSUNsYXNzTmFtZVJ1bGUsIElDb25zdFJ1bGUsIENsYXNzUHJvcFR5cGUsXHJcbiAgICBOYW1lR2VuZXJhdGlvbk1ldGhvZCwgSUNvdW50ZXJTdHlsZVJ1bGUsIElTdHlsZURlZmluaXRpb25cclxufSBmcm9tIFwiLi9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHtNZWRpYVN0YXRlbWVudCwgU3VwcG9ydHNTdGF0ZW1lbnR9IGZyb20gXCIuL01lZGlhVHlwZXNcIlxyXG5pbXBvcnQge0V4dGVuZGVkRm9udEZhY2V9IGZyb20gXCIuL0ZvbnRUeXBlc1wiO1xyXG5pbXBvcnQge0V4dGVuZGVkQ291bnRlclN0eWxlc2V0fSBmcm9tIFwiLi9Db3VudGVyVHlwZXNcIjtcclxuaW1wb3J0IHtcclxuICAgIFN0eWxlc2V0LCBWYXJUZW1wbGF0ZU5hbWUsIEV4dGVuZGVkVmFyVmFsdWUsIENvbWJpbmVkU3R5bGVzZXQsIENvbWJpbmVkQ2xhc3NTdHlsZXNldCxcclxuICAgIElTeW50YXhUeXBlU3R5bGVzZXRcclxufSBmcm9tIFwiLi9TdHlsZXNldHNcIjtcclxuaW1wb3J0IHtzeW1SQ30gZnJvbSBcIi4uL3J1bGVzL1J1bGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGVtYmVkZGVkRGVjb3JhdG9yLCBnZXRDdXJyZW50VGhlbWUsIHByb2Nlc3NTRCwgY29uZmlnTmFtZXMsIFJ1bGVDb250YWluZXIsXHJcbiAgICBzX3N0YXJ0U1NSLCBzX3N0b3BTU1IsIHNfc3RhcnRIeWRyYXRpb24sIHNfc3RvcEh5ZHJhdGlvblxyXG59IGZyb20gXCIuLi9ydWxlcy9SdWxlQ29udGFpbmVyXCI7XHJcbmltcG9ydCB7QWJzdHJhY3RSdWxlLCBDbGFzc1J1bGUsIElEUnVsZSwgU2VsZWN0b3JSdWxlLCBQYWdlUnVsZX0gZnJvbSBcIi4uL3J1bGVzL1N0eWxlUnVsZXNcIlxyXG5pbXBvcnQge0FuaW1hdGlvblJ1bGV9IGZyb20gXCIuLi9ydWxlcy9BbmltYXRpb25SdWxlXCJcclxuaW1wb3J0IHtWYXJSdWxlLCBDb25zdFJ1bGUsIFByb3BlcnR5UnVsZX0gZnJvbSBcIi4uL3J1bGVzL1ZhclJ1bGVcIlxyXG5pbXBvcnQge0NvdW50ZXJSdWxlLCBDb3VudGVyU3R5bGVSdWxlfSBmcm9tIFwiLi4vcnVsZXMvQ291bnRlclJ1bGVzXCI7XHJcbmltcG9ydCB7R3JpZExpbmVSdWxlLCBHcmlkQXJlYVJ1bGV9IGZyb20gXCIuLi9ydWxlcy9HcmlkUnVsZXNcIjtcclxuaW1wb3J0IHtGb250RmFjZVJ1bGUsIEltcG9ydFJ1bGUsIE5hbWVzcGFjZVJ1bGUsIENsYXNzTmFtZVJ1bGV9IGZyb20gXCIuLi9ydWxlcy9NaXNjUnVsZXNcIlxyXG5pbXBvcnQge1N1cHBvcnRzUnVsZSwgTWVkaWFSdWxlfSBmcm9tIFwiLi4vcnVsZXMvR3JvdXBSdWxlc1wiXHJcbmltcG9ydCB7djJzfSBmcm9tIFwiLi4vaW1wbC9VdGlsc1wiO1xyXG5pbXBvcnQge2dldEFjdGl2YXRvcn0gZnJvbSBcIi4uL2ltcGwvU2NoZWR1bGluZ0ltcGxcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgU3R5bGVEZWZpbml0aW9uYCBjbGFzcyBpcyBhIGJhc2UgZm9yIGFsbCBjbGFzc2VzIHRoYXQgY29udGFpbiBkZWZpbmluaXRpb25zIG9mIENTUyBydWxlcy5cclxuICogU3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIGFyZSByZWd1bGFyIFR5cGVTY3JpcHQgY2xhc3NlcyBhbmQgYXMgc3VjaCBjYW4gaGF2ZSBhbnkgZmllbGRzIGFuZFxyXG4gKiBtZXRob2RzIC0gYm90aCBpbnN0YW5jZSBhbmQgc3RhdGljLiBOb3JtYWxseSwgaG93ZXZlciwgdGhleSBjb250YWluIGluc3RhbmNlIHByb3BlcnRpZXNcclxuICogaW5pdGlhbGl6ZWQgd2l0aCBmdW5jdGlvbnMgcmV0dXJuaW5nIHN0eWxlIHJ1bGVzIGFuZCBhdC1ydWxlcywgc3VjaCBhcyBbWyRjbGFzc11dLFxyXG4gKiBbWyR0YWddXSwgW1skbWVkaWFdXSwgW1skY291bnRlcl1dIGFuZCBvdGhlcnMuXHJcbiAqXHJcbiAqICoqRXhhbXBsZXMqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIC8vIHRvcC1sZXZlbCBzdHlsZSBkZWZpbml0aW9uIGNsYXNzXHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICBjbHMgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiBcInJlZFwifSlcclxuICpcclxuICogICAgIC8vIHVzaW5nIHN0eWxlLWRlZmluaXRpb24gY2xhc3MgZm9yIEBtZWRpYSBydWxlXHJcbiAqICAgICBpZk5hcnJvd1NjcmVlbiA9IHRoaXMuJG1lZGlhKCB7IG1heFdpZHRoOiA4MDAgfSxcclxuICogICAgICAgICBjbGFzcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb248TXlTdHlsZXM+XHJcbiAqICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICBjbHMgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiBcInBpbmtcIn0pXHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFAgUGFyZW50IHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFBhcmVudCBvZiBhIHRvcC1sZXZlbCBjbGFzcyBpcyBudWxsLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0eWxlRGVmaW5pdGlvbjxQIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uID0gYW55PiBpbXBsZW1lbnRzIElTdHlsZURlZmluaXRpb248UD5cclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcnMgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIHdoaWNoIGlzIHRoZSBwYXJlbnQgb2YgdGhpcyBzdHlsZVxyXG4gICAgICogZGVmaW5pdGlvbiBvYmplY3QgaW4gdGhlIGNoYWluIG9mIHN0eWxlIGRlZmluaXRpb24gY2xhc3Nlcy4gVGhyb3VnaCB0aGlzIG1lbWJlciwgYWxsIHJ1bGVzXHJcbiAgICAgKiBhbmQgb3RoZXIgbWVtYmVycyBkZWZpbmVkIGluIHRoZSBwYXJlbnQgZGVmaW5pdGlvbiBjbGFzcyBjYW4gYmUgYWNjZXNzZWQuIEZvciB0b3AtbGV2ZWxcclxuICAgICAqIHN0eWxlIGRlZmluaXRpb25zLCB0aGlzIHByb3BlcnR5IGlzIGFsd2F5cyB1bmRlZmluZWQuIFRoaXMgcHJvcGVydHkgY2FuIGFsc28gYmUgdW5kZWZpbmVkXHJcbiAgICAgKiBpZiBpdCB3YXMgbm90IHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciB3aGVuIGNyZWF0aW5nIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIG1hbnVhbGx5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgJHBhcmVudGAgcmVmZXJlbmNlIGlzIHVzZWQgd2hlbiB0aGVyZSBpcyBhIG5lZWQgdG8gcmVmZXIgZnJvbSBncm91cGluZyBydWxlcyAoY3JlYXRlZFxyXG4gICAgICogYnkgYCRtZWRpYSgpYCBvciBgJHN1cHBvcnQoKWAgZnVuY3Rpb25zKSB0byB0aGUgcnVsZXMgZGVmaW5lZCBpbiB0aGUgcGFyZW50IHN0eWxlIGRlZmluaXRpb25cclxuICAgICAqIGNsYXNzLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgbmVzdGVkIGdyb3VwaW5nIHJ1bGVzLCB0aGVuIHRoZSBjb25zdHVjdCBgdGhpcy4kcGFyZW50LiRwYXJlbnQuLi5gXHJcbiAgICAgKiBhbGxvd3MgcmVhY2hpbmcgdG8gcnVsZXMgZGVmaW5lZCBpbiBhbnkgYW5jZXN0b3Igc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBkZWZhdWx0Q29sb3IgPSB0aGlzLiR2YXIoIFwiY29sb3JcIiwgXCJibHVlXCIpXHJcbiAgICAgKlxyXG4gICAgICogICAgIGlmU21hbGxTY3JlZW4gPSB0aGlzLiRtZWRpYSggeyBtYXhXaWR0aDogNjAwIH0sXHJcbiAgICAgKiAgICAgICAgIGNsYXNzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvbjxNeVN0eWxlcz5cclxuICAgICAqICAgICAgICAge1xyXG4gICAgICogICAgICAgICAgICAgcCA9IHRoaXMuJHN0eWxlKCBcInBcIiwgeyBjb2xvcjogdGhpcy4kcGFyZW50LmRlZmF1bHRDb2xvciB9KVxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgKVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFkb25seSAkcGFyZW50PzogUDtcclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgZGlyZWN0bHkgb25seSBieSB0aGUgKnN0eWxlZCBjb21wb25lbnRzKiAtIHRoYXQgaXMsXHJcbiAgICAgKiBjb21wb25lbnRzIHRoYXQgdXNlIGRpZmZlcmVudCBzdHlsZXMgZm9yIGVhY2ggaW5zdGFuY2UuIE90aGVyd2lzZSwgc3R5bGUgZGVmaW5pdGlvblxyXG4gICAgICogaW5zdGFuY2VzIGFyZSBjcmVhdGVkIHdoZW4gZWl0aGVyIHRoZSBbWyR1c2VdXSBtZXRob2Qgb3IgW1thY3RpdmF0ZV1dIGZ1bmN0aW9uIGlzIGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSBwYXJlbnQgUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoIHBhcmVudD86IFApXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAvLyBTdHlsZSBEZWZpbml0aW9uIGluc3RhbmNlIHBvaW50cyB0byBydWxlIGNvbnRhaW5lclxyXG4gICAgICAgIGxldCByYyA9IG5ldyBSdWxlQ29udGFpbmVyKCB0aGlzKTtcclxuICAgICAgICB0aGlzW3N5bVJDXSA9IHJjO1xyXG5cclxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBpbnN0YW5jZSBvZiBvdXIgY2xhc3MsIHRoZSBjb25zdHJ1Y3RvciByZXR1cm5zIGEgcHJveHkuIFRoaXNcclxuICAgICAgICAvLyBhbGxvd3MgY3JlYXRpbmcgcHJveGllcyBmb3IgYWxsIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgY2xhc3MuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eTxTdHlsZURlZmluaXRpb248UD4+KCB0aGlzLCByYyk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYWJzdHJhY3QgcnVsZSwgd2hpY2ggZGVmaW5lcyBhIHN0eWxlc2V0IHRoYXQgY2FuIGJlIGV4dGVuZGVkIGJ5IG90aGVyIHN0eWxlIHJ1bGVzLlxyXG4gICAgICogQWJzdHJhY3QgcnVsZXMgZG9uJ3QgaGF2ZSBzZWxlY3RvcnMgYW5kIGFyZSBub3QgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLiBBYnN0cmFjdCBydWxlcyBjYW5cclxuICAgICAqIHRoZW1zZWx2ZXMgZXh0ZW5kIG90aGVyIHJ1bGVzIC0gYm90aCBhYnN0cmFjdCBhbmQgbm9uLWFic3RyYWN0LlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGNvbG9yQm94ID0gdGhpcy4kYWJzdHJhY3Qoe1xyXG4gICAgICogICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwib3JhbmdlXCIsXHJcbiAgICAgKiAgICAgICAgIGJvcmRlclJhZGl1czogY3NzLnBlcmNlbnQoMTApLFxyXG4gICAgICogICAgICAgICBib3JkZXI6IFs0LCBcInNvbGlkXCIsIFwicmVkXCJdLFxyXG4gICAgICogICAgICAgICBcIjpob3ZlclwiOiB7XHJcbiAgICAgKiAgICAgICAgICAgICBvcGFjaXR5OiAwLjdcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIGJveCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgXCIrXCI6IHRoaXMuY29sb3JCb3gsXHJcbiAgICAgKiAgICAgICAgIHdpZHRoOiAyMDAsXHJcbiAgICAgKiAgICAgICAgIGhlaWdodDogMjAwLFxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIHNwZWNpYWxFbG0gPSB0aGlzLiRpZCh7XHJcbiAgICAgKiAgICAgICAgIFwiK1wiOiB0aGlzLmNvbG9yQm94LFxyXG4gICAgICogICAgICAgICB3aWR0aDogNjAwLFxyXG4gICAgICogICAgICAgICBoZWlnaHQ6IDQwMCxcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0eWxlc2V0IE9uZSBvciBtb3JlIHN0eWxlc2V0IG9iamVjdHMgdGhhdCB3aWxsIGJlIGluaGVyaXRlZCBieSBzdHlsZSBydWxlcyB0aGF0XHJcbiAgICAgKiBleHRlbmQgdGhpcyBhYnN0cmFjdCBydWxlLlxyXG4gICAgICogQHJldHVybnMgYElTdHlsZVJ1bGVgIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IHRoZSBkZXJpdmVkIHJ1bGVzIGluIHRoZSBgXCIrXCJgIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGFic3RyYWN0KCBzdHlsZXNldDogQ29tYmluZWRTdHlsZXNldCB8IENvbWJpbmVkU3R5bGVzZXRbXSk6IElTdHlsZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFic3RyYWN0UnVsZSggdGhpcywgc3R5bGVzZXQpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsYXNzIHJ1bGUuIFRoZSBjbGFzcyBuYW1lIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBydWxlIGlzIHByb2Nlc3NlZCBhcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlIGFsc28gb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgZWl0aGVyIGFuIGV4cGxpY2l0XHJcbiAgICAgKiBuYW1lIG9yIGFub3RoZXIgY2xhc3MgcnVsZS4gVGhlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXJzIGp1c3QgdG8gXCJkZWNsYXJlXCJcclxuICAgICAqIHRoZSBjbGFzcy4gU3VjaCBjbGFzcyBjYW4gYmUgbGF0ZXIgdXNlZCBlaXRoZXIgaW4gY29uZGl0aW9uYWwgZ3JvdXBpbmcgcnVsZXMgb3IgaW4gZGVyaXZlZFxyXG4gICAgICogc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXR1cm5lZCBbW0lDbGFzc1J1bGVdXSBpbnRlcmZhY2UgaGFzIHRoZSBgbmFtZWAgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBhc3NpZ25cclxuICAgICAqIHRoZSBjbGFzcyB0byBhbiBIVE1MIGVsZW1lbnRcclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICB2Ym94ID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcclxuICAgICAqICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcclxuICAgICAqICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiAuLi5cclxuICAgICAqIGxldCBzdHlsZXMgPSBjc3MuYWN0aXZhdGUoIE15Q2xhc3Nlcyk7XHJcbiAgICAgKiAuLi5cclxuICAgICAqIHJlbmRlclxyXG4gICAgICoge1xyXG4gICAgICogICAgIHJldHVybiA8ZGl2IGNsYXNzPXtzdHlsZXMudmJveC5uYW1lfT5cclxuICAgICAqICAgICAgICAgPHNwYW4+SGVsbG88L3NwYW4+XHJcbiAgICAgKiAgICAgICAgIDxzcGFuPldvcmxkITwvc3Bhbj5cclxuICAgICAqICAgICA8L2Rpdj5cclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHlsZXNldCBPbmUgb3IgbW9yZSBzdHlsZXNldCBvYmplY3RzIHRoYXQgZGVmaW5lIHN0eWxlIHByb3BlcnRpZXMgb2YgdGhlIGNsYXNzLlxyXG4gICAgICogQHBhcmFtIG5hbWVPdmVycmlkZSBzdHJpbmcgb3IgYW5vdGhlciBgSUNsYXNzUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGNsYXNzLiBJZiB0aGlzIG9wdGlvbmFsIHBhcmFtZXRlciBpcyBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIG92ZXJyaWRlIHRoZSBNaW1jc3MgbmFtZVxyXG4gICAgICogYXNzaWdubWVudCBtZWNoYW5pc20uIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGlmIHRoZXJlIGlzIGEgbmVlZCBmb3IgdGhlIGNsYXNzIHRvIG1hdGNoIGEgbmFtZVxyXG4gICAgICogb2YgYW5vdGhlciwgcHJvYmFibHkgZXh0ZXJuYWwsIGNsYXNzLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBkZWZpbmVkIGFzIGEgc3RyaW5nLCBpdCBzaG91bGRcclxuICAgICAqIG5vdCBoYXZlIHRoZSBgXCIuXCJgIHByZWZpeC5cclxuICAgICAqIEByZXR1cm5zIGBJQ2xhc3NSdWxlYCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgZ2V0dGluZyB0aGUgY2xhc3MgbmFtZSBhbmQgZm9yIGFjY2Vzc2luZ1xyXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgaWYgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGNsYXNzKCBzdHlsZXNldD86IENvbWJpbmVkQ2xhc3NTdHlsZXNldCB8IENvbWJpbmVkQ2xhc3NTdHlsZXNldFtdLFxyXG4gICAgICAgIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElDbGFzc1J1bGUpOiBJQ2xhc3NSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGFzc1J1bGUoIHRoaXMsIHN0eWxlc2V0LCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsYXNzIG5hbWUgcnVsZSwgd2hpY2ggY29tYmluZXMgb25lIG9yIG1vcmUgb3RoZXIgY2xhc3MgbmFtZXMuIFRoaXMgY3JlYXRlcyBhXHJcbiAgICAgKiBcInN5bm9ueW1cIiB0aGF0IGlzIGVhc2llciB0byBhcHBseSB0byBhbiBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIHRoYW4gYW4gYXJyYXkgb2YgdHdvIG9yXHJcbiAgICAgKiBtb3JlIGNsYXNzIHJ1bGVzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIGRlY2xhcmUgY2xhc3MgLSBqdXN0IHRvIGJlIHVzZWQgbGF0ZXJcclxuICAgICAqICAgICBzcGFjZWQgPSBjc3MuY2xhc3Moe2dhcDogOH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZib3ggPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICogICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNlICRjbGFzc25hbWUgcnVsZSB0byBjb21iaW5lIHRoZSBuYW1lcyBvZiBjbGFzc2VzIHZib3ggYW5kIHNwYWNlZFxyXG4gICAgICogICAgIHNwYWNlZFZib3ggPSB0aGlzLiRjbGFzc25hbWUoIHRoaXMudmJveCwgdGhpcy5zcGFjZWQpXHJcbiAgICAgKiB9XHJcbiAgICAgKiAuLi5cclxuICAgICAqIGxldCBzdHlsZXMgPSBjc3MuYWN0aXZhdGUoIE15Q2xhc3Nlcyk7XHJcbiAgICAgKiAuLi5cclxuICAgICAqIHJlbmRlclxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHdpdGhvdXQgc3BhY2VkVmJveCwgdGhlIGNsYXNzIHdvdWxkIGJlOiB7W3N0eWxlcy52Ym94Lm5hbWUsIHN0eWxlcy5zcGFjZWQubmFtZV19XHJcbiAgICAgKiAgICAgcmV0dXJuIDxkaXYgY2xhc3M9e3N0eWxlcy5zcGFjZWRWYm94Lm5hbWV9PlxyXG4gICAgICogICAgICAgICA8c3Bhbj5IZWxsbzwvc3Bhbj5cclxuICAgICAqICAgICAgICAgPHNwYW4+V29ybGQhPC9zcGFuPlxyXG4gICAgICogICAgIDwvZGl2PlxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC4uLmNsYXNzZXMgTGlzdCBvZiBjbGFzcyBuYW1lcyBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgc3RyaW5nIG9yIFtbSUNsYXNzUnVsZV1dIG9yXHJcbiAgICAgKiBbW0lDbGFzc05hbWVSdWxlXV0gb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm5zIGBJQ2xhc3NOYW1lUnVsZWAgb2JqZWN0IHdob3NlIGBuYW1lYCBwcm9wZXJ0eSBjb250YWlucyB0aGUgY29tYmluZWQgY2xhc3MgbmFtZSwgZS5nLlxyXG4gICAgICogYFwiY2xhc3MxIGNsYXNzMlwiYC4gVGhlIGBjc3NDbGFzc05hbWVgIHByb3BlcnR5IGNvbnRhaW5zIHRoZSBjb21iaW5lZCBzZWxlY3RvciwgZS5nLlxyXG4gICAgICogYFwiLmNsYXNzMS5jbGFzczJcImAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkY2xhc3NuYW1lKCAuLi5jbGFzc2VzOiAoSUNsYXNzUnVsZSB8IElDbGFzc05hbWVSdWxlIHwgc3RyaW5nKVtdKTogSUNsYXNzTmFtZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsYXNzTmFtZVJ1bGUoIHRoaXMsIGNsYXNzZXMpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElEIHJ1bGUuIFRoZSBJRCBuYW1lIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBydWxlIGlzIHByb2Nlc3NlZCBhcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlIGFsc28gb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgZWl0aGVyIGFuIGV4cGxpY2l0XHJcbiAgICAgKiBuYW1lIG9yIGFub3RoZXIgSUQgcnVsZS4gVGhlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXJzIGp1c3QgdG8gXCJkZWNsYXJlXCJcclxuICAgICAqIHRoZSBJRC4gU3VjaCBJRCBjYW4gYmUgbGF0ZXIgdXNlZCBlaXRoZXIgaW4gY29uZGl0aW9uYWwgZ3JvdXBpbmcgcnVsZXMgb3IgaW4gZGVyaXZlZFxyXG4gICAgICogc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXR1cm5lZCBbW0lJRFJ1bGVdXSBpbnRlcmZhY2UgaGFzIHRoZSBgbmFtZWAgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBhc3NpZ25cclxuICAgICAqIHRoZSBJRCB0byBhbiBIVE1MIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgY29udGFpbmVyID0gdGhpcy4kaWQoe1xyXG4gICAgICogICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcclxuICAgICAqICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcclxuICAgICAqICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiAuLi5cclxuICAgICAqIGxldCBzdHlsZXMgPSBjc3MuYWN0aXZhdGUoIE15Q2xhc3Nlcyk7XHJcbiAgICAgKiAuLi5cclxuICAgICAqIHJlbmRlclxyXG4gICAgICoge1xyXG4gICAgICogICAgIHJldHVybiA8ZGl2IGlkPXtzdHlsZXMuY29udGFpbmVyLm5hbWV9PlxyXG4gICAgICogICAgICAgICA8c3Bhbj5IZWxsbzwvc3Bhbj5cclxuICAgICAqICAgICAgICAgPHNwYW4+V29ybGQhPC9zcGFuPlxyXG4gICAgICogICAgIDwvZGl2PlxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0eWxlc2V0IE9uZSBvciBtb3JlIHN0eWxlc2V0IG9iamVjdHMgdGhhdCBkZWZpbmUgc3R5bGUgcHJvcGVydGllcyBvZiB0aGUgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBuYW1lT3ZlcnJpZGUgc3RyaW5nIG9yIGFub3RoZXIgYElJRFJ1bGVgIG9iamVjdCB0aGF0IGRldGVybWluZXMgdGhlIG5hbWUgb2YgdGhlIElELlxyXG4gICAgICogSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWUgYXNzaWdubWVudFxyXG4gICAgICogbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBJRCB0byBtYXRjaCBhIG5hbWUgb2YgYW5vdGhlciBJRC5cclxuICAgICAqIElmIHRoaXMgcGFyYW1ldGVyIGlzIGRlZmluZWQgYXMgYSBzdHJpbmcsIGl0IHNob3VsZCBub3QgaGF2ZSB0aGUgYFwiLlwiYCBwcmVmaXguXHJcbiAgICAgKiBAcmV0dXJucyBgSUlEUnVsZWAgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGdldHRpbmcgdGhlIElEIG5hbWUgYW5kIGZvciBhY2Nlc3NpbmdcclxuICAgICAqIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGlmIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRpZCggc3R5bGVzZXQ/OiBDb21iaW5lZFN0eWxlc2V0IHwgQ29tYmluZWRTdHlsZXNldFtdLCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJSURSdWxlKTogSUlEUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgSURSdWxlKCB0aGlzLCBzdHlsZXNldCwgbmFtZU92ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBydWxlIGZvciB0aGUgZ2l2ZW4gSFRNTCBvciBTVkcgZWxlbWVudCB0YWdzLiBUaGUgYHRhZ2AgcGFyYW1ldGVyIHNwZWNpZmllc1xyXG4gICAgICogZWl0aGVyIGEgc2luZ2xlIHRhZyBvciBhbiBhcnJheSBvZiB0YWdzLiBJbiBhZGRpdGlvbiwgYW4gYXN0ZXJpc2sgc3ltYm9sIChgXCIqXCJgKSBjYW4gYmVcclxuICAgICAqIHNwZWNpZmllZCB0byB0YXJnZXQgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gbXVsdGlwbGUgdGFncyBhcmUgc3BlY2lmaWVkLCB0aGV5IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHNlbGVjdG9yIGxpc3Q7IHRoYXQgaXMsIHRoZXkgd2lsbFxyXG4gICAgICogYmUgc2VwYXJhdGVkIGJ5IGNvbW1hcy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGVzOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gdXNpbmcgc3RyaW5nIGZvciBzZWxlY3RpbmcgYSBzaW5nbGUgZWxlbWVuZXQgdGFnO1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIENTUyBcInRyIHt9XCJcclxuICAgICAqICAgICB0ciA9IHRoaXMuJHRhZyggXCJ0clwiLCB7fSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNpbmcgYXJyYXkgZm9yIHNlbGVjdGluZyBtdWx0aXBsZSBlbGVtZW5ldCB0YWdzO1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIENTUyBcImgxLCBoMiwgaDMge31cIlxyXG4gICAgICogICAgIGhlYWRlcjEyMyA9IHRoaXMuJHRhZyggW1wiaDFcIiwgXCJoMlwiLCBcImgzXCJdLCB7fSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNpbmcgYXN0ZXJpc2sgdG8gYWRkcmVzcyBhbGwgZWxlbWVudHNcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBDU1MgXCIqIHt9XCJcclxuICAgICAqICAgICBhbGwgPSB0aGlzLiR0YWcoIFwiKlwiLCB7fSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YWcgT25lIG9yIG1vcmUgZWxlbWVudCB0YWdzXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVzZXQgT25lIG9yIG1vcmUgc3R5bGVzZXQgb2JqZWN0cyB0aGF0IGRlZmluZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgdGFncy5cclxuICAgICAqIEByZXR1cm5zIGBJU3R5bGVSdWxlYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0YWcgcnVsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICR0YWcoIHRhZzogXCIqXCIgfCBFbGVtZW50VGFnTmFtZSB8IEVsZW1lbnRUYWdOYW1lW10sXHJcbiAgICAgICAgc3R5bGVzZXQ6IENvbWJpbmVkU3R5bGVzZXQgfCBDb21iaW5lZFN0eWxlc2V0W10pOiBJU3R5bGVSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvclJ1bGUoIHRoaXMsIEFycmF5LmlzQXJyYXkodGFnKSA/IHRhZy5qb2luKFwiLFwiKSA6IHRhZywgc3R5bGVzZXQpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN0eWxlIHJ1bGUgd2l0aCBhbiBhcmJpdHJhcnkgY29tcGxleCBzZWxlY3Rvci4gU2VsZWN0b3JzIGNhbiBiZSBzcGVjaWZpZWQgYXNcclxuICAgICAqIG9uZSBvciBhcnJheSBvZiBbW1NlbGVjdG9ySXRlbV1dIG9iamVjdHMgd2hlcmUgZWFjaCBgU2VsZWN0b3JJdGVtYCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xyXG4gICAgICogdHlwZXM6XHJcbiAgICAgKiAtIHN0cmluZyAtIGFsbG93cyBhbnkgY29udGVudCBidXQgbGFja3MgdHlwZS1zYWZldHkgY2hlY2tzLlxyXG4gICAgICogLSBhbnkgc3R5bGUgcnVsZSwgdGhhdCBpcyBhIHJ1bGUgdGhhdCBpbXBsZW1lbnRzIHRoZSBbW0lTdHlsZVJ1bGVdXSBpbnRlcmZhY2UuIFRoaXMgYWxsb3dzXHJcbiAgICAgKiAgIHVzaW5nIHByZXZvdXNseSBkZWZpbmVkIHRhZywgY2xhc3MsIElEIGFuZCBvdGhlciBzdHlsZSBydWxlcyBhcyBzZWxlY3RvciBpdGVtc1xyXG4gICAgICogLSBbW3NlbGVjdG9yXV0gZnVuY3Rpb24gLSBhIHRhZyBmdW5jdGlvbiB0aGF0IGFsbG93cyBjb252ZW5pZW50IG1peGluZyBvZiBmcmVlLWZvcm1hdCBzdHJpbmdzXHJcbiAgICAgKiAgIGFuZCBzdHJvbmdseSB0eXBlZCBzdHlsZSBydWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIG11bHRpcGxlIHNlbGVjdG9yIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgd2lsbCBiZSBjb25jYXRlbmF0ZWQgaW50byBhIHNpbmdsZSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IGFsdGhvdWdoIHN0eWxlIHJ1bGVzIGNhbiBiZSB1c2VkIGZvciBzZWxlY3RpbmcgZWxlbWVudCB0YWdzLCB0aGUgW1skdGFnXV0gZnVuY3Rpb24gd291bGRcclxuICAgICAqIGJlIG1vcmUgYXBwcm9wcmlhdGUgYmVjYXVzZSBpdCB3aWxsIGNhdGNoIG1pc3NwZWxsaW5ncyBvZiB0YWcgbmFtZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlczoqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHVzaW5nIGEgc3RyaW5nXHJcbiAgICAgKiAgICAgc3R5bGUxID0gdGhpcy4kc3R5bGUoIFwibGk6OmJlZm9yZVwiLCB7fSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgaWQgPSB0aGlzLiRpZCgpXHJcbiAgICAgKiAgICAgY2xzID0gdGhpcy4kY2xhc3MoKVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyB1c2luZyBhbiBhcnJheSBvZiBzdHlsZSBydWxlcy4gVGhlIHNlbGVjdG9yIHdpbGwgYmUgXCIjaWQuY2xzXCJcclxuICAgICAqICAgICBzdHlsZTIgPSB0aGlzLiRzdHlsZSggW3RoaXMuaWQsIHRoaXMuY2xzXSwge30pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHVzaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbi4gVGhlIHNlbGVjdG9yIHdpbGwgYmUgXCIjaWQgPiAuY2xzXCJcclxuICAgICAqICAgICBzdHlsZTMgPSB0aGlzLiRzdHlsZSggY3NzLnNlbGVjdG9yYCR7dGhpcy5pZH0gPiAke3RoaXMuY2xzfWAsIHt9KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyB1c2luZyBhIHN0cmluZyBmb3Igc2VsZWN0aW5nIGVsZW1lbnQgdGFnLlxyXG4gICAgICogICAgIGgxID0gdGhpcy4kc3R5bGUoIFwiaDFcIiwge30pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3IgU3R5bGUgcnVsZSBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIHN0eWxlc2V0IE9uZSBvciBtb3JlIHN0eWxlc2V0IG9iamVjdHMgdGhhdCBkZWZpbmUgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhpcyBzZWxlY3Rvci5cclxuICAgICAqIEByZXR1cm5zIGBJU3R5bGVSdWxlYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBydWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJHN0eWxlKCBzZWxlY3RvcjogQ3NzU2VsZWN0b3IsIHN0eWxlc2V0OiBDb21iaW5lZFN0eWxlc2V0IHwgQ29tYmluZWRTdHlsZXNldFtdKTogSVN0eWxlUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3JSdWxlKCB0aGlzLCBzZWxlY3Rvciwgc3R5bGVzZXQpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBhbmltYXRpb24gcnVsZS4gVGhlIGFuaW1hdGlvbiBuYW1lIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBydWxlIGlzIHByb2Nlc3NlZCBhc1xyXG4gICAgICogcGFydCBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlIGFsc28gb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgZWl0aGVyIGFuXHJcbiAgICAgKiBleHBsaWNpdCBuYW1lIG9yIGFub3RoZXIgYW5pbWF0aW9uIHJ1bGUuIFRoZSBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgcGFyYW1ldGVycyBqdXN0IHRvXHJcbiAgICAgKiBcImRlY2xhcmVcIiB0aGUgYW5pbWF0aW9uLiBTdWNoIGFuaW1hdGlvbiBjYW4gYmUgbGF0ZXIgdXNlZCBlaXRoZXIgaW4gY29uZGl0aW9uYWwgZ3JvdXBpbmcgcnVsZXNcclxuICAgICAqIG9yIGluIGRlcml2ZWQgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXR1cm5lZCBbW0lBbmltYXRpb25SdWxlXV0gaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlblxyXG4gICAgICogdXNpbmcgdGhlIGtleWZyYW1lcyBuYW1lIGluIHRoZSBgYW5pbWF0aW9uLW5hbWVgIG9yIGBhbmltYXRpb25gIHN0eWxlIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgdmFuaXNoID0gdGhpcy4ka2V5ZnJhbWVzKFtcclxuICAgICAqICAgICAgICAgWzAsIHsgb3BhY2l0eTogMTAwIH1dLFxyXG4gICAgICogICAgIFx0ICAgWzEwMCwgeyBvcGFjaXR5OiAwIH1dLFxyXG4gICAgICogICAgIF0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZhbmlzaGluZ0Jsb2NrID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBhbmltYXRpb246IHsgbmFtZTogdGhpcy52YW5pc2gsIGR1cmF0aW9uOiAyMDAwLCBjb3VudDogXCJpbmZpbml0ZVwiLCBkaXJlY3Rpb246IFwiYWx0ZXJuYXRlXCIgfVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZnJhbWVzIEFycmF5IG9mIFtbQW5pbWF0aW9uRnJhbWVdXSBvYmplY3RzLiBFYWNoIGFuaW1hdGlvbiBmcmFtZSBjb250YWlucyBhIHdheXBvaW50XHJcbiAgICAgKiBhbmQgYSBzdHlsZXNldC5cclxuICAgICAqIEBwYXJhbSBuYW1lT3ZlcnJpZGUgU3RyaW5nIG9yIGFub3RoZXIgYElBbmltYXRpb25SdWxlYCBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBuYW1lIG9mIHRoZVxyXG4gICAgICogYW5pbWF0aW9uLiBJZiB0aGlzIG9wdGlvbmFsIHBhcmFtZXRlciBpcyBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIG92ZXJyaWRlIHRoZSBNaW1jc3MgbmFtZVxyXG4gICAgICogYXNzaWdubWVudCBtZWNoYW5pc20uIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGlmIHRoZXJlIGlzIGEgbmVlZCBmb3IgdGhlIG5hbWUgdG8gbWF0Y2ggYSBuYW1lIG9mXHJcbiAgICAgKiBhbm90aGVyIGFuaW1hdGlvbi5cclxuICAgICAqIEByZXR1cm5zIGBJQW5pbWF0aW9uUnVsZWAgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGdldHRpbmcgdGhlIGFuaW1hdGlvbiBuYW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGtleWZyYW1lcyggZnJhbWVzPzogQW5pbWF0aW9uRnJhbWVbXSwgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUFuaW1hdGlvblJ1bGUpOiBJQW5pbWF0aW9uUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uUnVsZSggdGhpcywgZnJhbWVzLCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBjdXN0b20gdmFyaWFibGUgb2JqZWN0IHRoYXQgZGVmaW5lcyBhIGN1c3RvbSBDU1MgcHJvcGVydHkuIFRoZSB2YXJpYWJsZSBuYW1lIHdpbGxcclxuICAgICAqIGJlIGNyZWF0ZWQgd2hlbiB0aGUgcnVsZSBpcyBwcm9jZXNzZWQgYXMgcGFydCBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlXHJcbiAgICAgKiBhbHNvIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nIGVpdGhlciBhbiBleHBsaWNpdCBuYW1lIG9yIGFub3RoZXIgY3VzdG9tIHZhcmlhYmxlIHJ1bGUuIFRoZVxyXG4gICAgICogZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIHZhbHVlIGp1c3QgdG8gXCJkZWNsYXJlXCIgdGhlIHZhcmlhYmxlLiBTdWNoXHJcbiAgICAgKiB2YXJpYWJsZSBjYW4gYmUgbGF0ZXIgdXNlZCBlaXRoZXIgaW4gY29uZGl0aW9uYWwgZ3JvdXBpbmcgcnVsZXMgb3IgaW4gZGVyaXZlZCBzdHlsZSBkZWZpbml0aW9uXHJcbiAgICAgKiBjbGFzc2VzLlxyXG4gICAgICpcclxuICAgICAqIEN1c3RvbSBwcm9wZXJ0aWVzIGRlZmluZWQgdXNpbmcgdGhlIGAkdmFyYCBmdW5jdGlvbiBhcmUgaW5jbHVkZWQgaW50byB0aGUgYDpyb290IHt9YCBibG9jaztcclxuICAgICAqIGhvd2V2ZXIsIHRoZXkgY2FuIGJlIHJlZGVmaW5lZCB3aXRoIGRpZmZlcmVudCB2YWx1ZXMgdW5kZXIgYW55IHN0eWxlIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gZGVmaW5lIGFuZCB1c2UgY3VzdG9tIENTUyBwcm9wZXJ0eVxyXG4gICAgICogICAgIGltcG9ydGFudFRleHRDb2xvciA9IHRoaXMuJHZhciggXCJjb2xvclwiLCBcInJlZFwiKVxyXG4gICAgICogICAgIGltcG9ydGFudCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgY29sb3I6IHRoaXMuaW1wb3J0YW50VGV4dENvbG9yXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNlIGRpZmZlcmVudCB2YWx1ZSBmb3IgdGhlIGN1c3RvbSBwcm9wZXJ0eSB1bmRlciBhbm90aGVyIENTUyBjbGFzc1xyXG4gICAgICogICAgIHNwZWNpYWwgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIFwiK1wiOiB0aGlzLmltcG9ydGFudCxcclxuICAgICAqICAgICAgICAgXCItLVwiOiBbIFt0aGlzLmltcG9ydGFudFRleHRDb2xvciwgXCJtYXJvb25cIl0gXVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGUgRWl0aGVyIGEgbmFtZSBvZiBhIHN0eWxlIHByb3BlcnR5IChpbiBjYW1lbC1jYXNlKSBvciBhIG5hbWUgb2YgdGhlIHByb3BlcnR5IGZyb21cclxuICAgICAqIHRoZSBbW0lWYXJUZW1wbGF0ZVN0eWxlc2V0XV0gaW50ZXJmYWNlLiBUaGUgdHlwZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgcHJvcGVydHkgZGVmaW5lcyB0aGUgdHlwZVxyXG4gICAgICogb2YgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIGFzc2lnbmVkIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSBuYW1lT3ZlcnJpZGUgU3RyaW5nIG9yIGFub3RoZXIgYElWYXJSdWxlYCBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBuYW1lIG9mIHRoZVxyXG4gICAgICogY3VzdG9tIHByb3BlcnR5LiBJZiB0aGlzIG9wdGlvbmFsIHBhcmFtZXRlciBpcyBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIG92ZXJyaWRlIHRoZSBNaW1jc3MgbmFtZVxyXG4gICAgICogYXNzaWdubWVudCBtZWNoYW5pc20uIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGlmIHRoZXJlIGlzIGEgbmVlZCBmb3IgdGhlIG5hbWUgdG8gbWF0Y2ggYSBuYW1lIG9mXHJcbiAgICAgKiBleGlzdGluZyBwcm9wZXJ0eS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBhcyBhIHN0cmluZywgaXQgc2hvdWxkIG5vdCBoYXZlIHRoZSBgXCIuXCJgIHByZWZpeC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSVZhclJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1c3RvbSBwcm9wZXJ0eS4gQW55IHVzYWdlIG9mIHRoaXMgb2JqZWN0IGluXHJcbiAgICAgKiBzdHlsZSBwcm9wZXJ0aWVzIG9yIGZ1bmN0aW9uIHBhcmFtZXRlcnMgaXMgc3Vic3RpdHV0ZWQgYnkgdGhlIGB2YXIoKWAgQ1NTIGZ1bmN0aW9uIGludm9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkdmFyPEsgZXh0ZW5kcyBWYXJUZW1wbGF0ZU5hbWU+KCB0ZW1wbGF0ZTogSywgdmFsdWU/OiBFeHRlbmRlZFZhclZhbHVlPEs+LFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElWYXJSdWxlPEs+KTogSVZhclJ1bGU8Sz5cclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZhclJ1bGUoIHRoaXMsIHRlbXBsYXRlLCB2YWx1ZSwgbmFtZU92ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYEBwcm9wZXJ0eWAgcnVsZS4gVGhlIHByb3BlcnR5IG5hbWUgd2lsbCBiZSBjcmVhdGVkIHdoZW4gdGhlIHJ1bGUgaXMgcHJvY2Vzc2VkXHJcbiAgICAgKiBhcyBwYXJ0IG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBUaGUgbmFtZSBjYW4gYmUgYWxzbyBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBlaXRoZXJcclxuICAgICAqIGFuIGV4cGxpY2l0IG5hbWUgb3IgYW5vdGhlciBjdXN0b20gdmFyaWFibGUgcnVsZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHZhcmlhbnQgYWxsb3dzIHNwZWNpZnlpbmcgc3ludGF4IGFzIG9uZSBvZiBwcmVkZWZpbmVkIHN5bnRheCBpdGVtcyBzdWNoIGFzIGA8bnVtYmVyPmBcclxuICAgICAqIG9yIGA8Y29sb3I+YCBvcHRpb25hbGx5IGFjY29tcGFuaWVkIHdpdGggdGhlIG11bHRpcGxpZXJzIGBcIiNcImAgb3IgYFwiK1wiLiBUaGUgdHlwZSBvZiBpbml0aWFsXHJcbiAgICAgKiB2YWx1ZSBhcyB3ZWxsIGFzIHRoZSB0eXBlIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYHNldFZhbHVlYCBtZXRob2Qgb2YgdGhlIHJldHVybmVkXHJcbiAgICAgKiBbW0lWYXJSdWxlXV0gaW50ZXJmYWNlIHdpbGwgYmUgZW5mb3JjZWQgYWNjb3JkaW5nIHRvIHRoZSBzeW50YXggc3BlY2lmaWVkLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIGRlZmluZSBhbmQgdXNlIGN1c3RvbSBDU1MgcHJvcGVydHlcclxuICAgICAqICAgICBpbXBvcnRhbnRUZXh0Q29sb3IgPSB0aGlzLiRwcm9wZXJ0eSggXCI8Y29sb3I+XCIsIFwicmVkXCIsIGZhbHNlKVxyXG4gICAgICogICAgIGltcG9ydGFudCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgY29sb3I6IHRoaXMuaW1wb3J0YW50VGV4dENvbG9yXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNlIGRpZmZlcmVudCB2YWx1ZSBmb3IgdGhlIGN1c3RvbSBwcm9wZXJ0eSB1bmRlciBhbm90aGVyIENTUyBjbGFzc1xyXG4gICAgICogICAgIHNwZWNpYWwgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIFwiK1wiOiB0aGlzLmltcG9ydGFudCxcclxuICAgICAqICAgICAgICAgXCItLVwiOiBbIFt0aGlzLmltcG9ydGFudFRleHRDb2xvciwgXCJtYXJvb25cIl0gXVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3ludGF4IE5hbWUgb2YgdGhlIHByb3BlcnR5IGZyb20gdGhlIFtbSVN5bnRheFR5cGVTdHlsZXNldF1dIGludGVyZmFjZS4gVGhlIHR5cGVcclxuICAgICAqIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIHRoZSB0eXBlIG9mIHRoZSBpbml0aWFsIHZhbHVlIHBhcmFtZXRlci5cclxuICAgICAqIEBwYXJhbSBpbml0VmFsdWUgVGhlIHZhbHVlIHRvIGJlIHVzZWQgYXMgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gaW5oZXJpdHMgRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGN1c3RvbSBwcm9wZXJ0eSByZWdpc3RyYXRpb24gaW5oZXJpdHMgYnkgZGVmYXVsdC5cclxuICAgICAqIEBwYXJhbSBuYW1lT3ZlcnJpZGUgU3RyaW5nIG9yIGFub3RoZXIgYElWYXJSdWxlYCBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBuYW1lIG9mIHRoZVxyXG4gICAgICogY3VzdG9tIHByb3BlcnR5LiBJZiB0aGlzIG9wdGlvbmFsIHBhcmFtZXRlciBpcyBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIG92ZXJyaWRlIHRoZSBNaW1jc3MgbmFtZVxyXG4gICAgICogYXNzaWdubWVudCBtZWNoYW5pc20uIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGlmIHRoZXJlIGlzIGEgbmVlZCBmb3IgdGhlIG5hbWUgdG8gbWF0Y2ggYSBuYW1lIG9mXHJcbiAgICAgKiBleGlzdGluZyBwcm9wZXJ0eS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBhcyBhIHN0cmluZywgaXQgc2hvdWxkIG5vdCBoYXZlIHRoZSBgXCIuXCJgIHByZWZpeC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSVZhclJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGBAcHJvcGVydHlgIHJ1bGUuIEFueSB1c2FnZSBvZiB0aGlzIG9iamVjdCBpblxyXG4gICAgICogc3R5bGUgcHJvcGVydGllcyBvciBmdW5jdGlvbiBwYXJhbWV0ZXJzIGlzIHN1YnN0aXR1dGVkIGJ5IHRoZSBgdmFyKClgIENTUyBmdW5jdGlvbiBpbnZvY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJHByb3BlcnR5PEsgZXh0ZW5kcyBrZXlvZiBJU3ludGF4VHlwZVN0eWxlc2V0PihcclxuICAgICAgICBzeW50YXg6IEssIGluaXRWYWx1ZTogRXh0ZW5kZWRWYXJWYWx1ZTxLPiwgaW5oZXJpdHM6IGJvb2xlYW4sXHJcbiAgICAgICAgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSVZhclJ1bGU8Sz4pOiBJVmFyUnVsZTxLPlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYEBwcm9wZXJ0eWAgcnVsZS4gVGhlIHByb3BlcnR5IG5hbWUgd2lsbCBiZSBjcmVhdGVkIHdoZW4gdGhlIHJ1bGUgaXMgcHJvY2Vzc2VkXHJcbiAgICAgKiBhcyBwYXJ0IG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBUaGUgbmFtZSBjYW4gYmUgYWxzbyBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBlaXRoZXJcclxuICAgICAqIGFuIGV4cGxpY2l0IG5hbWUgb3IgYW5vdGhlciBjdXN0b20gdmFyaWFibGUgcnVsZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHZhcmlhbnQgYWxsb3dzIHNwZWNpZnlpbmcgYXJiaXRyYXJ5IHN5bnRheCBhbmQgdGhlIGRldmVsb3BlcnMgYXJlIHJlc3BvbnNpYmxlIHRvXHJcbiAgICAgKiBwcm92aWRlIGNvcnJlY3Qgc3ludGF4LiBUaGUgdHlwZSBvZiBpbml0aWFsIHZhbHVlIGFzIHdlbGwgYXMgdGhlIHR5cGUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXHJcbiAgICAgKiB0aGUgYHNldFZhbHVlYCBtZXRob2Qgb2YgdGhlIHJldHVybmVkIFtbSVZhclJ1bGVdXSBpbnRlcmZhY2UgYXJlIGxpbWl0ZWQgdG8gc3RyaW5nLiBUaGVcclxuICAgICAqIGRldmVsb3BlcnMgYXJlIHJlc3BvbnNpYmxlIHRvIHBhc3MgdmFsdWVzIHRoYXQgY29uZm9ybSB0byB0aGUgc3BlY2lmaWVkIHN5bnRheC5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBkZWZpbmUgYW5kIHVzZSBjdXN0b20gQ1NTIHByb3BlcnR5XHJcbiAgICAgKiAgICAgaW1wb3J0YW50VGV4dENvbG9yID0gdGhpcy4kcHJvcGVydHkoIFtcIjxjb2xvcj4jIHwgbm9uZVwiXSwgXCJyZWRcIiwgZmFsc2UpXHJcbiAgICAgKiAgICAgaW1wb3J0YW50ID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBjb2xvcjogdGhpcy5pbXBvcnRhbnRUZXh0Q29sb3JcclxuICAgICAqICAgICB9KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyB1c2UgZGlmZmVyZW50IHZhbHVlIGZvciB0aGUgY3VzdG9tIHByb3BlcnR5IHVuZGVyIGFub3RoZXIgQ1NTIGNsYXNzXHJcbiAgICAgKiAgICAgc3BlY2lhbCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgXCIrXCI6IHRoaXMuaW1wb3J0YW50LFxyXG4gICAgICogICAgICAgICBcIi0tXCI6IFsgW3RoaXMuaW1wb3J0YW50VGV4dENvbG9yLCBcIm1hcm9vblwiXSBdXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzeW50YXggU2luZ2xlLWVsZW1lbnQgdHVwbGUgY29udGFpbmluZyB0aGUgc3ludGF4IHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBpbml0VmFsdWUgVGhlIHZhbHVlIHRvIGJlIHVzZWQgYXMgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gaW5oZXJpdHMgRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGN1c3RvbSBwcm9wZXJ0eSByZWdpc3RyYXRpb24gaW5oZXJpdHMgYnkgZGVmYXVsdC5cclxuICAgICAqIEBwYXJhbSBuYW1lT3ZlcnJpZGUgU3RyaW5nIG9yIGFub3RoZXIgYElWYXJSdWxlYCBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBuYW1lIG9mIHRoZVxyXG4gICAgICogY3VzdG9tIHByb3BlcnR5LiBJZiB0aGlzIG9wdGlvbmFsIHBhcmFtZXRlciBpcyBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIG92ZXJyaWRlIHRoZSBNaW1jc3MgbmFtZVxyXG4gICAgICogYXNzaWdubWVudCBtZWNoYW5pc20uIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGlmIHRoZXJlIGlzIGEgbmVlZCBmb3IgdGhlIG5hbWUgdG8gbWF0Y2ggYSBuYW1lIG9mXHJcbiAgICAgKiBleGlzdGluZyBwcm9wZXJ0eS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBhcyBhIHN0cmluZywgaXQgc2hvdWxkIG5vdCBoYXZlIHRoZSBgXCIuXCJgIHByZWZpeC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSVZhclJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGBAcHJvcGVydHlgIHJ1bGUuIEFueSB1c2FnZSBvZiB0aGlzIG9iamVjdCBpblxyXG4gICAgICogc3R5bGUgcHJvcGVydGllcyBvciBmdW5jdGlvbiBwYXJhbWV0ZXJzIGlzIHN1YnN0aXR1dGVkIGJ5IHRoZSBgdmFyKClgIENTUyBmdW5jdGlvbiBpbnZvY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJHByb3BlcnR5KCBzeW50YXg6IFtzdHJpbmddLCBpbml0VmFsdWU6IEV4dGVuZGVkUHJvcDxzdHJpbmc+LCBpbmhlcml0czogYm9vbGVhbixcclxuICAgICAgICBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJVmFyUnVsZTxcIipcIj4pOiBJVmFyUnVsZTxcIipcIj47XHJcblxyXG4gICAgLy8gaW1wbGVtZW50YXRpb25cclxuICAgICRwcm9wZXJ0eTxLIGV4dGVuZHMga2V5b2YgSVN5bnRheFR5cGVTdHlsZXNldCA9IGFueSwgVCBleHRlbmRzIEsgfCBbc3RyaW5nXSA9IGFueT4oXHJcbiAgICAgICAgc3ludGF4OiBULCBpbml0VmFsdWU6IEV4dGVuZGVkVmFyVmFsdWU8Sz4sIGluaGVyaXRzID0gdHJ1ZSxcclxuICAgICAgICBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJVmFyUnVsZTxLPik6IElWYXJSdWxlPEs+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJ1bGUoIHRoaXMsIHN5bnRheCwgaW5pdFZhbHVlLCBpbmhlcml0cywgbmFtZU92ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFwiY29uc3RhbnRcIiB0aGF0IGNhbiBiZSB1c2VkIGFueXdoZXJlIHRoZSB0eXBlIGRlZmluZWQgYnkgdGhlIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIGNhblxyXG4gICAgICogYmUgdXNlZC4gVGhleSBhcmUgY2FsbGVkIGNvbnN0YW50cywgYmVjYXVzZSB0aGV5IHByb3ZpZGUgYSBjb252ZW5pZW50IGFuZCBsaWdodHdlaWdodCB3YXkgb2ZcclxuICAgICAqIGRlZmluaW5nIHZhbHVlcyB0aGF0IGFyZSB1bmNoYW5nZWQgZHVyaW5nIHRoZSBhcHBsaWNhdGlvbiBsaWZldGltZS4gQWx0aG91Z2ggY29uc3RhbnRzIGFyZVxyXG4gICAgICogZGVmaW5lZCB2ZXJ5IHNpbWlsYXJseSB0byBjdXN0b20gcHJvcGVydGllcyAoc2VlIHRoZSBbWyR2YXJdXSBmdW5jdGlvbiksIHRoZXkgY2Fubm90IHBhcnRpY2lwYXRlXHJcbiAgICAgKiBpbiB0aGUgY2FzY2FkZSBhbmQgY2Fubm90IGJlIHJlZGVmaW5lZCB1bmRlciBzdHlsZSBydWxlcy4gQ29uc3RhbnQgY2FuIHVzZSBhbnkgZXhwcmVzc2lvbiB0aGF0XHJcbiAgICAgKiBzYXRpc2ZpZXMgdGhlIHR5cGUgZGVmaW5lZCBieSB0aGUgYHRlbXBsYXRlYCBwYXJhbWV0ZXIgaW5jbHVkaW5nIG90aGVyIGNvbnN0YW50cywgY3VzdG9tXHJcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCBmdW5jdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogTm8gQ1NTIHJ1bGVzIGFyZSBjcmVhdGVkIGZvciBjb25zdGFudHMgYW5kLCBkdWUgdG8gdGhpcyBmYWN0LCBjb25zdGFudHMgYXJlIHByZWZlcmFibGUgdG8gY3VzdG9tXHJcbiAgICAgKiBwcm9wZXJ0aWVzIHVubGVzcyB0aGUgaW50ZW50aW9uIGlzIHRvIGNoYW5nZSB0aGUgdmFyaWFibGUgdmFsdWUgYXQgcnVuLXRpbWUgb3IgdG8gcmVkZWZpbmUgaXRzXHJcbiAgICAgKiB2YWx1ZSB1bmRlciBkaWZmZXJlbnQgc3R5bGUgcnVsZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gZGVmaW5pbmcgYW5kIHVzaW5nIGN1c3RvbSBDU1MgcHJvcGVydHlcclxuICAgICAqICAgICBkZWZhdWx0VGV4dENvbG9yID0gdGhpcy4kY29uc3QoIFwiY29sb3JcIiwgXCJyZWRcIilcclxuICAgICAqICAgICBwYXJhID0gdGhpcy4kc3R5bGUoIFwicFwiLCB7XHJcbiAgICAgKiAgICAgICAgIGNvbG9yOiB0aGlzLmRlZmF1bHRUZXh0Q29sb3JcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIEVpdGhlciBhIG5hbWUgb2YgYSBzdHlsZSBwcm9wZXJ0eSAoaW4gY2FtZWwtY2FzZSkgb3IgYSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBmcm9tXHJcbiAgICAgKiB0aGUgW1tJVmFyVGVtcGxhdGVTdHlsZXNldF1dIGludGVyZmFjZS4gVGhlIHR5cGUgY29ycmVzcG9uZGluZyB0byB0aGF0IHByb3BlcnR5IGRlZmluZXMgdGhlIHR5cGVcclxuICAgICAqIG9mIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgY29uc3RhbnQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYElDb25zdFJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mIHRoZSBjb25zdGFudC4gVGhlIHZhbHVlIGlzXHJcbiAgICAgKiBjb21wdXRlZCBvbmNlIHdoZW4gdGhlIHN0eWxlIGRlZmluaXRpb24gaXMgcHJvY2Vzc2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGNvbnN0PEsgZXh0ZW5kcyBWYXJUZW1wbGF0ZU5hbWU+KCB0ZW1wbGF0ZTogSywgdmFsdWU/OiBFeHRlbmRlZFZhclZhbHVlPEs+KTogSUNvbnN0UnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RSdWxlKCB0aGlzLCB0ZW1wbGF0ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBjb3VudGVyIG9iamVjdC4gVGhlIGNvdW50ZXIgbmFtZSB3aWxsIGJlIGNyZWF0ZWQgd2hlbiB0aGUgcnVsZSBpcyBwcm9jZXNzZWQgYXNcclxuICAgICAqIHBhcnQgb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBuYW1lIGNhbiBiZSBhbHNvIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nIGVpdGhlciBhblxyXG4gICAgICogZXhwbGljaXQgbmFtZSBvciBhbm90aGVyIGNvdW50ZXIgcnVsZS5cclxuICAgICAqXHJcbiAgICAgKiBDb3VudGVyIHJ1bGVzIGRvbid0IGNyZWF0ZSBhbnkgQ1NTIHJ1bGVzLCBidXQgdGhleSBjcmVhdGUgdW5pcXVlIG5hbWVzIHRoYXQgY2FuIGJlIHVzZWRcclxuICAgICAqIGZvciBgY291bnRlci1yZXNldGAgYW5kIGBjb3VudGVyLWluY3JlbWVudGAgc3R5bGUgcHJvcGVydGllcy4gQ291bnRlciBydWxlcyBhcmUgdXN1YWxseSB1c2VkXHJcbiAgICAgKiBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBbW2NvdW50ZXJdXSBhbmQgW1tjb3VudGVyc11dIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBjb3VudGVyID0gdGhpcy4kY291bnRlcigpXHJcbiAgICAgKiAgICAgb2wgPSB0aGlzLiRzdHlsZSggXCJvbFwiLCB7IGNvdW50ZXJSZXNldDogdGhpcy5jb3VudGVyLCBsaXN0U3R5bGVUeXBlOiBcIm5vbmVcIiB9KVxyXG4gICAgICogICAgIGxpID0gdGhpcy4kc3R5bGUoIFwibGlcIiwge1xyXG4gICAgICogICAgICAgICBjb3VudGVySW5jcmVtZW50OiB0aGlzLmNvdW50ZXIsXHJcbiAgICAgKiAgICAgICAgIFwiOjpiZWZvcmVcIjogeyBjb250ZW50OiBjc3MuY291bnRlcnMoIHRoaXMuY291bnRlcikgfVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJQ291bnRlclJ1bGVgIG9iamVjdCB0aGF0IGRldGVybWluZXMgdGhlIG5hbWUgb2YgdGhlXHJcbiAgICAgKiBjb3VudGVyLiBJZiB0aGlzIG9wdGlvbmFsIHBhcmFtZXRlciBpcyBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIG92ZXJyaWRlIHRoZSBNaW1jc3MgbmFtZVxyXG4gICAgICogYXNzaWdubWVudCBtZWNoYW5pc20uIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGlmIHRoZXJlIGlzIGEgbmVlZCBmb3IgdGhlIG5hbWUgdG8gbWF0Y2ggYSBuYW1lIG9mXHJcbiAgICAgKiBleGlzdGluZyBjb3VudGVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJQ291bnRlclJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGNvdW50ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkY291bnRlciggbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUNvdW50ZXJSdWxlKTogSUNvdW50ZXJSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb3VudGVyUnVsZSggdGhpcywgbmFtZU92ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGNvdW50ZXIgc3R5bGUgcnVsZS4gVGhlIGNvdW50ZXIgc3R5bGUgbmFtZSB3aWxsIGJlIGNyZWF0ZWQgd2hlbiB0aGUgcnVsZSBpc1xyXG4gICAgICogcHJvY2Vzc2VkIGFzIHBhcnQgb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBuYW1lIGNhbiBiZSBhbHNvIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nXHJcbiAgICAgKiBlaXRoZXIgYW4gZXhwbGljaXQgbmFtZSBvciBhbm90aGVyIGNvdW50ZXIgc3R5bGUgcnVsZS5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBjb3VudGVyU3R5bGUgPSB0aGlzLiRjb3VudGVyU3R5bGUoe1xyXG4gICAgICogICAgICAgICBzeXN0ZW06IFwiY3ljbGljXCIsXHJcbiAgICAgKiAgICAgICAgIHN5bWJvbHM6IFtcIm9uZVwiLCBcInR3b1wiLCBcInRocmVlXCJdLFxyXG4gICAgICogICAgICAgICBzdWZmaXg6IFwiIC0gXCJcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvdW50ZXJTdHlsZXNldCBBbiBvYmplY3QgdGhhdCBkZWZpbmVzIGNvdW50ZXIgc3R5bGUgZmVhdHVyZXMuXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJQ291bnRlclN0eWxlUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGNvdW50ZXIgc3R5bGUuIElmIHRoaXMgb3B0aW9uYWwgcGFyYW1ldGVyIGlzIGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgb3ZlcnJpZGUgdGhlIE1pbWNzcyBuYW1lXHJcbiAgICAgKiBhc3NpZ25tZW50IG1lY2hhbmlzbS4gVGhpcyBtaWdodCBiZSB1c2VmdWwgaWYgdGhlcmUgaXMgYSBuZWVkIGZvciB0aGUgbmFtZSB0byBtYXRjaCBhIG5hbWUgb2ZcclxuICAgICAqIGV4aXN0aW5nIGNvdW50ZXIgc3R5bGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYElDb3VudGVyU3R5bGVSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjb3VudGVyIHN0eWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGNvdW50ZXJTdHlsZSggY291bnRlclN0eWxlc2V0PzogRXh0ZW5kZWRDb3VudGVyU3R5bGVzZXQsXHJcbiAgICAgICAgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUNvdW50ZXJTdHlsZVJ1bGUpOiBJQ291bnRlclN0eWxlUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ291bnRlclN0eWxlUnVsZSggdGhpcywgY291bnRlclN0eWxlc2V0LCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBncmlkIGxpbmUgcnVsZS4gVGhlIGxpbmUgbmFtZSB3aWxsIGJlIGNyZWF0ZWQgd2hlbiB0aGUgcnVsZSBpcyBwcm9jZXNzZWQgYXNcclxuICAgICAqIHBhcnQgb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBuYW1lIGNhbiBiZSBhbHNvIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nIGVpdGhlciBhblxyXG4gICAgICogZXhwbGljaXQgbmFtZSBvciBhbm90aGVyIGdyaWQgbGluZSBydWxlLiBUaGUgZ3JpZCBsaW5lIHJ1bGVzIGFyZSB1c2VkIHRvIGRlZmluZSB2YWx1ZXMgb2ZcclxuICAgICAqIHN0eWxlIHByb3BlcnRpZXMgYGdyaWQtcm93LXN0YXJ0L2VuZGAgYW5kIGBncmlkLWNvbHVtbi1zdGFydC9lbmRgLlxyXG4gICAgICpcclxuICAgICAqIE5vIENTUyBydWxlIGlzIGNyZWF0ZWQgZm9yIGdyaWQgbGluZXMgLSB0aGVzZSBvYmplY3RzIGFyZSBzb2xlbHkgdXNlZCBmb3IgY3JlYXRpbmcgbmFtZXMsIHdoaWNoXHJcbiAgICAgKiBjYW4gYmUgdHlwZS1zYWZlbHkgcmVmZXJyZWQgdG8gZnJvbSBzdHlsZSBydWxlcy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBncmlkTGluZUZpcnN0ID0gdGhpcy4kZ3JpZGxpbmUoKVxyXG4gICAgICogICAgIGdyaWRMaW5lTGFzdCA9IHRoaXMuJGdyaWRsaW5lKClcclxuICAgICAqXHJcbiAgICAgKiAgICAgZ3JpZCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgZGlzcGxheTogXCJncmlkXCIsXHJcbiAgICAgKiAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IFsgW3RoaXMuZ3JpZExpbmVGaXJzdF0sIFwiMWZyXCIsIFwiMmZyXCIsIFt0aGlzLmdyaWRMaW5lTGFzdF0gXSxcclxuICAgICAqICAgICAgICAgZ3JpZFRlbXBsYXRlUm93czogY3NzLnJlcGVhdCggMiwgXCIxZnJcIiksXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgZmlyc3QgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGdyaWRDb2x1bW5TdGFydDogdGhpcy5ncmlkTGluZUZpcnN0LFxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIGxhc3QgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGdyaWRDb2x1bW5FbmQ6IHRoaXMuZ3JpZExpbmVMYXN0LFxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJR3JpZExpbmVSdWxlYCBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBuYW1lIG9mIHRoZVxyXG4gICAgICogbGluZS4gSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWVcclxuICAgICAqIGFzc2lnbm1lbnQgbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBuYW1lIHRvIG1hdGNoIGEgbmFtZSBvZlxyXG4gICAgICogZXhpc3RpbmcgZ3JpZCBsaW5lLlxyXG4gICAgICogQHBhcmFtIGlzU3RhcnRFbmRPck5vbmUgRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBcIi1zdGFydFwiYCBvciBgXCItZW5kXCJgIHN1ZmZpeCBzaG91bGQgYmVcclxuICAgICAqIGFwcGVuZGVkIHRvIHRoZSBydWxlIG5hbWUuIElmIHRoZSBmbGFnIGlzIHRydWUsIGBcIi1zdGFydFwiYCBpcyBhcHBlbmRlZDsgaWYgdGhlIGZsYWcgaXMgZmFsc2UsXHJcbiAgICAgKiBgXCItZW5kXCJgIGlzIGFwcGVuZGVkOyBpZiB0aGUgZmxhZyBpcyB1bmRlZmluZWQsIG5vIHN1ZmZpeCBpcyBhcHBlbmRlZCB0byB0aGUgcnVsZSBuYW1lLlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJR3JpZExpbmVSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBncmlkIGxpbmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkZ3JpZGxpbmUoIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkTGluZVJ1bGUsXHJcbiAgICAgICAgaXNTdGFydEVuZE9yTm9uZT86IGJvb2xlYW4pOiBJR3JpZExpbmVSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcmlkTGluZVJ1bGUoIHRoaXMsIG5hbWVPdmVycmlkZSwgaXNTdGFydEVuZE9yTm9uZSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZ3JpZCBhcmVhIHJ1bGUuIFRoZSBhcmVhIG5hbWUgd2lsbCBiZSBjcmVhdGVkIHdoZW4gdGhlIHJ1bGUgaXMgcHJvY2Vzc2VkIGFzXHJcbiAgICAgKiBwYXJ0IG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBUaGUgbmFtZSBjYW4gYmUgYWxzbyBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBlaXRoZXIgYW5cclxuICAgICAqIGV4cGxpY2l0IG5hbWUgb3IgYW5vdGhlciBncmlkIGFyZWEgcnVsZS4gVGhlIGdyaWQgYXJlYSBydWxlcyBhcmUgdXNlZCB0byBkZWZpbmUgdmFsdWVzIG9mXHJcbiAgICAgKiBzdHlsZSBwcm9wZXJ0aWVzIGBncmlkLWFyZWFgLCBgZ3JpZC1yb3ctc3RhcnQvZW5kYCwgYGdyaWQtY29sdW1uLXN0YXJ0L2VuZGAgYW5kXHJcbiAgICAgKiBgZ3JpZC10ZW1wbGF0ZS1hcmVhc2AuXHJcbiAgICAgKlxyXG4gICAgICogTm8gQ1NTIHJ1bGUgaXMgY3JlYXRlZCBmb3IgZ3JpZCBhcmVhcyAtIHRoZXNlIG9iamVjdHMgYXJlIHNvbGVseSB1c2VkIGZvciBjcmVhdGluZyBuYW1lcywgd2hpY2hcclxuICAgICAqIGNhbiBiZSB0eXBlLXNhZmVseSByZWZlcnJlZCB0byBmcm9tIHN0eWxlIHJ1bGVzLlxyXG4gICAgICpcclxuICAgICAqIEV2ZXJ5IGdyaWQgYXJlYSBkZWZpbmVzIHR3byBncmlkIGxpbmUgcnVsZXMgaW4gZWFjaCBkaXJlY3Rpb24sIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCB1c2luZyB0aGVcclxuICAgICAqIFtbSUdyaWRBcmVhUnVsZS5zdGFydExpbmVdXSBhbmQgW1tJR3JpZEFyZWFSdWxlLmVuZExpbmVdXSBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGhlYWRlckFyZWEgPSB0aGlzLiRncmlkYXJlYSgpO1xyXG4gICAgICogICAgIG1haW5BcmVhID0gdGhpcy4kZ3JpZGFyZWEoKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgZ3JpZCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgZGlzcGxheTogXCJncmlkXCIsXHJcbiAgICAgKiAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IFwiMWZyXCIsXHJcbiAgICAgKiAgICAgICAgIGdyaWRUZW1wbGF0ZVJvd3M6IFtcIjNlbVwiLCBcIjFmclwiXSxcclxuICAgICAqICAgICAgICAgZ3JpZFRlbXBsYXRlQXJlYXM6IFtcclxuICAgICAqICAgICAgICAgICAgIFt0aGlzLmhlYWRlckFyZWEsIDEsMSwgMSwxXSxcclxuICAgICAqICAgICAgICAgICAgIFt0aGlzLm1haW5BcmVhLCAyLDEsIDIsMV0sXHJcbiAgICAgKiAgICAgICAgIF0sXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgaGVhZGVyID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBncmlkQXJlYTogdGhpcy5oZWFkZXJBcmVhLFxyXG4gICAgICogICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgbWFpbiA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgZ3JpZEFyZWE6IHRoaXMubWFpbkFyZWEsXHJcbiAgICAgKiAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJsaWdodGdyZXlcIlxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJR3JpZEFyZWFSdWxlYCBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBuYW1lIG9mIHRoZVxyXG4gICAgICogYXJlYS4gSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWVcclxuICAgICAqIGFzc2lnbm1lbnQgbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBuYW1lIHRvIG1hdGNoIGEgbmFtZSBvZlxyXG4gICAgICogZXhpc3RpbmcgZ3JpZCBhcmVhLlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJR3JpZEFyZWFSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBncmlkIGFyZWEuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkZ3JpZGFyZWEoIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkQXJlYVJ1bGUpOiBJR3JpZEFyZWFSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcmlkQXJlYVJ1bGUoIHRoaXMsIG5hbWVPdmVycmlkZSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYEBmb250LWZhY2VgIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgZm9udCA9IHRoaXMuJGZvbnRmYWNlKHtcclxuICAgICAqICAgICAgICAgZm9udEZhbWlseTogXCJSb2JvdG9cIixcclxuICAgICAqICAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiLFxyXG4gICAgICogICAgICAgICBmb250V2VpZ2h0OiA3MDAsXHJcbiAgICAgKiAgICAgICAgIHNyYzoge3VybDogJ3JvYm90by53b2ZmJywgZm9ybWF0OiAnd29mZid9XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9udGZhY2UgT2JqZWN0IGltcGxlbWVudGluZyB0aGUgYElGb250RmFjZWAgaW50ZXJmYWNlIGRlZmluaW5nIHRoZSBwYXJhbWV0ZXIgb2YgdGhlXHJcbiAgICAgKiBmb250IHRvIHVzZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSUZvbnRGYWNlUnVsZWAgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgQGZvbnQtZmFjZSBydWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGZvbnRmYWNlKCBmb250ZmFjZTogRXh0ZW5kZWRGb250RmFjZSk6IElGb250RmFjZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZvbnRGYWNlUnVsZSggdGhpcywgZm9udGZhY2UpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBAaW1wb3J0YCBydWxlIHJlZmVyZW5jaW5nIHRoZSBnaXZlbiBDU1MgZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBpbXBvcnRlZENzc0ZpbGVzID0gW1xyXG4gICAgICogICAgICAgICB0aGlzLiRpbXBvcnQoIFwiY29tbW9uLTNyZHBhcnR5LmNzc1wiKSxcclxuICAgICAqICAgICAgICAgdGhpcy4kaW1wb3J0KCBcInNtYWxsLXNjcmVlbi0zcmRwYXJ0eS5jc3NcIiwge21heFdpZHRoOiA2MDB9KSxcclxuICAgICAqICAgICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFVSTCB0byB0aGUgQ1NTIGZpbGUuIFJlbGF0aXZlIFVSTHMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZSBiYXNlIFVSTCBvZiB0aGVcclxuICAgICAqIHBhZ2Ugd2hlcmUgdGhlIE1pbWNzcyBsaWJyYXJ5IGlzIGludm9rZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYElJbXBvcnRSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBgQGltcG9ydGAgcnVsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRpbXBvcnQoIHVybDogc3RyaW5nLCBtZWRpYVF1ZXJ5Pzogc3RyaW5nIHwgTWVkaWFTdGF0ZW1lbnQsXHJcbiAgICAgICAgc3VwcG9ydHNRdWVyeT86IHN0cmluZyB8IFN1cHBvcnRzU3RhdGVtZW50KTogSUltcG9ydFJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEltcG9ydFJ1bGUoIHRoaXMsIHVybCwgbWVkaWFRdWVyeSwgc3VwcG9ydHNRdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgQG5hbWVzcGFjZWAgcnVsZS5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBpbml0ID0gW1xyXG4gICAgICogICAgICAgICB0aGlzLiRuYW1lc3BhY2UoIGNzcy5XZWJOYW1lc3BhY2VzLlNWRywgXCJzdmdcIilcclxuICAgICAqICAgICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIE5hbWVzcGFjZSBzdHJpbmcgLSB1c2UgdGhlIFtbV2ViTmFtZXNwYWNlc11dIGZvciB3ZWxsLWtub3duIG5hbWVzcGFjZXMuXHJcbiAgICAgKiBAcGFyYW0gcHJlZml4IFByZWZpeCBzdHJpbmcgdG8gdXNlIGZvciB0aGUgbmFtZXNwYWNlLlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJTmFtZXNwYWNlUnVsZWAgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgbmFtZXNwYWNlIHJ1bGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkbmFtZXNwYWNlKCBuYW1lc3BhY2U6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKTogSU5hbWVzcGFjZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVzcGFjZVJ1bGUoIHRoaXMsIG5hbWVzcGFjZSwgcHJlZml4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGBAcGFnZWAgcnVsZS5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBpbml0ID0gW1xyXG4gICAgICogICAgICAgICB0aGlzLiRwYWdlKCBcIjpmaXJzdFwiLCB7IG1hcmdpbjogXCJhdXRvXCIgfSlcclxuICAgICAqICAgICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHNldWRvQ2xhc3MgT3B0aW9uYWwgbmFtZSBvZiB0aGUgcGFnZSBwc2V1ZG8gc3R5bGUuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVzZXQgU3R5bGVzIHRvIGFwcGx5LlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJUGFnZVJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhZ2UgcnVsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRwYWdlKCBwc2V1ZG9DbGFzcz86IFBhZ2VQc2V1ZG9DbGFzcywgc3R5bGVzZXQ/OiBTdHlsZXNldCk6IElQYWdlUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFnZVJ1bGUoIHRoaXMsIHBzZXVkb0NsYXNzLCBzdHlsZXNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBAc3VwcG9ydHNgIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgY2xzID0gdGhpcy4kY2xhc3MoeyBjb2xvcjogXCJyZWRcIn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIGlmR3JpZFN1cHBvcnRlZCA9IHRoaXMuJG1lZGlhKCB7IGRpc3BsYXk6IFwiZ3JpZFwiIH0sXHJcbiAgICAgKiAgICAgICAgIGNsYXNzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvbjxNeVN0eWxlcz5cclxuICAgICAqICAgICAgICAge1xyXG4gICAgICogICAgICAgICAgICAgY2xzID0gdGhpcy4kY2xhc3MoeyBjb2xvcjogXCJwaW5rXCJ9KVxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgKVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlbWVudCBTdXBwb3J0cyBzdGF0ZW1lbnQgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzdXBwb3J0cyBxdWVyaWVzLlxyXG4gICAgICogQHBhcmFtIGluc3RPckNsYXNzIEVpdGhlciBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIG9yIGFuIGluc3RhbmNlIG9mIGEgc3R5bGUgZGVmaW50aW9uIGNsYXNzLlxyXG4gICAgICogQHJldHVybnMgYElTdXBwb3J0c1J1bGVgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN1cHBvcnRzIHJ1bGVcclxuICAgICAqL1xyXG4gICAgcHVibGljICRzdXBwb3J0czxUIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uPFN0eWxlRGVmaW5pdGlvbjxQPj4+KCBzdGF0ZW1lbnQ6IFN1cHBvcnRzU3RhdGVtZW50LFxyXG4gICAgICAgIGluc3RPckNsYXNzOiBUIHwgSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFQ+KTogSVN1cHBvcnRzUnVsZTxUPlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3VwcG9ydHNSdWxlKCB0aGlzLCBzdGF0ZW1lbnQsIGluc3RPckNsYXNzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGBAbWVkaWFgIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgY2xzID0gdGhpcy4kY2xhc3MoeyBjb2xvcjogXCJyZWRcIn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIGlmTmFycm93U2NyZWVuID0gdGhpcy4kbWVkaWEoIHsgbWF4V2lkdGg6IDgwMCB9LFxyXG4gICAgICogICAgICAgICBjbGFzcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb248TXlTdHlsZXM+XHJcbiAgICAgKiAgICAgICAgIHtcclxuICAgICAqICAgICAgICAgICAgIGNscyA9IHRoaXMuJGNsYXNzKHsgY29sb3I6IFwicGlua1wifSlcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIClcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZW1lbnQgTWVkaWEgc3RhdGVtZW50IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgbWVkaWEgcXVlcmllcy5cclxuICAgICAqIEBwYXJhbSBpbnN0T3JDbGFzcyBFaXRoZXIgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBvciBhbiBpbnN0YW5jZSBvZiBhIHN0eWxlIGRlZmludGlvbiBjbGFzcy5cclxuICAgICAqIEByZXR1cm5zIGBJTWVkaWFSdWxlYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtZWRpYSBydWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkbWVkaWE8VCBleHRlbmRzIFN0eWxlRGVmaW5pdGlvbjxTdHlsZURlZmluaXRpb248UD4+Piggc3RhdGVtZW50OiBNZWRpYVN0YXRlbWVudCxcclxuICAgICAgICBpbnN0T3JDbGFzczogVCB8IElTdHlsZURlZmluaXRpb25DbGFzczxUPik6IElNZWRpYVJ1bGU8VD5cclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lZGlhUnVsZSggdGhpcywgc3RhdGVtZW50LCBpbnN0T3JDbGFzcyk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBvciBpbnN0YW5jZSBhbmQgY3JlYXRlcyB1bmlxdWUgbmFtZXMgZm9yIGFsbCBuYW1lZFxyXG4gICAgICogZW50aXRpZXMuIEZvciBhIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gY2xhc3Mgb25seSBhIHNpbmdsZSBpbnN0YW5jZSBpcyBjcmVhdGVkLCBubyBtYXR0ZXIgaG93XHJcbiAgICAgKiBtYW55IHRpbWVzIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZC4gSG93ZXZlciwgaWYgYW4gaW5zdGFuY2UsIHdoaWNoIGhhcyBub3QgeWV0IGJlZW4gcHJvY2Vzc2VkLFxyXG4gICAgICogaXMgcGFzc2VkLCB0aGVuIGEgbmV3IHNldCBvZiB1bmlxdWUgbmFtZXMgd2lsbCBiZSBjcmVhdGVkIGZvciBpdC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYCR1c2VgIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVmZXJlbmNlIGEgc3R5bGUgZGVmaW5pdGlvbiBmcm9tIGFub3RoZXIgc3R5bGUgZGVmaW5pdGlvbiwgZm9yXHJcbiAgICAgKiBleGFtcGxlOlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIENvbW1vblN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBlcnJvciA9IHRoaXMuJGNsYXNzKHsgY29sb3I6IFwicmVkXCJ9KVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGNsYXNzIFBhZ2VTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgY29tbW9uID0gdGhpcy4kdXNlKCBDb21tb25TdHlsZXMpXHJcbiAgICAgKlxyXG4gICAgICogICAgIGVycm9NZXNzYWdlID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBcIitcIjogdGhpcy5jb21tb24uZXJyb3IsXHJcbiAgICAgKiAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFdoZW4gdGhlIGAkdXNlYCBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSBydWxlcyBmcm9tIHRoZSByZWZlcmVuY2VkIHN0eWxlIGRlZmluaXRpb24gYXJlIG5vdFxyXG4gICAgICogaW5zZXJ0ZWQgaW50byB0aGUgRE9NOyB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQgd2hlbiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB0aGF0IGNvbnRhaW5zXHJcbiAgICAgKiB0aGUgYCR1c2VgIGNhbGwgaXMgYWN0aXZhdGVkLiBUaGUgc2FtZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIGNhbiBiZSB1c2VkIGZyb20gc2V2ZXJhbFxyXG4gICAgICogb3RoZXIgc3R5bGUgZGVmaW5pdGlvbnM6IGFzIGxvbmcgYXMgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHJlZmVyZW5jaW5nIHN0eWxlIGRlZmluaXRpb24gdGhhdFxyXG4gICAgICogaXMgYWN0aXZhdGVkLCB0aGUgcnVsZXMgd2lsbCBiZSBpbiB0aGUgRE9NOyBhcyBzb29uIGFzIGFsbCByZWZlcmVuY2luZyBzdHlsZSBkZWZpbml0aW9ucyBhcmVcclxuICAgICAqIGRlYWN0aXZhdGVkLCB0aGUgcnVsZXMgZnJvbSB0aGUgcmVmZXJlbmNlZCBkZWZpbml0aW9uIGFyZSByZW1vdmVkIGZyb20gdGhlIERPTS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5zdE9yQ2xhc3MgRWl0aGVyIHN0eWxlIGRlZmluaXRpb24gY2xhc3Mgb3IgYW4gaW5zdGFuY2Ugb2YgYSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MsIHdoaWNoIHdpbGwgYmUgYWN0aXZhdGVkIGFuZCBkZWFjdGl2YXRlZFxyXG4gICAgICogYWxvbmcgd2l0aCB0aGUgZW5jbG9zaW5nIHN0eWxlIGRlZmluaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkdXNlPFQgZXh0ZW5kcyBTdHlsZURlZmluaXRpb24+KCBpbnN0T3JDbGFzczogVCB8IElTdHlsZURlZmluaXRpb25DbGFzczxUPik6IFRcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzc1NEKCBpbnN0T3JDbGFzcykgYXMgVDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGZvciBzdHlsZSBkZWZpbml0aW9uIGNsYXNzZXMgdGhhdCB3aWxsIGJlIGVtYmVkZGVkIGludG8gYW4gZW1iZWRkaW5nXHJcbiAqIGNvbnRhaW5lciBmb3IgdGhlIGdpdmVuIGNhdGVnb3J5LiBBbGwgc3R5bGUgZGVmaW5pdGlvbnMgZm9yIGEgZ2l2ZW4gY2F0ZWdvcnkgd2lsbCBiZSBhY3RpdmF0ZWRcclxuICogYW5kIGRlYWN0aXZhdGVkIHRvZ2V0aGVyIGFuZCB0aGVpciBydWxlcyB3aWxsIGJlIGluc2VydGVkIGludG8gYSBzaW5nbGUgYDxzdHlsZT5gIGVsZW1lbnQuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIEBjc3MuZW1iZWRkZWQoXCJ3aWRnZXRzXCIpXHJcbiAqIGNsYXNzIEZpcnN0V2lkZ2V0U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvbiB7Li4ufVxyXG4gKlxyXG4gKiBAY3NzLmVtYmVkZGVkKFwid2lkZ2V0c1wiKVxyXG4gKiBjbGFzcyBTZWNvbmRXaWRnZXRTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uIHsuLi59XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVtYmVkZGVkID0gKGNhdGVnb3J5OiBzdHJpbmcpOiBDbGFzc0RlY29yYXRvciA9PlxyXG4gICAgLy8gd2UgcmV0dXJuIHRoZSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBhY3R1YWwgZGVjb3JhdG9yLlxyXG4gICAgZW1iZWRkZWREZWNvcmF0b3IuYmluZCggdW5kZWZpbmVkLCBjYXRlZ29yeSk7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBOYW1lIGdlbmVyYXRpb24uXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIG1ldGhvZCB1c2VzIHRvIGdlbmVyYXRlIG5hbWVzIG9mIENTUyBlbnRpdGllcy4gSWYgeWVzLCB0aGUgbmFtZXMgd2lsbCBiZSBjcmVhdGVkIGJ5XHJcbiAqIGFwcGVuZGluZyBhIHVuaXF1ZSBudW1iZXIgdG8gdGhlIGdpdmVuIHByZWZpeC4gSWYgdGhlIHByZWZpeCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgc3RhbmRhcmRcclxuICogcHJlZml4IFwiblwiIHdpbGwgYmUgdXNlZC5cclxuICpcclxuICogQnkgZGVmYXVsdCB0aGUgZGV2ZWxvcG1lbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeSAobWltY3NzLmRldi5qcykgdXNlcyB0aGUgW1tVbmlxdWVTY29wZWRdXVxyXG4gKiBtZXRob2QgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gKG1pbWNzcy5qcykgdXNlcyB0aGUgW1tPcHRpbWl6ZWRdXSBtZXRob2QuIFRoaXMgZnVuY3Rpb24gY2FuXHJcbiAqIGJlIGNhbGxlZCB0byBzd2l0Y2ggdG8gdGhlIGFsdGVybmF0aXZlIG1ldGhvZCBvZiBuYW1lIGdlbmVyYXRpb24gaW4gZWl0aGVyIHRoZSBkZXZlbG9wbWVudCBvclxyXG4gKiB0aGUgcHJvZHVjdGlvbiBidWlsZHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXRob2QgSW5kaWNhdGVzIHdoYXQgbWV0aG9kIHRvIHVzZS5cclxuICogQHBhcmFtIHByZWZpeCBPcHRpb25hbCBzdHJpbmcgdGhhdCB3aWxsIHNlcnZlIGFzIGEgcHJlZml4IHRvIHdoaWNoIHVuaXF1ZSBudW1iZXJzIHdpbGwgYmUgYWRkZWRcclxuICogdG8gZ2VuZXJhdGUgb3B0aW1pemVkIG5hbWVzLiBJZ25vcmVkIGlmIHRoZSBgbWV0aG9kYCBwYXJhbWV0ZXIgaXMgYW55dGhpbmcgb3RoZXIgdGhhblxyXG4gKiBbW05hbWVHZW5lcmF0aW9uTWV0aG9kLk9wdGltaXplZF1dLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbmZpZ05hbWVHZW5lcmF0aW9uID0gKG1ldGhvZDogTmFtZUdlbmVyYXRpb25NZXRob2QsIHByZWZpeD86IHN0cmluZyk6IHZvaWQgPT5cclxuXHRjb25maWdOYW1lcyggbWV0aG9kLCBwcmVmaXgpO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gSGVscGVyIGZ1bmN0aW9ucy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29uY2F0ZW5hdGVzIHRoZSBuYW1lcyBvZiB0aGUgZ2l2ZW4gY2xhc3NlcyBpbnRvIGEgc2luZ2xlIHN0cmluZyB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhXHJcbiAqIGBjbGFzc2AgcHJvcGVydHkgb2YgYW4gSFRNTCBlbGVtZW50LiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBhbiBlbGVtZW50IHNob3VsZCBoYXZlIG11bHRpcGxlXHJcbiAqIGNsYXNzZXMgYXNzaWduZWQgdG8gaXQgYW5kIHNvbWUgb2YgdGhlc2UgY2xhc3NlcyBhcmUgc3BlY2lmaWVkIGFzIFtbSUNsYXNzUnVsZV1dIG9yXHJcbiAqIFtbSUNsYXNzTmFtZVJ1bGVdXSB3aGlsZSBvdGhlcnMgYXJlIHNwZWNpZmllZCBhcyBzdHJpbmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY2xhc3NQcm9wcyBWYXJpYWJsZSBhcmd1bWVudCBsaXN0IG9mIGVpdGhlciBjbGFzcyBuYW1lcyBvciBjbGFzcyBydWxlIG9iamVjdHMuXHJcbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgdGhhdCBjb21iaW5lcyBhbGwgY2xhc3MgbmFtZXMgKHNlcGFyYXRlZCB3aXRoIHNwYWNlKSBmcm9tIHRoZSBpbnB1dCBhcnJheS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjbGFzc2VzID0gKC4uLmNsYXNzUHJvcHM6IENsYXNzUHJvcFR5cGVbXSk6IHN0cmluZyA9PlxyXG5cdHYycyggY2xhc3NQcm9wcywge1xyXG5cdFx0b2JqOiAodjogSUNsYXNzUnVsZSB8IElDbGFzc05hbWVSdWxlKSA9PiB2Lm5hbWUsXHJcblx0XHRpdGVtOiBjbGFzc2VzXHJcblx0fSk7XHJcblxyXG4vKipcclxuICogQ2hvb3NlcyB0aGUgZmlyc3Qgbm9uLWVtcHR5IG5hbWUgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBvZiBjbGFzc2VzLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGFuIGVsZW1lbnRcclxuICogc2hvdWxkIGhhdmUgYSBzaW5nbGUgY2xhc3MgYXBwbGllZCB0byBpdCB3aGlsZSB0aGUgY2xhc3MgY2FuIGJlIGNob3NlbiBmcm9tIGFuIG9yZGVyZWQgbGlzdCBvclxyXG4gKiBoaWVyYXJjaHkgb2YgcG9zc2libGUgY2hvaWNlcy5cclxuICpcclxuICogQHBhcmFtIGNsYXNzUHJvcHMgVmFyaWFibGUgYXJndW1lbnQgbGlzdCBvZiBlaXRoZXIgY2xhc3MgbmFtZXMgb3IgY2xhc3MgcnVsZSBvYmplY3RzLlxyXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgbm9uLWVtcHR5IGNsYXNzIG5hbWUgZnJvbSB0aGUgaW5wdXQgYXJyYXkgb3IgbnVsbCBpZiBhbGwgaW5wdXRzIGFyZSBlbXB0eS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaG9vc2VDbGFzcyA9ICguLi5jbGFzc1Byb3BzOiBDbGFzc1Byb3BUeXBlW10pOiBzdHJpbmcgPT5cclxue1xyXG4gICAgZm9yKCBsZXQgY2xhc3NQcm9wIG9mIGNsYXNzUHJvcHMpXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IG5hbWUgPVxyXG4gICAgICAgICAgICB0eXBlb2YgY2xhc3NQcm9wID09PSBcInN0cmluZ1wiID8gY2xhc3NQcm9wIDpcclxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjbGFzc1Byb3ApID8gY2hvb3NlQ2xhc3MoIGNsYXNzUHJvcCkgOlxyXG4gICAgICAgICAgICBjbGFzc1Byb3AgJiYgY2xhc3NQcm9wLm5hbWU7XHJcblxyXG4gICAgICAgIC8vIGlmIG5vbi1udWxsIGFuZCBub24tZW1wdHkgbmFtZSAtIHJldHVybiBpdFxyXG4gICAgICAgIGlmIChuYW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgIH1cclxuXHJcblx0cmV0dXJuIFwiXCI7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFJ1bGUgdmlydHVhbGl6YXRpb24gYW5kIHRoZW1pbmcuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGEgcnVsZSBpZiBpdCBpcyBkZWZpbmVkIGFuZCB1c2VkIGluIHRoZSBzYW1lIHN0eWxlXHJcbiAqIGRlZmluaXRpb24gY2xhc3MgYnV0IHRoZW4gaXMgb3ZlcnJpZGRlbiBpbiBhIGRlcml2ZWQgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIHByb2JsZW1cclxuICogdGhpcyBzb2x2ZXMgaXMgdGhpczogd2hlbiBhIHJ1bGUgaXMgZGVmaW5lZCBpbiBhIGJhc2UgY2xhc3MgYW5kIHRoZW4gb3ZlcnJpZGRlbiBpbiBhIGRlcml2ZWRcclxuICogY2xhc3MsIHdoZW4gYW4gaW5zdGFuY2Ugb2YgdGhlIGRlcml2ZWQgY2xhc3MgaXMgY3JlYXRlZCwgdGhlIHJ1bGVzIHRoYXQgYXJlIGNyZWF0ZWQgaW4gdGhlXHJcbiAqIGJhc2UgYW5kIGRlcml2ZWQgY2xhc3NlcyBzZWUgZGlmZmVyZW50IHZhbHVlcyBvZiB0aGUgcnVsZS4gU2luY2Ugb3VyIHJ1bGVzIGFyZSBkZWZpbmVkIGFzXHJcbiAqIHBhcnQgb2YgdGhlIGNvbnN0cnVjdG9yLCB0aGUgYmFzZSBjbGFzcyBjb25zdHJ1Y3RvcidzIGNvZGUgb25seSBzZWVzIHRoZSB2YWx1ZSBhc3NpZ25lZCBpbiB0aGF0XHJcbiAqIGNvZGUuIElmIGFub3RoZXIgcnVsZSBpbiB0aGUgYmFzZSBjbGFzcyB1c2VzIHRoaXMgZmlyc3QgcnVsZSwgdGhpcyB2YWx1ZSBpcyByZW1lbWJlcmVkLlxyXG4gKlxyXG4gKiBUaGUgYEB2aXJ0dWFsYCBkZWNvcmF0b3IgY3JlYXRlcyBhIFByb3h5IG9iamVjdCBmb3IgdGhlIHJ1bGUgd2l0aCB0aGUgaGFuZGxlciB0aGF0IGtlZXBzIHRoZVxyXG4gKiBtb3N0IHJlY2VudCB2YWx1ZSBzZXQuIFRodXMgd2hlbiBhIHJ1bGUgaW4gdGhlIGJhc2UgY2xhc3MncyBjb25zdHJ1Y3RvciB1c2VzIGEgdmlydHVhbGl6ZWRcclxuICogcnVsZSwgdGhlIGZpcnN0IHJ1bGUgd2lsbCBzZWUgdGhlIG92ZXJyaWRkZW4gdmFsdWUgb2YgdGhlIHJ1bGUgd2hlbiBhY2Nlc3NlZCBpbiB0aGVcclxuICogcG9zdC1jb25zdHJ1Y3RvciBjb2RlLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGRlY29yYXRvciBpcyBkZXByZWNhdGVkIGFzIGFsbCBydWxlcyBkZWZpbmVkIGluIHN0eWxlIGRlZmluaXRpb24gY2xhc3NlcyBhcmVcclxuICogYWx3YXlzIHZpcnR1YWxpemVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpcnR1YWwgPSAodGFyZ2V0OiBhbnksIG5hbWU6IHN0cmluZyk6IHZvaWQgPT4ge307XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFRoZW1lRGVmaW5pdGlvbmAgY2xhc3MgaXMgYSBiYXNlIGZvciBhbGwgY2xhc3NlcyB0aGF0IGRlZmluZSB0aGVtZXMuIEluIGFkZGl0aW9uIHRvXHJcbiAqIGJlaW5nIGEgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcywgdGhlbWVzIHByb3ZpZGUgc29tZSBleHRyYSBjYXBhYmlsaXRpZXMgcmVsYXRlZCB0byBzdHlsZVxyXG4gKiBpbmhlcml0YW5jZSBhbmQgdGhlbWUgYWN0aXZhdGlvbi5cclxuICpcclxuICogQHR5cGVwYXJhbSBQIFBhcmVudCBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBQYXJlbnQgb2YgYSB0b3AtbGV2ZWwgY2xhc3MgaXMgbnVsbC5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUaGVtZURlZmluaXRpb248UCBleHRlbmRzIFN0eWxlRGVmaW5pdGlvbiA9IGFueT4gZXh0ZW5kcyBTdHlsZURlZmluaXRpb248UD5cclxue1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBBY3RpdmF0aW9uLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBBY3RpdmF0ZXMgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gY2xhc3Mgb3IgaW5zdGFuY2UgYW5kIGluc2VydHMgYWxsIGl0cyBydWxlcyBpbnRvIERPTS4gSWZcclxuICogdGhlIGNsYXNzIGlzIG5vdCB5ZXQgYXNzb2NpYXRlZCB3aXRoIGFuIGluc3RhbmNlLCB0aGUgaW5zdGFuY2UgaXMgZmlyc3QgY3JlYXRlZCBhbmQgcHJvY2Vzc2VkLlxyXG4gKiBOb3RlIHRoYXQgZWFjaCBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlIG1haW50YWlucyBhIHJlZmVyZW5jZSBjb3VudGVyIG9mIGhvdyBtYW55IHRpbWVzIGl0IHdhc1xyXG4gKiBhY3RpdmF0ZWQgYW5kIGRlYWN0aXZhdGVkLiBUaGUgcnVsZXMgYXJlIGluc2VydGVkIGludG8gRE9NIG9ubHkgdXBvbiBmaXJzdCBhY3RpdmF0aW9uLlxyXG4gKlxyXG4gKiBBY3RpdmF0aW5nIGEgY2xhc3MgKGFzIG9wcG9zZWQgdG8gYWN0aXZhdGluZyBhIGRpcmVjdGx5IGNyZWF0ZWQgaW5zdGFuY2UpIGlzIGludGVuZGVkIGZvclxyXG4gKiBcImdsb2JhbFwiIENTUyBlbnRpdGllcyAtIHRoYXQgaXMsIGVudGl0aWVzIHRoYXQgYXJlIHVzZWQgdGhyb3VnaG91dCB0aGUgYXBwbGljYXRpb24gb3JcclxuICogYXBwbGljYXRpb24gYXJlYS4gTm8gbWF0dGVyIGhvdyBtYW55IHRpbWVzIGEgY2xhc3MgaXMgYWN0aXZhdGVkIG9yIGhvdyBtYW55IHRpbWVzIGl0IGlzIHVzZWRcclxuICogZnJvbSBvdGhlciBzdHlsZSBkZWZpbml0aW9ucywgYSBzaW5nbGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgdXNlZCBieSBNaW1jc3MuXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgQ29tbW9uU3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICByZWQgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiByZWQgfSlcclxuICogfVxyXG4gKlxyXG4gKiBjbGFzcyBNeUNvbXBvbmVudFxyXG4gKiB7XHJcbiAqICAgICBwcml2YXRlIHN0eWxlczogQ29tbW9uU3R5bGVzO1xyXG4gKlxyXG4gKiAgICAgLy8gQWN0aXZhdGUgY2xhc3NcclxuICogICAgIHdpbGxNb3VudCgpIHsgdGhpcy5zdHlsZXMgPSBjc3MuYWN0aXZhdGUoIENvbW1vblN0eWxlcyk7IH1cclxuICogICAgIHdpbGxVbm1vdW50KCkgeyBjc3MuZGVhY3RpdmF0ZSggdGhpcy5zdHlsZXMpOyB9XHJcbiAqICAgICByZW5kZXIoKSB7IHJldHVybiA8ZGl2IGNsYXNzTmFtZT17dGhpcy5zdHlsZXMucmVkLm5hbWV9PC9kaXY+IH1cclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQWN0aXZhdGluZyBhbiBpbnN0YW5jZSAoYXMgb3Bwb3NlZCB0byBhY3RpdmF0aW5nIGEgY2xhc3MpIGlzIGludGVuZGVkIGZvciBcInNjb3BlZFwiIENTUyBlbnRpdGllcyAtXHJcbiAqIHRoYXQgaXMsIGVudGl0aWVzIHRoYXQgYXBwbHkgdG8gaW5zdGFuY2VzIG9mIGNlcnRhaW4gY29tcG9uZW50cywgYS5rLmEuICpTdHlsZWQgQ29tcG9uZW50cyouXHJcbiAqIEluIHRoaXMgYXBwcm9hY2gsIGV2ZXJ5IGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGNyZWF0ZXMgaXRzIG93biBpbnN0YW5jZSBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvblxyXG4gKiBjbGFzcyBhbmQgTWltY3NzIHdpbGwgY3JlYXRlIGluZGVwZW5kZW50IGluc3RhbmNlcyBvZiBDU1MgcnVsZXMgc3BlY2lmaWMgKCpzY29wZWQqKSB0byBlYWNoXHJcbiAqIGNvbXBvbmVudCBpbnN0YW5jZS5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgcmVkID0gdGhpcy4kY2xhc3MoeyBjb2xvcjogcmVkIH0pXHJcbiAqIH1cclxuICpcclxuICogY2xhc3MgTXlDb21wb25lbnRcclxuICoge1xyXG4gKiAgICAgLy8gQ3JlYXRlIHN0eWxlIGRlZmluaXRpb24gZGlyZWN0bHlcclxuICogICAgIHByaXZhdGUgc3R5bGVzID0gbmV3IE15U3R5bGVzKCk7XHJcbiAqXHJcbiAqICAgICAvLyBBY3RpdmF0ZSBpbnN0YW5jZVxyXG4gKiAgICAgd2lsbE1vdW50KCkgeyB0aGlzLnN0eWxlcyA9IGNzcy5hY3RpdmF0ZSggdGhpcy5zdHlsZXMpOyB9XHJcbiAqICAgICB3aWxsVW5tb3VudCgpIHsgY3NzLmRlYWN0aXZhdGUoIHRoaXMuc3R5bGVzKTsgfVxyXG4gKiAgICAgcmVuZGVyKCkgeyByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMuc3R5bGVzLnJlZC5uYW1lfTwvZGl2PiB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVCBUeXBlIG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIG9yIGluc3RhbmNlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoaXMgaXNcclxuICogYWxzbyB0aGUgdHlwZSwgd2hpY2ggaXMgcmV0dXJuZWQgZm9ybSB0aGUgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSBpbnN0T3JDbGFzcyBTdHlsZSBkZWZpbml0aW9uIGNsYXNzIG9yIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBzY2hlZHVsZXJUeXBlIElkZW50aWZpZXIgb2YgYSBwcmUtZGVmaW5lZCBvciByZWdpc3RlcmVkIHNjaGVkdWxlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlXHJcbiAqIHNjaGVkdWxlciBzZXQgYXMgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXHJcbiAqIEByZXR1cm5zIEluc3RhbmNlIG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIC0gZWl0aGVyIGNyZWF0ZWQgKGlmIHRoaXMgd2FzIHRoZSBmaXJzdFxyXG4gKiBhY3RpdmF0aW9uIG9mIHRoZSBjbGFzcykgb3IgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggdGhlIGNsYXNzLiBJZiB0aGUgaW5wdXQgcGFyYW1ldGVyIGlzIGFuXHJcbiAqIGluc3RhbmNlIChhcyBvcHBvc2VkIHRvIGEgY2xhc3MpLCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZSBzYW1lIGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFjdGl2YXRlID0gPFQgZXh0ZW5kcyBJU3R5bGVEZWZpbml0aW9uPiggaW5zdE9yQ2xhc3M6IFQgfCBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VD4sXHJcblx0c2NoZWR1bGVyVHlwZT86IG51bWJlcik6IFQgPT5cclxue1xyXG5cdGxldCBpbnN0YW5jZSA9IHByb2Nlc3NTRCggaW5zdE9yQ2xhc3MpIGFzIFQ7XHJcblx0aWYgKGluc3RhbmNlKVxyXG4gICAgICAgIGdldEFjdGl2YXRvcihzY2hlZHVsZXJUeXBlKS5hY3RpdmF0ZSggaW5zdGFuY2UpO1xyXG5cclxuXHRyZXR1cm4gaW5zdGFuY2U7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIERlYWN0aXZhdGVzIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlIGJ5IHJlbW92aW5nIGl0cyBydWxlcyBmcm9tIERPTS4gTm90ZSB0aGF0IGVhY2hcclxuICogc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZSBtYWludGFpbnMgYSBjb3VudGVyIG9mIGhvdyBtYW55IHRpbWVzIGl0IHdhcyBhY3RpdmF0ZWQgYW5kXHJcbiAqIGRlYWN0aXZhdGVkLiBUaGUgcnVsZXMgYXJlIHJlbW92ZWQgZnJvbSBET00gb25seSB3aGVuIHRoaXMgY291bnRlciBnb2VzIGRvd24gdG8gMC5cclxuICpcclxuICogQHBhcmFtIHNkIEluc3RhbmNlIG9mIGEgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB0byBiZSBkZWFjdGl2YXRlZC5cclxuICogQHBhcmFtIHNjaGVkdWxlclR5cGUgSWRlbnRpZmllciBvZiBhIHByZS1kZWZpbmVkIG9yIHJlZ2lzdGVyZWQgc2NoZWR1bGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcclxuICogc2NoZWR1bGVyIHNldCBhcyBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWFjdGl2YXRlID0gKHNkOiBJU3R5bGVEZWZpbml0aW9uLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZCA9PlxyXG5cdGdldEFjdGl2YXRvcihzY2hlZHVsZXJUeXBlKS5kZWFjdGl2YXRlKCBzZCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0aGVtZSBkZWZpbml0aW9uIG9iamVjdCwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2ZSBmb3IgdGhlIGdpdmVuIHRoZW1lIGRlY2xhcmF0aW9uXHJcbiAqIGNsYXNzLlxyXG4gKiBAcGFyYW0gdGhlbWVDbGFzcyBUaGVtZSBkZWNsYXJhdGlvbiBjbGFzc1xyXG4gKiBAcmV0dXJucyBUaGVtZSBpbnN0YW5jZSwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2ZSBmb3IgdGhlIGdpdmVuIHRoZW1lIGNsYXNzIG9yIHVuZGVmaW5lZFxyXG4gKiBpZiBubyBpbnN0YW5jZSBpcyBjdXJyZW50bHkgYWN0aXZlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEFjdGl2ZVRoZW1lID0gKHRoZW1lQ2xhc3M6IElTdHlsZURlZmluaXRpb25DbGFzczxUaGVtZURlZmluaXRpb24+KTogVGhlbWVEZWZpbml0aW9uIHwgdW5kZWZpbmVkID0+XHJcbiAgICBnZXRDdXJyZW50VGhlbWUoIHRoZW1lQ2xhc3MpO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBTU1Igc3VwcG9ydC5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHNlcnZlci1zaWRlIGFjdGl2YXRpb24gY29udGV4dC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vbi1kZWZhdWx0IGFjdGl2YXRpb24gY29udGV4dCBpc1xyXG4gKiBhbHJlYWR5IHNldC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzdGFydFNTUiA9ICgpOiB2b2lkID0+IHNfc3RhcnRTU1IoKTtcclxuXHJcbi8qKlxyXG4gKiBTdG9wcyBzZXJ2ZXItc2lkZSBhY3RpdmF0aW9uIGZ1bmN0aW9uYWxpdHkgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCBzZXJpYWxpemVkIHN0eWxlcy4gVGhlXHJcbiAqIHN0cmluZyBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGA8aGVhZD5gIGVsZW1lbnQgdXNpbmcgYGluc2VydEFkamFjZW50SFRNTCgpYCBtZXRob2QuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiBTU1IgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQuXHJcbiAqIEByZXR1cm5zIFN0cmluZyBjb250YWluaW5nIHNlcmlhbGl6ZWQgc3R5bGVzXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RvcFNTUiA9ICgpOiBzdHJpbmcgPT4gc19zdG9wU1NSKCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGh5ZHJhdGlvbiBhY3RpdmF0aW9uIGNvbnRleHQuIFRocm93cyBhbiBlcnJvciBpZiBub24tZGVmYXVsdCBhY3RpdmF0aW9uIGNvbnRleHQgaXNcclxuICogYWxyZWFkeSBzZXQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhcnRIeWRyYXRpb24gPSAoKTogdm9pZCA9PiBzX3N0YXJ0SHlkcmF0aW9uKCk7XHJcblxyXG4vKipcclxuICogU3RvcHMgaHlkcmF0aW9uIGFjdGl2YXRpb24gZnVuY3Rpb25hbGl0eSBhbmQgcmVzdG9yZSB0aGUgZGVmYXVsdCBhY3RpdmF0aW9uIGNvbnRleHQuXHJcbiAqIEByZXR1cm5zIFN0cmluZyBjb250YWluaW5nIHNlcmlhbGl6ZWQgc3R5bGVzXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RvcEh5ZHJhdGlvbiA9ICgpOiB2b2lkID0+IHNfc3RvcEh5ZHJhdGlvbigpO1xyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQge0lTY2hlZHVsZXJ9IGZyb20gXCIuLi9hcGkvU2NoZWR1bGluZ1R5cGVzXCI7XHJcbmltcG9ydCAqIGFzIGltcGwgZnJvbSBcIi4uL2ltcGwvU2NoZWR1bGluZ0ltcGxcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gU2NoZWR1bGluZy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgdG8gRE9NIGFsbCBzdHlsZSBjaGFuZ2VzIGNhdXNlZCBieSB0aGUgY2FsbHMgdG8gdGhlIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9uc1xyXG4gKiBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdCBhY3RpdmF0aW9uIG9mIHRoZSBnaXZlbiBzY2hlZHVsaW5nIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZm9yY2VET01VcGRhdGUgPSAoc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQgPT5cclxuXHRpbXBsLmdldEFjdGl2YXRvcihzY2hlZHVsZXJUeXBlKS5mb3JjZURPTVVwZGF0ZSgpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwgc2NoZWR1bGVkIGFjdGl2YXRpb25zIGNhdXNlZCBieSB0aGUgY2FsbHMgdG8gdGhlIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9uc1xyXG4gKiBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdCBhY3RpdmF0aW9uIG9mIHRoZSBnaXZlbiBzY2hlZHVsaW5nIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FuY2VsRE9NVXBkYXRlID0gKHNjaGVkdWxlclR5cGU/OiBudW1iZXIpOiB2b2lkID0+XHJcblx0aW1wbC5nZXRBY3RpdmF0b3Ioc2NoZWR1bGVyVHlwZSkuY2FuY2VsRE9NVXBkYXRlKCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBkZWZhdWx0IHNjaGVkdWxpbmcgdHlwZSB0aGF0IGlzIHVzZWQgYnkgYWN0aXZhdGUgYW5kIGRlYWN0aXZhdGUgZnVuY3Rpb25zIHRoYXQgYXJlXHJcbiAqIGNhbGxlZCB3aXRob3V0IGV4cGxpY2l0bHkgcHJvdmlkaW5nIHZhbHVlIHRvIHRoZSBzY2hlZHVsaW5nIHBhcmFtZXRlci4gUmV0dXJucyB0aGUgdHlwZSBvZiB0aGVcclxuICogcHJldmlvdXMgZGVmYXVsdCBhY3RpdmF0b3Igb3IgMCBpZiBhbiBlcnJvciBvY2N1cnMgKGUuZy4gdGhlIGdpdmVuIHNjaGVkdWxlciB0eXBlIElEIGlzIG5vdFxyXG4gKiByZWdpc3RlcmVkKS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXREZWZhdWx0U2NoZWR1bGVyID0gKHNjaGVkdWxlclR5cGU6IG51bWJlcik6IG51bWJlciA9PlxyXG4gICAgaW1wbC5zZXREZWZhdWx0U2NoZWR1bGVyKCBzY2hlZHVsZXJUeXBlKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gc2NoZWR1bGVyIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgc2NoZWR1bGVyIHR5cGUgaWRlbnRpZmllciwgd2hpY2hcclxuICogc2hvdWxkIGJlIHVzZWQgd2hlbiBjYWxsaW5nIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlclNjaGVkdWxlciA9IChzY2hlZHVsZXI6IElTY2hlZHVsZXIpOiBudW1iZXIgPT5cclxuICAgIGltcGwucmVnaXN0ZXJTY2hlZHVsZXIoIHNjaGVkdWxlcik7XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7Q3NzSW1hZ2UsIEV4dGVuZGVkLCBFeHRlbnRLZXl3b3JkfSBmcm9tIFwiLi9Db3JlVHlwZXNcIjtcclxuaW1wb3J0IHtCb3JkZXJSYWRpdXMsIENzc0FuZ2xlLCBDc3NMZW5ndGgsIENzc051bWJlciwgQ3NzUGVyY2VudCwgQ3NzUG9pbnQsIENzc1Bvc2l0aW9ufSBmcm9tIFwiLi9OdW1lcmljVHlwZXNcIjtcclxuaW1wb3J0IHtDc3NDb2xvcn0gZnJvbSBcIi4vQ29sb3JUeXBlc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgR3JhZGllbnRTdG9wT3JIaW50LCBMaW5lYXJHcmFkaWVudEFuZ2xlLCBTaGFwZVJhZGl1cywgSU1pbk1heEZ1bmMsIElQYXRoQnVpbGRlcixcclxuICAgIElSZXBlYXRGdW5jLCBJR3JpZFNwYW5GdW5jLCBGaWxsUnVsZSwgSUNpcmNsZUJ1aWxkZXIsIElFbGxpcHNlQnVpbGRlcixcclxuICAgIElJbnNldEJ1aWxkZXIsIElQb2x5Z29uQnVpbGRlciwgUGF0aENvbW1hbmQsIFBhdGhDb21tYW5kUGFyYW0sIElSYXlGdW5jLFxyXG4gICAgUGVyY2VudEZpbHRlck5hbWVzLCBJUGVyY2VudEZpbHRlckZ1bmMsIElCbHVyRnVuYywgSURyb3BTaGFkb3dGdW5jLCBJSHVlUm90YXRlRnVuYywgSU1hdHJpeEZ1bmMsXHJcbiAgICBJTWF0cml4M2RGdW5jLCBJUGVyc3BlY3RpdmVGdW5jLCBJUm90YXRlRnVuYywgSVJvdGF0ZTNkRnVuYywgSVNjYWxlMWRGdW5jLCBJU2NhbGVGdW5jLCBJU2NhbGUzZEZ1bmMsXHJcbiAgICBJU2tld0Z1bmMsIElTa2V3MWRGdW5jLCBJVHJhbnNsYXRlMWRGdW5jLCBJVHJhbnNsYXRlM2RGdW5jLCBJVHJhbnNsYXRlRnVuYywgSUxpbmVhckdyYWRpZW50QnVpbGRlcixcclxuICAgIElMaW5lYXJHcmFkaWVudEZ1bmMsIElSYWRpYWxHcmFkaWVudEJ1aWxkZXIsIElSYWRpYWxHcmFkaWVudEZ1bmMsIElDb25pY0dyYWRpZW50QnVpbGRlcixcclxuICAgIElDb25pY0dyYWRpZW50RnVuYywgSUdyYWRpZW50QnVpbGRlciwgSUdyYWRpZW50RnVuYywgSUNyb3NzRmFkZUJ1aWxkZXIsIElDcm9zc0ZhZGVGdW5jLCBJSW1hZ2VTZXRGdW5jLFxyXG4gICAgSW1hZ2VTZXRJdGVtLCBJbWFnZVNldFJlc29sdXRpb24sIElQYWludFdvcmtsZXRzLCBJUGFpbnRGdW5jXHJcbn0gZnJvbSBcIi4vU2hhcGVUeXBlc1wiO1xyXG5pbXBvcnQge0dyaWRMaW5lQ291bnRPck5hbWUsIEdyaWRUcmFjaywgR3JpZFRyYWNrU2l6ZX0gZnJvbSBcIi4vU3R5bGVUeXBlc1wiO1xyXG5pbXBvcnQge212MnMsIFdLRiwgdjJzLCB3a2YsIGEycywgZmRvLCBmMnN9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcbmltcG9ydCB7IE1hcHBlZFN5bnRheFR5cGVzLCBTeW50YXhLZXkgfSBmcm9tIFwiLi9TdHlsZXNldHNcIjtcclxuaW1wb3J0IHsgc3AycyB9IGZyb20gXCIuLi9pbXBsL1N0eWxlSW1wbFwiO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gSW1hZ2VzIGFuZCBncmFkaWVudHMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuY29uc3QgZ3JhZGllbnROYW1lVG9TdHJpbmcgPSAodmFsOiBJR3JhZGllbnRGdW5jPGFueT4pOiBzdHJpbmcgPT4gYCR7dmFsLnJlcGVhdCA/IFwicmVwZWF0aW5nLVwiIDogXCJcIn0ke3ZhbC5mbn1gO1xyXG5cclxuY29uc3QgZ3JhZGllbnRTdG9wc09ySGludHNUb1N0cmluZyA9ICh2YWw6IEdyYWRpZW50U3RvcE9ySGludDxhbnk+W10sIG1hdGg6IFdLRi5MZW5ndGggfCBXS0YuQW5nbGUpOiBzdHJpbmcgPT5cclxuICAgIHYycyggdmFsLCB7XHJcbiAgICAgICAgaXRlbToge1xyXG4gICAgICAgICAgICBudW06IFdLRi5Db2xvcixcclxuICAgICAgICAgICAgYXJyOiB7IDE6IFttYXRoXSwgYW55OiBbV0tGLkNvbG9yLCBtYXRoLCBtYXRoXSB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXA6IFwiLFwiXHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgSUxpbmVhckdyYWRpZW50QnVpbGRlciBpbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBgbGluZWFyLWdyYWRpZW50YCBDU1MgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiAqRXhhbXBsZXM6KlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGJhY2tncm91bmRJbWFnZTogbGluZWFyR3JhZGllbnQoIFwicmVkXCIsIFwiYmx1ZVwiKVxyXG4gKlxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IGxpbmVhckdyYWRpZW50KCBbXCJyZWRcIiwgMzBdLCBbXCJncmVlblwiLCA1MCwgNjBdLCBbXCJibHVlXCIsIDgwXSkucmVwZWF0aW5nKClcclxuICpcclxuICogYmFja2dyb3VuZEltYWdlOiBsaW5lYXJHcmFkaWVudCggXCJyZWRcIiwgXCJibHVlXCIpLnRvKCA0NSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBzdG9wcyBWYXJpYWJsZSBhcmd1bWVudCBsaXN0IHNwZWNpZnlpbmcgc3RvcHMgb3IgaGludHMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvXHJcbiAqIHRoZSBncmFkaWVudCBkZWZpbml0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgSW1hZ2VcclxuICovXHJcbmV4cG9ydCBjb25zdCBsaW5lYXJHcmFkaWVudCA9ICguLi5zdG9wczogR3JhZGllbnRTdG9wT3JIaW50PENzc0xlbmd0aD5bXSk6IElMaW5lYXJHcmFkaWVudEJ1aWxkZXIgPT5cclxuICAgIG5ldyBMaW5lYXJHcmFkaWVudEJ1aWxkZXIoIHN0b3BzKTtcclxuXHJcbmZkb1tcImxpbmVhci1ncmFkaWVudFwiXSA9IHtcclxuICAgIGZuOiBncmFkaWVudE5hbWVUb1N0cmluZyxcclxuICAgIGY6ICh2YWw6IElMaW5lYXJHcmFkaWVudEZ1bmMpID0+IG12MnMoW1xyXG4gICAgICAgIHYycyggdmFsLmFuZ2xlLCB7bnVtOiBXS0YuQW5nbGUsIHN0cjogdiA9PiBcInRvIFwiICsgdn0pLFxyXG4gICAgICAgIGdyYWRpZW50U3RvcHNPckhpbnRzVG9TdHJpbmcoIHZhbC5zdG9wcywgV0tGLkxlbmd0aClcclxuICAgIF0sIFwiLFwiKVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIElSYWRpYWxHcmFkaWVudCBpbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBgcmFkaWFsLWdyYWRpZW50YCBDU1MgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiAqRXhhbXBsZXM6KlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGJhY2tncm91bmRJbWFnZTogcmFkaWFsR3JhZGllbnQoIFwicmVkXCIsIFwiYmx1ZVwiKVxyXG4gKlxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IHJhZGlhbEdyYWRpZW50KCBcInJlZFwiLCBcImJsdWVcIikuY2lyY2xlKCBjc3MucGVyY2VudCgzMCkpLmF0KCBbXCJjZW50ZXJcIiwgY3NzLnBlcmNlbnQoNjUpXSlcclxuICpcclxuICogYmFja2dyb3VuZEltYWdlOiByYWRpYWxHcmFkaWVudCggXCJyZWRcIiwgXCJibHVlXCIpLmNpcmNsZSggMjAwKS5yZXBlYXRpbmcoKVxyXG4gKlxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IHJhZGlhbEdyYWRpZW50KCBcInJlZFwiLCBcImJsdWVcIikuZWxsaXBzZSggXCJjbG9zZXN0LXNpZGVcIilcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBzdG9wcyBWYXJpYWJsZSBhcmd1bWVudCBsaXN0IHNwZWNpZnlpbmcgc3RvcHMgb3IgaGludHMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvXHJcbiAqIHRoZSBncmFkaWVudCBkZWZpbml0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgSW1hZ2VcclxuICovXHJcbmV4cG9ydCBjb25zdCByYWRpYWxHcmFkaWVudCA9ICguLi5zdG9wczogR3JhZGllbnRTdG9wT3JIaW50PENzc0xlbmd0aD5bXSk6IElSYWRpYWxHcmFkaWVudEJ1aWxkZXIgPT5cclxuICAgIG5ldyBSYWRpYWxHcmFkaWVudEJ1aWxkZXIoIHN0b3BzKTtcclxuXHJcbmZkb1tcInJhZGlhbC1ncmFkaWVudFwiXSA9IHtcclxuICAgIGZuOiBncmFkaWVudE5hbWVUb1N0cmluZyxcclxuICAgIGY6ICh2YWw6IElSYWRpYWxHcmFkaWVudEZ1bmMpID0+IG12MnMoW1xyXG4gICAgICAgIG12MnMoWyB2YWwuc2hhcGUsIFt2YWwuc2l6ZSwgV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlXSwgW3ZhbC5wb3MsIFdLRi5BdFBvc2l0aW9uXSBdKSxcclxuICAgICAgICBncmFkaWVudFN0b3BzT3JIaW50c1RvU3RyaW5nKCB2YWwuc3RvcHMsIFdLRi5MZW5ndGgpXHJcbiAgICBdLCBcIixcIilcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgSUNvbmljR3JhZGllbnQgaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgYHJhZGlhbC1ncmFkaWVudGAgQ1NTIGZ1bmN0aW9ucy5cclxuICpcclxuICogKkV4YW1wbGVzOipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IGNvbmljR3JhZGllbnQoIFwicmVkXCIsIFwiYmx1ZVwiKVxyXG4gKlxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IGNvbmljR3JhZGllbnQoKS5yZXBlYXRpbmcoKS5hZGQoIFwicmVkXCIsIFwiYmx1ZVwiKVxyXG4gKlxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IGNvbmljR3JhZGllbnQoIFwicmVkXCIsIFwiYmx1ZVwiKS5mcm9tKCAwLjI1KS5hdCggW1wiY2VudGVyXCIsIGNzcy5wZXJjZW50KDY1KV0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gc3RvcHMgVmFyaWFibGUgYXJndW1lbnQgbGlzdCBzcGVjaWZ5aW5nIHN0b3BzIG9yIGhpbnRzIHRoYXQgd2lsbCBiZSBhZGRlZCB0b1xyXG4gKiB0aGUgZ3JhZGllbnQgZGVmaW5pdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IEltYWdlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29uaWNHcmFkaWVudCA9ICguLi5zdG9wczogR3JhZGllbnRTdG9wT3JIaW50PENzc0FuZ2xlPltdKTogSUNvbmljR3JhZGllbnRCdWlsZGVyID0+XHJcbiAgICBuZXcgQ29uaWNHcmFkaWVudEJ1aWxkZXIoIHN0b3BzKTtcclxuXHJcbmZkb1tcImNvbmljLWdyYWRpZW50XCJdID0ge1xyXG4gICAgZm46IGdyYWRpZW50TmFtZVRvU3RyaW5nLFxyXG4gICAgZjogKHZhbDogSUNvbmljR3JhZGllbnRGdW5jKSA9PiBtdjJzKFtcclxuICAgICAgICBtdjJzKFsgW3ZhbC5hbmdsZSwgKHY6IEV4dGVuZGVkPENzc0FuZ2xlPikgPT4gXCJmcm9tIFwiICsgdjJzKCB2LCBXS0YuQW5nbGUpXSwgW3ZhbC5wb3MsIFdLRi5BdFBvc2l0aW9uXSBdKSxcclxuICAgICAgICBncmFkaWVudFN0b3BzT3JIaW50c1RvU3RyaW5nKCB2YWwuc3RvcHMsIFdLRi5BbmdsZSlcclxuICAgIF0sIFwiLFwiKVxyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgZ3JhZGllbnQgaW1wbGVtZW50YXRpb25cclxuICovXHJcbmFic3RyYWN0IGNsYXNzIEdyYWRpZW50QnVpbGRlcjxUIGV4dGVuZHMgKENzc0xlbmd0aCB8IENzc0FuZ2xlKT4gaW1wbGVtZW50cyBJR3JhZGllbnRCdWlsZGVyPFQ+XHJcbntcclxuICAgIGZuOiBcImxpbmVhci1ncmFkaWVudFwiIHwgXCJyYWRpYWwtZ3JhZGllbnRcIiB8IFwiY29uaWMtZ3JhZGllbnRcIjtcclxuXHJcbiAgICByZXBlYXQ/OiBib29sZWFuO1xyXG4gICAgc3RvcHM6IEdyYWRpZW50U3RvcE9ySGludDxUPltdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCBzdG9wczogR3JhZGllbnRTdG9wT3JIaW50PFQ+W10pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdG9wcyA9IHN0b3BzID8/IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXBlYXRpbmcoIGZsYWc/OiBib29sZWFuKTogdGhpc1xyXG4gICAge1xyXG4gICAgICAgIHRoaXMucmVwZWF0ID0gZmxhZyA9PSBudWxsID8gdHJ1ZSA6IGZsYWc7IHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGQoIC4uLnN0b3BzT3JIaW50czogR3JhZGllbnRTdG9wT3JIaW50PFQ+W10pOiB0aGlzXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zdG9wcy5wdXNoKCAuLi5zdG9wc09ySGludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGZ1bmN0aW9uYWxpdHkgb2YgbGluZWFyIGdyYWRpZW50c1xyXG4gKi9cclxuY2xhc3MgTGluZWFyR3JhZGllbnRCdWlsZGVyIGV4dGVuZHMgR3JhZGllbnRCdWlsZGVyPENzc0xlbmd0aD4gaW1wbGVtZW50cyBJTGluZWFyR3JhZGllbnRCdWlsZGVyXHJcbntcclxuICAgIGZuOiBcImxpbmVhci1ncmFkaWVudFwiID0gXCJsaW5lYXItZ3JhZGllbnRcIjtcclxuXHJcbiAgICBhbmdsZT86IExpbmVhckdyYWRpZW50QW5nbGU7XHJcblxyXG4gICAgcHVibGljIHRvKCBhbmdsZT86IExpbmVhckdyYWRpZW50QW5nbGUpOiB0aGlzIHsgdGhpcy5hbmdsZSA9IGFuZ2xlOyByZXR1cm4gdGhpczsgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGZ1bmN0aW9uYWxpdHkgb2YgcmFkaWFsIGdyYWRpZW50c1xyXG4gKi9cclxuY2xhc3MgUmFkaWFsR3JhZGllbnRCdWlsZGVyIGV4dGVuZHMgR3JhZGllbnRCdWlsZGVyPENzc0xlbmd0aD4gaW1wbGVtZW50cyBJUmFkaWFsR3JhZGllbnRCdWlsZGVyXHJcbntcclxuICAgIGZuOiBcInJhZGlhbC1ncmFkaWVudFwiID0gXCJyYWRpYWwtZ3JhZGllbnRcIjtcclxuXHJcbiAgICBzaGFwZT86IFwiY2lyY2xlXCIgfCBcImVsbGlwc2VcIjtcclxuXHRzaXplPzogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiB8IEV4dGVuZGVkPEV4dGVudEtleXdvcmQ+IHwgW0V4dGVuZGVkPENzc0xlbmd0aD4sIEV4dGVuZGVkPENzc0xlbmd0aD5dO1xyXG4gICAgcG9zPzogRXh0ZW5kZWQ8Q3NzUG9zaXRpb24+O1xyXG5cclxuXHRwdWJsaWMgY2lyY2xlKCBzaXplT3JFeHRlbnQ/OiBFeHRlbmRlZDxDc3NMZW5ndGg+IHwgRXh0ZW5kZWQ8RXh0ZW50S2V5d29yZD4pOiB0aGlzXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IFwiY2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZU9yRXh0ZW50O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuXHRwdWJsaWMgZWxsaXBzZSggLi4ucGFyYW1zOiBhbnlbXSk6IHRoaXNcclxuICAgIHtcclxuICAgICAgICB0aGlzLnNoYXBlID0gXCJlbGxpcHNlXCI7XHJcbiAgICAgICAgdGhpcy5zaXplID1cclxuICAgICAgICAgICAgcGFyYW1zLmxlbmd0aCA9PT0gMSA/IHBhcmFtc1swXSBhcyBFeHRlbmRlZDxFeHRlbnRLZXl3b3JkPiA6XHJcbiAgICAgICAgICAgIHBhcmFtcy5sZW5ndGggPT09IDIgPyBbcGFyYW1zWzBdIGFzIEV4dGVuZGVkPENzc0xlbmd0aD4sIHBhcmFtc1sxXSBhcyBFeHRlbmRlZDxDc3NMZW5ndGg+XSA6XHJcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG5cclxuXHRwdWJsaWMgZXh0ZW50KCBleHRlbnQ6IEV4dGVuZGVkPEV4dGVudEtleXdvcmQ+KTogdGhpcyB7IHRoaXMuc2l6ZSA9IGV4dGVudDsgcmV0dXJuIHRoaXM7IH1cclxuXHRwdWJsaWMgYXQoIHBvczogRXh0ZW5kZWQ8Q3NzUG9zaXRpb24+KTogdGhpcyB7IHRoaXMucG9zID0gcG9zOyByZXR1cm4gdGhpczsgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGZ1bmN0aW9uYWxpdHkgb2YgY29uaWMgZ3JhZGllbnRzXHJcbiAqL1xyXG5jbGFzcyBDb25pY0dyYWRpZW50QnVpbGRlciBleHRlbmRzIEdyYWRpZW50QnVpbGRlcjxDc3NBbmdsZT4gaW1wbGVtZW50cyBJQ29uaWNHcmFkaWVudEJ1aWxkZXJcclxue1xyXG4gICAgZm46IFwiY29uaWMtZ3JhZGllbnRcIiA9IFwiY29uaWMtZ3JhZGllbnRcIjtcclxuXHJcbiAgICBhbmdsZT86IEV4dGVuZGVkPENzc0FuZ2xlPjtcclxuICAgIHBvcz86IEV4dGVuZGVkPENzc1Bvc2l0aW9uPjtcclxuXHJcblx0cHVibGljIGZyb20oIGFuZ2xlPzogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogdGhpcyB7IHRoaXMuYW5nbGUgPSBhbmdsZTsgcmV0dXJuIHRoaXM7IH1cclxuXHRwdWJsaWMgYXQoIHBvcz86IEV4dGVuZGVkPENzc1Bvc2l0aW9uPik6IHRoaXMgeyB0aGlzLnBvcyA9IHBvczsgcmV0dXJuIHRoaXM7IH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBJQ3Jvc3NGYWRlRnVuYyBpbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBcIm9sZGVyXCIgYGNyb3NzLWZhZGVgIENTU1xyXG4gKiBmdW5jdGlvbiBpbnZvY2F0aW9uIHRoYXQgYWNjZXB0cyB0d28gaW1hZ2VzIGFuZCBhIHNpbmdsZSBwZXJjZW50YWdlLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgSW1hZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcm9zc0ZhZGUoIG9sZDogW0V4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzSW1hZ2U+LCBFeHRlbmRlZDxDc3NQZXJjZW50Pl0pOiBJQ3Jvc3NGYWRlRnVuYztcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIElDcm9zc0ZhZGVGdW5jIGludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIFwibmV3ZXJcIiBgY3Jvc3MtZmFkZWAgQ1NTXHJcbiAqIGZ1bmN0aW9uIGludm9jYXRpb24gdGhhdCBhY2NlcHRzIG11bHRpcGxlIGltYWdlcyAtIGVhY2ggd2l0aCBhbiBvcHRpb25hbCBwZXJjZW50YWdlLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgSW1hZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcm9zc0ZhZGUoIC4uLmltYWdlczogKEV4dGVuZGVkPENzc0ltYWdlPiB8IFtFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc1BlcmNlbnQ+XSlbXSk6IElDcm9zc0ZhZGVCdWlsZGVyO1xyXG5cclxuLyoqIEltcGxlbWVudGF0aW9uICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcm9zc0ZhZGUoKTogSUNyb3NzRmFkZUJ1aWxkZXJcclxue1xyXG4gICAgcmV0dXJuIG5ldyBDcm9zc0ZhZGVCdWlsZGVyKCAuLi5hcmd1bWVudHMpO1xyXG59XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBmdW5jdGlvbmFsaXR5IG9mIGNyb3NzLWZhZGUoKVxyXG4gKi9cclxuY2xhc3MgQ3Jvc3NGYWRlQnVpbGRlciBpbXBsZW1lbnRzIElDcm9zc0ZhZGVCdWlsZGVyXHJcbntcclxuICAgIGZuOiBcImNyb3NzLWZhZGVcIiA9IFwiY3Jvc3MtZmFkZVwiO1xyXG5cclxuICAgIG9sZD86IFtFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD5dO1xyXG4gICAgaW1hZ2VzPzogW0V4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD4/XVtdO1xyXG4gICAgYz86IEV4dGVuZGVkPENzc0NvbG9yPjtcclxuXHJcbiAgICAvLyBjb25zdHJ1Y3RvciBmb3Igb2xkIGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG5cdGNvbnN0cnVjdG9yKCBvbGQ6IFtFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD5dKTtcclxuXHJcbiAgICAvLyBjb25zdHJ1Y3RvciBmb3IgbmV3IGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG5cdGNvbnN0cnVjdG9yKCAuLi5pbWFnZXM6IChFeHRlbmRlZDxDc3NJbWFnZT4gfCBbRXh0ZW5kZWQ8Q3NzSW1hZ2U+LCBFeHRlbmRlZDxDc3NQZXJjZW50Pl0pW10pO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IHAxID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KCBwMSkgJiYgcDEubGVuZ3RoID09PSAzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgb2xkIHNpZ25hdHVyZVxyXG4gICAgICAgICAgICB0aGlzLm9sZCA9IHAxIGFzIFtFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBuZXcgc2lnbmF0dXJlXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKCAuLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblx0YWRkKCAuLi5pbWFnZXM6IChFeHRlbmRlZDxDc3NJbWFnZT4gfCBbRXh0ZW5kZWQ8Q3NzSW1hZ2U+LCBFeHRlbmRlZDxDc3NQZXJjZW50Pl0pW10pOiB0aGlzXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmltYWdlcylcclxuICAgICAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKCBsZXQgaXRlbSBvZiBpbWFnZXMpXHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2goIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG5cdGNvbG9yKCBjOiBFeHRlbmRlZDxDc3NDb2xvcj4pOiB0aGlzIHsgdGhpcy5jID0gYzsgcmV0dXJuIHRoaXM7IH1cclxufVxyXG5cclxuZmRvW1wiY3Jvc3MtZmFkZVwiXSA9ICh2YWw6IElDcm9zc0ZhZGVGdW5jKTogc3RyaW5nID0+XHJcbiAgICBmMnMoIFwiY3Jvc3MtZmFkZVwiLCBbXHJcbiAgICAgICAgdmFsLmltYWdlc1xyXG4gICAgICAgICAgICA/IG12MnMoIFtbdmFsLmltYWdlcywgeyBpdGVtOiB7IGFycjogW1dLRi5EZWZhdWx0LCBXS0YuUGVyY2VudF0gfSwgc2VwOiBcIixcIiB9XSwgW3ZhbC5jLCBXS0YuQ29sb3JdXSwgXCIsXCIpXHJcbiAgICAgICAgICAgIDogdjJzKCB2YWwub2xkLCB7IGFycjogW1dLRi5EZWZhdWx0LCBXS0YuRGVmYXVsdCwgV0tGLlBlcmNlbnRdLCBzZXA6IFwiLFwiIH0pXHJcbiAgICBdKVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJSW1hZ2VTZXRGdW5jIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBpbWFnZS1zZXQoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gaXRlbXMgT25lIG9yIG1vcmUgaXRlbXMgc3BlY2lmeWluZyBhbiBpbWFnZSBhbmQgb3B0aW9uYWxseSBpbWFnZSB0eXBlIGFuZCByZXNvbHV0aW9uLlxyXG4gKiBAcmV0dXJuc1xyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgSW1hZ2VcclxuICovXHJcbmV4cG9ydCBjb25zdCBpbWFnZVNldCA9ICguLi5pdGVtczogSW1hZ2VTZXRJdGVtW10pOiBJSW1hZ2VTZXRGdW5jID0+ICh7IGZuOiBcImltYWdlLXNldFwiLCBpdGVtcyB9KVxyXG5cclxuY29uc3QgaW1hZ2VUeXBlVG9TdHJpbmcgPSAodmFsOiBFeHRlbmRlZDxzdHJpbmc+KTogc3RyaW5nID0+IHYycyggdmFsLCB7XHJcbiAgICBzdHI6IHYgPT4gYHR5cGUoXCIke3YuaW5kZXhPZihcIi9cIikgPiAwID8gdmFsIDogXCJpbWFnZS9cIiArIHZhbH1cIilgXHJcbn0pO1xyXG5cclxuY29uc3QgaW1hZ2VSZXNvbHV0aW9uVG9TdHJpbmcgPSAodmFsOiBFeHRlbmRlZDxJbWFnZVNldFJlc29sdXRpb24+KTogc3RyaW5nID0+IHYycyggdmFsLCB7XHJcbiAgICBudW06IHYgPT4gdiArIFwieFwiXHJcbn0pO1xyXG5cclxuZmRvW1wiaW1hZ2Utc2V0XCJdID0gW1xyXG4gICAgW1xyXG4gICAgICAgIFwiaXRlbXNcIiwge1xyXG4gICAgICAgICAgICBpdGVtOiB7XHJcbiAgICAgICAgICAgICAgICBzdHI6IFdLRi5RdW90ZWQsXHJcbiAgICAgICAgICAgICAgICBhcnI6IHtcclxuICAgICAgICAgICAgICAgICAgICAxOiBbV0tGLlF1b3RlZF0sXHJcbiAgICAgICAgICAgICAgICAgICAgMjogW1dLRi5RdW90ZWQsIHtzdHI6IGltYWdlVHlwZVRvU3RyaW5nLCBudW06IGltYWdlUmVzb2x1dGlvblRvU3RyaW5nfV0sXHJcbiAgICAgICAgICAgICAgICAgICAgMzogW1dLRi5RdW90ZWQsIGltYWdlVHlwZVRvU3RyaW5nLCBpbWFnZVJlc29sdXRpb25Ub1N0cmluZ10sXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlcDogXCIsXCJcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIHBhaW50IHdvcmtsZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgb3B0aW9uYWwgYXJndW1lbnQgc3ludGF4IGFuZCBvcHRpb25hbCBVUkwgb2ZcclxuICogdGhlIHdvcmtsZXQgbW9kdWxlLiBUaGUgd29ya2xldCBuYW1lIHNob3VsZCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIFtbSVBhaW50V29ya2xldHNdXSBpbnRlcmZhY2VcclxuICogdXNpbmcgdGhlIG1vZHVsZSBhdWdtZW50YXRpb24gdGVjaG5pcXVlLiBBbHRob3VnaCBpdCBpcyBwb3NzaWJsZSB0byB1c2UgcGFpbnQgd29ya2xldHMgd2l0aG91dFxyXG4gKiBhZGRpbmcgdGhlbSB0byB0aGUgW1tJUGFpbnRXb3JrbGV0c11dIGludGVyZmFjZSwgdGhpcyB3aWxsIHByZXZlbnQgTWltY3NzIGZyb20gZW5mb3JjaW5nIHRoZVxyXG4gKiB0eXBlcyBvZiBhcmd1bWVudHMgd2hlbiB0aGUgW1twYWludF1dIGZ1bmN0aW9uIGlzIGludm9rZWQuXHJcbiAqIEBwYXJhbSBuYW1lIFdvcmtsZXQgbmFtZVxyXG4gKiBAcGFyYW0gc3ludGF4IFR1cGxlIGNvbnRhaW5pbmcgc3ludGF4IGRlZmluaXRpb25zIGZvciB3b3JrbGV0IGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHVybCBVUkwgdG8gdGhlIHdvcmtsZXQgbW9kdWxlLiBJZiBzcGVjaWZpZWQsIHRoZSBtb2R1bGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyUGFpbnRXb3JrbGV0ID0gYXN5bmMgPEsgZXh0ZW5kcyBrZXlvZiBJUGFpbnRXb3JrbGV0cz4oIG5hbWU6IEssXHJcbiAgICBzeW50YXg6IElQYWludFdvcmtsZXRzW0tdID0gW10sIHVybD86IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT5cclxue1xyXG4gICAgaWYgKChDU1MgYXMgYW55KS5wYWludFdvcmtsZXQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFyZWdpc3RlcmVkUGFpbnRXb3JrbGV0SW5mb3NbbmFtZV0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZWdpc3RlcmVkUGFpbnRXb3JrbGV0SW5mb3NbbmFtZV0gPSB7c3ludGF4LCB1cmx9O1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgVVJMIGlzIHNwZWNpZmllZCB1c2UgaXQgdG8gYWRkIHdvcmtsZXQgbW9kdWxlXHJcbiAgICAgICAgICAgIGlmICh1cmwgJiYgIWFkZGVkUGFpbnRXb3JrbGV0TW9kdWxlcy5oYXModXJsKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYWRkZWRQYWludFdvcmtsZXRNb2R1bGVzLmFkZCh1cmwpO1xyXG4gICAgICAgICAgICAgICAgdHJ5XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgKENTUyBhcyBhbnkpLnBhaW50V29ya2xldC5hZGRNb2R1bGUoIHVybCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCh4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGBFcnJvciBhZGRpbmcgbW9kdWxlICcke3VybH0nIGZvciBwYWludCB3b3JrbGV0ICcke25hbWV9J2AsIHgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIGluZm9ybWF0aW9uIHdlIGtlZXAgZm9yIHJlZ2lzdGVyZWQgcGFpbnQgd29ya2xldHMuXHJcbiAqL1xyXG50eXBlIFBhaW50V29ya2xldEluZm88SyBleHRlbmRzIGtleW9mIElQYWludFdvcmtsZXRzPiA9IHsgc3ludGF4OiBJUGFpbnRXb3JrbGV0c1tLXSwgdXJsPzogc3RyaW5nIH07XHJcblxyXG4vKipcclxuICogSW5mb3JtYXRpb24gYWJvdXQgcmVnaXN0ZXJlZCBwYWludCB3b3JrbGV0cy5cclxuICovXHJcbmxldCByZWdpc3RlcmVkUGFpbnRXb3JrbGV0SW5mb3M6IHsgW0sgaW4ga2V5b2YgSVBhaW50V29ya2xldHNdPzogUGFpbnRXb3JrbGV0SW5mbzxLPiB9ID0ge307XHJcblxyXG4vKipcclxuICogU2V0IG9mIFVSTHMgb2YgYWxyZWFkeSBhZGRlZCBwYWludCB3b3JrbGV0IG1vZHVsZXMuXHJcbiAqL1xyXG5sZXQgYWRkZWRQYWludFdvcmtsZXRNb2R1bGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBJUGFpbnRGdW5jIG9iamVjdCBkZXNjcmliaW5nIGFuIGludm9jYXRpb24gb2YgdGhlIGBwYWludCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIFBhaW50IHdvcmtsZXQgbmFtZS5cclxuICogQHBhcmFtIGFyZ3MgUGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIHBhaW50IHdvcmtsZXQuXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBJbWFnZVxyXG4gKlxyXG4gKiBAdHMtZXhwZWN0LWVycm9yOiBFcnJvbmVvdXNseSByZXBvcnRzIFRTMjM3MCBhbHRob3VnaCB0aGUgcmVzdCdzIHR5cGUgaXMgYW4gYXJyYXkgKGEgdHVwbGUpICovXHJcbmV4cG9ydCBjb25zdCBwYWludCA9IDxLIGV4dGVuZHMga2V5b2YgSVBhaW50V29ya2xldHM+KCBuYW1lOiBLLCAuLi5hcmdzOiBNYXBwZWRTeW50YXhUeXBlczxJUGFpbnRXb3JrbGV0c1tLXT4pOiBJUGFpbnRGdW5jID0+XHJcbiAgICAoeyBmbjogXCJwYWludFwiLCBuYW1lOiBuYW1lIGFzIHN0cmluZywgYXJnczogYXJncyBhcyBhbnkgYXMgc3RyaW5nW10gfSlcclxuXHJcbmZkb1tcInBhaW50XCJdID0gKHY6IElQYWludEZ1bmMpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgaWYgKCF2Py5hcmdzPy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGBwYWludCgke3YubmFtZX0pYDtcclxuXHJcbiAgICBsZXQgaW5mbyA9IHJlZ2lzdGVyZWRQYWludFdvcmtsZXRJbmZvc1t2Lm5hbWVdO1xyXG4gICAgbGV0IGJ1Zjogc3RyaW5nW10gPSBbXTtcclxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgdi5hcmdzLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGxldCBzeW50YXggPSBpbmZvPy5zeW50YXhbaV07XHJcbiAgICAgICAgYnVmLnB1c2goIHN5bnRheCA/IHNwMnMoIHN5bnRheCwgdi5hcmdzW2ldKSA6IHYycyggdi5hcmdzW2ldKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGBwYWludCgke3YubmFtZX0sJHtidWYuZmlsdGVyKHY9PiEhdikuam9pbihcIixcIil9KWA7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gRmlsdGVyc1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSUZpbHRlclByb3h5IGZ1bmN0aW9uIHJlcHJlc2VudGluZyBvbmUgb2YgdGhlIGZpbHRlciBDU1MgZnVuY3Rpb24uXHJcbiAqL1xyXG5jb25zdCBmaWx0ZXJQZXJjZW50ID0gKGZuOiBQZXJjZW50RmlsdGVyTmFtZXMsIHA6IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSVBlcmNlbnRGaWx0ZXJGdW5jID0+ICh7IGZuLCBwIH0pO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lQZXJjZW50RmlsdGVyRnVuY11dIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBicmlnaHRuZXNzKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IGJyaWdodG5lc3MoMTUwJSlcclxuICogICAgIGJyaWdodCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuYnJpZ2h0bmVzcygxNTApfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogYnJpZ2h0bmVzcyg1MCUpXHJcbiAqICAgICBkaW0gPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmJyaWdodG5lc3MoMC41KX0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFZhbHVlIGludGVycHJldGVkIGFzIHBlcmNlbnRhZ2UuIEludGVnZXIgbnVtYmVyIGlzIHVzZWQgYXMgaXMgd2hpbGUgIGZsb2F0aW5nIHBvaW50XHJcbiAqIG51bWJlcnMgYXJlIG11bHRpcGxpZWQgYnkgMTAwLlxyXG4gKiBAcmV0dXJucyBUaGUgYElQZXJjZW50RmlsdGVyRnVuY2AgaW50ZXJmYWNlIGNvbnRhaW5pbmcgcGVyY2VudGFnZSB2YWx1ZVxyXG4gKiBAY2F0ZWdvcnkgRmlsdGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYnJpZ2h0bmVzcyA9IChwOiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElQZXJjZW50RmlsdGVyRnVuYyA9PiBmaWx0ZXJQZXJjZW50KCBcImJyaWdodG5lc3NcIiwgcCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFtbSVBlcmNlbnRGaWx0ZXJGdW5jXV0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYGNvbnRyYXN0KClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IGNvbnRyYXN0KDE1MCUpXHJcbiAqICAgICBoaWdoQ29udHJhc3QgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmNvbnRyYXN0KDE1MCl9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBjb250cmFzdCg1MCUpXHJcbiAqICAgICBsb3dDb250cmFzdCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuY29udHJhc3QoMC41KX0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFZhbHVlIGludGVycHJldGVkIGFzIHBlcmNlbnRhZ2UuIEludGVnZXIgbnVtYmVyIGlzIHVzZWQgYXMgaXMgd2hpbGUgIGZsb2F0aW5nIHBvaW50XHJcbiAqIG51bWJlcnMgYXJlIG11bHRpcGxpZWQgYnkgMTAwLlxyXG4gKiBAcmV0dXJucyBUaGUgYElQZXJjZW50RmlsdGVyRnVuY2AgaW50ZXJmYWNlIGNvbnRhaW5pbmcgcGVyY2VudGFnZSB2YWx1ZVxyXG4gKiBAY2F0ZWdvcnkgRmlsdGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29udHJhc3QgPSAocDogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4pOiBJUGVyY2VudEZpbHRlckZ1bmMgPT4gZmlsdGVyUGVyY2VudCggXCJjb250cmFzdFwiLCBwKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJUGVyY2VudEZpbHRlckZ1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgZ3JheXNjYWxlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IGdyYXlzY2FsZSgxMDAlKVxyXG4gKiAgICAgZ3JheSA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuZ3JheXNjYWxlKDEwMCl9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBncmF5c2NhbGUoNTAlKVxyXG4gKiAgICAgaGFsZkNvbG9yID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5ncmF5c2NhbGUoMC41KX0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFZhbHVlIGludGVycHJldGVkIGFzIHBlcmNlbnRhZ2UuIEludGVnZXIgbnVtYmVyIGlzIHVzZWQgYXMgaXMgd2hpbGUgIGZsb2F0aW5nIHBvaW50XHJcbiAqIG51bWJlcnMgYXJlIG11bHRpcGxpZWQgYnkgMTAwLlxyXG4gKiBAcmV0dXJucyBUaGUgYElQZXJjZW50RmlsdGVyRnVuY2AgaW50ZXJmYWNlIGNvbnRhaW5pbmcgcGVyY2VudGFnZSB2YWx1ZVxyXG4gKiBAY2F0ZWdvcnkgRmlsdGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ3JheXNjYWxlID0gKHA6IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSVBlcmNlbnRGaWx0ZXJGdW5jID0+IGZpbHRlclBlcmNlbnQoIFwiZ3JheXNjYWxlXCIsIHApO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lQZXJjZW50RmlsdGVyRnVuY11dIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBpbnZlcnQoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKlxyXG4gKiBgYGB0c3hcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGZpbHRlcjogaW52ZXJ0KDEwMCUpXHJcbiAqICAgICBpbnZlcnRlZCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuaW52ZXJ0KDEwMCl9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBpbnZlcnQoNzUlKVxyXG4gKiAgICAgc29tZXdoYXRudmVydGVkID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5pbnZlcnQoMC43NSl9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBpbnZlcnQoNTAlKVxyXG4gKiAgICAgZ3JheSA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuaW52ZXJ0KDAuNSl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gcCBWYWx1ZSBpbnRlcnByZXRlZCBhcyBwZXJjZW50YWdlLiBJbnRlZ2VyIG51bWJlciBpcyB1c2VkIGFzIGlzIHdoaWxlICBmbG9hdGluZyBwb2ludFxyXG4gKiBudW1iZXJzIGFyZSBtdWx0aXBsaWVkIGJ5IDEwMC5cclxuICogQHJldHVybnMgVGhlIGBJUGVyY2VudEZpbHRlckZ1bmNgIGludGVyZmFjZSBjb250YWluaW5nIHBlcmNlbnRhZ2UgdmFsdWVcclxuICogQGNhdGVnb3J5IEZpbHRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGludmVydCA9IChwOiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElQZXJjZW50RmlsdGVyRnVuYyA9PiBmaWx0ZXJQZXJjZW50KCBcImludmVydFwiLCBwKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJUGVyY2VudEZpbHRlckZ1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgb3BhY2l0eSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqXHJcbiAqIGBgYHRzeFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gZmlsdGVyOiBvcGFjaXR5KDUwJSlcclxuICogICAgIGhhbGZUcmFuc3BhcmVudCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3Mub3BhY2l0eSgwLjUpfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHAgVmFsdWUgaW50ZXJwcmV0ZWQgYXMgcGVyY2VudGFnZS4gSW50ZWdlciBudW1iZXIgaXMgdXNlZCBhcyBpcyB3aGlsZSAgZmxvYXRpbmcgcG9pbnRcclxuICogbnVtYmVycyBhcmUgbXVsdGlwbGllZCBieSAxMDAuXHJcbiAqIEByZXR1cm5zIFRoZSBgSVBlcmNlbnRGaWx0ZXJGdW5jYCBpbnRlcmZhY2UgY29udGFpbmluZyBwZXJjZW50YWdlIHZhbHVlXHJcbiAqIEBjYXRlZ29yeSBGaWx0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBvcGFjaXR5ID0gKHA6IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSVBlcmNlbnRGaWx0ZXJGdW5jID0+IGZpbHRlclBlcmNlbnQoIFwib3BhY2l0eVwiLCBwKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJUGVyY2VudEZpbHRlckZ1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgc2F0dXJhdGUoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKlxyXG4gKiBgYGB0c3hcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGZpbHRlcjogc2F0dXJhdGUoMTUwJSlcclxuICogICAgIHN1cGVyU2F0dXJhdGVkID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5zYXR1cmF0ZSgxNTApfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogc2F0dXJhdGUoNTAlKVxyXG4gKiAgICAgdW5kZXJTYXR1cmF0ZWQgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLnNhdHVyYXRlKDAuNSl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gcCBWYWx1ZSBpbnRlcnByZXRlZCBhcyBwZXJjZW50YWdlLiBJbnRlZ2VyIG51bWJlciBpcyB1c2VkIGFzIGlzIHdoaWxlICBmbG9hdGluZyBwb2ludFxyXG4gKiBudW1iZXJzIGFyZSBtdWx0aXBsaWVkIGJ5IDEwMC5cclxuICogQHJldHVybnMgVGhlIGBJUGVyY2VudEZpbHRlckZ1bmNgIGludGVyZmFjZSBjb250YWluaW5nIHBlcmNlbnRhZ2UgdmFsdWVcclxuICogQGNhdGVnb3J5IEZpbHRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNhdHVyYXRlID0gKHA6IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSVBlcmNlbnRGaWx0ZXJGdW5jID0+IGZpbHRlclBlcmNlbnQoIFwic2F0dXJhdGVcIiwgcCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFtbSVBlcmNlbnRGaWx0ZXJGdW5jXV0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYHNlcGlhKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IHNlcGlhKDEwMCUpXHJcbiAqICAgICB2aW50YWdlID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5zZXBpYSgxMDApfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHAgVmFsdWUgaW50ZXJwcmV0ZWQgYXMgcGVyY2VudGFnZS4gSW50ZWdlciBudW1iZXIgaXMgdXNlZCBhcyBpcyB3aGlsZSAgZmxvYXRpbmcgcG9pbnRcclxuICogbnVtYmVycyBhcmUgbXVsdGlwbGllZCBieSAxMDAuXHJcbiAqIEByZXR1cm5zIFRoZSBgSVBlcmNlbnRGaWx0ZXJGdW5jYCBpbnRlcmZhY2UgY29udGFpbmluZyBwZXJjZW50YWdlIHZhbHVlXHJcbiAqIEBjYXRlZ29yeSBGaWx0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXBpYSA9IChwOiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElQZXJjZW50RmlsdGVyRnVuYyA9PiBmaWx0ZXJQZXJjZW50KCBcInNlcGlhXCIsIHApO1xyXG5cclxuZmRvLmJyaWdodG5lc3MgPSBmZG8uY29udHJhc3QgPSBmZG8uZ3JheXNjYWxlID0gZmRvLmludmVydCA9IGZkby5vcGFjaXR5ID0gZmRvLnNhdHVyYXRlID1cclxuICAgIGZkby5zZXBpYSA9IFdLRi5QZXJjZW50O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lCbHVyRnVuY11dIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBibHVyKClgIENTUyBmdW5jdGlvbiBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKlxyXG4gKiBgYGB0c3hcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGZpbHRlcjogYmx1cigwKVxyXG4gKiAgICAgc2hhcnAgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmJsdXIoMCl9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBibHVyKDJweClcclxuICogICAgIGJsdXJyZWQgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmJsdXIoMil9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBibHVyKDEuNWVtKVxyXG4gKiAgICAgc3VwZXJCbHVycmVkID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5ibHVyKDEuNSl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gciBSYWRpdXMgb2YgdGhlIGJsdXIuXHJcbiAqIEByZXR1cm5zIFRoZSBgSUJsdXJGdW5jYCBpbnRlcmZhY2UgY29udGFpbmluZyB0aGUgYmx1ciByYWRpdXNcclxuICogQGNhdGVnb3J5IEZpbHRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJsdXIgPSAoIHI6IEV4dGVuZGVkPENzc0xlbmd0aD4pOiBJQmx1ckZ1bmMgPT4gKHsgZm46IFwiYmx1clwiLCByIH0pO1xyXG5cclxuZmRvLmJsdXIgPSBXS0YuTGVuZ3RoO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lEcm9wU2hhZG93RnVuY11dIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBkcm9wU2hhZG93KClgIENTUyBmdW5jdGlvbiBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKlxyXG4gKiBgYGB0c3hcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGZpbHRlcjogZHJvcC1zaGFkb3coMzBweCAxMHB4IDRweCBibHVlKVxyXG4gKiAgICAgYmx1cnJlZFNoYWRvdyA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuZHJvcFNoYWRvdyggMzAsIDEwLCBcImJsdWVcIiwgNCl9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBkcm9wLXNoYWRvdygyLjVlbSAtMS41ZW0gZ3JlZW4pXHJcbiAqICAgICBzaGFycFNoYWRvdyA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuZHJvcFNoYWRvdyggMi41LCAtMS41LCBcImdyZWVuXCIpfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogZHJvcC1zaGFkb3coMCAwIDIwcHggb3JhbmdlKVxyXG4gKiAgICAgaGFsb1NoYWRvdyA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuZHJvcFNoYWRvdyggMCwgMCwgXCJvcmFuZ2VcIiwgMjBweCl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0geCBIb3Jpem9udGFsIG9mZnNldCBvZiB0aGUgc2hhZG93LlxyXG4gKiBAcGFyYW0geSBWZXJ0aWNhbCBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cclxuICogQHBhcmFtIGNvbG9yIENvbG9yIG9mIHRoZSBzaGFkb3cuIElmIHVuZGVmaW5lZCwgdGhlIGNvbG9yIG9mIHRoZSBzaGFkb3cgaXMgdGFrZW4gZnJvbSB0aGUgY29sb3JcclxuICogcHJvcGVydHkuXHJcbiAqIEBwYXJhbSBibHVyIFZhbHVlIG9mIHRoZSBzaGFkb3cncyBibHVycmluZy4gSWYgdW5kZWZpbmVkLCB0aGUgc2hhZG93IHdpbGwgYmUgc2hhcnAgKG5vdCBibHVycmVkKS5cclxuICogQHJldHVybnMgVGhlIGBJRHJvcFNoYWRvd0Z1bmNgIGludGVyZmFjZSBjb250YWluaW5nIHRoZSBzaGFkb3cgcGFyYW1ldGVycy5cclxuICpcclxuICogQGNhdGVnb3J5IEZpbHRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRyb3BTaGFkb3cgPSAoeDogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiwgeTogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPixcclxuICAgIGNvbG9yPzogRXh0ZW5kZWQ8Q3NzQ29sb3I+LCBibHVyPzogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElEcm9wU2hhZG93RnVuYyA9PiAoeyBmbjogXCJkcm9wLXNoYWRvd1wiLCB4LCB5LCBjb2xvciwgYmx1ciB9KTtcclxuXHJcbmZkb1tcImRyb3Atc2hhZG93XCJdID0ge1xyXG4gICAgcDogWyBcInhcIiwgXCJ5XCIsIFwiYmx1clwiLCBbXCJjb2xvclwiLCBXS0YuQ29sb3JdIF0sXHJcbiAgICBkbzogV0tGLkxlbmd0aCxcclxuICAgIHM6IFwiIFwiXHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJSHVlUm90YXRlRnVuY11dIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBodWUtcm90YXRlKClgIENTUyBmdW5jdGlvbiBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKlxyXG4gKiBgYGB0c3hcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGZpbHRlcjogaHVlLXJvdGF0ZSg5MGRlZylcclxuICogICAgIHRvVGhlUmlnaHQgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmh1ZVJvdGF0ZSg5MCl9KVxyXG4gKlxyXG4gKiAgICAgLy8gZmlsdGVyOiBodWUtcm90YXRlKC0wLjI1dHVybilcclxuICogICAgIHRvVGhlTGVmdCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuYmx1cigtMC4yNSl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgcmVsYXRpdmUgY2hhbmdlIGluIGh1ZSBvZiB0aGUgaW5wdXQgc2FtcGxlLlxyXG4gKiBAcmV0dXJucyBUaGUgYElIdWVSb3RhdGVGdW5jYCBpbnRlcmZhY2UgY29udGFpbmluZyB0aGUgaHVlIHJvdGF0aW9uIGFuZ2xlXHJcbiAqIEBjYXRlZ29yeSBGaWx0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBodWVSb3RhdGUgPSAoYTogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogSUh1ZVJvdGF0ZUZ1bmMgPT4gKHsgZm46IFwiaHVlLXJvdGF0ZVwiLCBhIH0pO1xyXG5cclxuZmRvW1wiaHVlLXJvdGF0ZVwiXSA9IFdLRi5BbmdsZVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBUcmFuc2Zvcm1zXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJTWF0cml4RnVuYyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgbWF0cml4KClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hdHJpeCA9IChhOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBiOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBjOiBFeHRlbmRlZDxDc3NOdW1iZXI+LFxyXG5cdGQ6IEV4dGVuZGVkPENzc051bWJlcj4sIHR4OiBFeHRlbmRlZDxDc3NOdW1iZXI+LCB0eTogRXh0ZW5kZWQ8Q3NzTnVtYmVyPik6IElNYXRyaXhGdW5jID0+XHJcbiAgICAoe2ZuOiBcIm1hdHJpeFwiLCBhLCBiLCBjLCBkLCB0eCwgdHkgfSk7XHJcblxyXG5mZG8ubWF0cml4ID0gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJ0eFwiLCBcInR5XCIgXTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSU1hdHJpeDNkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBtYXRyaXgzZCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXRyaXgzZCA9IChcclxuXHRcdGExOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBiMTogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYzE6IEV4dGVuZGVkPENzc051bWJlcj4sIGQxOiBFeHRlbmRlZDxDc3NOdW1iZXI+LFxyXG5cdFx0YTI6IEV4dGVuZGVkPENzc051bWJlcj4sIGIyOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBjMjogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgZDI6IEV4dGVuZGVkPENzc051bWJlcj4sXHJcblx0XHRhMzogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYjM6IEV4dGVuZGVkPENzc051bWJlcj4sIGMzOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBkMzogRXh0ZW5kZWQ8Q3NzTnVtYmVyPixcclxuXHRcdGE0OiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBiNDogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYzQ6IEV4dGVuZGVkPENzc051bWJlcj4sIGQ0OiBFeHRlbmRlZDxDc3NOdW1iZXI+LFxyXG5cdCk6IElNYXRyaXgzZEZ1bmMgPT4gKHsgZm46IFwibWF0cml4M2RcIiwgYTEsIGIxLCBjMSwgZDEsIGEyLCBiMiwgYzIsIGQyLCBhMywgYjMsIGMzLCBkMywgYTQsIGI0LCBjNCwgZDQgfSk7XHJcblxyXG5mZG8ubWF0cml4ID0gWyBcImExXCIsIFwiYjFcIiwgXCJjMVwiLCBcImQxXCIsIFwiYTJcIiwgXCJiMlwiLCBcImMyXCIsIFwiZDJcIiwgXCJhM1wiLCBcImIzXCIsIFwiYzNcIiwgXCJkM1wiLCBcImE0XCIsIFwiYjRcIiwgXCJjNFwiLCBcImQ0XCIgXTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVBlcnNwZWN0aXZlRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBwZXJzcGVjdGl2ZSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwZXJzcGVjdGl2ZSA9IChkOiBFeHRlbmRlZDxDc3NMZW5ndGg+KTogSVBlcnNwZWN0aXZlRnVuYyA9PiAoeyBmbjogXCJwZXJzcGVjdGl2ZVwiLCBkIH0pO1xyXG5cclxuZmRvLnBlcnNwZWN0aXZlID0gV0tGLkxlbmd0aDtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVJvdGF0ZUZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgcm90YXRlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJvdGF0ZSA9IChhOiBFeHRlbmRlZDxDc3NBbmdsZT4pOiBJUm90YXRlRnVuYyA9PiAoeyBmbjogXCJyb3RhdGVcIiwgYSB9KTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElUcmFuc2Zvcm1Qcm94eSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGByb3RhdGVYKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJvdGF0ZVggPSAoYTogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogSVJvdGF0ZUZ1bmMgPT4gKHsgZm46IFwicm90YXRlWFwiLCBhIH0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVRyYW5zZm9ybVByb3h5IGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHJvdGF0ZVkoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgcm90YXRlWSA9IChhOiBFeHRlbmRlZDxDc3NBbmdsZT4pOiBJUm90YXRlRnVuYyA9PiAoeyBmbjogXCJyb3RhdGVZXCIsIGEgfSk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJVHJhbnNmb3JtUHJveHkgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgcm90YXRlWigpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCByb3RhdGVaID0gKGE6IEV4dGVuZGVkPENzc0FuZ2xlPik6IElSb3RhdGVGdW5jID0+ICh7IGZuOiBcInJvdGF0ZVpcIiwgYSB9KTtcclxuXHJcbmZkby5yb3RhdGUgPSBmZG8ucm90YXRlWCA9IGZkby5yb3RhdGVZID0gZmRvLnJvdGF0ZVogPSBXS0YuQW5nbGU7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElSb3RhdGUzZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgcm90YXRlM2QoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgcm90YXRlM2QgPSAoeDogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgeTogRXh0ZW5kZWQ8Q3NzTnVtYmVyPixcclxuICAgIHo6IEV4dGVuZGVkPENzc051bWJlcj4sIGE6IEV4dGVuZGVkPENzc0FuZ2xlPik6IElSb3RhdGUzZEZ1bmMgPT4gKHsgZm46IFwicm90YXRlM2RcIiwgeCwgeSwgeiwgYSB9KTtcclxuXHJcbmZkby5yb3RhdGUzZCA9IFsgXCJ4XCIsIFwieVwiLCBcInpcIiwgW1wiYVwiLCBXS0YuQW5nbGVdIF07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElTY2FsZUZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgc2NhbGUoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2NhbGUgPSAoc3g6IEV4dGVuZGVkPENzc051bWJlcj4sIHN5PzogRXh0ZW5kZWQ8Q3NzTnVtYmVyPik6IElTY2FsZUZ1bmMgPT4gKHsgZm46IFwic2NhbGVcIiwgc3gsIHN5IH0pO1xyXG5cclxuZmRvLnNjYWxlID0gW1wic3hcIiwgXCJzeVwiXVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVNjYWxlMWRGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHNjYWxlWCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzY2FsZVggPSAoczogRXh0ZW5kZWQ8Q3NzTnVtYmVyPik6IElTY2FsZTFkRnVuYyA9PiAoeyBmbjogXCJzY2FsZVhcIiwgcyB9KTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElTY2FsZTFkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBzY2FsZVkoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2NhbGVZID0gKHM6IEV4dGVuZGVkPENzc051bWJlcj4pOiBJU2NhbGUxZEZ1bmMgPT4gKHsgZm46IFwic2NhbGVZXCIsIHMgfSk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJU2NhbGUxZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgc2NhbGVaKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNjYWxlWiA9IChzOiBFeHRlbmRlZDxDc3NOdW1iZXI+KTogSVNjYWxlMWRGdW5jID0+ICh7IGZuOiBcInNjYWxlWlwiLCBzIH0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVNjYWxlM2RGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHNjYWxlM2QoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2NhbGUzZCA9IChzeDogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgc3k6IEV4dGVuZGVkPENzc051bWJlcj4sXHJcbiAgICBzejogRXh0ZW5kZWQ8Q3NzTnVtYmVyPik6IElTY2FsZTNkRnVuYyA9PiAoeyBmbjogXCJzY2FsZTNkXCIsIHN4LCBzeSwgc3ogfSk7XHJcblxyXG5mZG8uc2NhbGUzZCA9IFtcInN4XCIsIFwic3lcIiwgXCJzelwiXVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJU2tld0Z1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgc2tldygpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCBza2V3ID0gKGF4OiBFeHRlbmRlZDxDc3NBbmdsZT4sIGF5PzogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogSVNrZXdGdW5jID0+ICh7IGZuOiBcInNrZXdcIiwgYXgsIGF5IH0pO1xyXG5cclxuZmRvLnNrZXcgPSB7XHJcbiAgICBwOiBbXCJheFwiLCBcImF5XCJdLFxyXG4gICAgZG86IFdLRi5BbmdsZVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJU2tldzFkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBza2V3WCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCBza2V3WCA9IChhOiBFeHRlbmRlZDxDc3NBbmdsZT4pOiBJU2tldzFkRnVuYyA9PiAoeyBmbjogXCJza2V3WFwiLCBhIH0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVNrZXcxZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgc2tld1koKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2tld1kgPSAoYTogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogSVNrZXcxZEZ1bmMgPT4gKHsgZm46IFwic2tld1lcIiwgYSB9KTtcclxuXHJcbmZkby5za2V3WCA9IGZkby5za2V3WSA9IFdLRi5BbmdsZTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVRyYW5zbGF0ZUZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgdHJhbnNsYXRlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRyYW5zbGF0ZSA9ICh4OiBFeHRlbmRlZDxDc3NMZW5ndGg+LCB5PzogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElUcmFuc2xhdGVGdW5jID0+ICh7IGZuOiBcInRyYW5zbGF0ZVwiLCB4LCB5IH0pO1xyXG5cclxuZmRvLnRyYW5zbGF0ZSA9IHtcclxuICAgIHA6IFtcInhcIiwgXCJ5XCJdLFxyXG4gICAgZG86IFdLRi5MZW5ndGhcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVRyYW5zbGF0ZTFkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGB0cmFuc2xhdGVYKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRyYW5zbGF0ZVggPSAoZDogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElUcmFuc2xhdGUxZEZ1bmMgPT4gKHsgZm46IFwidHJhbnNsYXRlWFwiLCBkIH0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVRyYW5zbGF0ZTFkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGB0cmFuc2xhdGVZKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRyYW5zbGF0ZVkgPSAoZDogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElUcmFuc2xhdGUxZEZ1bmMgPT4gKHsgZm46IFwidHJhbnNsYXRlWVwiLCBkIH0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVRyYW5zbGF0ZTFkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGB0cmFuc2xhdGVaKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRyYW5zbGF0ZVogPSAoZDogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElUcmFuc2xhdGUxZEZ1bmMgPT4gKHsgZm46IFwidHJhbnNsYXRlWlwiLCBkIH0pO1xyXG5cclxuZmRvLnRyYW5zbGF0ZVggPSBmZG8udHJhbnNsYXRlWSA9IGZkby50cmFuc2xhdGVaID0gV0tGLkxlbmd0aDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElUcmFuc2xhdGUzZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgdHJhbnNsYXRlM2QoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJhbnNsYXRlM2QgPSAoeDogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiwgeTogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPixcclxuXHR6OiBFeHRlbmRlZDxDc3NMZW5ndGg+KTogSVRyYW5zbGF0ZTNkRnVuYyA9PiAoeyBmbjogXCJ0cmFuc2xhdGUzZFwiLCB4LCB5LCB6IH0pO1xyXG5cclxuZmRvLnRyYW5zbGF0ZTNkID0ge1xyXG4gICAgcDogW1wieFwiLCBcInlcIiwgXCJ6XCJdLFxyXG4gICAgZG86IFdLRi5MZW5ndGhcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBCYXNpYyBzaGFwZXNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElJbnNldEJ1aWxkZXIgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYGluc2V0KClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKkV4YW1wbGU6KlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsaXBQYXRoOiBpbnNldCggY3NzLnBlcmNlbnQoMTUpKVxyXG4gKlxyXG4gKiBjbGlwUGF0aDogaW5zZXQoIDEwLCAxMiwgMTQsIDE2KS5yb3VuZCggOClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBCYXNpYyBTaGFwZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGluc2V0ID0gKG8xOiBFeHRlbmRlZDxDc3NMZW5ndGg+LCBvMj86IEV4dGVuZGVkPENzc0xlbmd0aD4sXHJcbiAgICBvMz86IEV4dGVuZGVkPENzc0xlbmd0aD4sIG80PzogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElJbnNldEJ1aWxkZXIgPT5cclxuICAgICh7XHJcbiAgICAgICAgZm46IFwiaW5zZXRcIiwgbzEsIG8yLCBvMywgbzQsXHJcbiAgICAgICAgcm91bmQoIHI6IEV4dGVuZGVkPEJvcmRlclJhZGl1cz4pIHsgdGhpcy5yID0gcjsgcmV0dXJuIHRoaXM7IH1cclxuICAgIH0pO1xyXG5cclxuZmRvLmluc2V0ID0ge1xyXG4gICAgcDogWyBcIm8xXCIsIFwibzJcIiwgXCJvM1wiLCBcIm80XCIsIFtcInJcIiwgdiA9PiBcInJvdW5kIFwiICsgd2tmW1dLRi5Cb3JkZXJSYWRpdXNdKHYpXSBdLFxyXG4gICAgZG86IFdLRi5MZW5ndGgsXHJcbiAgICBzOiBcIiBcIlxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElDaXJjbGVCdWlsZGVyIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBjaXJjbGUoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAqRXhhbXBsZToqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xpcFBhdGg6IGNpcmNsZSggMTAwKVxyXG4gKlxyXG4gKiBjbGlwUGF0aDogY2lyY2xlKCAxMDApLmF0KCBbXCJjZW50ZXJcIiwgY3NzLnBlcmNlbnQoMzApXSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBCYXNpYyBTaGFwZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNpcmNsZSA9IChyPzogU2hhcGVSYWRpdXMpOiBJQ2lyY2xlQnVpbGRlciA9PlxyXG4gICAgKHtcclxuICAgICAgICBmbjogXCJjaXJjbGVcIiwgcixcclxuICAgICAgICBhdCggcG9zOiBFeHRlbmRlZDxDc3NQb3NpdGlvbj4pIHsgdGhpcy5wb3MgPSBwb3M7IHJldHVybiB0aGlzOyB9XHJcbiAgICB9KTtcclxuXHJcbmZkby5jaXJjbGUgPSB7XHJcbiAgICBwOiBbIFtcInJcIiwgV0tGLkxlbmd0aF0sIFtcInBvc1wiLCBXS0YuQXRQb3NpdGlvbl0gXSxcclxuICAgIHM6IFwiIFwiXHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSUVsbGlwc2VCdWlsZGVyIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBlbGxpcHNlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKkV4YW1wbGU6KlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsaXBQYXRoOiBlbGxpcHNlKCkuYXQoIFtcInRvcFwiLCBcIjUwJVwiXSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBCYXNpYyBTaGFwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2UoKTogSUVsbGlwc2VCdWlsZGVyO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSUVsbGlwc2VCdWlsZGVyIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBlbGxpcHNlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKkV4YW1wbGU6KlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsaXBQYXRoOiBlbGxpcHNlKCAxMDAsIDUwKVxyXG4gKlxyXG4gKiBjbGlwUGF0aDogZWxsaXBzZSggMTAwLCA1MCkuYXQoIFtcImNlbnRlclwiLCBjc3MucGVyY2VudCgzMCldKVxyXG4gKiBgYGBcclxuICpcclxuICogQGNhdGVnb3J5IEJhc2ljIFNoYXBlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZWxsaXBzZSggcng6IFNoYXBlUmFkaXVzLCByeTogU2hhcGVSYWRpdXMpOiBJRWxsaXBzZUJ1aWxkZXI7XHJcblxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5leHBvcnQgZnVuY3Rpb24gZWxsaXBzZSgpOiBJRWxsaXBzZUJ1aWxkZXJcclxue1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmbjogXCJlbGxpcHNlXCIsIHJ4OiBhcmd1bWVudHNbMF0sIHJ5OiBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgYXQoIHBvczogRXh0ZW5kZWQ8Q3NzUG9zaXRpb24+KSB7IHRoaXMucG9zID0gcG9zOyByZXR1cm4gdGhpczsgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mZG8uZWxsaXBzZSA9IHtcclxuICAgIHA6IFsgXCJyeFwiLCBcInJ5XCIsIFtcInBvc1wiLCBXS0YuQXRQb3NpdGlvbl0gXSxcclxuICAgIGRvOiBXS0YuTGVuZ3RoLFxyXG4gICAgczogXCIgXCJcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElQb2x5Z29uIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBwb2x5Z29uKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKkV4YW1wbGU6KlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsaXBQYXRoOiBjc3MucG9seWdvbiggWzAsMTAwXSwgWzUwLDBdLCBbMTAwLDEwMF0pXHJcbiAqXHJcbiAqIGNsaXBQYXRoOiBjc3MucG9seWdvbiggWzAsMTAwXSwgWzUwLDBdLCBbMTAwLDEwMF0pLmZpbGwoIFwiZXZlbm9kZFwiKVxyXG4gKiBgYGBcclxuICpcclxuICogQGNhdGVnb3J5IEJhc2ljIFNoYXBlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcG9seWdvbiA9ICguLi5wb2ludHM6IENzc1BvaW50W10pOiBJUG9seWdvbkJ1aWxkZXIgPT5cclxuICAgICh7XHJcbiAgICAgICAgZm46IFwicG9seWdvblwiLCBwb2ludHM6IHBvaW50cyA/PyBbXSxcclxuICAgICAgICBhZGQoIC4uLnBvaW50czogQ3NzUG9pbnRbXSkgeyB0aGlzLnBvaW50cy5wdXNoKCAuLi5wb2ludHMpOyByZXR1cm4gdGhpczsgfSxcclxuICAgICAgICBmaWxsKCBydWxlOiBGaWxsUnVsZSkgeyB0aGlzLnJ1bGUgPSBydWxlOyByZXR1cm4gdGhpczsgfVxyXG4gICAgfSk7XHJcblxyXG5mZG8ucG9seWdvbiA9IFtcclxuICAgIFwicnVsZVwiLFxyXG4gICAgW1wicG9pbnRzXCIsIHsgaXRlbTogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLCBzZXA6IFwiLFwifV0sXHJcbl1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVBhdGhCdWlsZGVyIG9iamVjdCB0aGF0IGFsbG93cyBidWlsZGluZyBhIENTUyBwYXRoLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgQmFzaWMgU2hhcGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBwYXRoID0gKGZpbGxSdWxlPzogRmlsbFJ1bGUpOiBJUGF0aEJ1aWxkZXIgPT4gbmV3IFBhdGhCdWlsZGVyKCBmaWxsUnVsZSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgSVBhdGhCdWlsZGVyIGludGVyZmFjZSByZXByZXNlbnRzIHRoZSBvYmplY3QgdGhhdCBhY2N1bXVsYXRlcyBwYXRoIGNvbW1hbmRzIHRoYXQgYXJlIHRoZW5cclxuICogY29udmVydGVkIHRvIGEgc3RyaW5nIHBhcmFtZXRlciBvZiB0aGUgQ1NTIGBwYXRoKClgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgUGF0aEJ1aWxkZXIgaW1wbGVtZW50cyBJUGF0aEJ1aWxkZXJcclxue1xyXG4gICAgZm46IFwicGF0aFwiID0gXCJwYXRoXCI7XHJcbiAgICBydWxlPzogRmlsbFJ1bGU7XHJcbiAgICBpdGVtczogUGF0aENvbW1hbmRbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciggcnVsZT86IEZpbGxSdWxlKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkcyB0aGUgZ2l2ZW4gY29tbWFuZCBhbmQgcGFyYW1ldGVycyB0byB0aGUgcGF0aC5cclxuICAgIHB1YmxpYyBhZGQoIGNvbW1hbmQ6IHN0cmluZywgcGFyYW1zPzogUGF0aENvbW1hbmRQYXJhbVtdKTogdGhpc1xyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCggW2NvbW1hbmQsIHBhcmFtc10pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBNKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJNXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyBtKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJtXCIsIHBhcmFtcyk7IH1cclxuXHJcbiAgICBwdWJsaWMgTCggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwiTFwiLCBwYXJhbXMpOyB9XHJcbiAgICBwdWJsaWMgbCggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwibFwiLCBwYXJhbXMpOyB9XHJcblxyXG4gICAgcHVibGljIEgoIC4uLnBhcmFtczogbnVtYmVyW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcIkhcIiwgcGFyYW1zKTsgfVxyXG4gICAgcHVibGljIGgoIC4uLnBhcmFtczogbnVtYmVyW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcImhcIiwgcGFyYW1zKTsgfVxyXG5cclxuICAgIHB1YmxpYyBWKCAuLi5wYXJhbXM6IG51bWJlcltdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJWXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyB2KCAuLi5wYXJhbXM6IG51bWJlcltdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJ2XCIsIHBhcmFtcyk7IH1cclxuXHJcbiAgICBwdWJsaWMgQyggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcIkNcIiwgcGFyYW1zKTsgfVxyXG4gICAgcHVibGljIGMoIC4uLnBhcmFtczogW251bWJlcixudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJjXCIsIHBhcmFtcyk7IH1cclxuXHJcbiAgICBwdWJsaWMgUyggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJTXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyBzKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcInNcIiwgcGFyYW1zKTsgfVxyXG5cclxuICAgIHB1YmxpYyBRKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcIlFcIiwgcGFyYW1zKTsgfVxyXG4gICAgcHVibGljIHEoIC4uLnBhcmFtczogW251bWJlcixudW1iZXIsbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwicVwiLCBwYXJhbXMpOyB9XHJcblxyXG4gICAgcHVibGljIFQoIC4uLnBhcmFtczogW251bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcIlRcIiwgcGFyYW1zKTsgfVxyXG4gICAgcHVibGljIHQoIC4uLnBhcmFtczogW251bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcInRcIiwgcGFyYW1zKTsgfVxyXG5cclxuICAgIHB1YmxpYyBBKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyLG51bWJlciwwfDEsMHwxLG51bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcIkFcIiwgcGFyYW1zKTsgfVxyXG4gICAgcHVibGljIGEoIC4uLnBhcmFtczogW251bWJlcixudW1iZXIsbnVtYmVyLDB8MSwwfDEsbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwiYVwiLCBwYXJhbXMpOyB9XHJcblxyXG4gICAgcHVibGljIHooKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJ6XCIpOyB9XHJcbn1cclxuXHJcbmZkby5wYXRoID0gWyBcInJ1bGVcIiwgW1wiaXRlbXNcIiwgKHY6IFBhdGhDb21tYW5kW10pID0+IGBcIiR7YTJzKHYpfVwiYF0gXVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJUmF5IG9iamVjdCByZXByZXNlbnRpbmcgaW52b2NhdGlvbiBvZiB0aGUgYHJheSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBCYXNpYyBTaGFwZVxyXG4gKi9cclxuIGV4cG9ydCBjb25zdCByYXkgPSAoYW5nbGU6IEV4dGVuZGVkPENzc0FuZ2xlPiwgc2l6ZT86IEV4dGVuZGVkPEV4dGVudEtleXdvcmQgfCBDc3NMZW5ndGg+LFxyXG4gICAgY29udGFpbj86IGJvb2xlYW4pOiBJUmF5RnVuYyA9PiAoeyBmbjogXCJyYXlcIiwgYW5nbGUsIHNpemUsIGNvbnRhaW4gfSk7XHJcblxyXG5mZG8ucmF5ID0ge1xyXG4gICAgcDogW1xyXG4gICAgICAgIFtcImFuZ2xlXCIsIFdLRi5BbmdsZV0sXHJcbiAgICAgICAgW1wic2l6ZVwiLCBXS0YuTGVuZ3RoXSxcclxuICAgICAgICBbXCJjb250YWluXCIsICh2OiBib29sZWFuKSA9PiAodiA/IFwiY29udGFpblwiIDogXCJcIildXHJcbiAgICBdLFxyXG4gICAgczogXCIgXCJcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBHcmlkc1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuIC8qKlxyXG4gKiBSZXR1cm5zIGFuIElNaW5NYXggZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgbWlubWF4KClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IEdyaWRcclxuICovXHJcbmV4cG9ydCBjb25zdCBtaW5tYXggPSAobWluOiBHcmlkVHJhY2tTaXplLCBtYXg6IEdyaWRUcmFja1NpemUpOiBJTWluTWF4RnVuYyA9PlxyXG4gICAgKHsgZm46IFwibWlubWF4XCIsIG1pbiwgbWF4IH0pO1xyXG5cclxuZmRvLm1pbm1heCA9IFsgW1wibWluXCIsIFdLRi5MZW5ndGhdLCBbXCJtYXhcIiwgV0tGLkxlbmd0aF0gXVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJUmVwZWF0IGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHJlcGVhdCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBHcmlkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVwZWF0ID0gKGNvdW50OiBFeHRlbmRlZDxDc3NOdW1iZXI+IHwgXCJhdXRvLWZpbGxcIiB8IFwiYXV0by1maXRcIixcclxuICAgIC4uLnRyYWNrczogR3JpZFRyYWNrW10pOiBJUmVwZWF0RnVuYyA9PiAoeyBmbjogXCJyZXBlYXRcIiwgY291bnQsIHRyYWNrcyB9KTtcclxuXHJcbmZkby5yZXBlYXQgPSBbIFwiY291bnRcIiwgW1widHJhY2tzXCIsIHsgaXRlbTogV0tGLkdyaWRUcmFjayB9XSBdXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElHcmlkU3BhbkZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgc3BhbmAgZXhwcmVzc2lvbiBmb3IgZ3JpZCBsYXlvdXRzLiBJZiB0aGUgZmlyc3RcclxuICogcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGUgc2Vjb25kIHBhcmFtZXRlciAoaWYgZGVmaW5lZCkgbXVzdCBiZSBhIG5hbWU7IGlmIHRoZSBmaXJzdCBwYXJhbWV0ZXJcclxuICogaXMgYSBuYW1lLCB0aGUgc2Vjb25kIHBhcmFtZXRlciAoaWYgZGVmaW5lZCkgbXVzdCBiZSBhIG51bWJlci5cclxuICpcclxuICogQGNhdGVnb3J5IEdyaWRcclxuICovXHJcbmV4cG9ydCBjb25zdCBzcGFuID0gKHAxOiBFeHRlbmRlZDxHcmlkTGluZUNvdW50T3JOYW1lPiwgcDI/OiBFeHRlbmRlZDxHcmlkTGluZUNvdW50T3JOYW1lPik6IElHcmlkU3BhbkZ1bmMgPT5cclxuICAgICh7IGZuOiBcInNwYW5cIiwgcDEsIHAyIH0pO1xyXG5cclxuZmRvLnNwYW4gPSAodjogSUdyaWRTcGFuRnVuYykgPT4gbXYycyggW1wic3BhblwiLCB2LnAxLCB2LnAyXSlcclxuXHJcblxyXG5cclxuIiwi77u/aW1wb3J0IHtNZWRpYVN0YXRlbWVudCwgU3VwcG9ydHNTdGF0ZW1lbnR9IGZyb20gXCIuL01lZGlhVHlwZXNcIjtcclxuaW1wb3J0IHtTdHlsZXNldCwgRXh0ZW5kZWRJU3R5bGVzZXQsIFN0cmluZ1N0eWxlc2V0LCBJU3R5bGVzZXR9IGZyb20gXCIuL1N0eWxlc2V0c1wiXHJcbmltcG9ydCB7c3Aycywgc19yZWdpc3RlclNQLCBzMnNzLCBzMnN9IGZyb20gXCIuLi9pbXBsL1N0eWxlSW1wbFwiXHJcbmltcG9ydCB7Z2V0QWN0aXZhdG9yfSBmcm9tIFwiLi4vaW1wbC9TY2hlZHVsaW5nSW1wbFwiO1xyXG5pbXBvcnQge21lZGlhMnMsIHN1cHBvcnRzMnN9IGZyb20gXCIuLi9pbXBsL01pc2NJbXBsXCI7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBTdHlsZXNldCBtYW5pcHVsYXRpb25cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgdG9cclxuICogc3RyaW5nLiBUaGUgYHJlZ2lzdGVyU3R5bGVQcm9wZXJ0eWAgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIGFmdGVyIGFkZGluZyB0aGUgcHJvcGVydHkgdG8gdGhlXHJcbiAqIFtbSVN0eWxlc2V0XV0gaW50ZXJmYWNlIHZpYSB0aGUgbW9kdWxlIGF1Z21lbnRhdGlvbiB0ZWNobmlxdWUgaWYgdGhlIGNvbnZlcnNpb24gdG8gc3RyaW5nXHJcbiAqIHJlcXVpcmVzIG5vbi1zdGFuZGFyZCBvcGVyYXRpb25zLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGZvciBwcm9wZXRpZXMgd2hvc2VcclxuICogdmFsdWVzIG9ubHkgaW5jbHVkZSBudW1iZXJzLCBzdHJpbmdzLCBmdW5jdGlvbnMgcmV0dXJuaW5nIGEgc3RyaW5nLCBvYmplY3RzIHdob3NlIGB0b1N0cmluZ2BcclxuICogbWV0aG9kIHByb2R1Y2VzIHRoZSBuZWNlc3Nhcnkgc3RyaW5nIG9yIGFycmF5cyBvZiB0aGUgYWJvdmUgdHlwZXMuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yIHN0eWxlIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IHlldCBzdXBwb3J0ZWQgYnkgTWltY3NzLiBUaGlzIGlzXHJcbiAqIGFsc28gdGhlIHdheSB0byBzdXBwb3J0IHByb3BlcnRpZXMgd2l0aCB2ZW5kb3IgcHJlZml4ZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJTdHlsZVByb3BlcnR5ID0gKG5hbWU6IHN0cmluZywgdG9TdHJpbmdGdW5jOiAodjogYW55KSA9PiBzdHJpbmcpOiBib29sZWFuID0+XHJcbiAgICBzX3JlZ2lzdGVyU1AoIG5hbWUsIHRvU3RyaW5nRnVuYyk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgdG8gYSBDU1Mgc3RyaW5nLlxyXG4gKiBAcGFyYW0gc3R5bGVQcm9wTmFtZSBTdHlsZSBwcm9wZXJ0eSBuYW1lIHRoYXQgZGV0ZXJtaW5lcyBob3cgdGhlIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICogdG8gYSBDU1MgY29tcGxpYW50IHN0cmluZy5cclxuICogQHBhcmFtIHN0eWxlUHJvcFZhbHVlIFZhbHVlIHRvIGNvbnZlcnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0U3R5bGVQcm9wVmFsdWUgPSA8SyBleHRlbmRzIGtleW9mIElTdHlsZXNldD4oIHN0eWxlUHJvcE5hbWU6IEssXHJcblx0c3R5bGVQcm9wVmFsdWU6IEV4dGVuZGVkSVN0eWxlc2V0W0tdKTogc3RyaW5nID0+IHNwMnMoIHN0eWxlUHJvcE5hbWUsIHN0eWxlUHJvcFZhbHVlKTtcclxuXHJcblxyXG5cclxuLy8gU2V0cyBzdHlsZSBwcm9wZXJ0eSBvbiBIVE1MIG9yIFNWRyBlbGVtZW50XHJcbmNvbnN0IHNldEVsZW1lbnRTdHlsZVByb3AgPSA8SyBleHRlbmRzIGtleW9mIElTdHlsZXNldD4oIGVsbTogRWxlbWVudENTU0lubGluZVN0eWxlLCBuYW1lOiBLLFxyXG4gICAgdmFsdWU6IEV4dGVuZGVkSVN0eWxlc2V0W0tdLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZCA9PlxyXG4gICAgZ2V0QWN0aXZhdG9yKHNjaGVkdWxlclR5cGUpLnVwZGF0ZVN0eWxlKCBlbG0sIG5hbWUsIHNwMnMoIG5hbWUsIHZhbHVlKSwgZmFsc2UpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogU2V0cyB2YWx1ZXMgb2YgdGhlIHN0eWxlIHByb3BlcnRpZXMgZnJvbSB0aGUgZ2l2ZW4gU3R5bGVzZXQgb2JqZWN0IHRvIHRoZSBgc3R5bGVgIGF0dHJpYnV0ZVxyXG4gKiBvZiB0aGUgZ2l2ZW4gSFRNTCBlbGVtZW50LlxyXG4gKiBAcGFyYW0gZWxtIEhUTUwvU1ZHIGVsZW1lbnQgd2hvc2Ugc3R5bGVzIHdpbGwgYmUgc2V0LlxyXG4gKiBAcGFyYW0gc3R5bGVzZXQgU3R5bGVzZXQgb2JqZWN0IHdoaWNoIHByb3ZpZGVzIHZhbHVlcyBmb3Igc3R5bGUgcHJvcGVydGllcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXRFbGVtZW50U3R5bGUgPSAoZWxtOiBFbGVtZW50Q1NTSW5saW5lU3R5bGUsIHN0eWxlc2V0OiBTdHlsZXNldCB8IG51bGwgfCB1bmRlZmluZWQsXHJcblx0c2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQgPT5cclxuICAgIHNldEVsZW1lbnRTdHJpbmdTdHlsZSggZWxtLCBzdHlsZXNldCA/IHN0eWxlc2V0VG9TdHJpbmdTdHlsZXNldChzdHlsZXNldCkgOiBudWxsLCBzY2hlZHVsZXJUeXBlKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFNldHMgdmFsdWVzIG9mIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGdpdmVuIFN0cmluZ1N0eWxlc2V0IG9iamVjdCB0byB0aGUgYHN0eWxlYCBhdHRyaWJ1dGVcclxuICogb2YgdGhlIGdpdmVuIEhUTUwgZWxlbWVudC5cclxuICogQHBhcmFtIGVsbSBIVE1ML1NWRyBlbGVtZW50IHdob3NlIHN0eWxlcyB3aWxsIGJlIHNldC5cclxuICogQHBhcmFtIHN0eWxlc2V0IFtbU3RyaW5nU3R5bGVzZXRdXSBvYmplY3Qgd2hpY2ggcHJvdmlkZXMgdmFsdWVzIGZvciBzdHlsZSBwcm9wZXJ0aWVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldEVsZW1lbnRTdHJpbmdTdHlsZSA9IChlbG06IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgc3R5bGVzZXQ6IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuXHRzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZCA9PlxyXG4gICAgZ2V0QWN0aXZhdG9yKHNjaGVkdWxlclR5cGUpLnVwZGF0ZVN0eWxlKCBlbG0sIG51bGwsIHN0eWxlc2V0LCBmYWxzZSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBbW1N0eWxlc2V0XV0gdG8gYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBzdHlsZXNldFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0eWxlc2V0VG9TdHJpbmcgPSAoc3R5bGVzZXQ6IFN0eWxlc2V0KTogc3RyaW5nID0+IHMycyggc3R5bGVzZXQpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIFtbU3R5bGVzZXRdXSBvYmplY3QgaW50byBhbiBvYmplY3QsIHdoZXJlIGVhY2ggU3R5bGVzZXQncyBwcm9wZXJ0eSBpc1xyXG4gKiBjb252ZXJ0ZWQgdG8gaXRzIHN0cmluZyB2YWx1ZS5cclxuICogQHBhcmFtIHN0eWxlc2V0XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3R5bGVzZXRUb1N0cmluZ1N0eWxlc2V0ID0gKHN0eWxlc2V0OiBTdHlsZXNldCk6IFN0cmluZ1N0eWxlc2V0ID0+IHMyc3MoIHN0eWxlc2V0KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBTdHlsZXNldCBvYmplY3RzIGJ5IGNvbnZlcnRpbmcgc3R5bGUgcHJvcGVydGllcyB0byBzdHJpbmdzIGFuZCByZXR1cm5zIGFuIG9iamVjdFxyXG4gKiB0aGF0IGNvbnRhaW5zIHN0cmluZyB2YWx1ZXMgb2YgcHJvcGVydGllcyB0aGF0IHdlcmUgbmV3IG9yIGhhdmUgZGlmZmVyZW50IHZhbHVlcyBpbiB0aGUgbmV3XHJcbiAqIHN0eWxlc2V0IGFuZCB1bmRlZmluZWQgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gdGhlIG9sZCBzdHlsZXNldCBidXQgZG9uJ3QgZXhpc3RcclxuICogaW4gdGhlIG5ldyBvbmUuXHJcbiAqIEBwYXJhbSBvbGRTdHlsZXNldFxyXG4gKiBAcGFyYW0gbmV3U3R5bGVzZXRcclxuICogQHJldHVybnMgU3RyaW5nU3R5bGVzZXQgb2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IGhhdmUgZGlmZmVyZW50IHZhbHVlcyBpbiB0aGUgb2xkIGFuZCBuZXdcclxuICogc3R5bGVzZXRzLiBQcm9wZXJ0aWVzIHRoYXQgZXhpc3RlZCBpbiB0aGUgb2xkIGJ1dCBkb24ndCBleGlzdCBpbiB0aGUgbmV3IHN0eWxlc2V0LCB3aWxsIGhhdmVcclxuICogdGhlaXIgdmFsdWVzIHNldCB0byBgXCJ1bnNldFwiYC4gSWYgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIHN0eWxlc2V0cyBudWxsIGlzXHJcbiAqIHJldHVybmVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRpZmZTdHlsZXNldHMgPSAob2xkU3R5bGVzZXQ6IFN0eWxlc2V0LCBuZXdTdHlsZXNldDogU3R5bGVzZXQpOiBTdHJpbmdTdHlsZXNldCB8IG51bGwgPT5cclxue1xyXG5cdGlmICghb2xkU3R5bGVzZXQgJiYgIW5ld1N0eWxlc2V0KVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0ZWxzZSBpZiAoIW9sZFN0eWxlc2V0KVxyXG5cdFx0cmV0dXJuIHMyc3MoIG5ld1N0eWxlc2V0KTtcclxuXHRlbHNlIGlmICghbmV3U3R5bGVzZXQpXHJcblx0XHRyZXR1cm4gczJzcyggb2xkU3R5bGVzZXQpO1xyXG5cclxuXHQvLyBmaXJzdCBjb252ZXJ0IGJvdGggc3R5bGVzZXRzIHRvIHRoZWlyIHN0cmluZyB2ZXJzaW9uc1xyXG5cdGxldCBvbGRTdHJpbmdTdHlsZXNldCA9XHRzMnNzKCBvbGRTdHlsZXNldCk7XHJcblx0bGV0IG5ld1N0cmluZ1N0eWxlc2V0ID1cdHMyc3MoIG5ld1N0eWxlc2V0KTtcclxuXHJcblx0bGV0IHVwZGF0ZVZhbDogU3RyaW5nU3R5bGVzZXQgfCBudWxsID0gbnVsbDtcclxuXHJcblx0Ly8gbG9vcCBvdmVyIGtleXMgaW4gdGhlIG9sZCBzdHlsZSBvYmplY3QgYW5kIGZpbmQgdGhvc2UgdGhhdCBhcmUgbm90IGluIHRoZSBuZXcgb25lLiBUaGVzZVxyXG5cdC8vIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHRmb3IoIGxldCBrZXkgaW4gb2xkU3RyaW5nU3R5bGVzZXQpXHJcblx0e1xyXG5cdFx0bGV0IG5ld1N0cmluZ1ZhbCA9IG5ld1N0cmluZ1N0eWxlc2V0W2tleV07XHJcblx0XHRpZiAobmV3U3RyaW5nVmFsID09IG51bGwpXHJcblx0XHR7XHJcblx0XHRcdHVwZGF0ZVZhbCA9IHVwZGF0ZVZhbCB8fCB7fTtcclxuXHRcdFx0dXBkYXRlVmFsW2tleV0gPSBcInVuc2V0XCI7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdGxldCBvbGRTdHJpbmdWYWwgPSBvbGRTdHJpbmdTdHlsZXNldFtrZXldO1xyXG5cdFx0XHRpZiAob2xkU3RyaW5nVmFsICE9PSBuZXdTdHJpbmdWYWwpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR1cGRhdGVWYWwgPSB1cGRhdGVWYWwgfHwge307XHJcblx0XHRcdFx0dXBkYXRlVmFsW2tleV0gPSBuZXdTdHJpbmdWYWw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGxvb3Agb3ZlciBrZXlzIGluIHRoZSBuZXcgc3R5bGUgb2JqZWN0IGFuZCBmaW5kIHRob3NlIHRoYXQgYXJlIG5vdCBpbiB0aGUgb2xkIG9uZS4gVGhlc2VcclxuXHQvLyB3aWxsIGJlIGFkZGVkLlxyXG5cdGZvciggbGV0IGtleSBpbiBuZXdTdHJpbmdTdHlsZXNldClcclxuXHR7XHJcblx0XHRsZXQgb2xkU3RyaW5nVmFsID0gb2xkU3RyaW5nU3R5bGVzZXRba2V5XTtcclxuXHRcdGlmIChvbGRTdHJpbmdWYWwgPT0gbnVsbClcclxuXHRcdHtcclxuXHRcdFx0dXBkYXRlVmFsID0gdXBkYXRlVmFsIHx8IHt9O1xyXG5cdFx0XHR1cGRhdGVWYWxba2V5XSA9IG5ld1N0cmluZ1N0eWxlc2V0W2tleV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdXBkYXRlVmFsO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBBZGRpbmcgbWV0aG9kcyB0byBzZXZlcmFsIERPTSBwcm90b3R5cGVzIHVzaW5nIG1vZHVsZSBhdWdtZW50YXRpb25cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5kZWNsYXJlIGdsb2JhbFxyXG57XHJcbiAgICBpbnRlcmZhY2UgRWxlbWVudENTU0lubGluZVN0eWxlXHJcbiAgICB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgUHJvcGVydHkgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWUgdG8gc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSBzY2hlZHVsZXJUeXBlIFNjaGVkdWxlciBpZGVudGlmaWVyLiBJZiBvbWl0dGVkLCB0aGUgY3VycmVudCBkZWZhdWx0IHNjaGVkdWxlclxyXG4gICAgICAgICAqIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRTdHlsZVByb3A8SyBleHRlbmRzIGtleW9mIElTdHlsZXNldD4oIG5hbWU6IEssIHZhbHVlOiBFeHRlbmRlZElTdHlsZXNldFtLXSxcclxuICAgICAgICAgICAgc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1lcmdlcyBvciByZXBsYWNlcyB0aGUgZWxlbWVudCdzIHN0eWxlcyB3aXRoIHRoZSBnaXZlbiBzdHlsZXNldC5cclxuICAgICAgICAgKiBAcGFyYW0gc3R5bGVzZXQgU3R5bGVzZXQgdG8gc2V0IG9yIHJlcGxhY2VcclxuICAgICAgICAgKiBAcGFyYW0gcmVwbGFjZSBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgbmV3IHN0eWxlc2V0IHNob3VsZCBjb21wbGV0ZWx5IHJlcGxhY2UgdGhlXHJcbiAgICAgICAgICogZXhpc3RpbmcgZWxlbWVudCBzdHlsZXMgd2l0aCB0aGUgbmV3IHN0eWxlcyAodHJ1ZSkgb3IgbWVyZ2UgdGhlIG5ldyBzdHlsZXMgd2l0aCB0aGVcclxuICAgICAgICAgKiBleGlzdGluZyBvbmVzIChmYWxzZSkuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxyXG4gICAgICAgICAqIEBwYXJhbSBzY2hlZHVsZXJUeXBlIFNjaGVkdWxlciBpZGVudGlmaWVyLiBJZiBvbWl0dGVkLCB0aGUgY3VycmVudCBkZWZhdWx0IHNjaGVkdWxlclxyXG4gICAgICAgICAqIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRTdHlsZXNldCggc3R5bGVzZXQ6IFN0eWxlc2V0LCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZDtcclxuICAgIH1cclxufVxyXG5cclxuLy8gU2V0cyBzdHlsZSBwcm9wZXJ0eSBvbiBIVE1MIG9yIFNWRyBlbGVtZW50XHJcbkhUTUxFbGVtZW50LnByb3RvdHlwZS5zZXRTdHlsZVByb3AgPSBTVkdFbGVtZW50LnByb3RvdHlwZS5zZXRTdHlsZVByb3AgPVxyXG4gICAgZnVuY3Rpb24gPEsgZXh0ZW5kcyBrZXlvZiBJU3R5bGVzZXQ+KCBuYW1lOiBLLCB2YWx1ZTogRXh0ZW5kZWRJU3R5bGVzZXRbS10sXHJcbiAgICAgICAgc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWRcclxue1xyXG4gICAgc2V0RWxlbWVudFN0eWxlUHJvcCggdGhpcywgbmFtZSwgdmFsdWUsIHNjaGVkdWxlclR5cGUpO1xyXG59XHJcblxyXG4vLyBTZXRzIHN0eWxlc2V0IG9uIEhUTUwgb3IgU1ZHIGVsZW1lbnRcclxuSFRNTEVsZW1lbnQucHJvdG90eXBlLnNldFN0eWxlc2V0ID0gU1ZHRWxlbWVudC5wcm90b3R5cGUuc2V0U3R5bGVzZXQgPVxyXG4gICAgZnVuY3Rpb24oIHN0eWxlc2V0OiBTdHlsZXNldCwgc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWRcclxue1xyXG4gICAgc2V0RWxlbWVudFN0eWxlKCB0aGlzLCBzdHlsZXNldCwgc2NoZWR1bGVyVHlwZSk7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEBtZWRpYSBhbmQgQHN1cHBvcnRzIHF1ZXJpZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBtZWRpYSBxdWVyeSB2YWx1ZSB0byB0aGUgQ1NTIG1lZGlhIHF1ZXJ5IHN0cmluZy4gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZFxyXG4gKiBieSBsaWJyYXJpZXMgdGhhdCBhbGxvdyBzcGVjaWZ5aW5nIFtbTWVkaWFTdGF0ZW1lbnRdXSBmb3IgdGhlIGBtZWRpYWAgYXR0cmlidXRlIG9mIGVsZW1lbnRzXHJcbiAqIHN1Y2ggYXMgYDxsaW5rPmAsIGA8c3R5bGU+YCBhbmQgYDxzb3VyY2U+YFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1lZGlhVG9TdHJpbmcgPSAocXVlcnk6IE1lZGlhU3RhdGVtZW50KTogc3RyaW5nID0+IG1lZGlhMnMoIHF1ZXJ5KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBzdXBwb3J0cyBxdWVyeSB2YWx1ZSB0byB0aGUgQ1NTIHN1cHBvcnRzIHF1ZXJ5IHN0cmluZy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzdXBwb3J0c1RvU3RyaW5nID0gKHF1ZXJ5OiBTdXBwb3J0c1N0YXRlbWVudCk6IHN0cmluZyA9PiBzdXBwb3J0czJzKCBxdWVyeSk7XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7Q3NzU2VsZWN0b3IsIElBdHRyU2VsZWN0b3JGdW5jfSBmcm9tIFwiLi4vYXBpL0NvcmVUeXBlc1wiO1xyXG5pbXBvcnQge2ZkbywgdjJzfSBmcm9tIFwiLi9VdGlsc1wiO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIHNlbGVjdG9yLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VsZWN0b3IycyA9ICh2YWw6IENzc1NlbGVjdG9yKTogc3RyaW5nID0+IHYycyggdmFsLCB7IHNlcDogXCJcIiwgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG5cclxuXHJcblxyXG4vLyBDb252ZXJ0aW5nIGF0dHJpYnV0ZSBzZWxlY3RvciBkZWZpbml0aW9uIHRvIHN0cmluZ1xyXG5mZG9bXCJhdHRyLXNlbFwiXSA9ICh2OiBJQXR0clNlbGVjdG9yRnVuYykgPT4gYFske3YubnMgPyAodHlwZW9mIHYubnMgPT09IFwic3RyaW5nXCIgPyB2Lm5zIDogdi5ucy5wcmVmaXgpICsgXCJ8XCIgOiBcIlwifSR7di5uYW1lfWAgK1xyXG4gICAgKHYudmFsID09IG51bGwgPyBcIl1cIiA6IGAke3Yub3AgPz8gXCI9XCJ9XCIke3YudmFsfVwiJHt2LmNmID8gXCIgXCIgKyB2LmNmIDogXCJcIn1dYClcclxuXHJcblxyXG5cclxuLy8gQ29udmVydGluZyBcIm50aFwiIHBzZXVkbyBjbGFzc2VzIHRvIHN0cmluZ1xyXG5mZG9bXCI6bnRoLWNoaWxkXCJdID0gZmRvW1wiOm50aC1sYXN0LWNoaWxkXCJdID0gZmRvW1wiOm50aC1vZi10eXBlXCJdID0gZmRvW1wiOm50aC1sYXN0LW9mLXR5cGVcIl0gPSBbXHJcbiAgICBbXCJwXCIsIHtcclxuICAgICAgICBhcnI6IFtcclxuICAgICAgICAgICAgdiA9PiB2ICsgXCJuXCIsXHJcbiAgICAgICAgICAgIHYgPT4gIXYgPyBcIlwiIDogdiA+IDAgPyBcIitcIiArIHYgOiBcIi1cIiArIC12XHJcbiAgICAgICAgXSxcclxuICAgICAgICBzZXA6IFwiXCJcclxuICAgIH1dXHJcbl1cclxuXHJcblxyXG5cclxuLy8gLy8gQ29udmVydGluZyBwc2V1ZG8gZW50aXRpZXMgdGhhdCBhY2NlcHQgQ3NzU2VsZWN0b3IgdG8gc3RyaW5nXHJcbi8vIGZkb1tcIjppc1wiXSA9IGZkb1tcIjpoYXNcIl0gPSBmZG9bXCI6aG9zdC1jb250ZXh0XCJdID0gZmRvW1wiOm5vdFwiXSA9IGZkb1tcIjp3aGVyZVwiXSA9IGZkb1tcIjo6c2xvdHRlZFwiXSA9IFtcclxuLy8gICAgIFtcInBcIiwgc2VsZWN0b3Iyc11cclxuLy8gICAgIC8vIFtcInBcIiwge3NlcDogXCIsXCIsIHJlY3Vyc2l2ZTogdHJ1ZX1dXHJcbi8vIF1cclxuXHJcblxyXG5cclxuIiwi77u/aW1wb3J0IHtFeHRlbmRlZEZvbnRGYWNlLCBJRm9udEZhY2V9IGZyb20gXCIuLi9hcGkvRm9udFR5cGVzXCJcclxuaW1wb3J0IHtJTWVkaWFGZWF0dXJlc2V0LCBNZWRpYVF1ZXJ5LCBNZWRpYVN0YXRlbWVudCwgU3VwcG9ydHNRdWVyeSwgU3VwcG9ydHNTdGF0ZW1lbnR9IGZyb20gXCIuLi9hcGkvTWVkaWFUeXBlc1wiO1xyXG5pbXBvcnQge3NwMnN9IGZyb20gXCIuL1N0eWxlSW1wbFwiO1xyXG5pbXBvcnQge2NhbWVsVG9EYXNoLCB2MnMsIGEycywgV0tGLCBWMlNPcHRpb25zLCBkYXNoVG9DYW1lbCwgd2tmLCBwcm9wU2V0MnN9IGZyb20gXCIuL1V0aWxzXCI7XHJcbmltcG9ydCB7RXh0ZW5kZWRDb3VudGVyU3R5bGVzZXQsIElDb3VudGVyU3R5bGVzZXR9IGZyb20gXCIuLi9hcGkvQ291bnRlclR5cGVzXCI7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgQG1lZGlhIHJ1bGUuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBtZWRpYSBxdWVyeSBvYmplY3QgdG8gdGhlIENTUyBtZWRpYSBxdWVyeSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtZWRpYTJzID0gKHN0YXRlbWVudDogTWVkaWFTdGF0ZW1lbnQpOiBzdHJpbmcgPT5cclxuICAgIHYycyggc3RhdGVtZW50LCB7XHJcbiAgICAgICAgYW55OiBtZWRpYVF1ZXJ5MnMsXHJcbiAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgfSlcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbWVkaWEgcXVlcnkgb2JqZWN0IHRvIHRoZSBDU1MgbWVkaWEgcXVlcnkgc3RyaW5nXHJcbiAqL1xyXG5jb25zdCBtZWRpYVF1ZXJ5MnMgPSAocXVlcnk6IE1lZGlhUXVlcnkpOiBzdHJpbmcgPT5cclxuICAgIHByb3BTZXQycyggcXVlcnksIG1lZGlhRmVhdHVyZUluZm9zLCB7XHJcbiAgICAgICAgc2VwYXJhdG9yOiBcIiBhbmQgXCIsXHJcbiAgICAgICAgcHJvcEZ1bmM6IG1lZGlhRmVhdHVyZTJzLFxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIG1lZGlhIGZlYXR1cmUgdG8gdGhlIENTUyBtZWRpYSBxdWVyeSBzdHJpbmdcclxuICovXHJcbmNvbnN0IG1lZGlhRmVhdHVyZTJzID0gKGRhc2hOYW1lOiBzdHJpbmcsIGNhbWVsTmFtZTogc3RyaW5nLCB2YWw6IGFueSwgb3B0aW9uczogVjJTT3B0aW9ucyk6IHN0cmluZyA9PlxyXG57XHJcbiAgICBpZiAodmFsID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgLy8gaWYgZGVmYXVsdFZhbHVlIGlzIGRlZmluZWQgYW5kIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBlcXVhbCB0byBpdCwgbm8gdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkLlxyXG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IG1lZGlhRmVhdHVyZURlZmF1bHRWYWx1ZXMuZ2V0KGNhbWVsTmFtZSk7XHJcbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsID09PSBkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgcmV0dXJuIGRhc2hOYW1lO1xyXG5cclxuICAgIGxldCBpc1JhbmdlID0gcmFuZ2VNZWRpYUZlYXR1cmVzLmhhcyggY2FtZWxOYW1lKTtcclxuICAgIGlmIChpc1JhbmdlICYmIEFycmF5LmlzQXJyYXkoIHZhbCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtcIm1pbi1cIiArIGRhc2hOYW1lfToke3YycyggdmFsWzBdLCBvcHRpb25zKX0pIGFuZCAoJHtcIm1heC1cIiArIGRhc2hOYW1lfToke3YycyggdmFsWzFdLCBvcHRpb25zKX0pYDtcclxuXHJcbiAgICAgICAgLy8gdGhpcyBzeW50YXggaXMgbm90IHdpZGVseSBzdXBwb3J0ZWQgeWV0XHJcbiAgICAgICAgLy8gcmV0dXJuIGAke3MxfSA8PSAke2Rhc2hOYW1lfSA8PSAke3MyfWA7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGAoJHtkYXNoTmFtZX06JHt2MnMoIHZhbCwgb3B0aW9ucyl9KWA7XHJcbn1cclxuXHJcblxyXG5cclxuY29uc3QgbWVkaWFGZWF0dXJlSW5mb3M6IHsgW0sgaW4ga2V5b2YgSU1lZGlhRmVhdHVyZXNldF0/OiBWMlNPcHRpb25zIH0gPVxyXG57XHJcbiAgICBhc3BlY3RSYXRpbzoge1xyXG4gICAgICAgIG51bTogKHY6IG51bWJlcikgPT4gdiArIFwiLzFcIlxyXG4gICAgfSxcclxuICAgIGhlaWdodDogV0tGLkxlbmd0aCxcclxuICAgIG1pbkhlaWdodDogV0tGLkxlbmd0aCxcclxuICAgIG1heEhlaWdodDogV0tGLkxlbmd0aCxcclxuICAgIHJlc29sdXRpb246IFdLRi5SZXNvbHV0aW9uLFxyXG4gICAgbWluUmVzb2x1dGlvbjogV0tGLlJlc29sdXRpb24sXHJcbiAgICBtYXhSZXNvbHV0aW9uOiBXS0YuUmVzb2x1dGlvbixcclxuICAgIHdpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWluV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXhXaWR0aDogV0tGLkxlbmd0aCxcclxufTtcclxuXHJcbi8vIFNldCBvZiBtZWRpYSBmZWF0dXJlcyB0aGF0IGFsbG93IHJhbmdlIG9mIHZhbHVlc1xyXG5jb25zdCByYW5nZU1lZGlhRmVhdHVyZXMgPSBuZXcgU2V0PHN0cmluZz4oW1wiYXNwZWN0UmF0aW9cIiwgXCJjb2xvclwiLCBcImNvbG9ySW5kZXhcIiwgXCJoZWlnaHRcIiwgXCJtb25vY2hyb21lXCIsIFwicmVzb2x1dGlvblwiLCBcIndpZHRoXCJdKTtcclxuXHJcbi8vIE1hcCBvZiBtZWRpYSBmZWF0dXJlcyB0byBkZWZhdWx0IHZhbHVlc1xyXG5jb25zdCBtZWRpYUZlYXR1cmVEZWZhdWx0VmFsdWVzID0gbmV3IE1hcDxzdHJpbmcsYW55PihbXHJcbiAgICBbXCJjb2xvclwiLCAwXSxcclxuICAgIFtcImNvbG9ySW5kZXhcIiwgMF0sXHJcbiAgICBbXCJtb25vY2hyb21lXCIsIDBdXHJcbl0pO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIEBzdXBwb3J0cyBydWxlLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc3VwcG9ydHMgc3RhdGVtZW50IHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24gKi9cclxuZXhwb3J0IGNvbnN0IHN1cHBvcnRzMnMgPSAoc3RhdGVtZW50OiBTdXBwb3J0c1N0YXRlbWVudCk6IHN0cmluZyA9PlxyXG4gICAgdjJzKCBzdGF0ZW1lbnQsIHtcclxuICAgICAgICBhbnk6IHN1cHBvcnRzUXVlcnkycyxcclxuICAgICAgICBzZXA6IFwiIG9yIFwiXHJcbiAgICB9KTtcclxuXHJcbi8qKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc3VwcG9ydHMgcXVlcnkgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbiAqL1xyXG5jb25zdCBzdXBwb3J0c1F1ZXJ5MnMgPSAocXVlcnk6IFN1cHBvcnRzUXVlcnkpOiBzdHJpbmcgPT5cclxuICAgIHYycyggcXVlcnksIHtcclxuICAgICAgICBvYmo6ICh2OiBFeGNsdWRlPFN1cHBvcnRzUXVlcnksc3RyaW5nPikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoIHYpO1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGAoJHtwcm9wTmFtZXMubWFwKCAocHJvcE5hbWUpID0+XHJcbiAgICAgICAgICAgICAgICBgJHtjYW1lbFRvRGFzaChwcm9wTmFtZSl9OiR7c3AycyggcHJvcE5hbWUsIHF1ZXJ5W3Byb3BOYW1lXSl9YCkuam9pbiggXCIpIGFuZCAoXCIpfSlgO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIEBmb250LWZhY2UgcnVsZS5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgZmFjZSBvYmplY3QgdG8gdGhlIENTUyBzdHlsZSBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZm9udEZhY2UycyA9IChmb250ZmFjZTogRXh0ZW5kZWRGb250RmFjZSk6IHN0cmluZyA9PiBwcm9wU2V0MnMoIGZvbnRmYWNlLCBmb250RmFjZVByb3BlcnR5SW5mb3MpO1xyXG5cclxud2tmW1dLRi5Gb250U3R5bGVdID0gdiA9PiB2MnMoIHYsIHtcclxuICAgIG51bTogdiA9PiBgb2JsaXF1ZSAke3drZltXS0YuQW5nbGVdKHYpfWAsXHJcbiAgICBhcnI6IHYgPT4gYG9ibGlxdWUgJHthMnMoIHYsIFdLRi5BbmdsZSl9YFxyXG59KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIE1hcCBvZiBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgVjJTT3B0aW9ucyBvYmplY3RzIGRlc2NyaWJpbmcgY3VzdG9tIGFjdGlvbnMgbmVjZXNzYXJ5IHRvXHJcbiAqIGNvbnZlcnQgdGhlIHByb3BlcnR5IHZhbHVlIHRvIHRoZSBDU1MtY29tcGxpYW50IHN0cmluZy5cclxuICovXHJcbmNvbnN0IGZvbnRGYWNlUHJvcGVydHlJbmZvczogeyBbSyBpbiBrZXlvZiBJRm9udEZhY2VdPzogVjJTT3B0aW9ucyB9ID1cclxue1xyXG4gICAgYXNjZW50T3ZlcnJpZGU6IFdLRi5QZXJjZW50LFxyXG4gICAgZGVzY2VudE92ZXJyaWRlOiBXS0YuUGVyY2VudCxcclxuICAgIGZvbnRTdHJldGNoOiB7IGFueTogV0tGLlBlcmNlbnQgfSxcclxuICAgIGZvbnRTdHlsZTogV0tGLkZvbnRTdHlsZSxcclxuICAgIGZvbnRXZWlnaHQ6IHsgYW55OiBXS0YuTnVtYmVyIH0sXHJcbiAgICBsaW5lR2FwT3ZlcnJpZGU6IFdLRi5QZXJjZW50LFxyXG4gICAgc3JjOiB7XHJcbiAgICAgICAgYW55OiB7XHJcbiAgICAgICAgICAgIG9iajogW1xyXG4gICAgICAgICAgICAgICAgW1wibG9jYWxcIiwgdiA9PiBgbG9jYWwoJHt2fSlgXSxcclxuICAgICAgICAgICAgICAgIFtcInVybFwiLCB2ID0+IGB1cmwoJHt2fSlgXSxcclxuICAgICAgICAgICAgICAgIFtcImZvcm1hdFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW55OiB2ID0+IGBmb3JtYXQoXFxcIiR7dn1cXFwiKWAsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgfSxcclxuICAgIHNpemVBZGp1c3Q6IFdLRi5QZXJjZW50LFxyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgQGNvdW50ZXItc3R5bGUgcnVsZS5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGNvdW50ZXIgc3R5bGVzZXQgcHJvcGVydHkgdG8gdGhlIENTUyBzdHlsZSBzdHJpbmcuIFByb3BlcnR5IG5hbWUgY2FuIGJlIGluXHJcbiAqIGVpdGhlciBkYXNoIG9yIGNhbWVsIGZvcm0uXHJcbiAqL1xyXG4gY29uc3QgY291bnRlclN0eWxlc2V0UHJvcDJzID0gKHByb3BOYW1lOiBzdHJpbmcsIHByb3BWYWw6IGFueSwgaW5jbHVkZU5hbWU/OiBib29sZWFuKTogc3RyaW5nID0+XHJcbiB7XHJcbiAgICAgaWYgKCFwcm9wTmFtZSlcclxuICAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgIC8vIGNvbnZlcnQgdGhlIHZhbHVlIHRvIHN0cmluZyBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gb2JqZWN0IGZvciB0aGUgcHJvcGVydHkgKGlmIGRlZmluZWQpXHJcbiAgICAgbGV0IHN0cmluZ1ZhbHVlID0gdjJzKCBwcm9wVmFsLCBjb3VudGVyU3R5bGVQcm9wZXJ0eUluZm9zW2Rhc2hUb0NhbWVsKHByb3BOYW1lKV0pO1xyXG5cclxuICAgICAvLyBpZiB0aGUgcmVzdWx0aW5nIHN0cmluZyBpcyBlbXB0eSBhbmQgdGhlIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkLCB0aGVuIHdlIHJldHVyblxyXG4gICAgIC8vIFwibmFtZTo7IG90aGVyd2lzZSB3ZSB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgaWYgKCFzdHJpbmdWYWx1ZSAmJiBpbmNsdWRlTmFtZSlcclxuICAgICAgICAgc3RyaW5nVmFsdWUgPSBcIlwiO1xyXG5cclxuICAgICByZXR1cm4gaW5jbHVkZU5hbWUgPyBgJHtjYW1lbFRvRGFzaCggcHJvcE5hbWUpfToke3N0cmluZ1ZhbHVlfWAgOiBzdHJpbmdWYWx1ZTtcclxuIH1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gY291bnRlciBzdHlsZXNldCBvYmplY3QgdG8gdGhlIENTUyBtZWRpYSBxdWVyeSBzdHJpbmdcclxuICovXHJcbiBleHBvcnQgY29uc3QgY291bnRlclN0eWxlc2V0MnMgPSAoY291bnRlclN0eWxlc2V0OiBFeHRlbmRlZENvdW50ZXJTdHlsZXNldCk6IHN0cmluZyA9PlxyXG4ge1xyXG4gICAgaWYgKCFjb3VudGVyU3R5bGVzZXQpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgbGV0IHMgPSBcIlwiO1xyXG5cdGZvciggbGV0IG5hbWUgaW4gY291bnRlclN0eWxlc2V0KVxyXG4gICAgICAgIHMgKz0gY291bnRlclN0eWxlc2V0UHJvcDJzKCBuYW1lLCBjb3VudGVyU3R5bGVzZXRbbmFtZV0sIHRydWUpICsgXCI7XCI7XHJcblxyXG4gICAgcmV0dXJuIHM7XHJcbiB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuIC8qKlxyXG4gKiBNYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gdGhlIFYyU09wdGlvbnMgb2JqZWN0cyBkZXNjcmliaW5nIGN1c3RvbSBhY3Rpb25zIG5lY2Vzc2FyeSB0b1xyXG4gKiBjb252ZXJ0IHRoZSBwcm9wZXJ0eSB2YWx1ZSB0byB0aGUgQ1NTLWNvbXBsaWFudCBzdHJpbmcuXHJcbiAqL1xyXG5jb25zdCBjb3VudGVyU3R5bGVQcm9wZXJ0eUluZm9zOiB7IFtLIGluIGtleW9mIElDb3VudGVyU3R5bGVzZXRdPzogVjJTT3B0aW9ucyB9ID1cclxue1xyXG4gICAgc3lzdGVtOiB7XHJcbiAgICAgICAgbnVtOiB2ID0+IFwiZml4ZWQgXCIgKyB2LFxyXG4gICAgICAgIGFycjogdiA9PiBcImV4dGVuZHMgXCIgKyB2MnModlswXSlcclxuICAgIH0sXHJcbiAgICBuZWdhdGl2ZToge1xyXG4gICAgICAgIGFueTogV0tGLlF1b3RlZFxyXG4gICAgfSxcclxuICAgIHByZWZpeDogV0tGLlF1b3RlZCxcclxuICAgIHN1ZmZpeDogV0tGLlF1b3RlZCxcclxuICAgIHJhbmdlOiB7XHJcbiAgICAgICAgYXJyMjogeyBzZXA6IFwiLFwiIH1cclxuICAgIH0sXHJcbiAgICBwYWQ6IHtcclxuICAgICAgICBpdGVtOiBXS0YuUXVvdGVkXHJcbiAgICB9LFxyXG4gICAgc3ltYm9sczoge1xyXG4gICAgICAgIGl0ZW06IFdLRi5RdW90ZWRcclxuICAgIH0sXHJcbiAgICBhZGRpdGl2ZVN5bWJvbHM6IHtcclxuICAgICAgICBhcnIyOiB7IGl0ZW06IHsgaXRlbTogV0tGLlF1b3RlZCB9LCBzZXA6IFwiLFwiIH0sXHJcbiAgICAgICAgYW55OiBXS0YuUXVvdGVkXHJcbiAgICB9LFxyXG59XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7RXh0ZW5kZWQsIElHZW5lcmljUHJveHksIE9uZU9yTWFueX0gZnJvbSBcIi4uL2FwaS9Db3JlVHlwZXNcIjtcclxuaW1wb3J0IHtcclxuICAgIElOdW1lcmljTWF0aCwgQ3NzTGVuZ3RoLCBDc3NBbmdsZSwgQ3NzVGltZSwgQ3NzUmVzb2x1dGlvbixcclxuICAgIENzc0ZyZXF1ZW5jeSwgQ3NzUG9zaXRpb24sIExlbmd0aFVuaXRzLCBQZXJjZW50VW5pdHMsIEFuZ2xlVW5pdHMsIFRpbWVVbml0cyxcclxuICAgIFJlc29sdXRpb25Vbml0cywgRnJlcXVlbmN5VW5pdHMsIENzc051bWJlciwgQ3NzUGVyY2VudCwgQ3NzUmFkaXVzLCBCb3JkZXJSYWRpdXNcclxufSBmcm9tIFwiLi4vYXBpL051bWVyaWNUeXBlc1wiO1xyXG5pbXBvcnQge2EycywgTnVtYmVyVG9TdHJpbmdGdW5jLCB0YWcycywgdjJzLCB3a2YsIFdLRn0gZnJvbSBcIi4vVXRpbHNcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIE51bWJlcnNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBzaW5nbGUgbnVtZXJpYyB2YWx1ZSB0byBhIENTUyBzdHJpbmcgb3B0aW9uYWxseSBhcHBlbmRpbmcgdW5pdHMgdGhhdCBjYW4gYmUgZGlmZmVyZW50XHJcbiAqIGZvciBpbnRlZ2VyIGFuZCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxyXG4gKiBAcGFyYW0gbiBOdW1iZXIgdG8gY29udmVydCB0byBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSBpbnRVbml0IFVuaXRzIHRvIGFwcGVuZCBpZiB0aGUgbnVtYmVyIGlzIGludGVnZXIuXHJcbiAqIEBwYXJhbSBmbG9hdFVuaXQgVW5pdHMgdG8gYXBwZW5kIGlmIHRoZSBudW1iZXIgaXMgZmxvYXRpbmcgcG9pbnQuXHJcbiAqL1xyXG5jb25zdCBudW1iZXJUb1N0cmluZyA9IChuOiBudW1iZXIsIGludFVuaXQ6IHN0cmluZyA9IFwiXCIsIGZsb2F0VWludDogc3RyaW5nID0gXCJcIik6IHN0cmluZyA9PlxyXG4gICAgbiArIChOdW1iZXIuaXNJbnRlZ2VyKG4pID8gIGludFVuaXQgOiBmbG9hdFVpbnQpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIE51bWVyaWNNYXRoIGNsYXNzIGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBudW1lcmljIENTUyB0eXBlcy4gV2hlbiBhcmd1bWVudHMgZm9yIHRoZXNlIGZ1bmN0aW9ucyBhcmUgb2YgdGhlIG51bWJlciBKYXZhU2NyaXB0IHR5cGUgdGhleVxyXG4gKiBhcmUgY29udmVydGVkIHRvIHN0cmluZ3MgYnkgY2FsbGluZyBhIGZ1bmN0aW9uIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTnVtZXJpY01hdGg8VCA9IGFueSwgVSBleHRlbmRzIHN0cmluZyA9IGFueT4gaW1wbGVtZW50cyBJTnVtZXJpY01hdGg8VCxVPlxyXG57XHJcbiAgICBwdWJsaWMgbjJzOiBOdW1iZXJUb1N0cmluZ0Z1bmM7XHJcblxyXG4gICAgY29uc3RydWN0b3IoIG4yczogTnVtYmVyVG9TdHJpbmdGdW5jKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubjJzID0gbjJzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2MnMoIHZhbDogRXh0ZW5kZWQ8VD4pOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdjJzKCB2YWwsIHsgbnVtOiB0aGlzLm4ycyB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbXYycyggdmFsOiBPbmVPck1hbnk8VD4sIHNlcGFyYXRvcjogc3RyaW5nKTogc3RyaW5nXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHYycyggdmFsLCB7XHJcbiAgICAgICAgICAgIGFueTogdiA9PiB0aGlzLnYycyh2KSxcclxuICAgICAgICAgICAgc2VwOiBzZXBhcmF0b3JcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlcyBDc3NMZW5ndGggdmFsdWUgZnJvbSB0aGUgbnVtYmVyIGFuZCB0aGUgZ2l2ZW4gdW5pdC4gKi9cclxuICAgIHB1YmxpYyB1bml0cyggbjogbnVtYmVyLCB1bml0OiBVKTogSUdlbmVyaWNQcm94eTxVPlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBuICsgdW5pdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbWluKCAuLi5wYXJhbXM6IEV4dGVuZGVkPFQ+W10pOiBJR2VuZXJpY1Byb3h5PFU+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMubSggXCJtaW5cIiwgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbWF4KCAuLi5wYXJhbXM6IEV4dGVuZGVkPFQ+W10pOiBJR2VuZXJpY1Byb3h5PFU+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMubSggXCJtYXhcIiwgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xhbXAoIG1pbjogRXh0ZW5kZWQ8VD4sIHByZWY6IEV4dGVuZGVkPFQ+LCBtYXg6IEV4dGVuZGVkPFQ+KTogSUdlbmVyaWNQcm94eTxVPlxyXG4gICAge1xyXG4gICAgICAgIC8vIHJldHVybiAoKSA9PiBtYXRoRnVuYyggXCJjbGFtcFwiLCBbbWluLCBwcmVmLCBtYXhdLCB0aGlzLm4ycyk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMubSggXCJjbGFtcFwiLCBbbWluLCBwcmVmLCBtYXhdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2FsYyggZm9ybXVsYVBhcnRzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4ucGFyYW1zOiBFeHRlbmRlZDxUPltdKTogSUdlbmVyaWNQcm94eTxVPlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBgY2FsYygke3RhZzJzKCBmb3JtdWxhUGFydHMsIHBhcmFtcywgKHY6IEV4dGVuZGVkPFQ+KSA9PiB0aGlzLnYycyh2KSl9KWA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtKCBuYW1lOiBzdHJpbmcsIHBhcmFtczogRXh0ZW5kZWQ8VD5bXSk6IHN0cmluZ1xyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfSgke3RoaXMubXYycyggcGFyYW1zLCBcIixcIil9KWA7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBOdW1iZXJNYXRoIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGUgYDxudW1iZXI+YFxyXG4gKiBDU1MgdHlwZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBOdW1iZXJNYXRoID0gbmV3IE51bWVyaWNNYXRoPENzc051bWJlcixcIlwiPiggbiA9PiBuLnRvU3RyaW5nKCkpO1xyXG5cclxud2tmW1dLRi5OdW1iZXJdID0gdiA9PiBOdW1iZXJNYXRoLnYycyggdik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUGVyY2VudE1hdGggb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSBcIiVcIiB1bml0IHN1ZmZpeC4gSWYgdGhlIG51bWJlciBpcyBiZXR3ZWVuIC0xIGFuZCAxIChub25cclxuICogaW5jbHVzaXZlKSwgbXVsdGlwbGllcyB0aGUgbnVtYmVyIGJ5IDEwMC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQZXJjZW50TWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NQZXJjZW50LFBlcmNlbnRVbml0cz4oXHJcbiAgICBuID0+IChuID49IDEgfHwgbiA8PSAtMSA/IG4gOiBNYXRoLnJvdW5kKG4gKiAxMDApKSArIFwiJVwiKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbnVtYmVyIHRvIHN0cmluZyB1c2luZyB0aGUgZm9sbG93aW5nIHJ1bGVzOlxyXG4gKiAtIGlmIHRoZSBudW1iZXIgaXMgYmV0d2VlbiAtMSBhbmQgMSAobm9uIGluY2x1c2l2ZSksIG11bHRpcGxpZXMgdGhlIG51bWJlciBieSAxMDAgYW5kIGFwcGVuZHMgXCIlXCJcclxuICogLSBvdGhlcndpc2UsIGNvbnZlcnRzIHRoZSBudW1iZXIgdG8gc3RyaW5nIHdpdGhvdXQgYXBwZW5kaW5nIGFueSB1bml0cy5cclxuICovXHJcbmNvbnN0IHVuaXRsZXNzT3JQZXJjZW50VG9TdHJpbmcgPSAobjogbnVtYmVyKTogc3RyaW5nID0+IG4gPj0gMSB8fCBuIDw9IC0xID8gbi50b1N0cmluZygpIDogKE1hdGgucm91bmQobiAqIDEwMCkgKyBcIiVcIik7XHJcblxyXG53a2ZbV0tGLlBlcmNlbnRdID0gdiA9PiBQZXJjZW50TWF0aC52MnMoIHYpO1xyXG53a2ZbV0tGLlVuaXRsZXNzT3JQZXJjZW50XSA9IHVuaXRsZXNzT3JQZXJjZW50VG9TdHJpbmc7XHJcbndrZltXS0YuQWx3YXlzUGVyY2VudF0gPSB2ID0+IHYgKyBcIiVcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBMZW5ndGhNYXRoIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGUgYDxsZW5ndGg+YFxyXG4gKiBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSBsZW5ndGggdW5pdCBzdWZmaXguXHJcbiAqIEludGVnZXIgbnVtYmVycyB1c2UgXCJweFwiOyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHVzZSBcImVtXCIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTGVuZ3RoTWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NMZW5ndGgsTGVuZ3RoVW5pdHM+KCBuID0+IG51bWJlclRvU3RyaW5nKCBuLCBcInB4XCIsIFwiZW1cIikpO1xyXG5cclxud2tmW1dLRi5MZW5ndGhdID0gdiA9PiBMZW5ndGhNYXRoLnYycyggdik7XHJcbndrZltXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2VdID0gdiA9PiBMZW5ndGhNYXRoLm12MnMoIHYsIFwiIFwiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBBbmdsZU1hdGggb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZSBgPGFuZ2xlPmBcclxuICogQ1NTIHR5cGUgYnkgYXBwZW5kaW5nIGFuIGFuZ2xlIHVuaXQgc3VmZml4LlxyXG4gKiBJbnRlZ2VyIG51bWJlcnMgdXNlIFwiZGVnXCI7IGZsb2F0aW5nIHBvaW50IG51bWJlcnMgdXNlIFwidHVyblwiLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEFuZ2xlTWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NBbmdsZSxBbmdsZVVuaXRzPiggbiA9PiBudW1iZXJUb1N0cmluZyggbiwgXCJkZWdcIiwgXCJ0dXJuXCIpKTtcclxuXHJcbndrZltXS0YuQW5nbGVdID0gdiA9PiBBbmdsZU1hdGgudjJzKCB2KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBUaW1lTWF0aCBvYmplY3QgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlIGA8dGltZT5gXHJcbiAqIENTUyB0eXBlIGJ5IGFwcGVuZGluZyBhIHRpbWUgdW5pdCBzdWZmaXguXHJcbiAqIEludGVnZXIgbnVtYmVycyB1c2UgXCJtc1wiOyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHVzZSBcInNcIi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBUaW1lTWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NUaW1lLFRpbWVVbml0cz4oIG4gPT4gbnVtYmVyVG9TdHJpbmcoIG4sIFwibXNcIiwgXCJzXCIpKTtcclxuXHJcbndrZltXS0YuVGltZV0gPSB2ID0+IFRpbWVNYXRoLnYycyggdik7XHJcbndrZltXS0YuTXVsdGlUaW1lV2l0aENvbW1hXSA9IHYgPT4gVGltZU1hdGgubXYycyggdiwgXCIsXCIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUmVzb2x1dGlvbk1hdGggb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHJlc29sdXRpb24+YCBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSByZXNvbHV0aW9uIHVuaXQgc3VmZml4LlxyXG4gKiBJbnRlZ2VyIG51bWJlcnMgdXNlIFwiZHBpXCI7IGZsb2F0aW5nIHBvaW50IG51bWJlcnMgdXNlIFwieFwiLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFJlc29sdXRpb25NYXRoID0gbmV3IE51bWVyaWNNYXRoPENzc1Jlc29sdXRpb24sUmVzb2x1dGlvblVuaXRzPiggbiA9PiBudW1iZXJUb1N0cmluZyggbiwgXCJkcGlcIiwgXCJ4XCIpKTtcclxuXHJcbndrZltXS0YuUmVzb2x1dGlvbl0gPSB2ID0+IFJlc29sdXRpb25NYXRoLnYycyggdik7XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBGcmVxdWVuY3lNYXRoIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxmcmVxdWVuY3k+YCBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSBmcmVxdWVuY3kgdW5pdCBzdWZmaXguXHJcbiAqIEludGVnZXIgbnVtYmVycyB1c2UgXCJIelwiOyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHVzZSBcImtIelwiLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEZyZXF1ZW5jeU1hdGggPSBuZXcgTnVtZXJpY01hdGg8Q3NzRnJlcXVlbmN5LCBGcmVxdWVuY3lVbml0cz4oIG4gPT4gbnVtYmVyVG9TdHJpbmcoIG4sIFwiSHpcIiwgXCJrSHpcIikpO1xyXG5cclxud2tmW1dLRi5GcmVxdWVuY3ldID0gdiA9PiBGcmVxdWVuY3lNYXRoLnYycyggdik7XHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFNpemUsIFBvaW50LCBQb3NpdGlvbiwgUmFkaXVzXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLy8gLy8gQ29udmVydHMgc2luZ2xlIHBvc2l0aW9uIHN0eWxlIHZhbHVlIHRvIHRoZSBDU1Mgc3RyaW5nLlxyXG4vLyBjb25zdCBwb3MycyA9ICh2YWw6IEV4dGVuZGVkPENzc1Bvc2l0aW9uPik6IHN0cmluZyA9PiB2MnMoIHZhbCwgeyBhbnk6IFdLRi5MZW5ndGggfSk7XHJcblxyXG53a2ZbV0tGLlBvc2l0aW9uXSA9ICh2YWw6IEV4dGVuZGVkPENzc1Bvc2l0aW9uPik6IHN0cmluZyA9PiB2MnMoIHZhbCwgeyBhbnk6IFdLRi5MZW5ndGggfSk7XHJcbndrZltXS0YuQXRQb3NpdGlvbl0gPSAodjogRXh0ZW5kZWQ8Q3NzUG9zaXRpb24+KSA9PiB2ID09IG51bGwgPyBcIlwiIDogXCJhdCBcIiArIHdrZltXS0YuUG9zaXRpb25dKHYpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIG11bHRpLXBvc2l0aW9uIHN0eWxlIHZhbHVlIHRvIHRoZSBDU1Mgc3RyaW5nLlxyXG4gKi9cclxuIHdrZltXS0YuTXVsdGlQb3NpdGlvbl0gPSAodmFsOiBPbmVPck1hbnk8Q3NzUG9zaXRpb24+KTogc3RyaW5nID0+XHJcbiAgICB2MnMoIHZhbCwge1xyXG4gICAgICAgIGFycjI6IHsgYW55OiBXS0YuUG9zaXRpb24sIHNlcDogXCIsXCIgfSxcclxuICAgICAgICBhbnk6IFdLRi5Qb3NpdGlvblxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcbi8vIENvbnZlcnRzIGNvcm5lciByYWRpdXMgc3R5bGUgdmFsdWUgdG8gdGhlIENTUyBzdHJpbmcuXHJcbndrZltXS0YuUmFkaXVzXSA9ICh2OiBFeHRlbmRlZDxDc3NSYWRpdXM+KSA9PiB2MnMoIHYsIHsgYW55OiBXS0YuTGVuZ3RoIH0pO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgYm9yZGVyIHJhZGl1cyBzdHlsZSB2YWx1ZSB0byB0aGUgQ1NTIHN0cmluZy5cclxuICovXHJcbiB3a2ZbV0tGLkJvcmRlclJhZGl1c10gPSAodmFsOiBFeHRlbmRlZDxCb3JkZXJSYWRpdXM+KTogc3RyaW5nID0+XHJcbiAgICB2MnMoIHZhbCwge1xyXG4gICAgICAgIGFycjI6IHsgYW55OiB7IGFueTogV0tGLkxlbmd0aCB9LCBzZXA6IFwiL1wiIH0sXHJcbiAgICAgICAgYW55OiBXS0YuTGVuZ3RoXHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7SVN0eWxlRGVmaW5pdGlvbn0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHtTY2hlZHVsZXJUeXBlLCBJU2NoZWR1bGVyfSBmcm9tIFwiLi4vYXBpL1NjaGVkdWxpbmdUeXBlc1wiO1xyXG5pbXBvcnQge1N0cmluZ1N0eWxlc2V0fSBmcm9tIFwiLi4vYXBpL1N0eWxlc2V0c1wiO1xyXG5pbXBvcnQge2FjdGl2YXRlU0QsIGRlYWN0aXZhdGVTRH0gZnJvbSBcIi4uL3J1bGVzL1J1bGVDb250YWluZXJcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJQWN0aXZhdG9yIGludGVyZmFjZSByZXByZXNlbnRzIGFuIG9iamVjdCByZXNwb25zaWJsZSBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgYWN0aXZhdGlvblxyXG4gKiBtZWNoYW5pc20uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTdHlsZUFjdGl2YXRvclxyXG57XHJcblx0LyoqXHJcblx0ICogSW5zdHJ1Y3RzIHRvIGFjdGl2YXRlIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuXHQgKiBhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICovXHJcblx0YWN0aXZhdGUoIGRlZmluaXRpb246IElTdHlsZURlZmluaXRpb24pOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gZGVhY3RpdmF0ZSB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlXHJcblx0ICogZGVhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICovXHJcblx0ZGVhY3RpdmF0ZSggZGVmaW5pdGlvbjogSVN0eWxlRGVmaW5pdGlvbik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RydWN0cyB0byBzZXQgdGhlIHZhbHVlIG9mIGVpdGhlciBhIHNpbmdsZSBwcm9wZXJ0eSBvciBhIHNldCBvZiBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlblxyXG4gICAgICogQ1NTIHN0eWxlIG9iamVjdC5cclxuXHQgKi9cclxuICAgIHVwZGF0ZVN0eWxlKCBydWxlT3JFbG06IENTU1N0eWxlUnVsZSB8IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgbmFtZTogc3RyaW5nIHwgbnVsbCxcclxuICAgICAgICB2YWx1ZT86IHN0cmluZyB8IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCwgaW1wb3J0YW50PzogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGZvciBhbGwgc3R5bGUgZGVmaW5pdGlvbnMgYWNjdW11bGF0ZWQgc2luY2UgdGhlIGxhc3RcclxuXHQgKiBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGZvcmNlRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdGZvcmNlRE9NVXBkYXRlKCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbmNlbHMgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gZm9yIGFsbCBzdHlsZSBkZWZpbml0aW9ucyBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdFxyXG5cdCAqIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgY2FuY2VsRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdGNhbmNlbERPTVVwZGF0ZSgpOiB2b2lkO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGVpdGhlciBhIHNpbmdsZSBwcm9wZXJ0eSBvciBhIHNldCBvZiBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlblxyXG4gKiBDU1Mgc3R5bGUgb2JqZWN0LlxyXG4gKi9cclxuY29uc3QgdXBkYXRlU3R5bGVQcm9wZXJ0eSA9IChydWxlT3JFbG06IENTU1N0eWxlUnVsZSB8IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgbmFtZTogc3RyaW5nIHwgbnVsbCxcclxuICAgIHZhbHVlPzogc3RyaW5nIHwgU3RyaW5nU3R5bGVzZXQgfCBudWxsLCBpbXBvcnRhbnQ/OiBib29sZWFuKTogdm9pZCA9PlxyXG57XHJcbiAgICBpZiAoIW5hbWUgJiYgdmFsdWUgPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICBpZiAocnVsZU9yRWxtIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlKVxyXG4gICAgICAgICAgICBydWxlT3JFbG0uY3NzVGV4dCA9IFwiXCI7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAocnVsZU9yRWxtIGFzIGFueSBhcyBFbGVtZW50KS5yZW1vdmVBdHRyaWJ1dGUoIFwic3R5bGVcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICBydWxlT3JFbG0uc3R5bGUucmVtb3ZlUHJvcGVydHkoIG5hbWUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcnVsZU9yRWxtLnN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSBhcyBzdHJpbmcsIGltcG9ydGFudCA/IFwiaW1wb3J0YW50XCIgOiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGxldCBzdHlsZXNldCA9IHZhbHVlIGFzIFN0cmluZ1N0eWxlc2V0O1xyXG4gICAgICAgIGZvciggbGV0IHByb3BOYW1lIGluIHN0eWxlc2V0KVxyXG4gICAgICAgICAgICBydWxlT3JFbG0uc3R5bGVbcHJvcE5hbWVdID0gc3R5bGVzZXRbcHJvcE5hbWVdO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgU3luY2hyb25vdXNBY3RpdmF0b3IgY2xhc3MgcmVwcmVzZW50cyB0aGUgc3luY2hyb25vdXMgYWN0aXZhdGlvbiBtZWNoYW5pc20sIHdoaWNoIHdyaXRlc1xyXG4gKiBzdHlsZSBjaGFuZ2VzIHRvIHRoZSBET00gd2hlbiB0aGUgYWN0aXZhdGUgYW5kIGRlYWN0aXZhdGUgZnVuY3Rpb25zIGFyZSBjYWxsZWQuXHJcbiAqL1xyXG5jbGFzcyBTeW5jaHJvbm91c0FjdGl2YXRvciBpbXBsZW1lbnRzIElTdHlsZUFjdGl2YXRvclxyXG57XHJcblx0LyoqXHJcblx0ICogSW5zdHJ1Y3RzIHRvIGFjdGl2YXRlIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuXHQgKiBhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICogQHBhcmFtIGRlZmluaXRpb25cclxuXHQgKi9cclxuXHRwdWJsaWMgYWN0aXZhdGUoIGRlZmluaXRpb246IElTdHlsZURlZmluaXRpb24pOiB2b2lkXHJcblx0e1xyXG5cdFx0YWN0aXZhdGVTRCggZGVmaW5pdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gZGVhY3RpdmF0ZSB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlXHJcblx0ICogZGVhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICogQHBhcmFtIGRlZmluaXRpb25cclxuXHQgKi9cclxuXHRwdWJsaWMgZGVhY3RpdmF0ZSggZGVmaW5pdGlvbjogSVN0eWxlRGVmaW5pdGlvbik6IHZvaWRcclxuXHR7XHJcblx0XHRkZWFjdGl2YXRlU0QoIGRlZmluaXRpb24pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5zdHJ1Y3RzIHRvIHNldCB0aGUgdmFsdWUgb2YgZWl0aGVyIGEgc2luZ2xlIHByb3BlcnR5IG9yIGEgc2V0IG9mIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuXHJcbiAgICAgKiBDU1Mgc3R5bGUgb2JqZWN0LlxyXG5cdCAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVN0eWxlKCBydWxlT3JFbG06IENTU1N0eWxlUnVsZSB8IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgbmFtZTogc3RyaW5nIHwgbnVsbCxcclxuICAgICAgICB2YWx1ZT86IHN0cmluZyB8IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCwgaW1wb3J0YW50PzogYm9vbGVhbik6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgdXBkYXRlU3R5bGVQcm9wZXJ0eSggcnVsZU9yRWxtLCBuYW1lLCB2YWx1ZSwgaW1wb3J0YW50KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGZvciBhbGwgc3R5bGUgZGVmaW5pdGlvbnMgYWNjdW11bGF0ZWQgc2luY2UgdGhlIGxhc3RcclxuXHQgKiBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGZvcmNlRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBmb3JjZURPTVVwZGF0ZSgpOiB2b2lkIHt9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbmNlbHMgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gZm9yIGFsbCBzdHlsZSBkZWZpbml0aW9ucyBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdFxyXG5cdCAqIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgY2FuY2VsRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjYW5jZWxET01VcGRhdGUoKTogdm9pZCB7fVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgU2NoZWR1bGluZ0FjdGl2YXRvciBjbGFzcyBrZWVwcyBhIG1hcCBvZiBTdHlsZURlZmluaXRpb24gaW5zdGFuY2VzIHRoYXQgYXJlIHNjaGVkdWxlZCBmb3JcclxuICogYWN0aXZhdGlvbiBvciBkZWFjdGl2YXRpb24uIEVhY2ggaW5zdGFuY2UgaXMgbWFwcGVkIHRvIGEgcmVmZXJuY2UgY291bnQsIHdoaWNoIGlzIGluY3JlbWVudGVkXHJcbiAqIHVwb24gdGhlIGFjdGl2YXRlIGNhbGxzIGFuZCBkZWNyZW1lbnRlZCB1cG9uIHRoZSBkZWFjdGl2YXRlIGNhbGxzLiBXaGVuIHRoZSBkb0FjdGl2YXRpb25cclxuICogbWV0aG9kIGlzIGNhbGxlZCBUaGUgc3R5bGUgZGVmaW5pdGlvbiB3aWxsIGJlIGVpdGhlciBhY3RpdmF0ZWQgb3IgZGVhY3RpdmF0ZWQgYmFzZWQgb24gd2hldGhlclxyXG4gKiB0aGUgcmVmZXJlbmNlIGNvdW50IGlzIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxyXG4gKi9cclxuY2xhc3MgU2NoZWR1bGluZ0FjdGl2YXRvciBpbXBsZW1lbnRzIElTdHlsZUFjdGl2YXRvclxyXG57XHJcbiAgICAvLyBBcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBydW5zLlxyXG4gICAgcHJpdmF0ZSBhY3Rpb25zOiAoKCk9PnZvaWQpW10gPSBbXTtcclxuXHJcbiAgICAvLyBvcHRpb25hbCBzY2hlZHVsZXIgb2JqZWN0XHJcbiAgICBwcml2YXRlIHNjaGVkdWxlcj86IElTY2hlZHVsZXI7XHJcblxyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvciggc2NoZWR1bGVyPzogSVNjaGVkdWxlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoc2NoZWR1bGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2NoZWR1bGVyLmluaXQoICgpID0+IHRoaXMuZG9ET01VcGRhdGUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gYWN0aXZhdGUgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2UuXHJcblx0ICovXHJcblx0cHVibGljIGFjdGl2YXRlKCBkZWZpbml0aW9uOiBJU3R5bGVEZWZpbml0aW9uKTogdm9pZFxyXG5cdHtcclxuICAgICAgICBpZiAodGhpcy5pc1NjaGVkdWxpbmdOZWVkZWQpXHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyIS5zY2hlZHVsZURPTVVwZGF0ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaCggKCkgPT4gYWN0aXZhdGVTRCggZGVmaW5pdGlvbikpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gZGVhY3RpdmF0ZSB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS5cclxuXHQgKi9cclxuXHRwdWJsaWMgZGVhY3RpdmF0ZSggZGVmaW5pdGlvbjogSVN0eWxlRGVmaW5pdGlvbik6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTY2hlZHVsaW5nTmVlZGVkKVxyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlciEuc2NoZWR1bGVET01VcGRhdGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnB1c2goICgpID0+IGRlYWN0aXZhdGVTRCggZGVmaW5pdGlvbikpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gc2V0IHRoZSB2YWx1ZSBvZiBlaXRoZXIgYSBzaW5nbGUgcHJvcGVydHkgb3IgYSBzZXQgb2YgcHJvcGVydGllcyBpbiB0aGUgZ2l2ZW5cclxuICAgICAqIENTUyBzdHlsZSBvYmplY3QuXHJcblx0ICovXHJcbiAgICBwdWJsaWMgdXBkYXRlU3R5bGUoIHJ1bGVPckVsbTogQ1NTU3R5bGVSdWxlIHwgRWxlbWVudENTU0lubGluZVN0eWxlLCBuYW1lOiBzdHJpbmcgfCBudWxsLFxyXG4gICAgICAgIHZhbHVlPzogc3RyaW5nIHwgU3RyaW5nU3R5bGVzZXQgfCBudWxsLCBpbXBvcnRhbnQ/OiBib29sZWFuKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICh0aGlzLmlzU2NoZWR1bGluZ05lZWRlZClcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIhLnNjaGVkdWxlRE9NVXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5hY3Rpb25zLnB1c2goICgpID0+IHVwZGF0ZVN0eWxlUHJvcGVydHkoIHJ1bGVPckVsbSwgbmFtZSwgdmFsdWUsIGltcG9ydGFudCkpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBmb3IgYWxsIHN0eWxlIGRlZmluaXRpb25zIGluIG91ciBpbnRlcm5hbCBtYXAuXHJcblx0ICovXHJcblx0cHVibGljIGZvcmNlRE9NVXBkYXRlKCk6IHZvaWRcclxuXHR7XHJcblx0XHRpZiAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IDApXHJcblx0XHR7XHJcbiAgICAgICAgICAgIHRoaXMuZG9ET01VcGRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIgJiYgdGhpcy5zY2hlZHVsZXIuY2FuY2VsRE9NVXBkYXRlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbmNlbHMgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gZm9yIGFsbCBzdHlsZSBkZWZpbml0aW9ucyBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdFxyXG5cdCAqIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjYW5jZWxET01VcGRhdGUoKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gMClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5hY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyICYmIHRoaXMuc2NoZWR1bGVyLmNhbmNlbERPTVVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHRwcml2YXRlIGdldCBpc1NjaGVkdWxpbmdOZWVkZWQoKTogYm9vbGVhblxyXG4gICAge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5zY2hlZHVsZXIgJiYgIXRoaXMuYWN0aW9ucy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuXHQgKiBQZXJmb3JtcyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBhbmQgcHJvcGVydHkgc2V0IG9wZXJhdGlvbnMgYWNjdW11bGF0ZWQgaW50ZXJuYWxseS4gVGhpc1xyXG4gICAgICogbWV0aG9kIHNob3VsZCBiZSB1c2VkIGJ5IHRoZSBkZXJpdmVkIGNsYXNzZXMgd2hlbiBzY2hlZHVsZWQgYWN0aXZhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZC5cclxuXHQgKi9cclxuXHRwcml2YXRlIGRvRE9NVXBkYXRlKCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgLy8gdXBkYXRlIHN0eWxlIHByb3BlcnRpZXNcclxuICAgICAgICBmb3IoIGxldCBhY3Rpb24gb2YgdGhpcy5hY3Rpb25zKVxyXG4gICAgXHRcdGFjdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuYWN0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgaW1wbGVtZW50cyBzY2hlZHVsaW5nIHVzaW5nIGFuaW1hdGlvbiBmcmFtZXMuXHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb25GcmFtZVNjaGVkdWxlciBpbXBsZW1lbnRzIElTY2hlZHVsZXJcclxue1xyXG4gICAgLy8gSGFuZGxlIHJldHVybmVkIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbi5cclxuXHRwcml2YXRlIGggPSAwO1xyXG5cclxuICAgIC8vIENhbGxiYWNrIHRvIGNhbGwgdG8gd3JpdGUgY2hhbmdlcyB0byB0aGUgRE9NLlxyXG5cdHByaXZhdGUgY2I6ICgpID0+IHZvaWQ7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHNjaGVkdWxlciBvYmplY3QgYW5kIHByb3ZpZGVzIHRoZSBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlXHJcbiAgICAgKiBzY2hlZHVsZXIgZGVjaWRlcyB0byBtYWtlIGNoYW5nZXMgdG8gdGhlIERPTS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluaXQoIGRvRE9NVXBkYXRlOiAoKSA9PiB2b2lkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2IgPSBkb0RPTVVwZGF0ZTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcblx0ICogSXMgaW52b2tlZCB3aGVuIHRoZSBzY2hlZHVsZXIgbmVlZHMgdG8gc2NoZWR1bGUgaXRzIGNhbGxiYWNrIG9yIGV2ZW50LlxyXG5cdCAqL1xyXG4gICAgcHVibGljIHNjaGVkdWxlRE9NVXBkYXRlKCk6IHZvaWRcclxuICAgIHtcclxuXHRcdHRoaXMuaCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGhpcy5vbkZyYW1lKVxyXG4gICAgfVxyXG5cclxuXHQvKipcclxuXHQgKiBJcyBpbnZva2VkIHdoZW4gdGhlIHNjaGVkdWxlciBuZWVkcyB0byBjYW5jZWxzIGl0cyBzY2hlZHVsZWQgY2FsbGJhY2sgb3IgZXZlbnQuXHJcblx0ICovXHJcbiAgICBwdWJsaWMgY2FuY2VsRE9NVXBkYXRlKCk6IHZvaWRcclxuICAgIHtcclxuXHRcdGlmICh0aGlzLmggPiAwKVxyXG5cdFx0e1xyXG5cdFx0XHRjYW5jZWxBbmltYXRpb25GcmFtZSggdGhpcy5oKTtcclxuXHRcdFx0dGhpcy5oID0gMDtcclxuXHRcdH1cclxuICAgIH1cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIElzIGludm9rZWQgd2hlbiBhbmltYXRpb24gZnJhbWUgc2hvdWxkIGJlIGV4ZWN1dGVkLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgb25GcmFtZSA9ICgpOiB2b2lkID0+XHJcblx0e1xyXG5cdFx0dGhpcy5oID0gMDtcclxuXHRcdHRoaXMuY2IoKTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGFjdGl2YXRvciBmb3IgdGhlIGdpdmVuIHNjaGVkdWxlciB0eXBlLiBJZiBzY2hlZHVsZXIgdHlwZSBpcyBub3Qgc3BlY2lmaWVkIHJldHVybnNcclxuICogdGhlIGFjdGl2YXRvciBjdXJyZW50bHkgc2V0IGFzIGRlZmF1bHQuIElmLCBmb3Igc29tZSByZWFzb24sIHRoZSBkZWZhdWx0IGFjdGl2YXRvciBpcyBub3Qgc2V0LFxyXG4gKiByZXR1cm5zIHRoZSBzeW5jaHJvbm91cyBhY3RpdmF0b3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZhdG9yID0gKHNjaGVkdWxlclR5cGU/OiBudW1iZXIpOiBJU3R5bGVBY3RpdmF0b3IgPT5cclxuXHQoc2NoZWR1bGVyVHlwZSA9PSBudWxsID8gc19kZWZhdWx0QWN0aXZhdG9yIDogc19yZWdpc3RlcmVkQWN0aXZhdG9ycy5nZXQoIHNjaGVkdWxlclR5cGUpKSA/PyBzX3N5bmNocm9ub3VzQWN0aXZhdG9yO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgZGVmYXVsdCBzY2hlZHVsaW5nIHR5cGUgdGhhdCBpcyB1c2VkIGJ5IGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9ucyB0aGF0IGFyZVxyXG4gKiBjYWxsZWQgd2l0aG91dCBleHBsaWNpdGx5IHByb3ZpZGluZyB2YWx1ZSB0byB0aGUgc2NoZWR1bGluZyBwYXJhbWV0ZXIuIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlXHJcbiAqIHByZXZpb3VzIGRlZmF1bHQgYWN0aXZhdG9yIG9yIDAgaWYgYW4gZXJyb3Igb2NjdXJzIChlLmcuIHRoZSBnaXZlbiBzY2hlZHVsZXIgdHlwZSBJRCBpcyBub3RcclxuICogcmVnaXN0ZXJlZCkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0RGVmYXVsdFNjaGVkdWxlciA9IChzY2hlZHVsZXJUeXBlOiBudW1iZXIpOiBudW1iZXIgPT5cclxue1xyXG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgZ2l2ZW4gbnVtYmVyIGlzIGluIG91ciBtYXAgb2YgcmVnaXN0ZXJlZCBhY3RpdmF0b3JzXHJcbiAgICBsZXQgYWN0aXZhdG9yID0gc19yZWdpc3RlcmVkQWN0aXZhdG9ycy5nZXQoIHNjaGVkdWxlclR5cGUpO1xyXG5cdGlmICghYWN0aXZhdG9yKVxyXG5cdFx0cmV0dXJuIDA7XHJcblxyXG5cdGxldCBwcmV2U2NoZWR1bGVyVHlwZSA9IHNfZGVmYXVsdFNjaGVkdWxlclR5cGU7XHJcbiAgICBzX2RlZmF1bHRTY2hlZHVsZXJUeXBlID0gc2NoZWR1bGVyVHlwZTtcclxuICAgIHNfZGVmYXVsdEFjdGl2YXRvciA9IGFjdGl2YXRvcjtcclxuXHRyZXR1cm4gcHJldlNjaGVkdWxlclR5cGU7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gc2NoZWR1bGVyIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgc2NoZWR1bGVyIHR5cGUgaWRlbnRpZmllciwgd2hpY2hcclxuICogc2hvdWxkIGJlIHVzZWQgd2hlbiBjYWxsaW5nIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlclNjaGVkdWxlciA9IChzY2hlZHVsZXI6IElTY2hlZHVsZXIpOiBudW1iZXIgPT5cclxue1xyXG5cdC8vIGdldCB0aGUgcmVnaXN0cmF0aW9uIElEIGZvciB0aGlzIHNjaGVkdWxlclxyXG5cdGxldCBpZCA9IHNfbmV4dEN1c3RvbVNjaGVkdWxlclR5cGUrKztcclxuXHRzX3JlZ2lzdGVyZWRBY3RpdmF0b3JzLnNldCggaWQsIG5ldyBTY2hlZHVsaW5nQWN0aXZhdG9yKCBzY2hlZHVsZXIpKTtcclxuXHRyZXR1cm4gaWQ7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEN1cnJlbnQgZGVmYXVsdCBzY2hlZHVsZXIuIFRoaXMgc2NoZWR1bGVyIHdpbGwgYmUgdXNlZCBpZiBzY2hlZHVsZXIgdHlwZSBpcyBub3QgZXhwbGljaXRseVxyXG4gKiBzcGVjaWZpZWQgaW4gY2FsbHMgc3VjaCBhcyBhY3RpdmF0ZSBvciBJU3R5bGVSdWxlLnNldFByb3AuXHJcbiAqL1xyXG5sZXQgc19kZWZhdWx0U2NoZWR1bGVyVHlwZTogbnVtYmVyID0gU2NoZWR1bGVyVHlwZS5TeW5jO1xyXG5cclxuLyoqXHJcbiAqIFN5bmNocm9ub3VzIGFjdGl2YXRvciBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IHNfc3luY2hyb25vdXNBY3RpdmF0b3IgPSBuZXcgU3luY2hyb25vdXNBY3RpdmF0b3IoKTtcclxuXHJcbi8qKlxyXG4gKiBDdXJyZW50IGRlZmF1bHQgYWN0aXZhdG9yLiBUaGlzIGFjdGl2YXRvciB3aWxsIGJlIHVzZWQgaWYgc2NoZWR1bGVyIHR5cGUgaXMgbm90IGV4cGxpY2l0bHlcclxuICogc3BlY2lmaWVkIGluIGNhbGxzIHN1Y2ggYXMgYWN0aXZhdGUgb3IgSVN0eWxlUnVsZS5zZXRQcm9wLlxyXG4gKi9cclxubGV0IHNfZGVmYXVsdEFjdGl2YXRvcjogSVN0eWxlQWN0aXZhdG9yID0gc19zeW5jaHJvbm91c0FjdGl2YXRvcjtcclxuXHJcbi8qKlxyXG4gKiBTY2hlZHVsZXIgdHlwZSBpZGVudGlmaWVyIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBmaXJzdCBjdXN0b20gc2NoZWR1bGVyIHRvIGJlIHJlZ2lzdGVyZWQuXHJcbiAqIEFsbCBjdXN0b20gc2NoZWR1bGVyIGlkZW50aWZpZXJzIGFyZSBncmVhdGVyIG9yIGVxdWFsIHRvIHRoaXMgbnVtYmVyLlxyXG4gKi9cclxuY29uc3Qgc19maXJzdEN1c3RvbVNjaGVkdWxlclR5cGU6IG51bWJlciA9IDEwMDE7XHJcblxyXG4vKipcclxuICogU2NoZWR1bGVyIHR5cGUgaWRlbnRpZmllciB0byBiZSBhc3NpZ25lZCB0byB0aGUgbmV4dCBjdXN0b20gc2NoZWR1bGVyIHRvIGJlIHJlZ2lzdGVyZWQuXHJcbiAqL1xyXG5sZXQgc19uZXh0Q3VzdG9tU2NoZWR1bGVyVHlwZTogbnVtYmVyID0gc19maXJzdEN1c3RvbVNjaGVkdWxlclR5cGU7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgcmVnaXN0ZXJlZCBidWlsdC1pbiBhbmQgY3VzdG9tIGFjdGl2YXRvcnMuXHJcbiAqL1xyXG5jb25zdCBzX3JlZ2lzdGVyZWRBY3RpdmF0b3JzID0gbmV3IE1hcDxudW1iZXIsSVN0eWxlQWN0aXZhdG9yPigpO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGJ1aWx0LWluIGFuZCBjdXN0b20gYWN0aXZhdG9ycy5cclxuICovXHJcbnNfcmVnaXN0ZXJlZEFjdGl2YXRvcnMuc2V0KCBTY2hlZHVsZXJUeXBlLlN5bmMsIHNfc3luY2hyb25vdXNBY3RpdmF0b3IpO1xyXG5zX3JlZ2lzdGVyZWRBY3RpdmF0b3JzLnNldCggU2NoZWR1bGVyVHlwZS5BbmltYXRpb25GcmFtZSwgbmV3IFNjaGVkdWxpbmdBY3RpdmF0b3IoIG5ldyBBbmltYXRpb25GcmFtZVNjaGVkdWxlcigpKSk7XHJcbnNfcmVnaXN0ZXJlZEFjdGl2YXRvcnMuc2V0KCBTY2hlZHVsZXJUeXBlLk1hbnVhbCwgbmV3IFNjaGVkdWxpbmdBY3RpdmF0b3IoKSk7XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7RXh0ZW5kZWR9IGZyb20gXCIuLi9hcGkvQ29yZVR5cGVzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBCb3JkZXJJbWFnZV9PYmplY3QsIEJvcmRlcl9TdHlsZVR5cGUsIEdyaWRUZW1wbGF0ZUFyZWFzX1N0eWxlVHlwZSxcclxuICAgIEdyaWRUZW1wbGF0ZUFyZWFEZWZpbml0aW9uLCBHcmlkVHJhY2ssIEdyaWRUZW1wbGF0ZUF4aXNfU3R5bGVUeXBlLCBNYXJrZXJfU3R5bGVUeXBlLFxyXG4gICAgQm94U2hhZG93X1N0eWxlVHlwZSwgQm94U2hhZG93X1NpbmdsZSxcclxufSBmcm9tIFwiLi4vYXBpL1N0eWxlVHlwZXNcIjtcclxuaW1wb3J0IHsgQ3VzdG9tVmFyX1N0eWxlVHlwZSwgSVN0eWxlc2V0LCBTdHJpbmdTdHlsZXNldCwgU3R5bGVzZXQsIFZhclRlbXBsYXRlTmFtZSB9IGZyb20gXCIuLi9hcGkvU3R5bGVzZXRzXCI7XHJcbmltcG9ydCB7SUlEUnVsZX0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHt2MnMsIFYyU09wdGlvbnMsIG8ycywgV0tGLCBhMnMsIHdrZiwgY2FtZWxUb0Rhc2gsIGRhc2hUb0NhbWVsLCBBbnlUb1N0cmluZ0Z1bmN9IGZyb20gXCIuL1V0aWxzXCI7XHJcbmltcG9ydCB7Z2V0VmFyc0Zyb21TRH0gZnJvbSBcIi4uL3J1bGVzL1J1bGVDb250YWluZXJcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEZ1bmN0aW9ucyBmb3IgY29udmVydGluZyBDU1MgcHJvcGVydHkgdHlwZXMgdG8gc3RyaW5ncy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5jb25zdCBib3JkZXJJbWFnZVRvU3RyaW5nID0gKHZhbDogQm9yZGVySW1hZ2VfT2JqZWN0KTogc3RyaW5nID0+XHJcbntcclxuICAgIC8vIGlmIHdpZHRoIGlzIHNwZWNpZmllZCwgYnV0IHNsaWNlIGlzIG5vdCwgd2UgbmVlZCB0byBzZXQgc2xpY2UgdG8gdGhlIGRlZmF1bHQgMTAwJSB2YWx1ZTtcclxuICAgIC8vIGlmIG91dHNldCBpcyBzcGVjaWZpZWQgYnV0IHdpZHRoIGlzIG5vdC4gd2UgbmVlZCB0byBzZXQgd2lkdGggdG8gdGhlIGRlZmF1bHQgMSB2YWx1ZTtcclxuICAgIGxldCB2YWxDb3B5OiBCb3JkZXJJbWFnZV9PYmplY3QgPSBPYmplY3QuYXNzaWduKCB7fSwgdmFsKTtcclxuICAgIGlmICh2YWwuc2xpY2UgPT0gbnVsbCAmJiAodmFsLndpZHRoICE9IG51bGwgfHwgdmFsLm91dHNldCAhPSBudWxsKSlcclxuICAgICAgICB2YWxDb3B5LnNsaWNlID0gXCIxMDAlXCI7XHJcbiAgICBpZiAodmFsLndpZHRoID09IG51bGwgJiYgdmFsLm91dHNldCAhPSBudWxsKVxyXG4gICAgICAgIHZhbENvcHkud2lkdGggPSAxO1xyXG5cclxuICAgIHJldHVybiBvMnMoIHZhbENvcHksIFtcclxuICAgICAgICBcInNvdXJjZVwiLFxyXG4gICAgICAgIFwic2xpY2VcIixcclxuICAgICAgICBbXCJ3aWR0aFwiLCB1bmRlZmluZWQsIFwiL1wiXSxcclxuICAgICAgICBbXCJvdXRzZXRcIiwgdW5kZWZpbmVkLCBcIi9cIl0sXHJcbiAgICAgICAgXCJyZXBlYXRcIixcclxuICAgICAgICBcIm1vZGVcIlxyXG4gICAgXSk7XHJcbn1cclxuXHJcblxyXG5cclxud2tmW1dLRi5Cb3hTaGFkb3dTaW5nbGVdID0gKHZhbDogQm94U2hhZG93X1NpbmdsZSkgPT4gdjJzKCB2YWwsIHtcclxuICAgIG9iajpbXHJcbiAgICAgICAgW1wiaW5zZXRcIiwgKHY6IGJvb2xlYW4pID0+IHYgPyBcImluc2V0XCIgOiBcIlwiXSxcclxuICAgICAgICBbXCJ4XCIsIFdLRi5MZW5ndGhdLFxyXG4gICAgICAgIFtcInlcIiwgV0tGLkxlbmd0aF0sXHJcbiAgICAgICAgW1wiYmx1clwiLCBXS0YuTGVuZ3RoXSxcclxuICAgICAgICBbXCJzcHJlYWRcIiwgV0tGLkxlbmd0aF0sXHJcbiAgICAgICAgW1wiY29sb3JcIiwgV0tGLkNvbG9yXVxyXG4gICAgXVxyXG59KTtcclxuXHJcbndrZltXS0YuQm94U2hhZG93XSA9ICh2YWw6IEJveFNoYWRvd19TdHlsZVR5cGUpID0+IHYycyggdmFsLCB7XHJcbiAgICBvYmo6IFdLRi5Cb3hTaGFkb3dTaW5nbGUsXHJcbiAgICBpdGVtOiBXS0YuQm94U2hhZG93U2luZ2xlLFxyXG4gICAgc2VwOiBcIixcIlxyXG59KTtcclxuXHJcblxyXG5cclxud2tmW1dLRi5Cb3JkZXJdID0gKHZhbDogRXh0ZW5kZWQ8Qm9yZGVyX1N0eWxlVHlwZT4pOiBzdHJpbmcgPT4gdjJzKCB2YWwsIHtcclxuICAgIG51bTogV0tGLkxlbmd0aCxcclxuICAgIGFycjogYXJyID0+IHtcclxuICAgICAgICBsZXQgbnVtYmVyc1Byb2Nlc3NlZCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGEycyggYXJyLCBpdGVtID0+IHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiXHJcbiAgICAgICAgICAgID8gdjJzKCBpdGVtLCBudW1iZXJzUHJvY2Vzc2VkKysgPyBXS0YuQ29sb3IgOiBXS0YuTGVuZ3RoKVxyXG4gICAgICAgICAgICA6IHYycyhpdGVtKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IGdyaWRUZW1wbGF0ZUFyZWFzVG9TdHJpbmcgPSAodmFsOiBFeHRlbmRlZDxHcmlkVGVtcGxhdGVBcmVhc19TdHlsZVR5cGU+KTogc3RyaW5nID0+XHJcbiAgICAvLyB2YWwgY2FuIGJlIGFycmF5IG9mIHN0cmluZ3Mgb3IgR3JpZFRlbXBsYXRlQXJlYV9EZWZpbml0aW9uIHRvdXBsZXNcclxuICAgIHYycyggdmFsLCB7XHJcbiAgICAgICAgYXJyOiB2ID0+IHR5cGVvZiB2WzBdID09PSBcInN0cmluZ1wiID8gYTJzKCB2LCBXS0YuUXVvdGVkKSA6IGNyZWF0ZUdyaWRUZW1wbGF0ZUFyZWFzRnJvbURlZmluaXRpb25zKHYpXHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBhcnJheSBvZiBHcmlkVGVtcGxhdGVBcmVhX0RlZmluaXRpb24gb2JqZWN0cyB0byBhIHN0cmluZyB0aGF0IGlzIHN1aXRhYmxlIGZvclxyXG4gKiB0aGUgZ3JpZC10ZW1wbGF0ZS1hcmVhcyBmb3JtYXQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVHcmlkVGVtcGxhdGVBcmVhc0Zyb21EZWZpbml0aW9ucyA9IChkZWZzOiBHcmlkVGVtcGxhdGVBcmVhRGVmaW5pdGlvbltdKTogc3RyaW5nID0+XHJcbntcclxuICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBzaXplIG9mIHRoZSBtYXRyaXggZnJvbSB0aGUgYXJlYXMnIHNpemVzXHJcbiAgICBsZXQgcm93Q291bnQgPSAwLCBjb2xDb3VudCA9IDA7XHJcbiAgICBmb3IoIGxldCBkZWYgb2YgZGVmcylcclxuICAgIHtcclxuICAgICAgICByb3dDb3VudCA9IE1hdGgubWF4KCByb3dDb3VudCwgZGVmWzNdKTtcclxuICAgICAgICBjb2xDb3VudCA9IE1hdGgubWF4KCBjb2xDb3VudCwgZGVmWzRdKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocm93Q291bnQgPT09IDAgfHwgY29sQ291bnQgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgLy8gY3JlYXRlIGFycmF5IG9mIHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBjZWxsc1xyXG4gICAgbGV0IG1hdHJpeCA9IG5ldyBBcnJheTxzdHJpbmdbXT4ocm93Q291bnQpO1xyXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKVxyXG4gICAgICAgIG1hdHJpeFtpXSA9IG5ldyBBcnJheTxzdHJpbmc+KGNvbENvdW50KTtcclxuXHJcbiAgICAvLyBnbyBvdmVyIGRlZmluaXRpb25zIGFuZCBmaWxsIHRoZSBhcHByb3ByaWF0ZSBwbGFjZXMgaW4gdGhlIGNlbGxzIHdpdGggYXJlYSBuYW1lc1xyXG4gICAgZm9yKCBsZXQgZGVmIG9mIGRlZnMpXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSB2MnMoIGRlZlswXSk7XHJcbiAgICAgICAgZm9yKCBsZXQgaSA9IGRlZlsxXTsgaSA8PSBkZWZbM107IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciggbGV0IGogPSBkZWZbMl07IGogPD0gZGVmWzRdOyBqKyspXHJcbiAgICAgICAgICAgICAgICBtYXRyaXhbaS0xXVtqLTFdID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ28gb3ZlciBvdXIgbWF0cml4IGFuZCBmb3IgZXZlcnkgcm93IGNyZWF0ZSBhIHF1b3RlZCBzdHJpbmcuIFNpbmNlIG91ciBjZWxsIGFycmF5cyBtYXkgYmVcclxuICAgIC8vIHNwYXJzZSwgdXNlIGRvdCBmb3IgdGhlIHVuZGVmaW5lZCBjZWxsc1xyXG4gICAgbGV0IHMgPSBcIlwiO1xyXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGxldCByb3dOYW1lczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBmb3IoIGxldCBqID0gMDsgaiA8IHJvd0NvdW50OyBqKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgbmFtZSA9IG1hdHJpeFtpXVtqXTtcclxuICAgICAgICAgICAgcm93TmFtZXMucHVzaCggbmFtZSA/IG5hbWUgOiBcIi5cIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHMgKz0gYFwiJHtyb3dOYW1lcy5qb2luKFwiIFwiKX1cIlxcbmA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHM7XHJcbn1cclxuXHJcblxyXG5cclxud2tmW1dLRi5HcmlkVHJhY2tdID0gKHY6IEdyaWRUcmFjaykgPT4gdjJzKCB2LCB7XHJcbiAgICBudW06IFdLRi5MZW5ndGgsXHJcbiAgICBhcnI6IHYgPT4gYFske2Eycyh2KX1dYFxyXG59KTtcclxuXHJcblxyXG5cclxud2tmW1dLRi5HcmlkQXhpc10gPSAodjogRXh0ZW5kZWQ8R3JpZFRlbXBsYXRlQXhpc19TdHlsZVR5cGU+KSA9PiB2MnMoIHYsIHtcclxuICAgIG51bTogV0tGLkxlbmd0aCxcclxuICAgIGl0ZW06IFdLRi5HcmlkVHJhY2tcclxufSk7XHJcblxyXG5cclxuXHJcbndrZltXS0YuTWFya2VyXSA9ICh2YWw6IEV4dGVuZGVkPE1hcmtlcl9TdHlsZVR5cGU+KTogc3RyaW5nID0+XHJcbntcclxuICAgIHJldHVybiB2MnMoIHZhbCwge1xyXG4gICAgICAgIG9iajogdiA9PiBgdXJsKCMkeyh2IGFzIElJRFJ1bGUpLm5hbWV9KWBcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBGdW5jdGlvbnMgZm9yIGhhbmRsaW5nIFN0eWxlc2V0cy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIHN0eWxlIHByb3BlcnR5IHRvIHRoZSBDU1Mgc3R5bGUgc3RyaW5nLiBQcm9wZXJ0eSBuYW1lIGNhbiBiZSBpbiBlaXRoZXJcclxuICogZGFzaCBvciBjYW1lbCBmb3JtLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNwMnMgPSAocHJvcE5hbWU6IHN0cmluZywgcHJvcFZhbDogYW55KTogc3RyaW5nID0+XHJcbntcclxuICAgIGlmICghcHJvcE5hbWUpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgLy8gaGFuZGxlIHNwZWNpYWwgcHJvcGVydGllcyBcIiFcIiBhbmQgXCJbXVwiXHJcbiAgICBsZXQgaW1wRmxhZyA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsID09PSBcIm9iamVjdFwiKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChcIiFcIiBpbiBwcm9wVmFsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBcIiFcIiBwcm9wZXJ0eSwgdGhlbiB0aGUgYWN0dWFsIHZhbHVlIGlzXHJcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGFuZCB3ZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBcIiFpbXBvcnRhbnRcIiBmbGFnLlxyXG4gICAgICAgICAgICBwcm9wVmFsID0gcHJvcFZhbFtcIiFcIl07XHJcbiAgICAgICAgICAgIGltcEZsYWcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcIltdXCIgaW4gcHJvcFZhbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgXCJbXVwiIHByb3BlcnR5LCB0aGVuIHdlIHRha2UgdGhlIGxhc3RcclxuICAgICAgICAgICAgLy8gdmFsdWUgZnJvbSB0aGlzIHByb3BlcnR5J3MgYXJyYXkuXHJcbiAgICAgICAgICAgIGxldCBhcnIgPSBwcm9wVmFsW1wiW11cIl0gYXMgYW55W107XHJcbiAgICAgICAgICAgIGlmICghYXJyIHx8IGFyci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlY3Vyc2Ugd2l0aCB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gc3AycyggcHJvcE5hbWUsIGFyclthcnIubGVuZ3RoLTFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29udmVydCB0aGUgdmFsdWUgdG8gc3RyaW5nIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBvYmplY3QgZm9yIHRoZSBwcm9wZXJ0eSAoaWYgZGVmaW5lZClcclxuICAgIGxldCBzdHJpbmdWYWx1ZSA9IHYycyggcHJvcFZhbCwgc3R5bGVQcm9wZXJ0eUluZm9zW2Rhc2hUb0NhbWVsKHByb3BOYW1lKV0pO1xyXG4gICAgaWYgKCFzdHJpbmdWYWx1ZSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICBpZiAoaW1wRmxhZylcclxuICAgICAgICBzdHJpbmdWYWx1ZSArPSBcIiAhaW1wb3J0YW50XCI7XHJcblxyXG4gICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc3R5bGVzZXQgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbiAqL1xyXG5leHBvcnQgY29uc3QgczJzID0gKHN0eWxlc2V0OiBTdHlsZXNldCk6IHN0cmluZyA9PlxyXG57XHJcbiAgICBpZiAoIXN0eWxlc2V0KVxyXG4gICAgICAgIHJldHVybiBcInt9XCI7XHJcblxyXG4gICAgbGV0IHMgPSBcIntcIjtcclxuXHJcbiAgICAvLyBlbnVtZXJhdGUgYWxsIHN0eWxlc2V0IHByb3BlcnRpZXMgcmV0cmlldmluZyBhbHNvIHZlbmRvci1wcmVmaXhlZCB2YXJpYW50c1xyXG5cdGZvckFsbFByb3BzSW5TdHlsc2V0KFxyXG4gICAgICAgIHN0eWxlc2V0LFxyXG4gICAgICAgIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLCBpc0N1c3RvbTogYm9vbGVhbiwgaXNQcmVmaXhlZDogYm9vbGVhbik6IHZvaWQgPT5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHMgKz0gaXNDdXN0b21cclxuICAgICAgICAgICAgICAgID8gYCR7bmFtZX06JHt2YWx1ZX07YFxyXG4gICAgICAgICAgICAgICAgOiBgJHtpc1ByZWZpeGVkID8gXCItXCIgOiBcIlwifSR7Y2FtZWxUb0Rhc2gobmFtZSl9OiR7dmFsdWV9O2A7XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gcyArIFwifVwiO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gU3R5bGVzZXQgb2JqZWN0IGludG8gYSBTdHJpbmdTdHlsZXNldCBvYmplY3QsIHdoZXJlIGVhY2ggU3R5bGVzZXQncyBwcm9wZXJ0eVxyXG4gKiBpcyBjb252ZXJ0ZWQgdG8gaXRzIHN0cmluZyB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzMnNzID0gKHN0eWxlc2V0OiBTdHlsZXNldCk6IFN0cmluZ1N0eWxlc2V0ID0+XHJcbntcclxuICAgIC8vIGVudW1lcmF0ZSBhbGwgc3R5bGVzZXQgcHJvcGVydGllcyB3aXRob3V0IHJldHJpZXZpbmcgdmVuZG9yLXByZWZpeGVkIHZhcmlhbnRzXHJcbiAgICBsZXQgcmVzOiBTdHJpbmdTdHlsZXNldCA9IHt9O1xyXG4gICAgZm9yQWxsUHJvcHNJblN0eWxzZXQoIHN0eWxlc2V0LCAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCA9PiB7cmVzW25hbWVdID0gdmFsdWV9KTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSB0dXBsZSB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdmVuZG9yIHByZWZpeGluZyBvbiBhIHByb3BlcnR5LlxyXG4gKiAtIHByb3BlcnR5IG5hbWUgKHRoYXQgbWF5IG9yIG1heSBub3QgYmUgcHJlZml4ZWQpLlxyXG4gKiAtIHByb3BlcnR5IHZhbHVlICh0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgcHJlZml4ZWQgaXRlbXMpXHJcbiAqL1xyXG50eXBlIFByb3BQcmVmaXhWYXJpYW50ID0gW3N0cmluZywgc3RyaW5nXTtcclxuXHJcblxyXG4vKiogVHVwbGUgdGhhdCBjb250YWlucyBuYW1lLCB0ZW1wbGF0ZSBhbmQgb3B0aW9uYWwgdmFsdWUgb2YgYSBjdXN0b20gQ1NTIHByb3BlcnR5IFZhclJ1bGUgKi9cclxudHlwZSBWYXJOVFYgPSBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZz9dO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogRXh0cmFjdHMgbmFtZSwgdGVtcGxhdGUgYW5kIHN0cmluZyB0dXBsZXMgZnJvbSB0aGUgZ2l2ZW4gY3VzdG9tIENTUyBwcm9wZXJ0eSBkZWZpbml0aW9uLlxyXG4gKiBAcGFyYW0gY3VzdG9tVmFyc1xyXG4gKi9cclxuY29uc3QgZ2V0VmFyc05UVnMgPSAoY3VzdG9tVmFyczogQ3VzdG9tVmFyX1N0eWxlVHlwZSk6IFZhck5UVltdID0+XHJcbntcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVZhcnMpKVxyXG4gICAge1xyXG4gICAgICAgIGxldCB2YXJOYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlOiBzdHJpbmc7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBhbnk7XHJcbiAgICAgICAgaWYgKGN1c3RvbVZhcnMubGVuZ3RoID09PSAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyTmFtZSA9IGN1c3RvbVZhcnNbMF0ubmFtZTtcclxuICAgICAgICAgICAgdGVtcGxhdGUgPSBjdXN0b21WYXJzWzBdLnRlbXBsYXRlO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGN1c3RvbVZhcnNbMV1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyTmFtZSA9IGN1c3RvbVZhcnNbMF07XHJcbiAgICAgICAgICAgIHRlbXBsYXRlID0gY3VzdG9tVmFyc1sxXTtcclxuICAgICAgICAgICAgdmFsdWUgPSBjdXN0b21WYXJzWzJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF2YXJOYW1lIHx8ICF0ZW1wbGF0ZSlcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICBpZiAoIXZhck5hbWUuc3RhcnRzV2l0aChcIi0tXCIpKVxyXG4gICAgICAgICAgICB2YXJOYW1lID0gXCItLVwiICsgdmFyTmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtbdmFyTmFtZSwgdGVtcGxhdGUsIHNwMnMoIHRlbXBsYXRlLCB2YWx1ZSldXTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBsZXQgdmFyUnVsZXMgPSBnZXRWYXJzRnJvbVNEKGN1c3RvbVZhcnMpO1xyXG4gICAgICAgIHJldHVybiB2YXJSdWxlcy5tYXAoIHZhclJ1bGUgPT4gW3ZhclJ1bGUuY3NzTmFtZSwgdmFyUnVsZS50ZW1wbGF0ZSxcclxuICAgICAgICAgICAgc3AycyggdmFyUnVsZS50ZW1wbGF0ZSwgdmFyUnVsZS5nZXRWYWx1ZSgpKV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBzaWduYXR1cmUgZm9yIGVudW1lcmF0aW5nIFN0eWxlc2V0IHByb3BlcnRpZXMgY29udmVydGVkIHRvIHN0cmluZ3NcclxuICovXHJcbnR5cGUgU3R5bGVzZXRQcm9wRW51bUNhbGxiYWNrID0gKG5hbWU6IHN0cmluZywgdmFsOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLFxyXG4gICAgaXNDdXN0b206IGJvb2xlYW4sIGlzUHJlZml4ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBGb3IgZWFjaCBwcm9wZXJ0eSAtIHJlZ3VsYXIgYW5kIGN1c3RvbSAtIGluIHRoZSBnaXZlbiBzdHlsZXNldCBpbnZva2VzIHRoZSBhcHByb3ByaWF0ZVxyXG4gKiBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIHByb3BlcnR5IG5hbWUgYW5kIHRoZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gc3RyaW5nLlxyXG4gKiBAcGFyYW0gc3R5bGVzZXRcclxuICogQHBhcmFtIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSBnZXRQcmVmaXhlZFZhcmlhbnRzIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHdlIG5lZWQgdG8gcmV0cmlldmUgcHJvcGVydHkgdmFyaWFudHMgd2l0aFxyXG4gKiB2ZW5kb3IgcHJlZml4ZXNcclxuICovXHJcbmNvbnN0IGZvckFsbFByb3BzSW5TdHlsc2V0ID0gKHN0eWxlc2V0OiBTdHlsZXNldCwgY2FsbGJhY2s6IFN0eWxlc2V0UHJvcEVudW1DYWxsYmFjaykgPT5cclxue1xyXG5cdGZvciggbGV0IHByb3BOYW1lIGluIHN0eWxlc2V0KVxyXG5cdHtcclxuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIG9mIHRoZSBcIi0tXCIgcHJvcGVydHksIHdoaWNoIGlzIGFuIGFycmF5IHdoZXJlIGVhY2ggaXRlbSBpc1xyXG4gICAgICAgIC8vIGEgdHdvLWl0ZW0gb3IgdGhyZWUtaXRlbSBhcnJheVxyXG5cdFx0aWYgKHByb3BOYW1lID09PSBcIi0tXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgY3VzdG9tVmFycyA9IHN0eWxlc2V0W3Byb3BOYW1lXSBhcyBDdXN0b21WYXJfU3R5bGVUeXBlW107XHJcbiAgICAgICAgICAgIGZvciggbGV0IGN1c3RvbVZhciBvZiBjdXN0b21WYXJzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1c3RvbVZhcilcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpbiBlYWNoIHR1cGxlLCB0aGUgZmlyc3QgZWxlbWVudCBpcyB2YXIgbmFtZSwgdGhlIHNlY29uZCBpcyB0ZW1wbGF0ZSBwcm9wZXJ0eSBhbmRcclxuICAgICAgICAgICAgICAgIC8vIHRoZSB0aGlyZCBpcyB0aGUgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnR2czogVmFyTlRWW10gPSBnZXRWYXJzTlRWcyggY3VzdG9tVmFyKTtcclxuICAgICAgICAgICAgICAgIGZvciggbGV0IG50diBvZiBudHZzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBudHZbMF0sIG50dlsyXSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBwcm9wVmFsID0gc3R5bGVzZXRbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAocHJvcFZhbCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgcHJvcGVydHkgY29udGFpbnMgYW4gYXJyYXkgb2YgdmFsdWVzIGJlaGluZCB0aGUgb2JqZWN0IHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBcIltdXCIgcHJvcGVydHkuIElmIG5vdCwgY29udmVydCB0aGUgc2luZ2xlIHZhbHVlIHRvIGFuIGFycmF5LCBzbyB0aGF0IHdlIGNhblxyXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGl0LlxyXG4gICAgICAgICAgICAgICAgbGV0IHByb3BBcnJheSA9IHByb3BWYWxbXCJbXVwiXSBhcyBhbnlbXTtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvcEFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BBcnJheSA9IFtwcm9wVmFsXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IoIGxldCBwcm9wVmFsIG9mIHByb3BBcnJheSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvcGVydHkgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcFN0cmluZyA9IHNwMnMoIHByb3BOYW1lLCBwcm9wVmFsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BTdHJpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmVuZG9yLXByZWZpeGVkIHZhcmlhbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhcmlhbnRzID0gZ2V0UHJlZml4VmFyaWFudHMoIHByb3BOYW1lIGFzIGtleW9mIElTdHlsZXNldCwgcHJvcFN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKCBsZXQgdmFyaWFudCBvZiB2YXJpYW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCB2YXJpYW50WzBdLCB2YXJpYW50WzFdLCBmYWxzZSwgdmFyaWFudFswXSAhPT0gcHJvcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIG9yaWdpbmFsbHkgZm91bmQgcHJvcCBuYW1lIGFuZCB3aXRoIChwZXJoYXBzIHVwZGF0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggcHJvcE5hbWUsIHByb3BTdHJpbmcsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBSZWdpc3RyeSBvZiBDU1MgcHJvcGVydGllcyB0aGF0IHNwZWNpZmllcyBob3cgdGhlaXIgdmFsdWVzIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5ncy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5leHBvcnQgY29uc3Qgc19yZWdpc3RlclNQID0gKG5hbWU6IHN0cmluZywgdG9TdHJpbmdGdW5jOiBBbnlUb1N0cmluZ0Z1bmMpID0+XHJcbiAgICBuYW1lIGluIHN0eWxlUHJvcGVydHlJbmZvcyA/IGZhbHNlIDogKHN0eWxlUHJvcGVydHlJbmZvc1tuYW1lXSA9IHRvU3RyaW5nRnVuYywgdHJ1ZSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gdGhlIFYyU09wdGlvbnMgb2JqZWN0cyBkZXNjcmliaW5nIGN1c3RvbSBhY3Rpb25zIG5lY2Vzc2FyeSB0b1xyXG4gKiBjb252ZXJ0IHRoZSBwcm9wZXJ0eSB2YWx1ZSB0byB0aGUgQ1NTLWNvbXBsaWFudCBzdHJpbmcuXHJcbiAqL1xyXG5jb25zdCBzdHlsZVByb3BlcnR5SW5mb3M6IHsgW0sgaW4gVmFyVGVtcGxhdGVOYW1lXT86IFYyU09wdGlvbnMgfSA9XHJcbntcclxuICAgIGFjY2VudENvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBhbmltYXRpb246IHtcclxuICAgICAgICBhbnk6IHsgb2JqOiBbXHJcbiAgICAgICAgICAgIFtcImR1cmF0aW9uXCIsIFdLRi5UaW1lXSxcclxuICAgICAgICAgICAgXCJmdW5jXCIsXHJcbiAgICAgICAgICAgIFtcImRlbGF5XCIsIFdLRi5UaW1lXSxcclxuICAgICAgICAgICAgW1wiY291bnRcIiwgV0tGLk51bWJlcl0sXHJcbiAgICAgICAgICAgIFwiZGlyZWN0aW9uXCIsXHJcbiAgICAgICAgICAgIFwibW9kZVwiLFxyXG4gICAgICAgICAgICBcInN0YXRlXCIsXHJcbiAgICAgICAgICAgIFwibmFtZVwiXHJcbiAgICAgICAgXX0sXHJcbiAgICAgICAgc2VwOiBcIixcIixcclxuICAgIH0sXHJcbiAgICBhbmltYXRpb25EZWxheTogV0tGLk11bHRpVGltZVdpdGhDb21tYSxcclxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBXS0YuTXVsdGlUaW1lV2l0aENvbW1hLFxyXG4gICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBhbmltYXRpb25GaWxsTW9kZTogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIGFuaW1hdGlvbk5hbWU6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBhbmltYXRpb25QbGF5U3RhdGU6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBhbmltYXRpb25UaW1pbmdGdW5jdGlvbjogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuXHJcbiAgICBiYWNrZ3JvdW5kOiB7XHJcbiAgICAgICAgbnVtOiBXS0YuQ29sb3IsXHJcbiAgICAgICAgYW55OiB7XHJcbiAgICAgICAgICAgIG51bTogV0tGLkNvbG9yLFxyXG4gICAgICAgICAgICBvYmo6IFtcclxuICAgICAgICAgICAgICAgIFtcImNvbG9yXCIsIFdLRi5Db2xvcl0sXHJcbiAgICAgICAgICAgICAgICBcImltYWdlXCIsXHJcbiAgICAgICAgICAgICAgICBbXCJwb3NpdGlvblwiLCBXS0YuUG9zaXRpb25dLFxyXG4gICAgICAgICAgICAgICAgW1wic2l6ZVwiLCBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsIFwiL1wiXSxcclxuICAgICAgICAgICAgICAgIFwicmVwZWF0XCIsXHJcbiAgICAgICAgICAgICAgICBcImF0dGFjaG1lbnRcIixcclxuICAgICAgICAgICAgICAgIFwib3JpZ2luXCIsXHJcbiAgICAgICAgICAgICAgICBcImNsaXBcIlxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXA6IFwiLFwiLFxyXG4gICAgfSxcclxuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYmFja2dyb3VuZEJsZW5kTW9kZTogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIGJhY2tncm91bmRDbGlwOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBiYWNrZ3JvdW5kT3JpZ2luOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uOiBXS0YuTXVsdGlQb3NpdGlvbixcclxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IFdLRi5NdWx0aVBvc2l0aW9uLFxyXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogV0tGLk11bHRpUG9zaXRpb24sXHJcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYmFja2dyb3VuZFNpemU6IHtcclxuICAgICAgICBudW06IFdLRi5MZW5ndGgsXHJcbiAgICAgICAgaXRlbTogeyBhbnk6IFdLRi5MZW5ndGggfSxcclxuICAgICAgICBzZXA6IFwiLFwiXHJcbiAgICB9LFxyXG4gICAgYmFzZWxpbmVTaGlmdDogV0tGLkxlbmd0aCxcclxuICAgIGJsb2NrU2l6ZTogV0tGLkxlbmd0aCxcclxuICAgIGJvcmRlcjogV0tGLkJvcmRlcixcclxuICAgIGJvcmRlckJsb2NrOiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVyQmxvY2tDb2xvcjogV0tGLkNvbG9ycyxcclxuICAgIGJvcmRlckJsb2NrRW5kOiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVyQmxvY2tFbmRDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgYm9yZGVyQmxvY2tFbmRXaWR0aDogV0tGLkxlbmd0aCxcclxuICAgIGJvcmRlckJsb2NrU3RhcnQ6IFdLRi5Cb3JkZXIsXHJcbiAgICBib3JkZXJCbG9ja1N0YXJ0Q29sb3I6IFdLRi5Db2xvcixcclxuICAgIGJvcmRlckJsb2NrU3RhcnRXaWR0aDogV0tGLkxlbmd0aCxcclxuICAgIGJvcmRlckJsb2NrV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJCb3R0b206IFdLRi5Cb3JkZXIsXHJcbiAgICBib3JkZXJCb3R0b21Db2xvcjogV0tGLkNvbG9yLFxyXG4gICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogV0tGLlJhZGl1cyxcclxuICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBXS0YuUmFkaXVzLFxyXG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJDb2xvcjogV0tGLkNvbG9ycyxcclxuICAgIGJvcmRlckVuZEVuZFJhZGl1czogV0tGLlJhZGl1cyxcclxuICAgIGJvcmRlckVuZFN0YXJ0UmFkaXVzOiBXS0YuUmFkaXVzLFxyXG4gICAgYm9yZGVySW1hZ2U6IHtcclxuICAgICAgICBvYmo6IGJvcmRlckltYWdlVG9TdHJpbmcsXHJcbiAgICB9LFxyXG4gICAgYm9yZGVySW5saW5lOiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVySW5saW5lQ29sb3I6IFdLRi5Db2xvcnMsXHJcbiAgICBib3JkZXJJbmxpbmVFbmQ6IFdLRi5Cb3JkZXIsXHJcbiAgICBib3JkZXJJbmxpbmVFbmRDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgYm9yZGVySW5saW5lRW5kV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJJbmxpbmVTdGFydDogV0tGLkJvcmRlcixcclxuICAgIGJvcmRlcklubGluZVN0YXJ0Q29sb3I6IFdLRi5Db2xvcixcclxuICAgIGJvcmRlcklubGluZVN0YXJ0V2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJJbmxpbmVXaWR0aDogV0tGLkxlbmd0aCxcclxuICAgIGJvcmRlckxlZnQ6IFdLRi5Cb3JkZXIsXHJcbiAgICBib3JkZXJMZWZ0Q29sb3I6IFdLRi5Db2xvcixcclxuICAgIGJvcmRlckxlZnRXaWR0aDogV0tGLkxlbmd0aCxcclxuICAgIGJvcmRlclJhZGl1czogV0tGLkJvcmRlclJhZGl1cyxcclxuICAgIGJvcmRlclJpZ2h0OiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgYm9yZGVyUmlnaHRXaWR0aDogV0tGLkxlbmd0aCxcclxuICAgIGJvcmRlclNwYWNpbmc6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIGJvcmRlclN0YXJ0RW5kUmFkaXVzOiBXS0YuUmFkaXVzLFxyXG4gICAgYm9yZGVyU3RhcnRTdGFydFJhZGl1czogV0tGLlJhZGl1cyxcclxuICAgIGJvcmRlclRvcDogV0tGLkJvcmRlcixcclxuICAgIGJvcmRlclRvcENvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBXS0YuUmFkaXVzLFxyXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IFdLRi5SYWRpdXMsXHJcbiAgICBib3JkZXJUb3BXaWR0aDogV0tGLkxlbmd0aCxcclxuICAgIGJvcmRlcldpZHRoOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBib3R0b206IFdLRi5MZW5ndGgsXHJcbiAgICBib3hTaGFkb3c6IFdLRi5Cb3hTaGFkb3csXHJcblxyXG4gICAgY2FyZXRDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgY2xpcDogIHtcclxuICAgICAgICBhcnI6IHYgPT4gYHJlY3QoJHt3a2ZbV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlXSh2KX1gXHJcbiAgICB9LFxyXG4gICAgY29sb3I6IFdLRi5Db2xvcixcclxuICAgIGNvbHVtbkdhcDogV0tGLkxlbmd0aCxcclxuICAgIGNvbHVtblJ1bGU6IFdLRi5Cb3JkZXIsXHJcbiAgICBjb2x1bW5SdWxlQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIGNvbHVtblJ1bGVXaWR0aDogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgY29sdW1uV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBjb250ZW50OiB7XHJcbiAgICAgICAgc3RyOiBXS0YuUXVvdGVkLFxyXG4gICAgICAgIGl0ZW06IFdLRi5RdW90ZWRcclxuICAgIH0sXHJcbiAgICBjdXJzb3I6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcblxyXG4gICAgZmlsbDogV0tGLkNvbG9yLFxyXG4gICAgZmlsbE9wYWNpdHk6IFdLRi5QZXJjZW50LFxyXG4gICAgZmxleDoge1xyXG4gICAgICAgIG51bTogV0tGLkxlbmd0aCxcclxuICAgICAgICBhcnI6IHtcclxuICAgICAgICAgICAgMzogW1dLRi5OdW1iZXIsIFdLRi5OdW1iZXIsIFdLRi5MZW5ndGhdXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGZsZXhCYXNpczogV0tGLkxlbmd0aCxcclxuICAgIGZsb29kQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIGZvbnQ6IHtcclxuICAgICAgICBpdGVtOiBXS0YuTGVuZ3RoLFxyXG4gICAgICAgIG9iajogW1xyXG4gICAgICAgICAgICBbXCJzdHlsZVwiLCBXS0YuRm9udFN0eWxlXSxcclxuICAgICAgICAgICAgXCJ2YXJpYW50XCIsXHJcbiAgICAgICAgICAgIFwid2VpZ2h0XCIsXHJcbiAgICAgICAgICAgIFwic3RyZXRjaFwiLFxyXG4gICAgICAgICAgICBbXCJzaXplXCIsIFdLRi5MZW5ndGhdLFxyXG4gICAgICAgICAgICBbXCJsaW5lSGVpZ2h0XCIsIHVuZGVmaW5lZCwgXCIvXCJdLFxyXG4gICAgICAgICAgICBcImZhbWlseVwiXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIGZvbnRTaXplOiBXS0YuTGVuZ3RoLFxyXG4gICAgZm9udFN0cmV0Y2g6IFdLRi5QZXJjZW50LFxyXG4gICAgZm9udFN0eWxlOiBXS0YuRm9udFN0eWxlLFxyXG5cclxuICAgIGdhcDogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgZ3JpZENvbHVtbkdhcDogV0tGLkxlbmd0aCxcclxuICAgIGdyaWRHYXA6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIGdyaWRSb3dHYXA6IFdLRi5MZW5ndGgsXHJcbiAgICBncmlkQXJlYTogV0tGLk9uZU9yTWFueVdpdGhTbGFzaCxcclxuICAgIGdyaWRBdXRvQ29sdW1uczogV0tGLkdyaWRBeGlzLFxyXG4gICAgZ3JpZEF1dG9Sb3dzOiBXS0YuR3JpZEF4aXMsXHJcbiAgICBncmlkQ29sdW1uOiBXS0YuT25lT3JNYW55V2l0aFNsYXNoLFxyXG4gICAgZ3JpZFJvdzogV0tGLk9uZU9yTWFueVdpdGhTbGFzaCxcclxuICAgIGdyaWRUZW1wbGF0ZUFyZWFzOiBncmlkVGVtcGxhdGVBcmVhc1RvU3RyaW5nLFxyXG4gICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogV0tGLkdyaWRBeGlzLFxyXG4gICAgZ3JpZFRlbXBsYXRlUm93czogV0tGLkdyaWRBeGlzLFxyXG5cclxuICAgIGhlaWdodDogV0tGLkxlbmd0aCxcclxuXHJcbiAgICBpbmxpbmVTaXplOiBXS0YuTGVuZ3RoLFxyXG4gICAgaW5zZXQ6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIGluc2V0QmxvY2s6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIGluc2V0QmxvY2tFbmQ6IFdLRi5MZW5ndGgsXHJcbiAgICBpbnNldEJsb2NrU3RhcnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBpbnNldElubGluZTogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgaW5zZXRJbmxpbmVFbmQ6IFdLRi5MZW5ndGgsXHJcbiAgICBpbnNldElubGluZVN0YXJ0OiBXS0YuTGVuZ3RoLFxyXG5cclxuICAgIGxlZnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBsZXR0ZXJTcGFjaW5nOiBXS0YuTGVuZ3RoLFxyXG4gICAgbGlnaHRpbmdDb2xvcjogV0tGLkNvbG9yLFxyXG5cclxuICAgIG1hcmdpbjogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgbWFyZ2luQmxvY2s6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIG1hcmdpbkJsb2NrRW5kOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWFyZ2luQmxvY2tTdGFydDogV0tGLkxlbmd0aCxcclxuICAgIG1hcmdpbkJvdHRvbTogV0tGLkxlbmd0aCxcclxuICAgIG1hcmdpbklubGluZTogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgbWFyZ2luSW5saW5lRW5kOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWFyZ2luSW5saW5lU3RhcnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXJnaW5MZWZ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgbWFyZ2luUmlnaHQ6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXJnaW5Ub3A6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXJrZXJFbmQ6IFdLRi5NYXJrZXIsXHJcbiAgICBtYXJrZXJNaWQ6IFdLRi5NYXJrZXIsXHJcbiAgICBtYXJrZXJTdGFydDogV0tGLk1hcmtlcixcclxuICAgIG1hc2tCb3JkZXI6IHtcclxuICAgICAgICBvYmo6IGJvcmRlckltYWdlVG9TdHJpbmcsXHJcbiAgICB9LFxyXG4gICAgbWFza0NsaXA6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBtYXNrQ29tcG9zaXRlOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgbWFza0ltYWdlOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgbWFza01vZGU6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBtYXNrT3JpZ2luOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgbWFza1Bvc2l0aW9uOiBXS0YuTXVsdGlQb3NpdGlvbixcclxuICAgIG1hc2tSZXBlYXQ6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBtYXNrU2l6ZToge1xyXG4gICAgICAgIG51bTogV0tGLkxlbmd0aCxcclxuICAgICAgICBpdGVtOiB7IGFueTogV0tGLkxlbmd0aCB9LFxyXG4gICAgICAgIHNlcDogXCIsXCJcclxuICAgIH0sXHJcbiAgICBtYXhCbG9ja1NpemU6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXhIZWlnaHQ6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXhJbmxpbmVTaXplOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWF4V2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBtaW5CbG9ja1NpemU6IFdLRi5MZW5ndGgsXHJcbiAgICBtaW5IZWlnaHQ6IFdLRi5MZW5ndGgsXHJcbiAgICBtaW5JbmxpbmVTaXplOiBXS0YuTGVuZ3RoLFxyXG5cdG1pbldpZHRoOiBXS0YuTGVuZ3RoLFxyXG5cclxuICAgIG9iamVjdFBvc2l0aW9uOiBXS0YuUG9zaXRpb24sXHJcbiAgICBvZmZzZXQ6IHtcclxuICAgICAgICBvYmo6IFtcclxuICAgICAgICAgICAgW1wicG9zaXRpb25cIiwgV0tGLlBvc2l0aW9uXSxcclxuICAgICAgICAgICAgXCJwYXRoXCIsXHJcbiAgICAgICAgICAgIFtcImRpc3RhbmNlXCIsIFdLRi5MZW5ndGhdLFxyXG4gICAgICAgICAgICBbXCJyb3RhdGVcIiwgeyBhbnk6IFdLRi5BbmdsZSB9XSxcclxuICAgICAgICAgICAgW1wiYW5jaG9yXCIsIFdLRi5Qb3NpdGlvbiwgXCIvXCJdLFxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBvZmZzZXRBbmNob3I6IFdLRi5Qb3NpdGlvbixcclxuICAgIG9mZnNldERpc3RhbmNlOiBXS0YuTGVuZ3RoLFxyXG4gICAgb2Zmc2V0UG9zaXRpb246IFdLRi5Qb3NpdGlvbixcclxuICAgIG9mZnNldFJvdGF0ZToge1xyXG4gICAgICAgIGFueTogV0tGLkFuZ2xlXHJcbiAgICB9LFxyXG4gICAgb3V0bGluZTogV0tGLkJvcmRlcixcclxuICAgIG91dGxpbmVDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgb3V0bGluZU9mZnNldDogV0tGLkxlbmd0aCxcclxuICAgIG92ZXJmbG93Q2xpcE1hcmdpbjogV0tGLkxlbmd0aCxcclxuXHJcbiAgICBwYWRkaW5nOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBwYWRkaW5nQmxvY2s6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIHBhZGRpbmdCbG9ja0VuZDogV0tGLkxlbmd0aCxcclxuICAgIHBhZGRpbmdCbG9ja1N0YXJ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgcGFkZGluZ0JvdHRvbTogV0tGLkxlbmd0aCxcclxuICAgIHBhZGRpbmdJbmxpbmU6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIHBhZGRpbmdJbmxpbmVFbmQ6IFdLRi5MZW5ndGgsXHJcbiAgICBwYWRkaW5nSW5saW5lU3RhcnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBwYWRkaW5nTGVmdDogV0tGLkxlbmd0aCxcclxuICAgIHBhZGRpbmdSaWdodDogV0tGLkxlbmd0aCxcclxuICAgIHBhZGRpbmdUb3A6IFdLRi5MZW5ndGgsXHJcbiAgICBwZXJzcGVjdGl2ZTogV0tGLkxlbmd0aCxcclxuICAgIHBlcnNwZWN0aXZlT3JpZ2luOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcblxyXG4gICAgcXVvdGVzOiB7XHJcbiAgICAgICAgaXRlbToge1xyXG4gICAgICAgICAgICBzdHI6IFdLRi5RdW90ZWQsXHJcbiAgICAgICAgICAgIGl0ZW06IFdLRi5RdW90ZWQsXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByaWdodDogV0tGLkxlbmd0aCxcclxuICAgIHJvdGF0ZToge1xyXG4gICAgICAgIG51bTogV0tGLkFuZ2xlLFxyXG4gICAgICAgIGFycjoge1xyXG4gICAgICAgICAgICAyOiBbV0tGLkRlZmF1bHQsIFdLRi5BbmdsZV0sXHJcbiAgICAgICAgICAgIGFueTogW1dLRi5EZWZhdWx0LCBXS0YuRGVmYXVsdCwgV0tGLkRlZmF1bHQsIFdLRi5BbmdsZV0sXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJvd0dhcDogV0tGLkxlbmd0aCxcclxuXHJcbiAgICBzY3JvbGxNYXJnaW46IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIHNjcm9sbE1hcmdpbkJsb2NrOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBzY3JvbGxNYXJnaW5CbG9ja0VuZDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbE1hcmdpbkJsb2NrU3RhcnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxNYXJnaW5Cb3R0b206IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxNYXJnaW5JbmxpbmU6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIHNjcm9sbE1hcmdpbklubGluZUVuZDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbE1hcmdpbklubGluZVN0YXJ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsTWFyZ2luTGVmdDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbE1hcmdpblJpZ2h0OiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsTWFyZ2luVG9wOiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsUGFkZGluZzogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgc2Nyb2xsUGFkZGluZ0Jsb2NrOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBzY3JvbGxQYWRkaW5nQmxvY2tFbmQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxQYWRkaW5nQmxvY2tTdGFydDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbFBhZGRpbmdCb3R0b206IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxQYWRkaW5nSW5saW5lOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBzY3JvbGxQYWRkaW5nSW5saW5lRW5kOiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsUGFkZGluZ0lubGluZVN0YXJ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsUGFkZGluZ0xlZnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxQYWRkaW5nUmlnaHQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxQYWRkaW5nVG9wOiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsYmFyQ29sb3I6IHtcclxuICAgICAgICBpdGVtOiBXS0YuQ29sb3JcclxuICAgIH0sXHJcbiAgICBzaGFwZU1hcmdpbjogV0tGLkxlbmd0aCxcclxuICAgIHN0b3BDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgc3Ryb2tlOiBXS0YuQ29sb3IsXHJcblxyXG4gICAgdGV4dENvbWJpbmVVcHJpZ2h0OiB7XHJcbiAgICAgICAgbnVtOiB2ID0+IGBkaWdpdHMgJHt2fWBcclxuICAgIH0sXHJcbiAgICB0ZXh0RGVjb3JhdGlvbjoge1xyXG4gICAgICAgIG51bTogV0tGLkNvbG9yLFxyXG4gICAgICAgIG9iajogW1xyXG4gICAgICAgICAgICBcImxpbmVcIixcclxuICAgICAgICAgICAgXCJzdHlsZVwiLFxyXG4gICAgICAgICAgICBbXCJjb2xvclwiLCBXS0YuQ29sb3JdLFxyXG4gICAgICAgICAgICBbXCJ0aGlja25lc3NcIiwgV0tGLkxlbmd0aF0sXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHRleHREZWNvcmF0aW9uQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIHRleHREZWNvcmF0aW9uVGhpY2tuZXNzOiBXS0YuTGVuZ3RoLFxyXG4gICAgdGV4dEVtcGhhc2lzOiBXS0YuQ29sb3IsXHJcbiAgICB0ZXh0RW1waGFzaXNDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgdGV4dEZpbGxDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgdGV4dEluZGVudDogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgdGV4dFNoYWRvdzogV0tGLkJveFNoYWRvdyxcclxuICAgIHRleHRTaXplQWRqdXN0OiBXS0YuUGVyY2VudCxcclxuICAgIHRleHRTdHJva2VDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgdGV4dFN0cm9rZVdpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgdG9wOiBXS0YuTGVuZ3RoLFxyXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICB0cmFuc2l0aW9uOiB7XHJcbiAgICAgICAgYW55OiB7IG9iajogW1xyXG4gICAgICAgICAgICBbXCJwcm9wZXJ0eVwiLCBjYW1lbFRvRGFzaF0sXHJcbiAgICAgICAgICAgIFtcImR1cmF0aW9uXCIsIFdLRi5UaW1lXSxcclxuICAgICAgICAgICAgXCJmdW5jXCIsXHJcbiAgICAgICAgICAgIFtcImRlbGF5XCIsIFdLRi5UaW1lXVxyXG4gICAgICAgIF19LFxyXG4gICAgICAgIHNlcDogXCIsXCIsXHJcbiAgICB9LFxyXG4gICAgdHJhbnNpdGlvbkRlbGF5OiBXS0YuTXVsdGlUaW1lV2l0aENvbW1hLFxyXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBXS0YuTXVsdGlUaW1lV2l0aENvbW1hLFxyXG4gICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgdHJhbnNsYXRlOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcblxyXG4gICAgdmVydGljYWxBbGlnbjogV0tGLkxlbmd0aCxcclxuXHJcbiAgICB3aWR0aDogV0tGLkxlbmd0aCxcclxuICAgIHdpbGxDaGFuZ2U6IHtcclxuICAgICAgICBzdHI6IGNhbWVsVG9EYXNoXHJcbiAgICB9LFxyXG4gICAgd29yZFNwYWNpbmc6IFdLRi5MZW5ndGgsXHJcblxyXG4gICAgem9vbTogV0tGLlBlcmNlbnQsXHJcblxyXG4gICAgLy8gcHJvcGVydGllcyBmb3IgQ1NTIHN5bnRheCB2YWx1ZXNcclxuICAgIFwiPG51bWJlcj4jXCI6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcblxyXG4gICAgXCI8bGVuZ3RoPlwiOiBXS0YuTGVuZ3RoLFxyXG4gICAgXCI8bGVuZ3RoPitcIjogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgXCI8bGVuZ3RoPiNcIjogeyBhbnk6IFdLRi5MZW5ndGgsIHNlcDogXCIsXCJ9LFxyXG5cclxuICAgIFwiPHBlcmNlbnRhZ2U+XCI6IFdLRi5QZXJjZW50LFxyXG4gICAgXCI8cGVyY2VudGFnZT4rXCI6IHsgYW55OiBXS0YuUGVyY2VudCB9LFxyXG4gICAgXCI8cGVyY2VudGFnZT4jXCI6IHsgYW55OiBXS0YuUGVyY2VudCwgc2VwOiBcIixcIn0sXHJcblxyXG4gICAgXCI8bGVuZ3RoLXBlcmNlbnRhZ2U+XCI6IFdLRi5MZW5ndGgsXHJcbiAgICBcIjxsZW5ndGgtcGVyY2VudGFnZT4rXCI6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIFwiPGxlbmd0aC1wZXJjZW50YWdlPiNcIjogeyBhbnk6IFdLRi5MZW5ndGgsIHNlcDogXCIsXCJ9LFxyXG5cclxuICAgIFwiPGFuZ2xlPlwiOiBXS0YuQW5nbGUsXHJcbiAgICBcIjxhbmdsZT4rXCI6IHsgYW55OiBXS0YuQW5nbGUgfSxcclxuICAgIFwiPGFuZ2xlPiNcIjogeyBhbnk6IFdLRi5BbmdsZSwgc2VwOiBcIixcIn0sXHJcblxyXG4gICAgXCI8dGltZT5cIjogV0tGLlRpbWUsXHJcbiAgICBcIjx0aW1lPitcIjogeyBhbnk6IFdLRi5UaW1lIH0sXHJcbiAgICBcIjx0aW1lPiNcIjogV0tGLk11bHRpVGltZVdpdGhDb21tYSxcclxuXHJcbiAgICBcIjxyZXNvbHV0aW9uPlwiOiBXS0YuUmVzb2x1dGlvbixcclxuICAgIFwiPHJlc29sdXRpb24+K1wiOiB7IGFueTogV0tGLlJlc29sdXRpb24gfSxcclxuICAgIFwiPHJlc29sdXRpb24+I1wiOiB7IGFueTogV0tGLlJlc29sdXRpb24sIHNlcDogXCIsXCJ9LFxyXG5cclxuICAgIFwiPGNvbG9yPlwiOiBXS0YuQ29sb3IsXHJcbiAgICBcIjxjb2xvcj4rXCI6IHsgYW55OiBXS0YuQ29sb3IgfSxcclxuICAgIFwiPGNvbG9yPiNcIjogeyBhbnk6IFdLRi5Db2xvciwgc2VwOiBcIixcIn0sXHJcblxyXG4gICAgXCI8aW1hZ2U+I1wiOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG5cclxuICAgIFwiPGN1c3RvbS1pZGVudD4jXCI6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcblxyXG4gICAgLy8gc3BlY2lhbCBwcm9wZXJ0aWVzIGZvciBJVmFyUnVsZSB0eXBlc1xyXG4gICAgXCI8c3RyaW5nPlwiOiBXS0YuUXVvdGVkLFxyXG4gICAgXCI8ZnJlcXVlbmN5PlwiOiBXS0YuRnJlcXVlbmN5LFxyXG4gICAgXCI8c2l6ZT5cIjogV0tGLkxlbmd0aCxcclxuICAgIFwiPHBvaW50PlwiOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBcIjxwb3NpdGlvbj5cIjogV0tGLlBvc2l0aW9uLFxyXG4gICAgXCI8bXVsdGktcG9zaXRpb24+XCI6IFdLRi5NdWx0aVBvc2l0aW9uLFxyXG4gICAgXCI8cmFkaXVzPlwiOiBXS0YuUmFkaXVzLFxyXG59O1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gVmVuZG9yIHByZWZpeCBzdXBwb3J0XHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuY29uc3QgZW51bSBWZW5kb3JQcmVmaXhcclxue1xyXG4gICAgd2Via2l0ID0gMSxcclxuICAgIG1veiA9IDIsXHJcbiAgICBtcyA9IDMsXHJcbn1cclxuXHJcbi8vIFZlbmRvciBwcmVmaXhlcyB3aXRoIGluZGV4ZXMgZnJvbSB0aGUgVmVuZG9yUHJlZml4IGVudW1lcmF0aW9uLiBUaGUgZmlyc3Qgb25lIGlzIG9ubHkgaGVyZSB0b1xyXG4vLyBhbGxvdyB0aGUgZmlyc3QgZW51bWVyYXRpb24gdmFsdWUgdG8gYmUgMSBhbmQgbm90IHplcm8uXHJcbmNvbnN0IHZlbmRvclByZWZpeFN0cmluZ3MgPSBbXCJcIiwgXCJ3ZWJraXRcIiwgXCJtb3pcIiwgXCJtc1wiXTtcclxuXHJcblxyXG4vLyBNb2RlIGluZGljYXRpbmcgdG8gd2hhdCBlbnRpdHkgdGhlIHByZWZpeCBzaG91bGQgYmUgYWRkZWQgaWYgYSBjZXJ0YWluIHZhbHVlIGlzIGZvdW5kIGluIHRoZVxyXG4vLyBwcm9wZXJ0eS5cclxuY29uc3QgZW51bSBWYWx1ZVByZWZpeE1vZGVcclxue1xyXG4gICAgLy8gQm90aCB0aGUgdmFsdWUgYW5kIHRoZSBwcm9wZXJ0eSBuYW1lIGFyZSBwcmVmaXhlZC5cclxuICAgIEJvdGggPSAwLFxyXG5cclxuICAgIC8vIE9ubHkgdGhlIHZhbHVlIGlzIHByZWZpeGVkXHJcbiAgICBWYWx1ZU9ubHkgPSAxLFxyXG5cclxuICAgIC8vIE9ubHkgdGhlIHByb3BlcnR5IG5hbWUgaXMgcHJlZml4ZWRcclxuICAgIFByb3BlcnR5T25seSA9IDIsXHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgZGVmaW5pbmcgYSB2YWx1ZSB3aGljaCBzaG91bGQgYmUgcHJlZml4ZWQgb3Igd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIHByb3BlcnR5IHNob3VsZCBiZVxyXG4gKiBwcmVmaXhlZC5cclxuICovXHJcbnR5cGUgVmFsdWVQcmVmaXhJbmZvID1cclxuICAgIHtcclxuICAgICAgICAvLyBWYWx1ZSB3aGljaCBzaG91bGQgYmUgcHJlZml4ZWQgb3Igd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBwcmVmaXhlZC5cclxuICAgICAgICB2YWw6IHN0cmluZztcclxuXHJcbiAgICAgICAgLy8gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgb3IgcHJvcGVydHkgb3IgYm90aCBzaG91bGQgYmUgcHJlZml4ZWQuIERlZmF1bHQgaXMgQm90aC5cclxuICAgICAgICBtb2RlPzogVmFsdWVQcmVmaXhNb2RlO1xyXG5cclxuICAgICAgICAvLyBBbHRlcm5hdGl2ZSBuYW1lIGZvciB0aGUgdmFsdWUgKHNvbWV0aW1lcyBhIHZhbHVlIGlzIG5vdCBqdXN0IHByZWZpeGVkLCBidXQgZ2V0c1xyXG4gICAgICAgIC8vIHdob2xseSBkaWZmZXJlbnQgbmFtZSkuXHJcbiAgICAgICAgYWx0Pzogc3RyaW5nO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBUeXBlIGRlZmluaW5nIGEgcHJvcGVydHkgd2hpY2ggc2hvdWxkIGJlIHByZWZpeGVkIG9yIHdob3NlIHZhbHVlcyBzaG91bGQgYmUgcHJlZml4ZWQuXHJcbiAqICAgLSBzdHJpbmcgLSBzcGVjaWZpZXMgdGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxyXG4gKiAgIC0gbnVtYmVyIC0gc3BlY2lmaWVzIHRoZSBzaW5nbGUgc3VwcG9ydGVkIHZlbmRvciBwcmVmaXhcclxuICovXHJcbnR5cGUgUHJvcFByZWZpeEluZm8gPSBzdHJpbmcgfCBudW1iZXIgfFxyXG4gICAge1xyXG4gICAgICAgIC8vIFByZWZpeCBpbmRleFxyXG4gICAgICAgIHA6IFZlbmRvclByZWZpeDtcclxuXHJcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmUgbmFtZSBmb3IgdGhlIHByb3BlcnR5IChzb21ldGltZXMgYSBwcm9wZXJ0eSBpcyBub3QganVzdCBwcmVmaXhlZCwgYnV0IGdldHNcclxuICAgICAgICAvLyB3aG9sbHkgZGlmZmVyZW50IG5hbWUpLlxyXG4gICAgICAgIGFsdD86IHN0cmluZztcclxuXHJcbiAgICAgICAgLy8gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIGFsd2F5cyBwcmVmaXhlZCBvciBvbmx5IGlmIGl0XHJcbiAgICAgICAgLy8gY29udGFpbnMgc3BlY2lhbCB2YWx1ZXMgc3BlY2lmaWVkIGJ5IHRoZSBgdmFsc2AgcHJvcGVydHkuXHJcbiAgICAgICAgdmFsc09ubHk/OiBib29sZWFuO1xyXG5cclxuICAgICAgICAvLyBBcnJheSBvZiBvYmplY3RzIHByb3ZpZGluZyBpbmZvbWF0aW9uIGFib3V0IHZhbHVlcyB3aGljaCBzaG91bGQgYmUgcHJlZml4ZWQgb3JcclxuICAgICAgICAvLyB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHByZWZpeGVkLlxyXG4gICAgICAgIHZhbHM/OiBWYWx1ZVByZWZpeEluZm9bXTtcclxuICAgIH07XHJcblxyXG5cclxuXHJcbmNvbnN0IGdldFByZWZpeFZhcmlhbnRzID0gKG5hbWU6IGtleW9mIElTdHlsZXNldCwgdmFsdWU6IHN0cmluZyk6IFByb3BQcmVmaXhWYXJpYW50W10gfCBudWxsID0+XHJcbntcclxuICAgIGxldCBpbmZvID0gcHJvcFByZWZpeEluZm9zW25hbWVdO1xyXG4gICAgaWYgKCFpbmZvKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGlmICh0eXBlb2YgaW5mbyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICByZXR1cm4gW1tpbmZvLCB2YWx1ZV1dO1xyXG5cclxuICAgIGlmICh0eXBlb2YgaW5mbyA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICByZXR1cm4gW1tkYXNoVG9DYW1lbChgJHt2ZW5kb3JQcmVmaXhTdHJpbmdzW2luZm9dfS0ke25hbWV9YCksIHZhbHVlXV07XHJcblxyXG4gICAgbGV0IHZhcmlhbnRzOiBQcm9wUHJlZml4VmFyaWFudFtdID0gW107XHJcbiAgICBmb3IoIGxldCBpdGVtIG9mIGluZm8pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICB2YXJpYW50cy5wdXNoKCBbaXRlbSwgdmFsdWVdKTtcclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgdmFyaWFudHMucHVzaCggW2Rhc2hUb0NhbWVsKGAke3ZlbmRvclByZWZpeFN0cmluZ3NbaXRlbV19LSR7bmFtZX1gKSwgdmFsdWVdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgcHJlZml4U3RyaW5nID0gdmVuZG9yUHJlZml4U3RyaW5nc1tpdGVtLnBdO1xyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHByb3BlcnR5IG5hbWUgc2hvdWxkIGJlIHByZWZpeGVkLiBOb3RlIHRoYXQgZXZlbiBpZiB3ZSBkZWNpZGVcclxuICAgICAgICAgICAgLy8gaGVyZSB0aGF0IGl0IHNob3VsZCBub3QgYmUgcHJlZml4ZWQsIGl0IGNhbiBjaGFuZ2Ugd2hlbiB3ZSBnbyBvdmVyIHByb3BlcnR5IHZhbHVlcy5cclxuICAgICAgICAgICAgbGV0IHNob3VsZFByZWZpeFByb3BlcnR5ID0gIWl0ZW0udmFsc09ubHk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGRlZmluZWQsIHRyeSB0byByZXBsYWNlIHRoZW0gd2l0aCBwcmVmaXhlZCB2ZXJzaW9ucy4gTm90ZSB0aGF0XHJcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIGFsc28gc2V0IHRoZSBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgcHJvcGVydHkgbmFtZSBzaG91bGQgYmUgcHJlZml4ZWQgdG9vLlxyXG4gICAgICAgICAgICBsZXQgbmV3UHJvcFZhbHVlID0gXCJcIjtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGl0ZW0udmFscylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yKCBsZXQgdmFsdWVJbmZvIG9mIGl0ZW0udmFscylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVUb1NlYXJjaCA9IHZhbHVlSW5mby52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoIHZhbHVlVG9TZWFyY2gpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUluZm8ubW9kZSAhPT0gVmFsdWVQcmVmaXhNb2RlLlByb3BlcnR5T25seSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BWYWx1ZSA9IHZhbHVlLnNwbGl0KHZhbHVlVG9TZWFyY2gpLmpvaW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZm8uYWx0ID8gdmFsdWVJbmZvLmFsdCA6IGAtJHtwcmVmaXhTdHJpbmd9LSR7dmFsdWVUb1NlYXJjaH1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdQcm9wVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVJbmZvLm1vZGUgIT09IFZhbHVlUHJlZml4TW9kZS5WYWx1ZU9ubHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFByZWZpeFByb3BlcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IG5ld1Byb3BOYW1lID0gXCJcIjtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFByZWZpeFByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgbmV3UHJvcE5hbWUgPSBpdGVtLmFsdCA/IGl0ZW0uYWx0IDogZGFzaFRvQ2FtZWwoYCR7cHJlZml4U3RyaW5nfS0ke25hbWV9YCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmV3UHJvcE5hbWUgfHwgbmV3UHJvcFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgdmFyaWFudHMucHVzaCggW25ld1Byb3BOYW1lIHx8IG5hbWUsIG5ld1Byb3BWYWx1ZSB8fCB2YWx1ZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFyaWFudHMubGVuZ3RoID4gMCA/IHZhcmlhbnRzIDogbnVsbDtcclxufVxyXG5cclxuXHJcblxyXG4vLyBQcmVmaXggaW5mb3JtYXRpb24gZm9yIHNpemUtbGlrZSBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IFwic3RyZXRjaFwiIHZhbHVlXHJcbmNvbnN0IHNpemVQcmVmaXhJbmZvczogUHJvcFByZWZpeEluZm9bXSA9IFtcclxuICAgIHtwOiBWZW5kb3JQcmVmaXgud2Via2l0LCB2YWxzT25seTogdHJ1ZSwgdmFsczogW3t2YWw6IFwic3RyZXRjaFwiLCBtb2RlOiBWYWx1ZVByZWZpeE1vZGUuVmFsdWVPbmx5LCBhbHQ6IFwiLXdlYmtpdC1maWxsLWF2YWlsYWJsZVwifV19LFxyXG5dO1xyXG5cclxuLy8gUHJlZml4IGluZm9ybWF0aW9uIGZvciBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IFwiY3Jvc3MtZmFkZVwiIGFuZCBcImltYWdlLXNldFwiIGZ1bmN0aW9ucyAodGhhdCBpcywgaW1hZ2VzKVxyXG5jb25zdCBpbWFnZUZ1bmNzUHJlZml4SW5mbzogUHJvcFByZWZpeEluZm8gPSB7XHJcbiAgICBwOiBWZW5kb3JQcmVmaXgud2Via2l0LCB2YWxzT25seTogdHJ1ZSwgdmFsczogW1xyXG4gICAgICAgIHt2YWw6IFwiY3Jvc3MtZmFkZVwiLCBtb2RlOiBWYWx1ZVByZWZpeE1vZGUuVmFsdWVPbmx5IH0sXHJcbiAgICAgICAge3ZhbDogXCJpbWFnZS1zZXRcIiwgbW9kZTogVmFsdWVQcmVmaXhNb2RlLlZhbHVlT25seSB9XHJcbiAgICBdXHJcbn07XHJcblxyXG5jb25zdCBpbWFnZUZ1bmNzUHJlZml4SW5mb3M6IFByb3BQcmVmaXhJbmZvW10gPSBbaW1hZ2VGdW5jc1ByZWZpeEluZm9dO1xyXG5cclxuXHJcbmNvbnN0IHByb3BQcmVmaXhJbmZvczogeyBbSyBpbiBrZXlvZiBJU3R5bGVzZXRdPzogc3RyaW5nIHwgbnVtYmVyIHwgUHJvcFByZWZpeEluZm9bXSB9ID1cclxue1xyXG4gICAgYXBwZWFyYW5jZTogWyBWZW5kb3JQcmVmaXgud2Via2l0LCBWZW5kb3JQcmVmaXgubW96IF0sXHJcbiAgICBiYWNrZ3JvdW5kQ2xpcDogW1xyXG4gICAgICAgIHtwOiBWZW5kb3JQcmVmaXgud2Via2l0LCB2YWxzT25seTogdHJ1ZSwgdmFsczogW3t2YWw6IFwidGV4dFwiLCBtb2RlOiBWYWx1ZVByZWZpeE1vZGUuUHJvcGVydHlPbmx5fV19XHJcbiAgICBdLFxyXG4gICAgYmxvY2tTaXplOiBzaXplUHJlZml4SW5mb3MsXHJcbiAgICBib3hEZWNvcmF0aW9uQnJlYWs6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBiYWNrZ3JvdW5kOiBpbWFnZUZ1bmNzUHJlZml4SW5mb3MsXHJcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGltYWdlRnVuY3NQcmVmaXhJbmZvcyxcclxuICAgIGJvcmRlckltYWdlOiBpbWFnZUZ1bmNzUHJlZml4SW5mb3MsXHJcbiAgICBib3JkZXJJbWFnZVNvdXJjZTogaW1hZ2VGdW5jc1ByZWZpeEluZm9zLFxyXG4gICAgY2xpcFBhdGg6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBjb2xvckFkanVzdDogXCJ3ZWJraXRQcmludENvbG9yQWRqdXN0XCIsXHJcbiAgICBjb250ZW50OiBpbWFnZUZ1bmNzUHJlZml4SW5mb3MsXHJcbiAgICBoZWlnaHQ6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIGh5cGhlbnM6IFsgVmVuZG9yUHJlZml4LndlYmtpdCwgVmVuZG9yUHJlZml4Lm1veiwgVmVuZG9yUHJlZml4Lm1zIF0sXHJcbiAgICBpbml0aWFsTGV0dGVyOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgaW5saW5lU2l6ZTogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgbGluZUNsYW1wOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWFzazogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIG1hc2tCb3JkZXI6IFtcIndlYmtpdE1hc2tCb3hJbWFnZVwiLCBpbWFnZUZ1bmNzUHJlZml4SW5mb10sXHJcbiAgICBtYXNrQm9yZGVyT3V0c2V0OiBcIndlYmtpdE1hc2tCb3hJbWFnZU91dHNldFwiLFxyXG4gICAgbWFza0JvcmRlclJlcGVhdDogXCJ3ZWJraXRNYXNrQm94SW1hZ2VSZXBlYXRcIixcclxuICAgIG1hc2tCb3JkZXJTbGljZTogXCJ3ZWJraXRNYXNrQm94SW1hZ2VTbGljZVwiLFxyXG4gICAgbWFza0JvcmRlclNvdXJjZTogXCJ3ZWJraXRNYXNrQm94SW1hZ2VTb3VyY2VcIixcclxuICAgIG1hc2tCb3JkZXJXaWR0aDogXCJ3ZWJraXRNYXNrQm94SW1hZ2VXaWR0aFwiLFxyXG4gICAgbWFza0NsaXA6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBtYXNrQ29tcG9zaXRlOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWFza0ltYWdlOiBbVmVuZG9yUHJlZml4LndlYmtpdCwgaW1hZ2VGdW5jc1ByZWZpeEluZm9dLFxyXG4gICAgbWFza01vZGU6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBtYXNrT3JpZ2luOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWFza1Bvc2l0aW9uOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWFza1JlcGVhdDogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIG1hc2tTaXplOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWFza1R5cGU6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBtYXhCbG9ja1NpemU6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIG1heEhlaWdodDogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgbWF4SW5saW5lU2l6ZTogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgbWF4V2lkdGg6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIG1pbkJsb2NrU2l6ZTogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgbWluSGVpZ2h0OiBzaXplUHJlZml4SW5mb3MsXHJcbiAgICBtaW5JbmxpbmVTaXplOiBzaXplUHJlZml4SW5mb3MsXHJcbiAgICBtaW5XaWR0aDogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgc2hhcGVPdXRzaWRlOiBpbWFnZUZ1bmNzUHJlZml4SW5mb3MsXHJcbiAgICBzY3JvbGxiYXJDb2xvcjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHNjcm9sbGJhcldpZHRoOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgdGV4dEVtcGhhc2lzOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgdGV4dEVtcGhhc2lzQ29sb3I6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICB0ZXh0RW1waGFzaXNQb3NpdGlvbjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRFbXBoYXNpc1N0eWxlOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgdGV4dEZpbGxDb2xvcjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRPcmllbnRhdGlvbjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRTaXplQWRqdXN0OiBbIFZlbmRvclByZWZpeC53ZWJraXQsIFZlbmRvclByZWZpeC5tb3osIFZlbmRvclByZWZpeC5tcyBdLFxyXG4gICAgdGV4dFN0cm9rZTogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRTdHJva2VDb2xvcjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRTdHJva2VXaWR0aDogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHVzZXJTZWxlY3Q6IFtcclxuICAgICAgICB7cDogVmVuZG9yUHJlZml4LndlYmtpdCwgdmFsczogW3t2YWw6IFwibm9uZVwiLCBtb2RlOiBWYWx1ZVByZWZpeE1vZGUuUHJvcGVydHlPbmx5fV19XHJcbiAgICBdLFxyXG4gICAgd2lkdGg6IHNpemVQcmVmaXhJbmZvcyxcclxufVxyXG5cclxuXHJcblxyXG4iLCLvu78vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ2FzZSBjb252ZXJzaW9ucyBmb3IgcHJvcGVydHkgbmFtZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuaW1wb3J0IHsgSUNzc0Z1bmNPYmplY3QsIE50aEV4cHJlc3Npb24gfSBmcm9tIFwiLi4vYXBpL0NvcmVUeXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGRhc2hlLWNhc2UgdG8gY2FtZWxDYXNlLCBlLmcuIGZvbnQtc2l6ZSB0byBmb250U2l6ZS5cclxuICogQHBhcmFtIGRhc2hcclxuICovXHJcbmV4cG9ydCBjb25zdCBkYXNoVG9DYW1lbCA9IChkYXNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cclxuXHQhZGFzaCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoIC8tKFthLXpBLVpdKS9nLCAoeCwgJDEpID0+ICQxLnRvVXBwZXJDYXNlKCkpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgY2FtZWxDYXNlIHRvIGRhc2gtY2FzZSwgZS5nLiBmb250U2l6ZSB0byBmb250LXNpemUuXHJcbiAqIEBwYXJhbSBjYW1lbFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhbWVsVG9EYXNoID0gKGNhbWVsOiBzdHJpbmcpOiBzdHJpbmcgPT5cclxuICAgIGNhbWVsLnJlcGxhY2UoIC8oW2EtekEtWl0pKD89W0EtWl0pL2csICckMS0nKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ29udmVyc2lvbiBvZiB2YWx1ZXMgdG8gc3RyaW5ncy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogU3ltYm9sIHVuZGVyIHdoaWNoIGEgZnVuY3Rpb24gaXMgZGVmaW5lZCB0aGF0IGNvbnZlcnRzIGFuIG9iamVjdCB0byBhIHN0cmluZy4gV2UgbmVlZCBhIHNwZWNpYWxcclxuICogc3ltYm9sIGJlY2F1c2UgdGhlIHN0YW5kYXJkIG1ldGhvZCB0b1N0cmluZyBleGlzdHMgb24gZXZlcnkgb2JqZWN0IGFuZCB3ZSBvbmx5IHdhbnQgc29tZSB0b1xyXG4gKiBleHBsaWNpdGx5IHByb3ZpZGUgdGhpcyBzdXBwb3J0LlxyXG4gKi9cclxuIGV4cG9ydCBjb25zdCBzeW1WMlM6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2woKTtcclxuXHJcblxyXG5cclxuLyoqIFR5cGUgb2YgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHZhbHVlIG9mIGFyYml0cmFyeSB0eXBlIHRvIGEgc3RyaW5nICovXHJcbmV4cG9ydCB0eXBlIEFueVRvU3RyaW5nRnVuYyA9ICh2YWw6IGFueSkgPT4gc3RyaW5nO1xyXG5cclxuLyoqIFR5cGUgb2YgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIG51bWJlciB0byBhIHN0cmluZyAqL1xyXG5leHBvcnQgdHlwZSBOdW1iZXJUb1N0cmluZ0Z1bmMgPSAobjogbnVtYmVyKSA9PiBzdHJpbmc7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBOdW1lcmljIGlkZW50aWZpZXJzIGNvcnJlc3BvbmRpbmcgdG8gV2VsbCBLbm93biBGdW5jdGlvbnMgdXNlZCB0byBjb252ZXJ0IHN0eWxlIHByb3BlcnR5IHZhbHVlc1xyXG4gKiB0byBzdHJpbmdzLiBUaGlzIGlzIHVzZWQgdG8gcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBvYmplY3QgdXNlZCBmb3IgbWFwcGluZyBzdHlsZSBwcm9wZXJ0aWVzIHRvXHJcbiAqIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudW0gV0tGXHJcbntcclxuICAgIERlZmF1bHQgPSAwLFxyXG4gICAgTnVtYmVyLFxyXG4gICAgUGVyY2VudCxcclxuICAgIExlbmd0aCxcclxuICAgIEFuZ2xlLFxyXG4gICAgVGltZSxcclxuICAgIFJlc29sdXRpb24sXHJcbiAgICBGcmVxdWVuY3ksXHJcbiAgICBQb3NpdGlvbixcclxuICAgIEF0UG9zaXRpb24sXHJcbiAgICBBc3BlY3RSYXRpbyxcclxuICAgIENvbG9yLFxyXG4gICAgTXVsdGlQb3NpdGlvbixcclxuICAgIE11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgTXVsdGlUaW1lV2l0aENvbW1hLFxyXG4gICAgT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgT25lT3JNYW55V2l0aFNsYXNoLFxyXG4gICAgVW5pdGxlc3NPclBlcmNlbnQsXHJcbiAgICBSYWRpdXMsXHJcbiAgICBCb3JkZXIsXHJcbiAgICBCb3JkZXJSYWRpdXMsXHJcbiAgICBHcmlkQXhpcyxcclxuICAgIEdyaWRUcmFjayxcclxuICAgIFF1b3RlZCxcclxuICAgIEZvbnRTdHlsZSxcclxuICAgIEJveFNoYWRvd1NpbmdsZSxcclxuICAgIEJveFNoYWRvdyxcclxuICAgIEFsd2F5c1BlcmNlbnQsXHJcbiAgICBDb2xvclNlcGFyYXRpb24sXHJcbiAgICBNYXJrZXIsXHJcbiAgICBDb2xvcnMsXHJcblxyXG4gICAgLy8gaW5kaWNhdGVzIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG5lZWRlZCB0byBrZWVwIGNvbnZlcnNpb24gZnVuY3Rpb25zLiBUaGlzIGlzIHVzZWQgd2hlblxyXG4gICAgLy8gd2UgY3JlYXRlIHRoaXMgYXJyYXkgYmVsb3cuIEFueSBuZXcgZW51bWVyYXRpb24gbWVtYmVycyBtdXN0IGJlIGFkZGVkIGJlZm9yZSB0aGlzLlxyXG4gICAgTGFzdFxyXG59XHJcblxyXG4vKipcclxuICogQXJyYXkgb2Ygd2VsbCBrbm93biBjb252ZXJzaW9uIGZ1bmN0aW9ucy4gSW5kZXhlcyBhcmUgdGhlIGlkZW50aWZpZXIgb2Ygd2VsbCBrbm93biBmdW5jdGlvbnNcclxuICogZnJvbSB0aGUgV2VsbEtub3duRnVuYyBlbnVtZXJhdGlvblxyXG4gKi9cclxuZXhwb3J0IGxldCB3a2Y6IEFueVRvU3RyaW5nRnVuY1tdID0gbmV3IEFycmF5KCBXS0YuTGFzdCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUDJTT3B0aW9uIHR5cGUgZGVmaW5lcyBhIG5hbWUgb2YgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgYWxvbmcgd2l0aCB0aGUgb3B0aW9ucyBvZiBob3dcclxuICogdGhpcyBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcuIFRoZSB0eXBlIGlzIGVpdGhlciBhIHByb3BlcnR5IG5hbWUgb3IgYSB0dXBsZVxyXG4gKiB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgcHJvcGVydHkgbmFtZSBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBWMlNPcHRpb25zIHZhbHVlLlxyXG4gKiBJZiB0aGUgdHVwbGUgaGFzIGEgdGhpcmQgc3RyaW5nIGVsZW1lbnQgaXQgaXMgcGxhY2VkIGJlZm9yZSB0aGUgY29udmVydGVkIHByb3BlcnR5IHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUDJTT3B0aW9uID0gc3RyaW5nIHwgW3N0cmluZywgVjJTT3B0aW9ucz8sIHN0cmluZz9dO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBQMlNPcHRpb25zIHR5cGUgZGVmaW5lcyBuYW1lcyBvZiBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbG9uZyB3aXRoIHRoZSBvcHRpb25zIG9mIGhvd1xyXG4gKiBlYWNoIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZy4gVGhlIHR5cGUgaXMgYW4gYXJyYXkgb2YgZWl0aGVyIHByb3BlcnR5IG5hbWVzIG9yIHR1cGxlc1xyXG4gKiB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgcHJvcGVydHkgbmFtZSBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBWMlNPcHRpb25zIHZhbHVlLlxyXG4gKiBJZiB0aGUgdHVwbGUgaGFzIGEgdGhpcmQgc3RyaW5nIGVsZW1lbnQgaXQgaXMgcGxhY2VkIGJlZm9yZSB0aGUgY29udmVydGVkIHByb3BlcnR5IHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUDJTT3B0aW9ucyA9IFAyU09wdGlvbltdO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogRGVmaW5lcyBvcHRpb25zIHRvIHByb2Nlc3MgdHVwbGVzLiBQcm9wZXJ0eSBuYW1lcyBhcmUgYWN0dWFsbHkgaW50ZWdlciBudW1iZXJzLCB3aGNpaCBhcmVcclxuICogY29tcGFyZWQgdG8gdGhlIHR1cGxlcycgbGVuZ3Rocy5cclxuICovXHJcbmV4cG9ydCB0eXBlIFQyU09wdGlvbnMgPSB7IFtOOiBudW1iZXJdOiBWMlNPcHRpb25zW10sIGFueT86IFYyU09wdGlvbnNbXSB9O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFYyU09wdGlvbnMgdHlwZSBkZWZpbmVzIG9wdGlvbnMgb24gaG93IHRvIGNvbnZlcnQgdmFsdWVzIG9mIGRpZmZlcm50XHJcbiAqIHR5cGVzIHRvIHN0cmluZ3MuIEEgdmFsdWUgaXMgY29udmVydGVkIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHJ1bGVzOlxyXG4gKiAtIElmIHRoZSBvcHRpb24gaXMgYSBudW1iZXIgaXQgaXMgdHJlYXRlZCBhcyBhbiBJRCBvZiBhIHJlZ2lzdGVyZWQgY29udmVyc2lvbiBmdW5jdGlvbi5cclxuICogLSBJZiB0aGUgb3B0aW9uIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGludm9rZWQgdG8gY29udmVydCB0aGUgdmFsdWUuXHJcbiAqIC0gSWYgdGhlIG9wdGlvbiBpcyBhbiBvYmplY3QsIHRoZW4gZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSwgb25lIG9mIHRoZSBmcm9tWHh4XHJcbiAqICAgbWV0aG9kcyBkZWZpbmVzIGhvdyB0aGUgdmFsdWUgaXMgY29udmVydGVkLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgVjJTT3B0aW9ucyA9IFdLRiB8IEFueVRvU3RyaW5nRnVuYyB8XHJcbntcclxuICAgIC8vIFN0cmluZyB2YWx1ZSB0byB1c2Ugb3IgZnVuY3Rpb24gdG8gY2FsbCBpZiB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgbmlsPzogc3RyaW5nIHwgKCh2YWw/OiBudWxsKSA9PiBzdHJpbmcpO1xyXG5cclxuICAgIC8vIEZmdW5jdGlvbiB0byBjYWxsIGlmIHZhbHVlIGlzIGEgYm9vbGVhblxyXG4gICAgYm9vbD86ICh2YWw6IGJvb2xlYW4pID0+IHN0cmluZztcclxuXHJcbiAgICAvLyBPcHRpb25zIHRvIHVzZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy4gVGhpcyBhbGxvd3MgdHJhbnNmb3JtaW5nIG9uZSBzdHJpbmcgdG8gYW5vdGhlci5cclxuICAgIHN0cj86IFdLRiB8ICgodmFsOiBzdHJpbmcpID0+IHN0cmluZyk7XHJcblxyXG4gICAgLy8gT3B0aW9ucyB0byB1c2UgaWYgdmFsdWUgaXMgYSBudW1iZXJcclxuICAgIG51bT86IFdLRiB8IE51bWJlclRvU3RyaW5nRnVuYztcclxuXHJcbiAgICAvLyBPcHRpb25zIHRvIHVzZSBpZiB2YWx1ZSBpcyBhbiBhcnJheVxyXG4gICAgYXJyPzogV0tGIHwgVjJTT3B0aW9uc1tdIHwgVDJTT3B0aW9ucyB8ICgodmFsOiBhbnlbXSkgPT4gc3RyaW5nKTtcclxuXHJcbiAgICAvLyBPcHRpb25zIHRvIHVzZSBpZiB2YWx1ZSBpcyBhbiBhcnJheSBhbmQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgaXQgaXMgYWxzbyBhbiBhcnJheVxyXG4gICAgYXJyMj86IFdLRiB8IFYyU09wdGlvbnMgfCAoKHZhbDogYW55W10pID0+IHN0cmluZyk7XHJcblxyXG4gICAgLy8gT3B0aW9ucyB0byB1c2UgaWYgdmFsdWUgaXMgYW4gb2JqZWN0XHJcbiAgICBvYmo/OiBWMlNPcHRpb25zIHwgUDJTT3B0aW9ucztcclxuXHJcbiAgICAvLyBPcHRpb25zIHRvIHVzZSBpZiB0eXBlLXNwZWNpZmljIGZ1bmN0aW9uIGlzIG5vdCBkZWZpbmVkIGV4Y2VwdCBmb3IgbnVsbCBhbmQgc3RyaW5nIHZhbHVlcy5cclxuICAgIC8vIFRoaXMgaXMgYWxzbyB1c2VkIGZvciBhcnJheSBlbGVtZW50cyBpZiBhcnJJdGVtRnVuYyBpcyBub3QgZGVmaW5lZC5cclxuICAgIGFueT86IFYyU09wdGlvbnM7XHJcblxyXG4gICAgLy8gT3B0aW9ucyB0byB1c2UgdG8gY29udmVydCBlYWNoIGFycmF5IGl0ZW0gLSB1c2VkIG9ubHkgaWYgYGFycmAgaXMgbm90IGRlZmluZWRcclxuICAgIGl0ZW0/OiBWMlNPcHRpb25zO1xyXG5cclxuICAgIC8vIFNlcGFyYXRvciBmb3IgYXJyYXkgaXRlbXMgdXNlZCB3aXRoIHRoZSBpdGVtIG9yIG9iaiBwcm9wZXJ0aWVzLiBJZiBub3Qgc3BlY2lmaWVkLCBhXHJcbiAgICAvLyBzaW5nbGUgc3BhY2Ugd2lsbCBiZSB1c2VkLlxyXG4gICAgc2VwPzogc3RyaW5nO1xyXG5cclxuICAgIC8vIEZsYWcgaW5kaWNhdGluZyB0aGF0IHRoaXMgb3B0aW9uIG9iamVjdCBzaG91bGQgYmUgcGFzc2VkIHJlY3Vyc2l2ZWx5IGludG8gYXJyYXlzIHdpdGhpblxyXG4gICAgLy8gYXJyYXlzLlxyXG4gICAgcmVjdXJzaXZlPzogYm9vbGVhbjtcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgdmFsdWUgb2YgYW4gYXJiaXRyYXJ5IHR5cGUgdG8gYSBzaW5nbGUgc3RyaW5nLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXJcclxuICogY2FuIGRlZmluZSBob3cgc3BlY2lmaWMgdHlwZXMgYXJlIGNvbnZlcnRlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCB2MnMgPSAodmFsOiBhbnksIG9wdGlvbnM/OiBWMlNPcHRpb25zKTogc3RyaW5nID0+XHJcbntcclxuICAgIC8vIGlmIG9wdGlvbnMgaXMgbm90IHNwZWNpZmllZCwgZG8gc3RhbmRhcmQgcHJvY2Vzc2luZ1xyXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXHJcbiAgICAgICAgICAgIHJldHVybiBhMnMoIHZhbCk7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdjJzKHZhbCgpKTtcclxuICAgICAgICBlbHNlIGlmICh2YWwgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbFtzeW1WMlNdID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWxbc3ltVjJTXSgpO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwuZm4gPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBmZG8ycyggdmFsKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkbyBkaWZmZXJlbnQgdGhpbmdzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2Ygb3B0aW9uc1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgcmV0dXJuIHdrZltvcHRpb25zXSA/IHdrZltvcHRpb25zXSh2YWwpIDogXCJcIjtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICByZXR1cm4gb3B0aW9ucyggdmFsKTtcclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyBwcm9jZXNzaW5nIHdpdGggb3B0aW9ucy4gRm9yIGFsbCB0eXBlcyBleGNlcHQgbnVsbCBhbmQgc3RyaW5nLCBpZiB0aGUgdHlwZS1zcGVjaWZpY1xyXG4gICAgICAgIC8vIHByb3BlcnR5IGlzIG5vdCBkZWZpbmVkLCB1c2Ugb3B0aW9ucy5hbnkgaWYgZGVmaW5lZC5cclxuICAgICAgICBsZXQgbmV3T3B0aW9uczogVjJTT3B0aW9ucyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5uaWwgPyB0eXBlb2Ygb3B0aW9ucy5uaWwgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLm5pbCA6IG9wdGlvbnMubmlsKCB2YWwpIDogXCJcIjtcclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy5udW0gPz8gb3B0aW9ucy5hbnk7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdjJzKCB2YWwoKSk7XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCB2YWwubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmFyciA9PT0gXCJvYmplY3RcIikgLy8gdGhpcyBjYW4gYWxzbyBiZSBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQycyggdmFsLCBvcHRpb25zLmFyciwgb3B0aW9ucy5zZXApXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYXJyMiAmJiBBcnJheS5pc0FycmF5KHZhbFswXSkpXHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy5hcnIyO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmFycilcclxuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMgPSBvcHRpb25zLmFycjtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEycyggdmFsLCBvcHRpb25zLml0ZW0gPz8gb3B0aW9ucy5hbnkgPz8gKG9wdGlvbnMucmVjdXJzaXZlID8gb3B0aW9ucyA6IHVuZGVmaW5lZCksIG9wdGlvbnMuc2VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsW3N5bVYyU10gPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWxbc3ltVjJTXSgpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsLmZuID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkbzJzKCB2YWwpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9iaiB8fCBvcHRpb25zLmFueSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5vYmopKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvMnMoIHZhbCwgb3B0aW9ucy5vYmosIG9wdGlvbnMuc2VwKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy5vYmogPz8gb3B0aW9ucy5hbnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy5zdHIgPz8gb3B0aW9ucy5hbnk7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmJvb2wgPyBvcHRpb25zLmJvb2woIHZhbCkgOiB2YWwudG9TdHJpbmcoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICByZXR1cm4gdjJzKCB2YWwsIG5ld09wdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbndrZltXS0YuRGVmYXVsdF0gPSB2MnM7XHJcbndrZltXS0YuT25lT3JNYW55V2l0aENvbW1hXSA9IHYgPT4gdjJzKCB2LCB7IHNlcDogXCIsXCIgfSk7XHJcbndrZltXS0YuT25lT3JNYW55V2l0aFNsYXNoXSA9IHYgPT4gdjJzKCB2LCB7IHNlcDogXCIvXCIgfSk7XHJcbndrZltXS0YuUXVvdGVkXSA9IHYgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyBgXCIke3Z9XCJgIDogdjJzKHYpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGFycmF5IHRvIGEgc2luZ2xlIHN0cmluZyBieSBjb252ZXJ0aW5nIGV2ZXJ5IGl0ZW0gdXNpbmcgdGhlIGdpdmVuIG90aW9uc1xyXG4gKiBhbmQgam9pbmluZyB0aGUgcmVzdWx0cyB3aXRoIHRoZSBnaXZlbiBkZWxpbWl0ZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYTJzID0gKHZhbDogYW55W10sIG9wdGlvbnM/OiBWMlNPcHRpb25zLCBzZXBhcmF0b3I6IHN0cmluZyA9IFwiIFwiKTogc3RyaW5nID0+XHJcbiAgICAhdmFsIHx8IHZhbC5sZW5ndGggPT09IDBcclxuICAgICAgICA/IFwiXCJcclxuICAgICAgICA6IHZhbC5tYXAoIHYgPT4gdjJzKCB2LCBvcHRpb25zKSkuZmlsdGVyKCB2ID0+ICEhdikuam9pbiggc2VwYXJhdG9yKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhcnJheSB0byBhIHNpbmdsZSBzdHJpbmcgYnkgY29udmVydGluZyBldmVyeSBpdGVtIHVzaW5nIHRoZSBnaXZlbiBvdGlvbnNcclxuICogYW5kIGpvaW5pbmcgdGhlIHJlc3VsdHMgd2l0aCB0aGUgZ2l2ZW4gZGVsaW1pdGVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHQycyA9ICh2YWw6IGFueVtdLCBvcHRpb25zOiBWMlNPcHRpb25zW10gfCBUMlNPcHRpb25zLCBzZXBhcmF0b3I6IHN0cmluZyA9IFwiIFwiKTogc3RyaW5nID0+XHJcbntcclxuICAgIGxldCB2MnNPcHRpb25zID0gQXJyYXkuaXNBcnJheShvcHRpb25zKSA/IG9wdGlvbnMgOiAob3B0aW9uc1t2YWwubGVuZ3RoXSA/PyBvcHRpb25zLmFueSk7XHJcbiAgICBpZiAoIXYyc09wdGlvbnMpXHJcbiAgICAgICAgcmV0dXJuIGEycyggdmFsLCB1bmRlZmluZWQsIHNlcGFyYXRvcik7XHJcblxyXG4gICAgbGV0IGJ1Zjogc3RyaW5nW10gPSBbXTtcclxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgdjJzT3B0aW9ucy5sZW5ndGg7IGkrKylcclxuICAgICAgICBidWYucHVzaCggdjJzKCB2YWxbaV0sIHYyc09wdGlvbnNbaV0pKTtcclxuXHJcbiAgICByZXR1cm4gYnVmLmZpbHRlciggdiA9PiAhIXYpLmpvaW4oc2VwYXJhdG9yKTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHRvIHN0cmluZyBieSBjb252ZXJ0aW5nIGVhY2ggcHJvcGVydHkgZnJvbSB0aGUgb3B0aW9uc1xyXG4gKiBhcnJheSBhbmQgam9pbmluZyB0aGVtIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXHJcbiAqIEBwYXJhbSB2YWwgT2JqZWN0IHRvIGNvbnZlcnQgdG8gc3RyaW5nXHJcbiAqIEBwYXJhbSBvcHRpb25zIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9yIHR1cGxlcyB3aXRoIHByb3BlcnR5IG5hbWVzLCBvcHRpb25zIGFuZCBwcmVmaXhlcy5cclxuICogQHBhcmFtIHNlcGFyYXRvciBTZXBhcmF0b3IgY2hhcmFjdGVyLlxyXG4gKiBAcGFyYW0gZGVmYXVsdE9wdGlvbnMgLSBWMlNPcHRpb25zIGZvciB0aG9zZSBwcm9wZXJ0aWVzIGluIHRoZSBcInBhcmFtc1wiIGFycmF5IHRoYXQgZG9uJ3RcclxuICogZGVmaW5lIHRoZWlyIG93bi4gVGhpcyBzaG91bGQgYmUgdXNlZCBpbiB0aGUgY2FzZSB3aGVuIGFsbCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFyZSBvZiB0aGVcclxuICogc2FtZSB0eXBlXHJcbiAqIEBwYXJhbSBkZWZhdWx0UHJlZml4IC0gcHJlZml4IHRvIHVzZSBmb3IgdGhvc2UgcHJvcGVydGllcyBpbiB0aGUgXCJwYXJhbXNcIiBhcnJheSB0aGF0IGRvbid0XHJcbiAqIGRlZmluZSB0aGVpciBvd24gcHJlZml4XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbzJzID0gKHZhbDoge1twOnN0cmluZ106IGFueX0sIG9wdGlvbnM6IFAyU09wdGlvbnMsIHNlcGFyYXRvcj86IHN0cmluZyxcclxuICAgIGRlZmF1bHRPcHRpb25zPzogVjJTT3B0aW9ucywgZGVmYXVsdFByZWZpeD86IHN0cmluZyk6IHN0cmluZyA9PlxyXG57XHJcbiAgICBpZiAodmFsID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgbGV0IHBhcmFtczogc3RyaW5nW10gPSBbXTtcclxuICAgIGZvciggbGV0IG5hbWVPclR1cGxlIG9mIG9wdGlvbnMpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZTtcclxuICAgICAgICAvLyBpZiB0aGUgcHJvcGVydGllcyB2YWx1ZSBpcyBub3QgZGVmaW5lZCwgc2tpcCBpdC5cclxuICAgICAgICBsZXQgcHJvcE5hbWUgPSB0eXBlb2YgbmFtZU9yVHVwbGUgPT09IFwic3RyaW5nXCIgPyBuYW1lT3JUdXBsZSA6IG5hbWVPclR1cGxlWzBdO1xyXG4gICAgICAgIGxldCBwcm9wVmFsID0gdmFsW3Byb3BOYW1lXTtcclxuICAgICAgICBpZiAocHJvcFZhbCA9PSBudWxsKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgcHJlZml4XHJcbiAgICAgICAgbGV0IHByZWZpeCA9IHR5cGVvZiBuYW1lT3JUdXBsZSA9PT0gXCJzdHJpbmdcIiA/IGRlZmF1bHRQcmVmaXggOiBuYW1lT3JUdXBsZVsyXTtcclxuICAgICAgICBpZiAocHJlZml4KVxyXG4gICAgICAgICAgICBwYXJhbXMucHVzaCggcHJlZml4KTtcclxuXHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0eXBlb2YgbmFtZU9yVHVwbGUgPT09IFwic3RyaW5nXCIgPyBkZWZhdWx0T3B0aW9ucyA6IG5hbWVPclR1cGxlWzFdO1xyXG4gICAgICAgIHBhcmFtcy5wdXNoKCB2MnMoIHByb3BWYWwsIG9wdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyYW1zLmZpbHRlciggdiA9PiAhIXYpLmpvaW4oIHNlcGFyYXRvciA/PyBcIiBcIik7XHJcbn1cclxuXHJcblxyXG5cclxuLy8gVHlwZSByZXByZXNlbnRpbmcgYW4gYXJyYXkgb2YgdmFsdWVzIG9yIHR3by1pdGVtIHR1cGxlcyB3aGVyZSB0aGUgaXRlbSBpcyBhIHZhbHVlIGFuZCB0aGVcclxuLy8gc2Vjb25kIGl0ZW0gaXMgdGhlIFYyU09wdGlvbnMgb2JqZWN0IGRldGVybWluaW5nIGhvdyB0aGlzIHZhbHVlIHNob3VsZCBiZSBzZXJpYWxpemVkLlxyXG5leHBvcnQgdHlwZSBQYXJhbUxpc3RXaXRoT3B0aW9ucyA9IChhbnkgfCBbYW55LCBWMlNPcHRpb25zP10pW107XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmFsdWVzIHRvIGEgc2luZ2xlIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBvcHRpb25zIGFuZFxyXG4gKiB1c2luZyB0aGUgZ2l2ZW4gc2VwYXJhdG9yLiBGb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheSwgdGhlIHYycyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gY29udmVydFxyXG4gKiBpdCB0byBzdHJpbmcuXHJcbiAqIEBwYXJhbSB2YWx1ZXNcclxuICogQHBhcmFtIHNlcGFyYXRvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG12MnMgPSAodmFsdWVzOiBQYXJhbUxpc3RXaXRoT3B0aW9ucywgc2VwYXJhdG9yOiBzdHJpbmcgPSBcIiBcIik6IHN0cmluZyA9PlxyXG57XHJcbiAgICBpZiAodmFsdWVzID09IG51bGwgfHwgdmFsdWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICBsZXQgYXJyOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgZm9yKCBsZXQgaXRlbSBvZiB2YWx1ZXMpXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IHZhbDogYW55O1xyXG4gICAgICAgIGxldCBvcHRpb25zOiBWMlNPcHRpb25zIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsID0gaXRlbVswXTtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IGl0ZW1bMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFsID0gaXRlbTtcclxuXHJcbiAgICAgICAgaWYgKHZhbCB8fCAob3B0aW9ucyAmJiAob3B0aW9ucyBhcyBhbnkpLm5pbCkpXHJcbiAgICAgICAgICAgIGFyci5wdXNoKCB2MnMoIHZhbCwgb3B0aW9ucykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcnIuZmlsdGVyKCB2ID0+ICEhdikuam9pbiggc2VwYXJhdG9yKTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlcyBhcyBwYXJhbWV0ZXJzIHRvIHRoZSBnaXZlbiBDU1MgZnVuY3Rpb24gaW52b2NhdGlvbi5cclxuICogQHBhcmFtIG5hbWVcclxuICogQHBhcmFtIHZhbHVlc1xyXG4gKiBAcGFyYW0gc2VwYXJhdG9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZjJzID0gKG5hbWU6IHN0cmluZywgdmFsdWVzOiBQYXJhbUxpc3RXaXRoT3B0aW9ucywgc2VwYXJhdG9yID0gXCIsXCIpID0+XHJcbiAgICBgJHtuYW1lfSgke212MnMoIHZhbHVlcywgc2VwYXJhdG9yKX0pYDtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSB0YWcycyBpcyBhIHRhZyBmdW5jdGlvbiBoZWxwZXIgdGhhdCBjb252ZXJ0cyB0aGUgdGVtcGxhdGUgc3RyaW5nIHdpdGhcclxuICogcGFyYW1ldGVycyB0byBhIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucyBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdGFnMnMgPSAocGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCBwYXJhbXM6IGFueVtdLCBvcHRpb25zPzogVjJTT3B0aW9ucyk6IHN0cmluZyA9PlxyXG57XHJcbiAgICAvLyBudW1iZXIgb2YgcGFyYW1ldGVycyBpcyBhbHdheXMgMSBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBzdHJpbmcgcGFydHNcclxuICAgIGxldCBwYXJhbXNMZW4gPSBwYXJhbXMubGVuZ3RoO1xyXG4gICAgaWYgKHBhcmFtc0xlbiA9PT0gMClcclxuICAgICAgICByZXR1cm4gcGFydHNbMF07XHJcblxyXG4gICAgbGV0IHMgPSBcIlwiO1xyXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBwYXJhbXNMZW47IGkrKylcclxuICAgICAgICBzICs9IHBhcnRzW2ldICsgdjJzKCBwYXJhbXNbaV0sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgbGFzdCBwYXJ0XHJcbiAgICByZXR1cm4gcyArIHBhcnRzW3BhcmFtc0xlbl07XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIE9iamVjdCB0aGF0IHNwZWNpZnlpbmcgc3RyaW5nIHNlcmlhbGl6YXRpb24gb3B0aW9ucyBmb3IgcHJvcGVydGllcyBpbiBhIHByb3BlcnR5IHNldC4gRWFjaFxyXG4gKiBwcm9wZXJ0eSBvZiBhIHByb3BlcnR5IHNldCB3aWxsIGJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBWMlNPcHRpb25zIHBhcmFtZXRlciBpbiB0aGlzXHJcbiAqIG9iamVjdDsgaWYgdGhlIHByb3BlcnR5IGRvZXMgbm90IGFwcGVhciBpbiB0aGlzIG9iamVjdCwgdGhlIHYycyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBQcm9wU2V0SW5mb3MgPSB7IFtLOiBzdHJpbmddOiBWMlNPcHRpb25zIH07XHJcblxyXG4vKipcclxuICogT2JqZWN0IHRoYXQgc3BlY2lmaWVzIG9wdGlvbnMgZm9yIHN0cmluZyBzZXJpYWxpemF0aW9uIG9mIGEgcHJvcGVydHkgc2V0LlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUHJvcFNldDJTT3B0aW9ucyA9IHtcclxuICAgIHByZWZpeD86IHN0cmluZztcclxuICAgIHN1ZmZpeD86IHN0cmluZztcclxuICAgIHNlcGFyYXRvcj86IHN0cmluZztcclxuICAgIHByb3BGdW5jPzogKGRhc2hOYW1lOiBzdHJpbmcsIGNhbWVsTmFtZTogc3RyaW5nLCB2YWw6IGFueSwgb3B0aW9uczogVjJTT3B0aW9ucykgPT4gc3RyaW5nO1xyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIHByb3BlcnR5IHNldCBvYmplY3QgdG8gdGhlIENTUyBzdHlsZSBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcHJvcFNldDJzID0gKHZhbDogYW55LCBpbmZvczogUHJvcFNldEluZm9zLCBvcHRpb25zPzogUHJvcFNldDJTT3B0aW9ucyk6IHN0cmluZyA9PlxyXG4gICAgdjJzKCB2YWwsIHtcclxuICAgICAgICBvYmo6IHYgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoIHYpO1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZ1bmMgPSBvcHRpb25zPy5wcm9wRnVuYyA/PyBwcm9wSW5Qcm9wU2V0MnM7XHJcbiAgICAgICAgICAgIGxldCBhcnIgPSBwcm9wTmFtZXMubWFwKCAocHJvcE5hbWUpID0+XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBkYXNoUHJvcE5hbWUgPSBjYW1lbFRvRGFzaChwcm9wTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FtZWxQcm9wTmFtZSA9IGRhc2hUb0NhbWVsKHByb3BOYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jKCBkYXNoUHJvcE5hbWUsIGNhbWVsUHJvcE5hbWUsIHZbcHJvcE5hbWVdLCBpbmZvc1tjYW1lbFByb3BOYW1lXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKG9wdGlvbnM/LnByZWZpeCA/PyBcIlwiKSArIGAke2Fyci5qb2luKCBvcHRpb25zPy5zZXBhcmF0b3IgPz8gXCI7XCIpfWAgKyAob3B0aW9ucz8uc3VmZml4ID8/IFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLy8gY29udmVydCB0aGUgdmFsdWUgdG8gc3RyaW5nIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBvYmplY3QgZm9yIHRoZSBwcm9wZXJ0eSAoaWYgZGVmaW5lZClcclxuY29uc3QgcHJvcEluUHJvcFNldDJzID0gKGRhc2hOYW1lOiBzdHJpbmcsIGNhbWVsTmFtZTogc3RyaW5nLCB2YWw6IGFueSwgb3B0aW9uczogVjJTT3B0aW9ucyk6IHN0cmluZyA9PlxyXG4gICAgYCR7ZGFzaE5hbWV9OiR7IHYycyggdmFsLCBvcHRpb25zKX1gO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSB0aGF0IGRlZmluZXMgaG93IHRvIHNlcmlhbGl6ZSBhIHZhbHVlIGZvciBhbiBlbnRyeSBpbiB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbnMgb2JqZWN0LlxyXG4gKiBUaGUgdmFsdWUgY2FuIGJlIG9mIG9uZSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzIHdpdGggZWFjaCBjb3JyZXNwb25kaW5nIHRvIGEgY2VydGFpbiB3YXkgb2ZcclxuICogc3RyaW5nIHNlcmlhbGl6YXRpb246XHJcbiAqICAgLSBmdW5jdGlvbiAtIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkLlxyXG4gKiAgIC0gbnVtYmVyIC0gYWxsIG9iamVjdCBwcm9wZXJ0aWVzIGV4Y2VwdCBcImZuXCIgYXJlIGNvbnZlcnRlZCB1c2luZyB0aGUgY29ycmVzcG9uZGluZyBmdW5jdGlvblxyXG4gKiAgICAgZnJvbSB0aGUgV0tGIGVudW1lcmF0aW9uLiBTaW5jZSB0aGUgZW51bWVyYXRpbmcgb3JkZXIgb2YgdGhlIHByb3BlcnRpZXMgaXMgaW5kZXRlcm1pbmF0ZSxcclxuICogICAgIHRoaXMgb3B0aW9uIGlzIG9ubHkgZ29vZCBmb3IgZnVuY3Rpb25zIHdpdGggYSBzaW5nbGUgcGFyYW1ldGVyLlxyXG4gKiAgIC0gYXJyYXkgb2YgUDJTT3B0aW9uIHR5cGVzIC0gbzJzIGlzIGl2b2tlZFxyXG4gKiAgIC0gb2JqZWN0IC0gbWF5IGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKiAgICAgLSBvcHRpb25hbCBcImZuXCIgLSByZXBsYWNlcyBmdW5jdGlvbiBuYW1lLlxyXG4gKiAgICAgLSBvcHRpb25hbCBcInBcIiAtIGFycmF5IG9mIFAyU09wdGlvbiB0eXBlcywgZm9yIHdoaWNoIG8ycyBpcyBpbnZva2VkLlxyXG4gKiAgICAgLSBvcHRpb25hbCBcImZcIiAtIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbGlzdCBvZiBwYXJhbWV0ZXJzLlxyXG4gKiAgICAgLSBlaXRoZXIgXCJwXCIgb3IgXCJmXCIgbXVzdCBiZSBwcmVzZW50IGFuZCBcInBcIiBoYXMgcHJlY2VkZW5jZS5cclxuICogICAgIC0gb3B0aW9uYWwgXCJzZXBcIiBmb3Igc2VwYXJhdG9yIChkZWZhdWx0IGlzIFwiLFwiKS5cclxuICogICAgIC0gb3B0aW9uYWwgXCJkb1wiIC0gZGVmaW5lcyBWMlNPcHRpb25zIGZvciB0aG9zZSBwcm9wZXJ0aWVzIGluIHRoZSBcInBhcmFtc1wiIGFycmF5IHRoYXQgZG9uJ3RcclxuICogICAgICAgZGVmaW5lIHRoZWlyIG93bi4gVGhpcyBzaG91bGQgYmUgdXNlZCBpbiB0aGUgY2FzZSB3aGVuIGFsbCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFyZSBvZiB0aGVcclxuICogICAgICAgc2FtZSB0eXBlXHJcbiAqICAgICAtIG9wdGlvbmFsIFwiZHBcIiAtIGRlZmF1bHQgcHJlZml4IHRvIHVzZSBmb3IgdGhvc2UgcHJvcGVydGllcyBpbiB0aGUgXCJwYXJhbXNcIiBhcnJheSB0aGF0XHJcbiAqICAgICAgIGRvbid0IGRlZmluZSB0aGVpciBvd24gcHJlZml4XHJcbiAqL1xyXG50eXBlIEZkb09wdGlvbnMgPSBBbnlUb1N0cmluZ0Z1bmMgfCBudW1iZXIgfCBQMlNPcHRpb25zIHxcclxuICAgIHtcclxuICAgICAgICBmbj86IHN0cmluZyB8IEFueVRvU3RyaW5nRnVuYyxcclxuICAgICAgICBwPzogUDJTT3B0aW9ucyxcclxuICAgICAgICBmPzogQW55VG9TdHJpbmdGdW5jLFxyXG4gICAgICAgIHM/OiBzdHJpbmcsXHJcbiAgICAgICAgZG8/OiBWMlNPcHRpb25zLFxyXG4gICAgICAgIGRwPzogc3RyaW5nXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbi8vIFRoaXMgb2JqZWN0IGlzIGZpbGxlZCBpbiBpbiB0aGUgWHh4QVBJIGZpbGVzIHdoZXJlIHRoZSBmdW5jdGlvbnMgY29ycmVzcG9uZGluZyB0byBDU1MgZnVuY3Rpb25zXHJcbi8vIGFyZSBkZWZpbmVkLlxyXG5leHBvcnQgY29uc3QgZmRvOiB7IFtmbjogc3RyaW5nXTogRmRvT3B0aW9ucyB9ID0ge307XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmdW5jdGlvbiBkZWZpbml0aW9uIG9iamVjdCB0byBzdHJpbmcuIENvbnZlcnNpb24gaXMgcGVyZm9ybWVkIGFjY29yZGluZ1xyXG4gKiB0byB0aGUgdHlwZSBmb3VuZCBpbiB0aGUgXCJmZG9cIiBvYmplY3QgZm9yIHRoZSBwcm9wZXJ0eSBuYW1lIGVxdWFsIHRvIHRoZSBcImZuXCIgcHJvcGVydHkgb2ZcclxuICogdGhlIGdpdmVuIHZhbHVlLiBJZiBubyBzdWNoIHByb3BlcnR5IGV4aXN0IGluIHRoZSBcImZkb1wiIG9iamVjdCwgYWxsIG9iamVjdCdzIHByb3BlcnRpZXMgZXhjZXB0XHJcbiAqIFwiZm5cIiB3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmdzIHVzaW5nIHYycyBhbmQgY29uY2F0ZW5hdGVkIHdpdGggY29tbWEuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWwgRnVuY3Rpb24gZGVmaW5pdGlvbiBvYmplY3QgdGhhdCBoYXMgdGhlIFwiZm5cIiBwcm9wZXJ0eSBkZWZpbmluZyB0aGUgZnVuY3Rpb24gbmFtZS5cclxuICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIENTUyBmdW5jdGlvbiBpbnZvY2F0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZkbzJzID0gKHZhbDogSUNzc0Z1bmNPYmplY3QpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgbGV0IG9wdGlvbnMgPSBmZG9bdmFsLmZuXTtcclxuICAgIGlmICghb3B0aW9ucylcclxuICAgICAgICByZXR1cm4gZ29PdmVyUHJvcHModmFsKTtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiBnb092ZXJQcm9wcyggdmFsLCBvcHRpb25zKTtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMoIHZhbCk7XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKVxyXG4gICAgICAgIHJldHVybiBgJHt2YWwuZm59KCR7bzJzKCB2YWwsIG9wdGlvbnMsIFwiLFwiKX0pYDtcclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBsZXQgZm4gPSBvcHRpb25zLmZuO1xyXG4gICAgICAgIGZuID0gIWZuID8gdmFsLmZuIDogdHlwZW9mIGZuID09PSBcInN0cmluZ1wiID8gZm4gOiBmbih2YWwpO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLnBcclxuICAgICAgICAgICAgPyBgJHtmbn0oJHtvMnMoIHZhbCwgb3B0aW9ucy5wLCBvcHRpb25zLnMgPz8gXCIsXCIsIG9wdGlvbnMuZG8sIG9wdGlvbnMuZHApfSlgXHJcbiAgICAgICAgICAgIDogb3B0aW9ucy5mXHJcbiAgICAgICAgICAgICAgICA/IGAke2ZufSgke29wdGlvbnMuZih2YWwpfSlgXHJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGdvZXMgb3ZlciB0aGUgcHJvcHMgb2YgdGhlIGdpdmVuIG9iamVjdCBleGNlcHQgdGhlIFwiZm5cIiBwcm9wZXJ0eSxcclxuICogc2VyaWFsaXplcyBhbGwgdGhlIHByb3BzIHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zIGFuZCBjb25jYXRlbmF0ZXMgdGhlbSB3aXRoIHRoZSBnaXZlblxyXG4gKiBzZXBhcmF0b3IgKGNvbW1hIGJ5IGRlZmF1bHQpLlxyXG4gKiBAcGFyYW0gdmFsXHJcbiAqIEBwYXJhbSBvcHRpb25zXHJcbiAqIEBwYXJhbSBzZXBcclxuICogQHJldHVybnNcclxuICovXHJcbmNvbnN0IGdvT3ZlclByb3BzID0gKHZhbDogSUNzc0Z1bmNPYmplY3QsIG9wdGlvbnM/OiBWMlNPcHRpb25zLCBzZXA/OiBzdHJpbmcpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgbGV0IGJ1Zjogc3RyaW5nW10gPSBbXTtcclxuICAgIGZvciggbGV0IHAgaW4gdmFsKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChwICE9PSBcImZuXCIpXHJcbiAgICAgICAgICAgIGJ1Zi5wdXNoKCB2MnMoIHZhbFtwXSwgb3B0aW9ucykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBgJHt2YWwuZm59KCR7YnVmLmZpbHRlcih2PT4hIXYpLmpvaW4oIHNlcCA/PyBcIixcIil9KWA7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJQW5pbWF0aW9uUnVsZSwgQW5pbWF0aW9uRnJhbWUsIEFuaW1hdGlvbldheXBvaW50LCBJQW5pbWF0aW9uRnJhbWVSdWxlLCBJU3R5bGVEZWZpbml0aW9ufSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiXHJcbmltcG9ydCB7QW5pbWF0aW9uU3R5bGVzZXR9IGZyb20gXCIuLi9hcGkvU3R5bGVzZXRzXCI7XHJcbmltcG9ydCB7UnVsZSwgSU1pbWNzc1J1bGVCYWd9IGZyb20gXCIuL1J1bGVcIlxyXG5pbXBvcnQge1N0eWxlUnVsZX0gZnJvbSBcIi4vU3R5bGVSdWxlc1wiO1xyXG5pbXBvcnQge3YycywgV0tGfSBmcm9tIFwiLi4vaW1wbC9VdGlsc1wiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIEFuaW1hdGlvblJ1bGUgY2xhc3MgZGVzY3JpYmVzIGEgQGtleWZyYW1lcyBDU1MgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBbmltYXRpb25SdWxlIGV4dGVuZHMgUnVsZSBpbXBsZW1lbnRzIElBbmltYXRpb25SdWxlXHJcbntcclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIHNkOiBJU3R5bGVEZWZpbml0aW9uLCBmcmFtZXM/OiBBbmltYXRpb25GcmFtZVtdLFxyXG4gICAgICAgIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElBbmltYXRpb25SdWxlKVxyXG5cdHtcclxuXHRcdHN1cGVyKHNkKTtcclxuXHJcblx0XHRpZiAoZnJhbWVzKVxyXG5cdFx0XHR0aGlzLmZyYW1lUnVsZXMgPSBmcmFtZXMubWFwKCBmcmFtZSA9PiBuZXcgQW5pbWF0aW9uRnJhbWVSdWxlKCBzZCwgZnJhbWVbMF0sIGZyYW1lWzFdKSk7XHJcblxyXG5cdFx0dGhpcy5uYW1lT3ZlcnJpZGUgPSBuYW1lT3ZlcnJpZGU7XHJcblx0fVxyXG5cclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBjb252ZXJ0IGFuIG9iamVjdCB0byBhIHN0cmluZy4gQW5pbWF0aW9uIHJ1bGUgcmV0dXJucyBpdHMgbmFtZS5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5uYW1lOyB9XHJcblxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKVxyXG5cdHtcclxuXHRcdHN1cGVyLnByb2Nlc3MoIHJ1bGVOYW1lKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSB0aGlzLnJjLmdldFNjb3BlZE5hbWUoIHJ1bGVOYW1lLCB0aGlzLm5hbWVPdmVycmlkZSk7XHJcblxyXG5cdFx0Zm9yKCBsZXQga2V5ZnJhbWVSdWxlIG9mIHRoaXMuZnJhbWVSdWxlcylcclxuXHRcdFx0a2V5ZnJhbWVSdWxlLnByb2Nlc3MoIG51bGwpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LlxyXG5cdHB1YmxpYyBpbnNlcnQoIHJ1bGVCYWc6IElNaW1jc3NSdWxlQmFnKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICghdGhpcy5mcmFtZVJ1bGVzKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0bGV0IG1pbWNzc1J1bGUgPSBydWxlQmFnLmFkZEtleWZyYW1lcyggdGhpcy5uYW1lKTtcclxuICAgICAgICBpZiAobWltY3NzUnVsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuY3NzUnVsZSA9IG1pbWNzc1J1bGU/LmNzc1J1bGUgYXMgQ1NTS2V5ZnJhbWVzUnVsZTtcclxuICAgICAgICAgICAgZm9yKCBsZXQgZnJhbWVSdWxlIG9mIHRoaXMuZnJhbWVSdWxlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gYWx0aG91Z2ggdGhlIGNzc1J1bGUgaW4gdGhlIGZyYW1lIGlzIHR5cGVkIGFzIENTU1N0eWxlUnVsZSwgd2Uga25vdyB0aGF0IGluXHJcbiAgICAgICAgICAgICAgICAvLyBwcmFjdGljZSwgaXQgaXMgb2YgdGhlIENTU0tleWZyYW1lUnVsZSB0eXBlLlxyXG4gICAgICAgICAgICAgICAgZnJhbWVSdWxlLmNzc1J1bGUgPSBtaW1jc3NSdWxlLmFkZEZyYW1lKCBmcmFtZVJ1bGUudG9Dc3MoKSk/LmNzc1J1bGUgYXMgQ1NTU3R5bGVSdWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKiogU09NIGtleWZyYW1lcyBydWxlICovXHJcblx0cHVibGljIGNzc1J1bGU6IENTU0tleWZyYW1lc1J1bGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJ1bGUncyBuYW1lIC0gdGhpcyBpcyBhIHVuaXF1ZSBuYW1lIHRoYXQgaXMgYXNzaWduZWQgYnkgdGhlIE1pbWNzcyBpbmZyYXN0dWN0dXJlLiBUaGlzIG5hbWVcclxuXHQgKiBkb2Vzbid0IGhhdmUgdGhlIHByZWZpeCB0aGF0IGlzIHVzZWQgd2hlbiByZWZlcnJpbmcgdG8gY2xhc3NlcyAoLiksIElEcyAoIykgYW5kIGN1c3RvbSBDU1NcclxuXHQgKiBwcm9wZXJ0aWVzICgtLSkuXHJcblx0ICovXHJcblx0cHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcblx0LyoqIExpc3Qgb2Ygc3R5bGUgcnVsZXMgcmVwcmVzZW50aW5nIGFuaW1hdGlvbiBmcmFtZXMgKi9cclxuXHRwdWJsaWMgZnJhbWVSdWxlczogQW5pbWF0aW9uRnJhbWVSdWxlW107XHJcblxyXG5cdC8vIE5hbWUgb3IgbmFtZWQgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGEgbmFtZSBmb3IgdGhpcyBydWxlLiBJZiB0aGlzIHByb3BlcnR5XHJcblx0Ly8gaXMgbm90IGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgYmUgdW5pcXVlbHkgZ2VuZXJhdGVkLlxyXG5cdHByaXZhdGUgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUFuaW1hdGlvblJ1bGU7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBBbmltYXRpb25GcmFtZVJ1bGUgY2xhc3MgcmVwcmVzZW50cyBhIHNpbmdsZSBrZXlmcmFtZSBjbGF1c2UgaW4gdGhlIGFuaW1hdGlvbiBydWxlLlxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uRnJhbWVSdWxlIGV4dGVuZHMgU3R5bGVSdWxlIGltcGxlbWVudHMgSUFuaW1hdGlvbkZyYW1lUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgd2F5cG9pbnQ6IEFuaW1hdGlvbldheXBvaW50LFxyXG4gICAgICAgIHN0eWxlc2V0PzogQW5pbWF0aW9uU3R5bGVzZXQgfCBBbmltYXRpb25TdHlsZXNldFtdKVxyXG5cdHtcclxuXHRcdHN1cGVyKCBzZCwgc3R5bGVzZXQpO1xyXG5cdFx0dGhpcy53YXlwb2ludCA9IHdheXBvaW50O1xyXG5cdH1cclxuXHJcblx0Ly8gUmV0dXJucyB0aGUgc2VsZWN0b3IgcGFydCBvZiB0aGUgc3R5bGUgcnVsZS5cclxuXHRwdWJsaWMgZ2V0U2VsKCk6IHN0cmluZ1xyXG5cdHtcclxuXHRcdHJldHVybiB2MnMoIHRoaXMud2F5cG9pbnQsIHsgYW55OiBXS0YuUGVyY2VudCwgc2VwOiBcIixcIiB9KTtcclxuXHR9XHJcblxyXG5cdC8qKiBJZGVudGlmaWVyIG9mIHRoZSB3YXlwb2ludCAqL1xyXG5cdHB1YmxpYyB3YXlwb2ludDogQW5pbWF0aW9uV2F5cG9pbnQ7XHJcblxyXG5cdC8qKlxyXG4gICAgICogU09NIGtleWZyYW1lIHJ1bGUuIEFsdGhvdWdoIHRoZSBjc3NSdWxlIGluIHRoZSBmcmFtZSBpcyB0eXBlZCBhcyBDU1NTdHlsZVJ1bGUsIHdlIGtub3cgdGhhdFxyXG4gICAgICogaW4gcHJhY3RpY2UsIGl0IGlzIG9mIHRoZSBDU1NLZXlmcmFtZVJ1bGUgdHlwZS5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBnZXQgY3NzS2V5ZnJhbWVSdWxlKCk6IENTU0tleWZyYW1lUnVsZSB7IHJldHVybiB0aGlzLmNzc1J1bGUgYXMgYW55IGFzIENTU0tleWZyYW1lUnVsZTsgfTtcclxufVxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQge0V4dGVuZGVkQ291bnRlclN0eWxlc2V0fSBmcm9tIFwiLi4vYXBpL0NvdW50ZXJUeXBlc1wiO1xyXG5pbXBvcnQge0lDb3VudGVyUnVsZSwgSUNvdW50ZXJTdHlsZVJ1bGUsIElTdHlsZURlZmluaXRpb259IGZyb20gXCIuLi9hcGkvUnVsZVR5cGVzXCJcclxuaW1wb3J0IHtjb3VudGVyU3R5bGVzZXQyc30gZnJvbSBcIi4uL2ltcGwvTWlzY0ltcGxcIjtcclxuaW1wb3J0IHtJTWltY3NzUnVsZUJhZywgUnVsZSwgUnVsZUxpa2V9IGZyb20gXCIuL1J1bGVcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBDb3VudGVyUnVsZSBjbGFzcyBkZXNjcmliZXMgYSBuYW1lZCBjb3VudGVyIGRlZmluaXRpb24uIFVzZSB0aGlzIHJ1bGUgdG8gY3JlYXRlXHJcbiAqIGNvdW50ZXIgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGluIGNvdW50ZXItaW5jcmVtZW50LCBjb3VudGVyLXJlc2V0IGFuZCBjb3VudGVyLXNldCBzdHlsZVxyXG4gKiBwcm9wZXJ0aWVzLiBObyBDU1MgcnVsZSBpcyBjcmVhdGVkIGZvciBjb3VudGVycyAtIHRoZXkgYXJlIG5lZWRlZCBvbmx5IHRvIHByb3ZpZGUgdHlwZS1zYWZlXHJcbiAqIGNvdW50ZXIgZGVmaW5pdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ291bnRlclJ1bGUgZXh0ZW5kcyBSdWxlTGlrZSBpbXBsZW1lbnRzIElDb3VudGVyUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUNvdW50ZXJSdWxlKVxyXG5cdHtcclxuICAgICAgICBzdXBlcihzZCk7XHJcblx0XHR0aGlzLm5hbWVPdmVycmlkZSA9IG5hbWVPdmVycmlkZTtcclxuXHR9XHJcblxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS5cclxuICAgIC8vIFdlIHJldHVybiB0aGUgY291bnRlciBuYW1lLlxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuXHRwdWJsaWMgcHJvY2VzcyggcnVsZU5hbWU6IHN0cmluZyB8IG51bGwpOiB2b2lkXHJcblx0e1xyXG5cdFx0dGhpcy5uYW1lID0gdGhpcy5yYy5nZXRTY29wZWROYW1lKCBydWxlTmFtZSwgdGhpcy5uYW1lT3ZlcnJpZGUpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBSdWxlJ3MgbmFtZSAtIHRoaXMgaXMgYSB1bmlxdWUgbmFtZSB0aGF0IGlzIGFzc2lnbmVkIGJ5IHRoZSBNaW1jc3MgaW5mcmFzdHVjdHVyZS4gVGhpcyBuYW1lXHJcblx0ICogZG9lc24ndCBoYXZlIHRoZSBwcmVmaXggdGhhdCBpcyB1c2VkIHdoZW4gcmVmZXJyaW5nIHRvIGNsYXNzZXMgKC4pLCBJRHMgKCMpIGFuZCBjdXN0b20gQ1NTXHJcblx0ICogcHJvcGVydGllcyAoLS0pLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIE5hbWUgb2YgdGhlIGNvdW50ZXIgKi9cclxuXHRwdWJsaWMgZ2V0IGNvdW50ZXJOYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblx0Ly8gTmFtZSBvciBuYW1lZCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgYSBuYW1lIGZvciB0aGlzIHJ1bGUuIElmIHRoaXMgcHJvcGVydHlcclxuXHQvLyBpcyBub3QgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBiZSB1bmlxdWVseSBnZW5lcmF0ZWQuXHJcblx0cHJpdmF0ZSBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJQ291bnRlclJ1bGU7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBDb3VudGVyU3R5bGVSdWxlIGNsYXNzIGRlc2NyaWJlcyB0aGUgQ1NTIEBub3VudGVyLXN0eWxlIGF0LXJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ291bnRlclN0eWxlUnVsZSBleHRlbmRzIFJ1bGUgaW1wbGVtZW50cyBJQ291bnRlclN0eWxlUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgY291bnRlclN0eWxlc2V0PzogRXh0ZW5kZWRDb3VudGVyU3R5bGVzZXQsXHJcbiAgICAgICAgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUNvdW50ZXJTdHlsZVJ1bGUpXHJcblx0e1xyXG4gICAgICAgIHN1cGVyKHNkKTtcclxuICAgICAgICB0aGlzLmNvdW50ZXJTdHlsZXNldCA9IGNvdW50ZXJTdHlsZXNldCA/PyB7fTtcclxuXHRcdHRoaXMubmFtZU92ZXJyaWRlID0gbmFtZU92ZXJyaWRlO1xyXG5cdH1cclxuXHJcblxyXG5cclxuICAgIC8qKiBOYW1lIG9mIHRoZSBjb3VudGVyICovXHJcblx0cHVibGljIGdldCBjb3VudGVyU3R5bGVOYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgaW4gYSBzdHlsZSBwcm9wZXJ0eSBvciBpblxyXG4gICAgLy8gYW5vdGhlciBjb3VudGVyIHN0eWxlIHJ1bGUuIFdlIHJldHVybiB0aGUgY291bnRlciBzdHlsZSBuYW1lLlxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuXHRwdWJsaWMgcHJvY2VzcyggcnVsZU5hbWU6IHN0cmluZyB8IG51bGwpOiB2b2lkXHJcblx0e1xyXG5cdFx0dGhpcy5uYW1lID0gdGhpcy5yYy5nZXRTY29wZWROYW1lKCBydWxlTmFtZSwgdGhpcy5uYW1lT3ZlcnJpZGUpO1xyXG5cdH1cclxuXHJcblx0Ly8gSW5zZXJ0cyB0aGlzIHJ1bGUgaW50byB0aGUgZ2l2ZW4gcGFyZW50IHJ1bGUgb3Igc3R5bGVzaGVldC5cclxuXHRwdWJsaWMgaW5zZXJ0KCBydWxlQmFnOiBJTWltY3NzUnVsZUJhZyk6IHZvaWRcclxuXHR7XHJcblx0XHRsZXQgcnVsZVRleHQgPSBgQGNvdW50ZXItc3R5bGUgJHt0aGlzLm5hbWV9IHske2NvdW50ZXJTdHlsZXNldDJzKCB0aGlzLmNvdW50ZXJTdHlsZXNldCl9fWA7XHJcblx0XHR0aGlzLmNzc1J1bGUgPSBydWxlQmFnLmFkZCggcnVsZVRleHQpPy5jc3NSdWxlIGFzIENTU1J1bGU7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFNlcmlhbGl6ZXMgdGhpcyBydWxlIHRvIGEgc3RyaW5nLlxyXG4gICAgcHJpdmF0ZSB0b0NzcygpOiBzdHJpbmdcclxuICAgIHtcclxuXHRcdHJldHVybiBgQGNvdW50ZXItc3R5bGUgJHt0aGlzLm5hbWV9IHske2NvdW50ZXJTdHlsZXNldDJzKCB0aGlzLmNvdW50ZXJTdHlsZXNldCl9fWA7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0LyoqIFNPTSBjb3VudGVyLXN0eWxlIHJ1bGUgKi9cclxuXHQvLyBwdWJsaWMgY3NzUnVsZTogQ1NTQ291bnRlclN0eWxlUnVsZTtcclxuXHRwdWJsaWMgY3NzUnVsZTogQ1NTUnVsZSB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcblx0ICogUnVsZSdzIG5hbWUgLSB0aGlzIGlzIGEgdW5pcXVlIG5hbWUgdGhhdCBpcyBhc3NpZ25lZCBieSB0aGUgTWltY3NzIGluZnJhc3R1Y3R1cmUuIFRoaXMgbmFtZVxyXG5cdCAqIGRvZXNuJ3QgaGF2ZSB0aGUgcHJlZml4IHRoYXQgaXMgdXNlZCB3aGVuIHJlZmVycmluZyB0byBjbGFzc2VzICguKSwgSURzICgjKSBhbmQgY3VzdG9tIENTU1xyXG5cdCAqIHByb3BlcnRpZXMgKC0tKS5cclxuXHQgKi9cclxuXHRwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIC8vIE9iamVjdCBkZWZpbmluZyB0aGUgY291bnRlciBzdHlsZSBydWxlIGZlYXR1cmVzLlxyXG4gICAgcHJpdmF0ZSBjb3VudGVyU3R5bGVzZXQ6IEV4dGVuZGVkQ291bnRlclN0eWxlc2V0O1xyXG5cclxuICAgIC8vIE5hbWUgb3IgbmFtZWQgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGEgbmFtZSBmb3IgdGhpcyBydWxlLiBJZiB0aGlzIHByb3BlcnR5XHJcblx0Ly8gaXMgbm90IGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgYmUgdW5pcXVlbHkgZ2VuZXJhdGVkLlxyXG5cdHByaXZhdGUgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUNvdW50ZXJTdHlsZVJ1bGU7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJR3JpZExpbmVSdWxlLCBJR3JpZEFyZWFSdWxlLCBJU3R5bGVEZWZpbml0aW9ufSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiXHJcbmltcG9ydCB7UnVsZUxpa2V9IGZyb20gXCIuL1J1bGVcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBHcmlkTGluZVJ1bGUgY2xhc3MgZGVzY3JpYmVzIGEgbmFtZWQgZ3JpZCBsaW5lIGRlZmluaXRpb24uIE5vIENTUyBydWxlIGlzIGNyZWF0ZWQgZm9yIGdyaWRcclxuICogbGluZXMgLSB0aGV5IGFyZSBuZWVkZWQgb25seSB0byBwcm92aWRlIHR5cGUtc2FmZSBncmlkIGxpbmUgZGVmaW5pdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR3JpZExpbmVSdWxlIGV4dGVuZHMgUnVsZUxpa2UgaW1wbGVtZW50cyBJR3JpZExpbmVSdWxlXHJcbntcclxuICAgIC8vIGlmIHRoZSBuYW1lT3ZlcnJpZGUgaXMgYW4gYXJlYSBydWxlIG9iamVjdCwgdGhlIGlzU3RhcnRFbmRPck5vbmUgZmxhZyBpcyBhbHdheXMgZGVmaW5lZFxyXG4gICAgLy8gYmVjYXVzZSB0aGlzIGNvbnN0cnVjdG9yIGNhbiBvbmx5IGJlIGludm9rZWQgZm9yIHRoZSBzdGFydCBhbmQgZW5kIGxpbmVzIG9mIHRoZSBHcmlkQXJlYVJ1bGVcclxuICAgIC8vIG9iamVjdC5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24sIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkTGluZVJ1bGUgfCBJR3JpZEFyZWFSdWxlLFxyXG4gICAgICAgIGlzU3RhcnRFbmRPck5vbmU/OiBib29sZWFuKVxyXG5cdHtcclxuICAgICAgICBzdXBlcihzZCk7XHJcbiAgICAgICAgdGhpcy5uYW1lT3ZlcnJpZGUgPSBuYW1lT3ZlcnJpZGU7XHJcbiAgICAgICAgdGhpcy5pc1N0YXJ0RW5kT3JOb25lID0gaXNTdGFydEVuZE9yTm9uZTtcclxuXHR9XHJcblxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS5cclxuICAgIC8vIFdlIHJldHVybiB0aGUgbGluZSBuYW1lLlxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuXHRwdWJsaWMgcHJvY2VzcyggcnVsZU5hbWU6IHN0cmluZyB8IG51bGwpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIHN1cGVyLnByb2Nlc3MoIHJ1bGVOYW1lKTtcclxuXHJcbiAgICAgICAgbGV0IG5hbWU6IHN0cmluZztcclxuICAgICAgICBsZXQgYXJlYU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgaXNTdGFydEVuZE9yTm9uZTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHRoaXMuaXNTdGFydEVuZE9yTm9uZTtcclxuICAgICAgICBsZXQgbmFtZU92ZXJyaWRlID0gdGhpcy5uYW1lT3ZlcnJpZGU7XHJcbiAgICAgICAgaWYgKG5hbWVPdmVycmlkZSBpbnN0YW5jZW9mIEdyaWRMaW5lUnVsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3ZlcnJpZGUubmFtZTtcclxuICAgICAgICAgICAgdGhpcy5pc1N0YXJ0RW5kT3JOb25lID0gbmFtZU92ZXJyaWRlLmlzU3RhcnRFbmRPck5vbmU7XHJcbiAgICAgICAgICAgIGFyZWFOYW1lID0gbmFtZU92ZXJyaWRlLmFyZWFOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuYW1lT3ZlcnJpZGUgaW5zdGFuY2VvZiBHcmlkQXJlYVJ1bGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZU92ZXJyaWRlLm5hbWUgKyAoaXNTdGFydEVuZE9yTm9uZSA9PT0gdHJ1ZSA/IFwiLXN0YXJ0XCIgOiBpc1N0YXJ0RW5kT3JOb25lID09PSBmYWxzZSA/IFwiLWVuZFwiIDogXCJcIik7XHJcbiAgICAgICAgICAgIGFyZWFOYW1lID0gbmFtZU92ZXJyaWRlLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnJjLmdldFNjb3BlZE5hbWUoIHJ1bGVOYW1lLCBuYW1lT3ZlcnJpZGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlIG9idGFpbmVkIG5hbWUgZG9lc24ndCBoYXZlIFwiLXN0YXJ0XCIgb3IgXCItZW5kXCIgYnV0IHRoZSBpc1N0YXJ0RW5kT3JOb25lIGZsYWcgaXNcclxuICAgICAgICAgICAgLy8gZGVmaW5lZCAodGhhdCBpcywgaXQgaXMgZWl0aGVyIHN0YXJ0IG9yIGVuZCBsaW5lKSwgd2UgbmVlZCB0byBhcHBlbmQgdGhlIHN1ZmZpeC4gSWYgdGhlXHJcbiAgICAgICAgICAgIC8vIG9idGFpbmVkIG5hbWUgYWxyZWFkeSBoYXMgXCItc3RhcnRcIiBvciBcIi1lbmRcIiBhbmQgdGhlIGlzU3RhcnRFbmRPck5vbmUgZmxhZyBpcyBub3RcclxuICAgICAgICAgICAgLy8gZGVmaW5lZCwgd2Ugc2V0IHRoaXMgZmxhZyB0byBlaXRoZXIgdHJ1ZSBvciBmYWxzZSBkZXBlbmRpbmcgb24gdGhlIHN1ZmZpeC4gTm90ZSB0aGF0IGlmXHJcbiAgICAgICAgICAgIC8vIHRoZSBuYW1lT3ZlcnJpZGUgaXMgYW4gYXJlYSBydWxlIG9iamVjdCwgdGhlIGlzU3RhcnRFbmRPck5vbmUgZmxhZyBpcyBhbHdheXMgZGVmaW5lZC5cclxuICAgICAgICAgICAgbGV0IG5hbWVIYXNTdGFydCA9IG5hbWUuZW5kc1dpdGgoXCItc3RhcnRcIik7XHJcbiAgICAgICAgICAgIGxldCBuYW1lSGFzRW5kID0gbmFtZS5lbmRzV2l0aChcIi1lbmRcIik7XHJcbiAgICAgICAgICAgIGlmIChuYW1lSGFzU3RhcnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTdGFydEVuZE9yTm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhcmVhTmFtZSA9IG5hbWUuc3Vic3RyKCAwLCBuYW1lLmxlbmd0aCAtIDYgLyogXCItc3RhcnRcIi5sZW5ndGggKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVIYXNFbmQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlzU3RhcnRFbmRPck5vbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGFyZWFOYW1lID0gbmFtZS5zdWJzdHIoIDAsIG5hbWUubGVuZ3RoIC0gNCAvKiBcIi1lbmRcIi5sZW5ndGggKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RhcnRFbmRPck5vbmUgPT09IHRydWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFyZWFOYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCItc3RhcnRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0YXJ0RW5kT3JOb25lID09PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYXJlYU5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgbmFtZSArPSBcIi1lbmRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmFyZWFOYW1lID0gYXJlYU5hbWU7XHJcbiAgICAgICAgdGhpcy5pc1N0YXJ0RW5kT3JOb25lID0gaXNTdGFydEVuZE9yTm9uZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJ1bGUncyBuYW1lIC0gdGhpcyBpcyBhIHVuaXF1ZSBuYW1lIHRoYXQgaXMgYXNzaWduZWQgYnkgdGhlIE1pbWNzcyBpbmZyYXN0dWN0dXJlLiBUaGlzIG5hbWVcclxuXHQgKiBkb2Vzbid0IGhhdmUgdGhlIHByZWZpeCB0aGF0IGlzIHVzZWQgd2hlbiByZWZlcnJpbmcgdG8gY2xhc3NlcyAoLiksIElEcyAoIykgYW5kIGN1c3RvbSBDU1NcclxuXHQgKiBwcm9wZXJ0aWVzICgtLSkuXHJcblx0ICovXHJcblx0cHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcblx0LyoqXHJcbiAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgbGluZSBpcyBhIHN0YXJ0IG9yIGVuZCBsaW5lIG9mIGEgZ3JpZCBhcmVhLiBUaGUgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogaWYgdGhpcyBpcyB0aGUgc3RhcnQgbGluZTsgZmFsc2UgaWYgdGhpcyBpcyB0aGUgZW5kIGxpbmU7IGFuZCB1bmRlZmluZWQgaWYgdGhlIGxpbmUgaXNcclxuICAgICAqIG5vdCByZWxhdGVkIHRvIGFueSBhcmVhLlxyXG4gICAgICovXHJcblx0cHVibGljIGlzU3RhcnRFbmRPck5vbmU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSBncmlkIGFyZWEgb2Ygd2hpY2ggdGhlIGxpbmUgaXMgZWl0aGVyIGEgc3RhcnQgb3IgYW4gZW5kIGxpbmUuIEl0IGlzIGRlZmluZWRcclxuICAgICAqIG9ubHkgaWYgdGhlIGxpbmUgbmFtZSBlbmRzIHdpdGggXCItc3RhcnRcIiBvciBcIi1lbmRcIi5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBhcmVhTmFtZT86IHN0cmluZztcclxuXHJcbiAgICAvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG5cdC8vIGlzIG5vdCBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIGJlIHVuaXF1ZWx5IGdlbmVyYXRlZC5cclxuXHRwcml2YXRlIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkTGluZVJ1bGUgfCBJR3JpZEFyZWFSdWxlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgR3JpZEFyZWFSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIG5hbWVkIGdyaWQgYXJlYSBkZWZpbml0aW9uLiBObyBDU1MgcnVsZSBpcyBjcmVhdGVkIGZvciBncmlkXHJcbiAqIGFyZWFzIC0gdGhleSBhcmUgbmVlZGVkIG9ubHkgdG8gcHJvdmlkZSB0eXBlLXNhZmUgZ3JpZCBhcmVhIGRlZmluaXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdyaWRBcmVhUnVsZSBleHRlbmRzIFJ1bGVMaWtlIGltcGxlbWVudHMgSUdyaWRBcmVhUnVsZVxyXG57XHJcbiAgICAvLyBpZiB0aGUgbmFtZU92ZXJyaWRlIGlzIGFuIGFyZWEgcnVsZSBvYmplY3QsIHRoZSBpc1N0YXJ0RW5kT3JOb25lIGZsYWcgaXMgYWx3YXlzIGRlZmluZWRcclxuICAgIC8vIGJlY2F1c2UgdGhpcyBjb25zdHJ1Y3RvciBjYW4gb25seSBiZSBpbnZva2VkIGZvciB0aGUgc3RhcnQgYW5kIGVuZCBsaW5lcyBvZiB0aGUgR3JpZEFyZWFSdWxlXHJcbiAgICAvLyBvYmplY3QuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoIHNkOiBJU3R5bGVEZWZpbml0aW9uLCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJR3JpZEFyZWFSdWxlKVxyXG5cdHtcclxuICAgICAgICBzdXBlcihzZCk7XHJcbiAgICAgICAgdGhpcy5uYW1lT3ZlcnJpZGUgPSBuYW1lT3ZlcnJpZGU7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBsaW5lIHJ1bGVzXHJcbiAgICAgICAgdGhpcy5zdGFydExpbmUgPSBuZXcgR3JpZExpbmVSdWxlKCBzZCwgdGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5lbmRMaW5lID0gbmV3IEdyaWRMaW5lUnVsZSggc2QsIHRoaXMsIGZhbHNlKTtcclxuXHR9XHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gdGhlIG9iamVjdCBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSBvZiBhIHN0eWxlIHByb3BlcnR5LlxyXG4gICAgLy8gV2UgcmV0dXJuIHRoZSBhcmVhIG5hbWUuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMubmFtZTsgfVxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKTogdm9pZFxyXG5cdHtcclxuICAgICAgICBzdXBlci5wcm9jZXNzKCBydWxlTmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMucmMuZ2V0U2NvcGVkTmFtZSggcnVsZU5hbWUsIHRoaXMubmFtZU92ZXJyaWRlKTtcclxuXHJcbiAgICAgICAgLy8gcHJvY2VzcyBsaW5lIHJ1bGVzXHJcbiAgICAgICAgdGhpcy5zdGFydExpbmUucHJvY2VzcyggbnVsbCk7XHJcbiAgICAgICAgdGhpcy5lbmRMaW5lLnByb2Nlc3MoIG51bGwpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUnVsZSdzIG5hbWUgLSB0aGlzIGlzIGEgdW5pcXVlIG5hbWUgdGhhdCBpcyBhc3NpZ25lZCBieSB0aGUgTWltY3NzIGluZnJhc3R1Y3R1cmUuIFRoaXMgbmFtZVxyXG5cdCAqIGRvZXNuJ3QgaGF2ZSB0aGUgcHJlZml4IHRoYXQgaXMgdXNlZCB3aGVuIHJlZmVycmluZyB0byBjbGFzc2VzICguKSwgSURzICgjKSBhbmQgY3VzdG9tIENTU1xyXG5cdCAqIHByb3BlcnRpZXMgKC0tKS5cclxuXHQgKi9cclxuXHRwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuXHQvKiogU3RhcnQgbGluZSBvZiB0aGUgYXJlYS4gKi9cclxuXHRwdWJsaWMgc3RhcnRMaW5lOiBHcmlkTGluZVJ1bGU7XHJcblxyXG4gICAgLyoqIEVuZCBsaW5lIG9mIHRoZSBhcmVhIGFyZWEuICovXHJcblx0cHVibGljIGVuZExpbmU6IEdyaWRMaW5lUnVsZTtcclxuXHJcbiAgICAvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG5cdC8vIGlzIG5vdCBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIGJlIHVuaXF1ZWx5IGdlbmVyYXRlZC5cclxuXHRwcml2YXRlIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkQXJlYVJ1bGU7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJU3R5bGVEZWZpbml0aW9uQ2xhc3MsIElTdHlsZURlZmluaXRpb24sIElHcm91cFJ1bGUsIElNZWRpYVJ1bGUsIElTdXBwb3J0c1J1bGV9IGZyb20gXCIuLi9hcGkvUnVsZVR5cGVzXCJcclxuaW1wb3J0IHtNZWRpYVN0YXRlbWVudCwgU3VwcG9ydHNTdGF0ZW1lbnR9IGZyb20gXCIuLi9hcGkvTWVkaWFUeXBlc1wiO1xyXG5pbXBvcnQge3Byb2Nlc3NTRH0gZnJvbSBcIi4vUnVsZUNvbnRhaW5lclwiXHJcbmltcG9ydCB7SVJ1bGVDb250YWluZXIsIFJ1bGUsIHN5bVJDLCBJTWltY3NzUnVsZUJhZ30gZnJvbSBcIi4vUnVsZVwiXHJcbmltcG9ydCB7bWVkaWEycywgc3VwcG9ydHMyc30gZnJvbSBcIi4uL2ltcGwvTWlzY0ltcGxcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBHcm91cFJ1bGUgY2xhc3Mgc2VydmVzIGFzIGEgYmFzZSBjbGFzcyBmb3IgYWxsIGdyb3VwaW5nIENTUyBydWxlcy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHcm91cFJ1bGU8VCBleHRlbmRzIElTdHlsZURlZmluaXRpb24sIFIgZXh0ZW5kcyBDU1NHcm91cGluZ1J1bGUgPSBhbnk+XHJcbiAgICBleHRlbmRzIFJ1bGUgaW1wbGVtZW50cyBJR3JvdXBSdWxlPFQ+XHJcbntcclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIHNkOiBJU3R5bGVEZWZpbml0aW9uLCBybjogc3RyaW5nLCBpbnN0T3JDbGFzczogVCB8IElTdHlsZURlZmluaXRpb25DbGFzczxUPilcclxuXHR7XHJcblx0XHRzdXBlcihzZCk7XHJcbiAgICAgICAgdGhpcy5ybiA9IHJuO1xyXG5cdFx0dGhpcy5pbnN0T3JDbGFzcyA9IGluc3RPckNsYXNzO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKVxyXG5cdHtcclxuXHRcdHN1cGVyLnByb2Nlc3MoIHJ1bGVOYW1lKTtcclxuXHJcbiAgICAgICAgLy8gY29udGFpbmVyIHRvIHdoaWNoIG91ciBncm91cGluZyBydWxlIGJlbG9uZ3MgYmVjb21lcyB0aGUgcGFyZW50IGNvbnRhaW5lciBmb3IgdGhlXHJcbiAgICAgICAgLy8gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZVxyXG5cdFx0dGhpcy5nc2QgPSBwcm9jZXNzU0QoIHRoaXMuaW5zdE9yQ2xhc3MsIHRoaXMuc2QpIGFzIFQ7XHJcblx0XHR0aGlzLmdyYyA9IHRoaXMuZ3NkW3N5bVJDXTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gSW5zZXJ0cyB0aGlzIHJ1bGUgaW50byB0aGUgZ2l2ZW4gcGFyZW50IHJ1bGUgb3Igc3R5bGVzaGVldC5cclxuXHRwdWJsaWMgaW5zZXJ0KCBydWxlQmFnOiBJTWltY3NzUnVsZUJhZyk6IHZvaWRcclxuXHR7XHJcblx0XHRsZXQgbWltY3NzUnVsZSA9IHJ1bGVCYWcuYWRkR3JvdXAoIGBAJHt0aGlzLnJufSAke3RoaXMuY29uZGl0aW9ufWApO1xyXG4gICAgICAgIGlmIChtaW1jc3NSdWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5jc3NSdWxlID0gbWltY3NzUnVsZT8uY3NzUnVsZSBhcyBSO1xyXG5cclxuICAgICAgICAgICAgLy8gaW5zZXJ0IHN1Yi1ydWxlc1xyXG5cdFx0XHR0aGlzLmdyYy5pbnNlcnQoIG1pbWNzc1J1bGUpO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gQ29uZGl0aW9uIG9mIHRoaXMgZ3JvdXBpbmcgcnVsZS5cclxuXHRwdWJsaWMgZ2V0IGNvbmRpdGlvbigpOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbmQpXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbmQgPSB0aGlzLmdldENvbmQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmQgPz8gXCJcIjtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBjb25kaXRpb24gc3RyaW5nIG9mIHRoaXMgZ3JvdXBpbmcgcnVsZS5cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0Q29uZCgpOiBzdHJpbmcgfCBudWxsO1xyXG5cclxuXHJcblxyXG5cdC8vIENsZXJzIHRoZSBDU1MgcnVsZSBvYmplY3QuXHJcblx0cHVibGljIGNsZWFyKCk6IHZvaWRcclxuXHR7XHJcblx0XHRzdXBlci5jbGVhcigpO1xyXG5cclxuXHRcdC8vIGNsZWFyIHN1Yi1ydWxlc1xyXG5cdFx0dGhpcy5ncmMuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0LyoqIEluc3RhbmNlIG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIGRlZmluaW5nIHRoZSBydWxlcyB1bmRlciB0aGlzIGdyb3VwaW5nIHJ1bGUgKi9cclxuXHRwdWJsaWMgZ3NkOiBUO1xyXG5cclxuXHQvKiogU09NIHN1cHBvcnRzIHJ1bGUgKi9cclxuXHRwdWJsaWMgY3NzUnVsZTogUiB8IG51bGw7XHJcblxyXG5cdC8qKiBOYW1lIG9mIHRoZSBhdC1ydWxlIChlLmcuIFwic3VwcG9ydHNcIikuICovXHJcblx0cHJpdmF0ZSBybjogc3RyaW5nO1xyXG5cclxuXHQvKiogU3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB0aGF0IGRlZmluZXMgcnVsZXMgdW5kZXIgdGhpcyBncm91cGluZyBydWxlLiAqL1xyXG5cdHByaXZhdGUgaW5zdE9yQ2xhc3M6IFQgfCBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VD47XHJcblxyXG5cdC8qKlxyXG4gICAgICogR3JvdXAgUnVsZSBDb250YWluZXIgLSB0aGlzIGNvbnRhaW5lciBjb250YWlucyBydWxlcyBmb3IgdGhlIGdyb3VwIGRlZmluaXRpb24gaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuXHRwcml2YXRlIGdyYzogSVJ1bGVDb250YWluZXI7XHJcblxyXG5cdC8qKiBDb25kaXRpb24gb2YgdGhpcyBncm91cGluZyBydWxlLiAqL1xyXG5cdHByaXZhdGUgX2NvbmQ6IHN0cmluZyB8IG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBTdXBwb3J0UnVsZSBjbGFzcyBkZXNjcmliZXMgYSBDU1MgQHN1cHBvcnRzIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3VwcG9ydHNSdWxlPFQgZXh0ZW5kcyBJU3R5bGVEZWZpbml0aW9uPiBleHRlbmRzIEdyb3VwUnVsZTxULENTU1N1cHBvcnRzUnVsZT4gaW1wbGVtZW50cyBJU3VwcG9ydHNSdWxlPFQ+XHJcbntcclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIHNkOiBJU3R5bGVEZWZpbml0aW9uLCBzdGF0ZW1lbnQ6IFN1cHBvcnRzU3RhdGVtZW50LCBpbnN0T3JDbGFzczogVCB8IElTdHlsZURlZmluaXRpb25DbGFzczxUPilcclxuXHR7XHJcblx0XHRzdXBlciggc2QsIFwic3VwcG9ydHNcIiwgaW5zdE9yQ2xhc3MpO1xyXG5cdFx0dGhpcy5zdG10ID0gc3RhdGVtZW50O1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKiogRmxhZyBpbmRpY2F0ZWQgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHJ1bGUncyBxdWVyeSAqL1xyXG4gICAgcHVibGljIGdldCBpc1N1cHBvcnRlZCgpOiBib29sZWFuXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdyAmJiBDU1Muc3VwcG9ydHMoIHRoaXMuY29uZGl0aW9uKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBjb25kaXRpb24gc3RyaW5nIG9mIHRoaXMgZ3JvdXBpbmcgcnVsZS5cclxuXHRwcm90ZWN0ZWQgZ2V0Q29uZCgpOiBzdHJpbmcgfCBudWxsXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzMnMoIHRoaXMuc3RtdCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0Ly8gc3VwcG9ydCBzdGF0ZW1lbnQgZm9yIHRoaXMgcnVsZS5cclxuXHRwcml2YXRlIHN0bXQ6IFN1cHBvcnRzU3RhdGVtZW50O1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgTWVkaWFSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIENTUyBAbWVkaWEgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNZWRpYVJ1bGU8VCBleHRlbmRzIElTdHlsZURlZmluaXRpb24+IGV4dGVuZHMgR3JvdXBSdWxlPFQsQ1NTTWVkaWFSdWxlPiBpbXBsZW1lbnRzIElNZWRpYVJ1bGU8VD5cclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24sIHN0YXRlbWVudDogTWVkaWFTdGF0ZW1lbnQsIGluc3RPckNsYXNzOiBUIHwgSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFQ+KVxyXG5cdHtcclxuXHRcdHN1cGVyKCBzZCwgXCJtZWRpYVwiLCBpbnN0T3JDbGFzcyk7XHJcblx0XHR0aGlzLnN0bXQgPSBzdGF0ZW1lbnQ7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFJldHVybnMgdGhlIGNvbmRpdGlvbiBzdHJpbmcgb2YgdGhpcyBncm91cGluZyBydWxlLlxyXG5cdHByb3RlY3RlZCBnZXRDb25kKCk6IHN0cmluZyB8IG51bGxcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbWVkaWEycyggdGhpcy5zdG10KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgTWVkaWFRdWVyeUxpc3RgIG9iamVjdCB0aGF0IGFsbG93cyBwcm9ncmFtbWF0aWMgY2hlY2tpbmcgd2hldGhlciB0aGUgZG9jdW1lbnQgbWF0Y2hlc1xyXG4gICAgICogdGhlIG1lZGlhIHN0YXRlbWVudCBhbmQgYWxzbyBhbGxvd3MgbGlzdGVuaW5nIHRvIGl0cyBgY2hhbmdlYCBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBxdWVyeUxpc3QoKTogTWVkaWFRdWVyeUxpc3QgfCB1bmRlZmluZWRcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gd2luZG93ICYmIG1hdGNoTWVkaWEoIHRoaXMuY29uZGl0aW9uKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBtZWRpYSBzdGF0ZW1lbnQgZm9yIHRoaXMgcnVsZS5cclxuXHRwcml2YXRlIHN0bXQ6IE1lZGlhU3RhdGVtZW50O1xyXG59XHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7SUZvbnRGYWNlUnVsZSwgSUltcG9ydFJ1bGUsIElOYW1lc3BhY2VSdWxlLCBJQ2xhc3NOYW1lUnVsZSwgSUNsYXNzUnVsZSwgSVN0eWxlRGVmaW5pdGlvbn0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHtFeHRlbmRlZEZvbnRGYWNlfSBmcm9tIFwiLi4vYXBpL0ZvbnRUeXBlc1wiXHJcbmltcG9ydCB7TWVkaWFTdGF0ZW1lbnQsIFN1cHBvcnRzU3RhdGVtZW50fSBmcm9tIFwiLi4vYXBpL01lZGlhVHlwZXNcIjtcclxuaW1wb3J0IHtmb250RmFjZTJzfSBmcm9tIFwiLi4vaW1wbC9NaXNjSW1wbFwiXHJcbmltcG9ydCB7UnVsZSwgUnVsZUxpa2UsIElNaW1jc3NSdWxlQmFnfSBmcm9tIFwiLi9SdWxlXCI7XHJcbmltcG9ydCB7bWVkaWEycywgc3VwcG9ydHMyc30gZnJvbSBcIi4uL2ltcGwvTWlzY0ltcGxcIjtcclxuaW1wb3J0IHtzeW1WMlN9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgTWlzY1J1bGUgY2xhc3Mgc2VydmVzIGFzIGEgYmFzZSBjbGFzcyBmb3Igc2ltcGxlIHJ1bGVzLlxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgTWlzY1J1bGU8VCBleHRlbmRzIENTU1J1bGU+IGV4dGVuZHMgUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbilcclxuXHR7XHJcblx0XHRzdXBlcihzZCk7XHJcblx0fVxyXG5cclxuXHQvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LlxyXG5cdHB1YmxpYyBpbnNlcnQoIHJ1bGVCYWc6IElNaW1jc3NSdWxlQmFnKTogdm9pZFxyXG5cdHtcclxuXHRcdHRoaXMuY3NzUnVsZSA9IHJ1bGVCYWcuYWRkKCB0aGlzLnRvQ3NzKCkpPy5jc3NSdWxlIGFzIFQ7XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm5zIENTUyBzdHJpbmcgZm9yIHRoaXMgcnVsZS5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCB0b0NzcygpOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBTT00gZm9udC1mYWNlIHJ1bGUgKi9cclxuXHRwdWJsaWMgY3NzUnVsZTogVDtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIEltcG9ydFJ1bGUgY2xhc3MgZGVzY3JpYmVzIGEgQ1NTIEBpbXBvcnQgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbXBvcnRSdWxlIGV4dGVuZHMgTWlzY1J1bGU8Q1NTSW1wb3J0UnVsZT4gaW1wbGVtZW50cyBJSW1wb3J0UnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgdXJsOiBzdHJpbmcsIG1lZGlhU3RhdGVtZW50PzogTWVkaWFTdGF0ZW1lbnQsXHJcbiAgICAgICAgc3VwcG9ydHNTdGF0ZW1lbnQ/OiBzdHJpbmcgfCBTdXBwb3J0c1N0YXRlbWVudClcclxuXHR7XHJcblx0XHRzdXBlcihzZCk7XHJcblxyXG5cdFx0dGhpcy51cmwgPSB1cmw7XHJcblx0XHR0aGlzLm1lZGlhU3RhdGVtZW50ID0gbWVkaWFTdGF0ZW1lbnQ7XHJcblx0XHR0aGlzLnN1cHBvcnRzU3RhdGVtZW50ID0gc3VwcG9ydHNTdGF0ZW1lbnQ7XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm5zIENTUyBzdHJpbmcgZm9yIHRoaXMgcnVsZS5cclxuICAgIHByb3RlY3RlZCB0b0NzcygpOiBzdHJpbmdcclxuICAgIHtcclxuXHRcdGxldCB1cmw6IHN0cmluZztcclxuXHRcdGlmICh0aGlzLnVybC5zdGFydHNXaXRoKFwidXJsXCIpIHx8IHRoaXMudXJsLnN0YXJ0c1dpdGgoXCJcXFwiXCIpIHx8IHRoaXMudXJsLnN0YXJ0c1dpdGgoXCInXCIpKVxyXG5cdFx0XHR1cmwgPSB0aGlzLnVybDtcclxuXHRcdGVsc2VcclxuXHRcdFx0dXJsID0gYHVybCgke3RoaXMudXJsfSlgO1xyXG5cclxuXHRcdGxldCBzdXBwb3J0c1F1ZXJ5U3RyaW5nID0gIXRoaXMuc3VwcG9ydHNTdGF0ZW1lbnQgPyBcIlwiIDogc3VwcG9ydHMycyggdGhpcy5zdXBwb3J0c1N0YXRlbWVudCk7XHJcblx0XHRpZiAoc3VwcG9ydHNRdWVyeVN0cmluZyAmJiAhc3VwcG9ydHNRdWVyeVN0cmluZy5zdGFydHNXaXRoKCBcInN1cHBvcnRzXCIpKVxyXG5cdFx0ICAgIHN1cHBvcnRzUXVlcnlTdHJpbmcgPSBgc3VwcG9ydHMoICR7c3VwcG9ydHNRdWVyeVN0cmluZ30gKWA7XHJcblxyXG5cdFx0bGV0IG1lZGlhUXVlcnlTdHJpbmcgPSAhdGhpcy5tZWRpYVN0YXRlbWVudCA/IFwiXCIgOiBtZWRpYTJzKCB0aGlzLm1lZGlhU3RhdGVtZW50KTtcclxuXHRcdHJldHVybiBgQGltcG9ydCAke3VybH0gJHtzdXBwb3J0c1F1ZXJ5U3RyaW5nfSAke21lZGlhUXVlcnlTdHJpbmd9YDtcclxuICAgIH1cclxuXHJcblx0Ly8gVVJMIHRvIGltcG9ydCBmcm9tLlxyXG5cdHB1YmxpYyB1cmw6IHN0cmluZztcclxuXHJcblx0Ly8gT3B0aW9uYWwgbWVkaWEgcXVlcnkgZm9yIHRoaXMgcnVsZS5cclxuXHRwdWJsaWMgbWVkaWFTdGF0ZW1lbnQ/OiBNZWRpYVN0YXRlbWVudDtcclxuXHJcblx0Ly8gT3B0aW9uYWwgc3VwcG9ydHMgcXVlcnkgZm9yIHRoaXMgcnVsZS5cclxuXHRwdWJsaWMgc3VwcG9ydHNTdGF0ZW1lbnQ/OiBzdHJpbmcgfCBTdXBwb3J0c1N0YXRlbWVudDtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIE5hbWVzcGFjZVJ1bGUgY2xhc3MgZGVzY3JpYmVzIGEgQ1NTIEBuYW1lc3BhY2UgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOYW1lc3BhY2VSdWxlIGV4dGVuZHMgTWlzY1J1bGU8Q1NTTmFtZXNwYWNlUnVsZT4gaW1wbGVtZW50cyBJTmFtZXNwYWNlUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgbmFtZXNwYWNlOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZylcclxuXHR7XHJcblx0XHRzdXBlcihzZCk7XHJcblxyXG5cdFx0dGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcblx0XHR0aGlzLnByZWZpeCA9IHByZWZpeDtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgQ1NTIHN0cmluZyBmb3IgdGhpcyBydWxlLlxyXG4gICAgcHJvdGVjdGVkIHRvQ3NzKCk6IHN0cmluZ1xyXG4gICAge1xyXG5cdFx0bGV0IHVybCA9IHRoaXMubmFtZXNwYWNlLnN0YXJ0c1dpdGgoIFwidXJsKFwiKSA/IHRoaXMubmFtZXNwYWNlIDogYHVybCgke3RoaXMubmFtZXNwYWNlfSlgO1xyXG5cdFx0cmV0dXJuIGBAbmFtZXNwYWNlICR7dGhpcy5wcmVmaXggPyB0aGlzLnByZWZpeCA6IFwiXCJ9ICR7dXJsfWA7XHJcbiAgICB9XHJcblxyXG5cdC8qKiBOYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgcnVsZSAqL1xyXG5cdHB1YmxpYyBuYW1lc3BhY2U6IHN0cmluZztcclxuXHJcblx0LyoqIE9wdGlvbmFsIHByZWZpeCBmb3IgdGhlIHJ1bGUgKi9cclxuXHRwdWJsaWMgcHJlZml4OiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgRm9udEZhY2VSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIEBmb250LWZhY2UgQ1NTIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRm9udEZhY2VSdWxlIGV4dGVuZHMgTWlzY1J1bGU8Q1NTRm9udEZhY2VSdWxlPiBpbXBsZW1lbnRzIElGb250RmFjZVJ1bGVcclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24sIGZvbnRmYWNlOiBFeHRlbmRlZEZvbnRGYWNlKVxyXG5cdHtcclxuXHRcdHN1cGVyKHNkKTtcclxuXHJcblx0XHR0aGlzLmZvbnRmYWNlID0gZm9udGZhY2U7XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm5zIENTUyBzdHJpbmcgZm9yIHRoaXMgcnVsZS5cclxuICAgIHByb3RlY3RlZCB0b0NzcygpOiBzdHJpbmdcclxuICAgIHtcclxuXHRcdHJldHVybiBgQGZvbnQtZmFjZSB7JHtmb250RmFjZTJzKCB0aGlzLmZvbnRmYWNlKX19YDtcclxuICAgIH1cclxuXHJcblx0Ly8gT2JqZWN0IGRlZmluaW5nIGZvbnQtZmFjZSBwcm9wZXJ0aWVzLlxyXG5cdHB1YmxpYyBmb250ZmFjZTogRXh0ZW5kZWRGb250RmFjZTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFBhZ2VSdWxlIGNsYXNzIHJlcHJlc2VudHMgdGhlIENTUyBAcGFnZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENsYXNzTmFtZVJ1bGUgZXh0ZW5kcyBSdWxlTGlrZSBpbXBsZW1lbnRzIElDbGFzc05hbWVSdWxlXHJcbntcclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIHNkOiBJU3R5bGVEZWZpbml0aW9uLCBjbGFzc2VzOiAoSUNsYXNzUnVsZSB8IElDbGFzc05hbWVSdWxlIHwgc3RyaW5nKVtdKVxyXG5cdHtcclxuXHRcdHN1cGVyKHNkKTtcclxuXHRcdHRoaXMuY2xhc3NlcyA9IGNsYXNzZXM7XHJcblx0fVxyXG5cclxuXHQvLyBQcmVmaXggZm9yIENTUyBjbGFzc2VzLlxyXG5cdHB1YmxpYyBwcmVmaXg6IFwiLlwiO1xyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS5cclxuICAgIC8vIFdlIHJldHVybiB0aGUgQ1NTIGNsYXNzIG5hbWUuXHJcbiAgICBbc3ltVjJTXSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5jc3NOYW1lOyB9XHJcblxyXG5cdC8qKiBDU1MgcnVsZSBzZWxlY3RvciBzdHJpbmcgKi9cclxuXHRwdWJsaWMgZ2V0IHNlbGVjdG9yVGV4dCgpOiBzdHJpbmdcclxuXHR7XHJcblx0XHRyZXR1cm4gdGhpcy5jc3NOYW1lO1xyXG5cdH1cclxuXHJcblx0Ly8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBydWxlLlxyXG5cdHB1YmxpYyBwcm9jZXNzKCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jbGFzc2VzLm1hcCggdiA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYgOiB2Lm5hbWUpLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgIHRoaXMuY3NzTmFtZSA9IFwiLlwiICsgdGhpcy5uYW1lLnJlcGxhY2UoIC8gL2csIFwiLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdG9TdHJpbmcgbWV0aG9kIHJldHVybnMgdGhlIGNvbWJpbmVkIG5hbWUgb2YgdGhlIGNsYXNzZXMgKHdpdGhvdXRcclxuICAgIC8vIHRoZSBDU1MgcHJlZml4ZXMpLlxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmdcclxuXHR7XHJcblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xyXG5cdH1cclxuXHJcbiAgICAvKiogQWxsIGNsYXNzIG5hbWVzIGNvbmNhdGVuYXRlZCB3aXRoIHNwYWNlICovXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBBbGwgY2xhc3MgQ1NTIG5hbWVzICh3aXRoIGRvdHMpIGNvbmNhdGVuYXRlZCB0b2dldGhlciAqL1xyXG4gICAgcHVibGljIGNzc05hbWU6IHN0cmluZztcclxuXHJcbiAgICBwcml2YXRlIGNsYXNzZXM6IChJQ2xhc3NSdWxlIHwgSUNsYXNzTmFtZVJ1bGUgfCBzdHJpbmcpW107XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJUnVsZSwgSU5hbWVkRW50aXR5LCBJU3R5bGVEZWZpbml0aW9ufSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTeW1ib2wgb24gdGhlIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2UgcG9pbnRpbmcgdG8gdGhlIFJ1bGVDb250YWluZXIgb2JqZWN0IHRoYXQgaXNcclxuICogcmVzcG9uc2libGUgZm9yIHByb2Nlc3NpbmcgcnVsZXMuXHJcbiAqL1xyXG4gZXhwb3J0IGNvbnN0IHN5bVJDID0gU3ltYm9sKFwicmNcIik7XHJcblxyXG5cclxuXHJcbiAvKipcclxuICogVGhlIElSdWxlQ29udGFpbmVyIGludGVyZmFjZSByZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IGFjY29tcGFuaWVzIGFuZCBpcyBhc3NvY2lhdGVkIHdpdGhcclxuICogYSBzdHlsZSBkZWZpbml0aW9uIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVJ1bGVDb250YWluZXJcclxue1xyXG5cdC8qKiBHZW5lcmF0ZXMgYSBuYW1lLCB3aGljaCB3aWxsIGJlIHVuaXF1ZSBpbiB0aGlzIHN0eWxlc2hlZXQgKi9cclxuXHRnZXRTY29wZWROYW1lKCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCwgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSU5hbWVkRW50aXR5KTogc3RyaW5nO1xyXG5cclxuXHQvKiogSW5zZXJ0cyBhbGwgcnVsZXMgZGVmaW5lZCBpbiB0aGlzIGNvbnRhaW5lciB0byBlaXRoZXIgdGhlIHN0eWxlIHNoZWV0IG9yIGdyb3VwaW5nIHJ1bGUuICovXHJcblx0aW5zZXJ0KCBydWxlQmFnOiBJTWltY3NzUnVsZUJhZyk6IHZvaWQ7XHJcblxyXG5cdC8qKiBDbGVhcnMgYWxsIENTUyBydWxlIG9iamVjdHMgZGVmaW5lZCBpbiB0aGlzIGNvbnRhaW5lci4gKi9cclxuXHRjbGVhcigpOiB2b2lkO1xyXG5cclxuICAgIC8qKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGN1c3RvbSBDU1Mgcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lLiAqL1xyXG5cdHNldFZhclZhbHVlKCBuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudWxsLCBpbXBvcnRhbnQ/OiBib29sZWFuLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZDtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFJ1bGVMaWtlIGFic3RyYWN0IGNsYXNzIGlzIGEgYmFzZSBmb3IgYWxsIFwicnVsZXNcIiBkZWZpbmVkIGluIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzZXMgLVxyXG4gKiB3aGV0aGVyIHRoZXkgY29ycmVzcG9uZCB0byByZWFsIENTUyBydWxlcyAoYW5kIHRodXMgZGVyaXZlIGZyb20gdGhlIFJ1bGUgY2xhc3MpIG9yIG5vdCAoc3VjaCBhc1xyXG4gKiBjb3VudGVycywgZ3JpZCBsaW5lcyBhbmQgZ3JpZCBhcmVhcykuXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUnVsZUxpa2Vcclxue1xyXG4gICAgY29uc3RydWN0b3IoIHNkOiBJU3R5bGVEZWZpbml0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2QgPSBzZDtcclxuICAgICAgICB0aGlzLnJjID0gc2Rbc3ltUkNdIGFzIElSdWxlQ29udGFpbmVyO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuICAgICAqIFByb2Nlc3NlcyB0aGUgcnVsZSBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gUHJvcGVydHkgbmFtZSBjYW4gYmUgbnVsbFxyXG4gICAgICogZm9yIHJ1bGVzIG5vdCBhc3NpZ25lZCB0byBhIHByb3BlcnR5OyBlLmcuIGRlcGVuZGVudCBydWxlcyBkZWZpbmVkIGluIHRoZSBDb21iaW5lZFN0eWxlc2V0LlxyXG4gICAgICovXHJcblx0cHVibGljIHByb2Nlc3MoIHByb3BOYW1lOiBzdHJpbmcgfCBudWxsKTogdm9pZCB7fVxyXG5cclxuXHJcblxyXG5cdC8qKiBTdHlsZSBEZWZpbml0aW9uIG9iamVjdCB0byB3aGljaCB0aGlzIHJ1bGUgYmVsb25ncy4gKi9cclxuXHRwdWJsaWMgc2Q6IElTdHlsZURlZmluaXRpb247XHJcblxyXG5cdC8qKiBSdWxlIENvbnRhaW5lciBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdHlsZSBkZWZpbml0aW9uIG9iamVjdCB0byB3aGljaCB0aGlzIHJ1bGUgYmVsb25ncy4gKi9cclxuXHRwdWJsaWMgcmM6IElSdWxlQ29udGFpbmVyO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUnVsZSBjbGFzcyBpcyB1c2VkIGFzIGEgYmFzZSBjbGFzcyBmb3IgYWxsIHJ1bGVzLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJ1bGUgZXh0ZW5kcyBSdWxlTGlrZSBpbXBsZW1lbnRzIElSdWxlXHJcbntcclxuXHQvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuXHQvLyBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLCB0byB3aGljaCB0aGlzIHJ1bGUgYmVsb25ncywgaXMgYWN0aXZhdGVkLlxyXG5cdHB1YmxpYyBhYnN0cmFjdCBpbnNlcnQoIHJ1bGVCYWc6IElNaW1jc3NSdWxlQmFnKTogdm9pZDtcclxuXHJcblx0Ly8gQ2xlcnMgdGhlIENTUyBydWxlIG9iamVjdC4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MsIHRvIHdoaWNoXHJcblx0Ly8gdGhpcyBydWxlIGJlbG9uZ3MsIGlzIGRlYWN0aXZhdGVkLlxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHsgdGhpcy5jc3NSdWxlID0gbnVsbDsgfVxyXG5cclxuXHJcblxyXG5cdC8vIENTU1J1bGUtZGVyaXZlZCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgYWN0dWFsbCBDU1MgcnVsZSBpbnNlcnRlZCBpbnRvXHJcblx0Ly8gdGhlIHN0eWxlcyBzaGVldCBvciB0aGUgcGFyZW50IHJ1bGUuXHJcblx0cHVibGljIGNzc1J1bGU6IENTU1J1bGUgfCBudWxsO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDbGllbnQtIGFuZCBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgaW50ZXJmYWNlc1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBjb250ZXh0IGluIHdoaWNoIHN0eWxlIGRlZmluaXRpb25zIGFyZSBhY3RpdmF0ZWQuIERpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnNcclxuICogZXhpc3RzIGZvciBjbGllbnQtc2lkZSBhbmQgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQWN0aXZhdGlvbkNvbnRleHRcclxue1xyXG4gICAgZ2V0VGhlbWVQbGFjZWhvbGRlcigpOiBJTWltY3NzU3R5bGVFbGVtZW50O1xyXG4gICAgY3JlYXRlU3R5bGVFbG0oIGlkOiBzdHJpbmcsIGluc2VydEJlZm9yZT86IElNaW1jc3NTdHlsZUVsZW1lbnQpOiBJTWltY3NzU3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBvYmplY3QgdG8gd2hpY2ggcnVsZXMgY2FuIGJlIGFkZGVkLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJTWltY3NzUnVsZUJhZ1xyXG57XHJcbiAgICBhZGQoIHJ1bGVUZXh0OiBzdHJpbmcpOiBJTWltY3NzUnVsZSB8IG51bGw7XHJcbiAgICBhZGRHcm91cCggc2VsZWN0b3I6IHN0cmluZyk6IElNaW1jc3NHcm91cGluZ1J1bGUgfCBudWxsO1xyXG4gICAgYWRkS2V5ZnJhbWVzKCBuYW1lOiBzdHJpbmcpOiBJTWltY3NzS2V5ZnJhbWVzUnVsZSB8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc3R5bGUgZWxlbWVudCB0byB3aGljaCBydWxlcyBjYW4gYmUgYWRkZWQuIERpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnNcclxuICogZXhpc3RzIGZvciBjbGllbnQtc2lkZSBhbmQgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJTWltY3NzU3R5bGVFbGVtZW50IGV4dGVuZHMgSU1pbWNzc1J1bGVCYWdcclxue1xyXG4gICAgcmVhZG9ubHkgZG9tRWxtOiBIVE1MU3R5bGVFbGVtZW50IHwgbnVsbDtcclxuICAgIHJlbW92ZSgpOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJhc2UgaW50ZXJmYWNlIGZvciBDU1MgcnVsZS4gRGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBleGlzdHMgZm9yIGNsaWVudC1zaWRlXHJcbiAqIGFuZCBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElNaW1jc3NSdWxlXHJcbntcclxuICAgIHJlYWRvbmx5IGNzc1J1bGU6IENTU1J1bGUgfCBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGdyb3VwaW5nIHJ1bGUgdG8gd2hpY2ggcnVsZXMgY2FuIGJlIGFkZGVkLiBEaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zXHJcbiAqIGV4aXN0cyBmb3IgY2xpZW50LXNpZGUgYW5kIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU1pbWNzc0dyb3VwaW5nUnVsZSBleHRlbmRzIElNaW1jc3NSdWxlLCBJTWltY3NzUnVsZUJhZ1xyXG57XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEga2V5ZnJhbWVzIHJ1bGUgdG8gd2hpY2ggZnJhbWVzIGNhbiBiZSBhZGRlZC4gRGlmZmVyZW50IGltcGxlbWVudGF0aW9uc1xyXG4gKiBleGlzdHMgZm9yIGNsaWVudC1zaWRlIGFuZCBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElNaW1jc3NLZXlmcmFtZXNSdWxlIGV4dGVuZHMgSU1pbWNzc1J1bGVcclxue1xyXG4gICAgYWRkRnJhbWUoIGZyYW1lVGV4dDogc3RyaW5nKTogSU1pbWNzc1J1bGUgfCBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgY29udGV4dCBpbiB3aGljaCBzdHlsZSBkZWZpbml0aW9ucyBhcmUgYWN0aXZhdGVkLiBEaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zXHJcbiAqIGV4aXN0cyBmb3IgY2xpZW50LXNpZGUgYW5kIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVNlcnZlckFjdGl2YXRpb25Db250ZXh0IGV4dGVuZHMgSUFjdGl2YXRpb25Db250ZXh0XHJcbntcclxuICAgIHNlcmlhbGl6ZSgpOiBzdHJpbmc7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJTmFtZWRFbnRpdHksIElTdHlsZURlZmluaXRpb24sIElTdHlsZURlZmluaXRpb25DbGFzcywgSVZhclJ1bGUsIE5hbWVHZW5lcmF0aW9uTWV0aG9kfSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiXHJcbmltcG9ydCB7U3R5bGVEZWZpbml0aW9uLCBUaGVtZURlZmluaXRpb259IGZyb20gXCIuLi9hcGkvUnVsZUFQSVwiXHJcbmltcG9ydCB7XHJcbiAgICBSdWxlLCBSdWxlTGlrZSwgSVJ1bGVDb250YWluZXIsIElBY3RpdmF0aW9uQ29udGV4dCwgSU1pbWNzc0dyb3VwaW5nUnVsZSwgSU1pbWNzc0tleWZyYW1lc1J1bGUsXHJcbiAgICBJTWltY3NzUnVsZSwgSU1pbWNzc1N0eWxlRWxlbWVudCwgSU1pbWNzc1J1bGVCYWcsIElTZXJ2ZXJBY3RpdmF0aW9uQ29udGV4dCwgc3ltUkNcclxufSBmcm9tIFwiLi9SdWxlXCJcclxuaW1wb3J0IHtWYXJSdWxlfSBmcm9tIFwiLi9WYXJSdWxlXCJcclxuaW1wb3J0IHtJbXBvcnRSdWxlLCBOYW1lc3BhY2VSdWxlfSBmcm9tIFwiLi9NaXNjUnVsZXNcIlxyXG5pbXBvcnQge2dldEFjdGl2YXRvciwgc2V0RGVmYXVsdFNjaGVkdWxlcn0gZnJvbSBcIi4uL2ltcGwvU2NoZWR1bGluZ0ltcGxcIjtcclxuaW1wb3J0IHtTY2hlZHVsZXJUeXBlfSBmcm9tIFwiLi4vYXBpL1NjaGVkdWxpbmdUeXBlc1wiXHJcblxyXG5cclxuXHJcbi8qKiBTeW1ib2wgb24gdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MgcG9pbnRpbmcgdG8gdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS4gKi9cclxuY29uc3Qgc3ltSW5zdGFuY2UgPSBTeW1ib2woXCJzZFwiKTtcclxuXHJcbi8qKlxyXG4gKiBTeW1ib2wgb24gdGhlIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2UgcG9pbnRpbmcgdG8gdGhlIFN0eWxlRGVmaW5pdGlvbiBjbGFzcyBmb3Igd2hpY2hcclxuICogdGhpcyBpbnN0YW5jZSB3YXMgY3JlYXRlZC5cclxuICovXHJcbmNvbnN0IHN5bUNsYXNzID0gU3ltYm9sKFwic2RjXCIpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogRmxhZyBpbmRpY2F0aW5nIHRoYXQgYSBydWxlIGNvbnRhaW5lciBpcyBjcmVhdGVkIG5vdCBkaXJlY3RseSAoYXMgZm9yIHN0eWxlZCBjb21wb25lbnRzKVxyXG4gKiBidXQgZnJvbSB0aGUgcHJvY2Vzc0NsYXNzIGZ1bmN0aW9uLiBUaGlzIHZhcmlhYmxlIGlzIHNldCB0byB0cnVlIGJlZm9yZSBpbnN0YW50aWF0aW5nIHRoZVxyXG4gKiBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIChhbmQgdGh1cyB0aGUgUnVsZUNvbnRhaW5lciBvYmplY3QpIGFuZCBpcyBzZXQgYmFjayB0byBmYWxzZSBhZnRlclxyXG4gKiBpdCBpcyB1c2VkIGluIHRoZSBSdWxlQ29udGFpbmVyIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxubGV0IHNfcHJvY2Vzc2luZ1N0eWxlRGVmaW5pdGlvbkNsYXNzID0gZmFsc2U7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUnVsZUNvbnRhaW5lciBjbGFzcyBpcyBhIHNoYWRvdyBzdHJ1Y3R1cmUgdGhhdCBhY2NvbXBhbmllcyBldmVyeSBwcm9jZXNzZWQgc3R5bGUgZGVmaW5pdGlvblxyXG4gKiBvYmplY3QuIFNpbmNlIFN0eWxlRGVmaW5pdGlvbiBjbGFzcyBpcyBhbiBleHBvcnRlZCBjbGFzcyB2aXNpYmxlIHRvIGRldmVsb3BlcnMsIHdlIGRvbid0IHdhbnRcclxuICogdG8gaGF2ZSBhIGxvdCBvZiBmdW5jdGlvbmFsaXR5IGluIGl0LiBUaGUgUnVsZUNvbnRhaW5lciBvYmplY3QgaXMgbGlua2VkIHRvIHRoZSBTdHlsZURlZmluaXRpb25cclxuICogb2JqZWN0IHZpYSB0aGUgW3N5bUNvbnRhaW5lcl0gc3ltYm9sLiBJdCBjb250YWlucyBhbGwgdGhlIGZ1bmN0aW9uYWxpdHkgZm9yIHBhcnNpbmcgcnVsZVxyXG4gKiBkZWZpbml0aW9ucywgbmFtZSBhc3NpZ25tZW50IGFuZCBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQ29udGFpbmVyIGltcGxlbWVudHMgSVJ1bGVDb250YWluZXIsIFByb3h5SGFuZGxlcjxTdHlsZURlZmluaXRpb24+XHJcbntcclxuXHRjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24pXHJcblx0e1xyXG5cdFx0dGhpcy5zZCA9IHNkO1xyXG5cclxuICAgICAgICB0aGlzLnNkYyA9IHNkLmNvbnN0cnVjdG9yIGFzIElTdHlsZURlZmluaXRpb25DbGFzcztcclxuICAgICAgICB0aGlzLnBzZCA9IHNkLiRwYXJlbnQ7XHJcblx0XHR0aGlzLmVjID0gdGhpcy5zZGNbc3ltRW1iZWRkaW5nQ29udGFpbmVyXTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHBhcmVudCBhbmQgdG9wIGxldmVsIGNvbnRhaW5lcnNcclxuICAgICAgICBpZiAodGhpcy5wc2QpXHJcbiAgICAgICAgICAgIHRoaXMucGMgPSB0aGlzLnBzZFtzeW1SQ107XHJcblxyXG4gICAgICAgIC8vIHNldCB0aGUgbmFtZSBmb3Igb3VyIGNvbnRhaW5lci4gRm9yIG9wdGltaXplZCBuYW1lIGdlbmVyYXRpb24gbW9kZSwgZ2VuZXJhdGUgdW5pcXVlXHJcbiAgICAgICAgLy8gbmFtZS4gT3RoZXJ3aXNlLCBpZiB0aGUgY29udGFpbmVyIGlzIGNyZWF0ZWQgZm9yIGEgY2xhc3MgZnJvbSB0aGVcclxuICAgICAgICAvLyBwcm9jZXNzQ2xhc3MgZnVuY3Rpb24sIHRoZW4gdGhlIGZsYWcgc19wcm9jZXNzaW5nU3R5bGVEZWZpbml0aW9uQ2xhc3MgaXMgZGVmaW5lZFxyXG4gICAgICAgIC8vIGFuZCB0aGUgbmFtZSBpcyBnZW5lcmF0ZWQgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGdlbmVyYXRpb24gbWV0aG9kLiBJZiB0aGlzIGZsYWcgaXNcclxuICAgICAgICAvLyBmYWxzZSwgdGhhdCBtZWFucyB0aGF0IHRoZSBjb250YWluZXIgaXMgY3JlYXRlZCBmcm9tIGEgZGlyZWN0IFwibmV3XCIgY2FsbCBvbiB0aGUgc3R5bGVcclxuICAgICAgICAvLyBkZWZpbml0aW9uIGNsYXNzIGFuZCB0aGUgbmFtZSBpcyBnZW5lcmF0ZWQgdW5pcXVlbHkuXHJcbiAgICAgICAgaWYgKHNfbmFtZUdlbmVyYXRvbk1ldGhvZCA9PT0gTmFtZUdlbmVyYXRpb25NZXRob2QuT3B0aW1pemVkKVxyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBnZW5lcmF0ZVVuaXF1ZU5hbWUoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gdGhpcy5zZGMubmFtZTtcclxuICAgICAgICAgICAgbGV0IG5hbWUgPSBjbGFzc05hbWUgPyBcIlwiIDogZ2VuZXJhdGVVbmlxdWVOYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChzX3Byb2Nlc3NpbmdTdHlsZURlZmluaXRpb25DbGFzcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc19wcm9jZXNzaW5nU3R5bGVEZWZpbml0aW9uQ2xhc3MgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBuYW1lID0gIWNsYXNzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2VuZXJhdGVVbmlxdWVOYW1lKClcclxuICAgICAgICAgICAgICAgICAgICA6IHNfbmFtZUdlbmVyYXRvbk1ldGhvZCA9PT0gTmFtZUdlbmVyYXRpb25NZXRob2QuVW5pcXVlU2NvcGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2VuZXJhdGVVbmlxdWVOYW1lKCBjbGFzc05hbWUgKyBcIl9cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gZ2VuZXJhdGVVbmlxdWVOYW1lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gXCJfXCIgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIG91ciBjb250YWluZXIgaGFzIHBhcmVudCBjb250YWluZXIsIHByZWZpeCBvdXIgbmFtZSB3aXRoIHRoZSB1cHBlciBvbmVcclxuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5wYyA/IGAke3RoaXMucGMubmFtZX1fJHtuYW1lfWAgOiBuYW1lO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG5cclxuXHJcbiAgICAvLyBQcm94eUhhbmRsZXIgbWV0aG9kLCB3aGljaCB2aXJ0dWFsaXplcyBhbGwgUnVsZUxpa2UgcHJvcGVydGllc1xyXG4gICAgc2V0KCB0OiBTdHlsZURlZmluaXRpb24sIHA6IFByb3BlcnR5S2V5LCB2OiBhbnksIHI6IGFueSk6IGJvb2xlYW5cclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHAgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHYgIT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgIHRbcF0gPSB2O1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgdmlydHVhbGl6ZSBydWxlLWxpa2Ugb2JqZWN0cy4gV2UgZG9uJ3QgdmlydHVhbGl6ZSBhcnJheXMgYmVjYXVzZSB0aGVyZVxyXG4gICAgICAgICAgICAvLyBpcyBubyB0cmFwIGZvciBpc0FycmF5KCkgbWV0aG9kLCB3aGljaCB3ZSB1c2UgbGF0ZXIgaW4gdGhlIHByb2Nlc3NQcm9wZXJ0eSgpXHJcbiAgICAgICAgICAgIC8vIG1ldGhvZC4gV2UgYWxzbyBkb24ndCB2aXJ0dWFsaXplIHByaW1pdGl2ZSB0eXBlcyBiZWNhdXNlIHRoZXJlIGlzIG5vIHRyYXAgZm9yXHJcbiAgICAgICAgICAgIC8vIHR5cGVvZiBvcGVyYXRpb24gKG5lZWRlZCB3aGVuIGNvbnZlcnRpbmcgdmFsdWVzIHRvIHN0cmluZ3MpLiBXZSBhbHNvIGRvbid0XHJcbiAgICAgICAgICAgIC8vIHZpcnR1YWxpemUgc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZXMgKHJlc3VsdHMgb2YgJHVzZSgpIG1ldGhvZCBpbnZvY2F0aW9ucykuXHJcbiAgICAgICAgICAgIGxldCBpc1J1bGVMaWtlID0gdiBpbnN0YW5jZW9mIFJ1bGVMaWtlO1xyXG4gICAgICAgICAgICBpZiAocCBpbiB0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSdWxlTGlrZSlcclxuICAgICAgICAgICAgICAgICAgICB2LnByb2Nlc3MoIHApO1xyXG5cclxuICAgICAgICAgICAgICAgIHRbcF0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUnVsZUxpa2UpXHJcbiAgICAgICAgICAgICAgICAgICAgdmlydHVhbGl6ZSggdCwgcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQcm9wZXJ0eSggcCwgdFtwXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS4gVGhpcyBjcmVhdGVzIG5hbWVzIGZvciBjbGFzc2VzLFxyXG5cdC8vIElEcywgYW5pbWF0aW9ucyBhbmQgY3VzdG9tIHZhcmlhYmxlcy5cclxuXHRwcml2YXRlIHByb2Nlc3NQcm9wZXJ0eSggcHJvcE5hbWU6IHN0cmluZyB8IG51bGwsIHByb3BWYWw6IGFueSk6IHZvaWRcclxuXHR7XHJcblx0XHRpZiAocHJvcFZhbCBpbnN0YW5jZW9mIFN0eWxlRGVmaW5pdGlvbilcclxuICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goIHByb3BWYWwpO1xyXG4gICAgICAgIC8vIGVsc2UgaWYgKHByb3BWYWwgaW5zdGFuY2VvZiBBcnJheSlcclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWwpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGFycmF5IGVsZW1lbnRzIGFuZCByZWN1cnNpdmVseSBwcm9jZXNzIHRoZW0uIEluZGV4IGJlY29tZXMgcGFydCBvZiB0aGVcclxuICAgICAgICAgICAgLy8gcnVsZSBuYW1lLlxyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIGZvciggbGV0IGl0ZW0gb2YgcHJvcFZhbClcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1Byb3BlcnR5KCBgJHtwcm9wTmFtZX1fJHtpKyt9YCwgaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wVmFsIGluc3RhbmNlb2YgUnVsZUxpa2UpXHJcbiAgICAgICAgICAgICAgICBwcm9wVmFsLnByb2Nlc3MoIHByb3BOYW1lKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wVmFsIGluc3RhbmNlb2YgVmFyUnVsZSlcclxuICAgICAgICAgICAgICAgIHRoaXMudmFycy5wdXNoKCBwcm9wVmFsKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcFZhbCBpbnN0YW5jZW9mIEltcG9ydFJ1bGUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHMucHVzaCggcHJvcFZhbCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BWYWwgaW5zdGFuY2VvZiBOYW1lc3BhY2VSdWxlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2VzLnB1c2goIHByb3BWYWwpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wVmFsIGluc3RhbmNlb2YgUnVsZSlcclxuICAgICAgICAgICAgICAgIHRoaXMucnVsZXMucHVzaCggcHJvcFZhbCk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGN1c3RvbSBDU1Mgcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG5cdHB1YmxpYyBzZXRWYXJWYWx1ZSggbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBpbXBvcnRhbnQ/OiBib29sZWFuLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICh0aGlzLnZhclJvb3RSdWxlKVxyXG4gICAgICAgIGdldEFjdGl2YXRvcihzY2hlZHVsZXJUeXBlKS51cGRhdGVTdHlsZSggdGhpcy52YXJSb290UnVsZSwgbmFtZSwgdmFsdWUsIGltcG9ydGFudCk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIGdsb2JhbGx5IHVuaXF1ZSBDU1MgbmFtZSBmb3IgdGhlIGdpdmVuIHJ1bGUgbmFtZSB1bmxlc3MgdGhpcyBydWxlIG5hbWUgYWxyZWFkeVxyXG5cdCAqIGV4aXN0cyBlaXRoZXIgaW4gYSBiYXNlIGNsYXNzIG9yIGluIHRoZSBjaGFpbiBvZiBwYXJlbnQgZ3JvdXBpbmcgcnVsZXMuXHJcblx0ICovXHJcblx0cHVibGljIGdldFNjb3BlZE5hbWUoIHJ1bGVOYW1lOiBzdHJpbmcsIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElOYW1lZEVudGl0eSk6IHN0cmluZ1xyXG5cdHtcclxuICAgICAgICBpZiAobmFtZU92ZXJyaWRlKVxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG5hbWVPdmVycmlkZSA9PT0gXCJzdHJpbmdcIiA/IG5hbWVPdmVycmlkZSA6IG5hbWVPdmVycmlkZS5uYW1lO1xyXG5cdFx0ZWxzZSBpZiAoIXJ1bGVOYW1lKVxyXG5cdFx0XHRyZXR1cm4gZ2VuZXJhdGVVbmlxdWVOYW1lKCk7XHJcblx0XHRlbHNlIGlmIChydWxlTmFtZSBpbiB0aGlzLnNkICYmIFwibmFtZVwiIGluIHRoaXMuc2RbcnVsZU5hbWVdKVxyXG4gICAgICAgICAgICAvLyB0aGlzIGhhbmRsZXMgY2FzZXMgd2hlbiBhIFwibmFtZWRcIiBydWxlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBzdHlsZSBkZWZpbml0aW9uO1xyXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSB3aGVuIGEgZGVyaXZlZCBjbGFzcyBvdmVycmlkZXMgdGhlIHZhbHVlIG9mIGEgYmFzZSBjbGFzc1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZFtydWxlTmFtZV0ubmFtZTtcclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0Ly8gZmluZCBvdXQgaWYgdGhlcmUgaXMgYSBydWxlIHdpdGggdGhpcyBuYW1lIGRlZmluZWQgaW4gYSBzdHlsZXNoZWV0IGluc3RhbmNlIGNyZWF0ZWRcclxuICAgICAgICAgICAgLy8gZm9yIGEgY2xhc3MgZnJvbSB0aGUgcHJvdG90eXBlIGNoYWluIG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBPdGhlcndpc2UsIGlmXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgcGFyZW50IGNvbnRhaW5lciwgcmVjdXJzZSB0byBpdDsgb3RoZXJ3aXNlLCBnZW5lcmF0ZSB0aGUgbmFtZS5cclxuXHRcdFx0bGV0IGV4aXN0aW5nTmFtZSA9IGZpbmROYW1lRm9yUnVsZUluUHJvdG90eXBlQ2hhaW4oIHRoaXMuc2RjLCBydWxlTmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ05hbWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdOYW1lO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBjKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGMuZ2V0U2NvcGVkTmFtZSggcnVsZU5hbWUpO1xyXG4gICAgICAgICAgICBlbHNlXHJcblx0XHRcdCAgICByZXR1cm4gZ2VuZXJhdGVOYW1lKCB0aGlzLm5hbWUsIHJ1bGVOYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcbiAgICAvKiogSW5zZXJ0cyBhbGwgcnVsZXMgZGVmaW5lZCBpbiB0aGlzIGNvbnRhaW5lciB0byBlaXRoZXIgdGhlIHN0eWxlIHNoZWV0IG9yIGdyb3VwaW5nIHJ1bGUuICovXHJcblx0cHVibGljIGluc2VydCggcnVsZUJhZzogSU1pbWNzc1J1bGVCYWcpOiB2b2lkXHJcblx0e1xyXG5cdFx0Ly8gaW5zZXJ0IEBpbXBvcnQgYW5kIEBuYW1lc3BhY2UgcnVsZXMgYXMgdGhleSBtdXN0IGJlIGJlZm9yZSBvdGhlciBydWxlcy4gSWYgdGhlIHBhcmVudCBpcyBhIGdyb3VwaW5nXHJcblx0XHQvLyBydWxlLCBkb24ndCBpbnNlcnQgQGltcG9ydCBhbmQgQG5hbWVzcGFjZSBydWxlcyBhdCBhbGxcclxuXHRcdGlmICghdGhpcy5wc2QpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuaW1wb3J0cy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuaW5zZXJ0KCBydWxlQmFnKSk7XHJcblx0XHRcdHRoaXMubmFtZXNwYWNlcy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuaW5zZXJ0KCBydWxlQmFnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWN0aXZhdGUgcmVmZXJlbmNlZCBzdHlsZSBkZWZpbml0aW9uc1xyXG5cdFx0Zm9yKCBsZXQgcmVmIG9mIHRoaXMucmVmcylcclxuXHRcdFx0cmVmW3N5bVJDXS5hY3RpdmF0ZSggdGhpcy5lbG0pO1xyXG5cclxuXHRcdC8vIGluc2VydCBvdXIgY3VzdG9tIHZhcmlhYmxlcyBpbnRvIHRoZSBcIjpyb290XCIgcnVsZVxyXG5cdFx0aWYgKHRoaXMudmFycy5sZW5ndGggPiAwKVxyXG5cdFx0XHR0aGlzLnZhclJvb3RSdWxlID0gcnVsZUJhZy5hZGQoIGdldFJvb3RDc3NGb3JWYXJzKCB0aGlzLnZhcnMpKT8uY3NzUnVsZSBhcyBDU1NTdHlsZVJ1bGU7XHJcblxyXG5cdFx0Ly8gaW5zZXJ0IGFsbCBvdGhlciBydWxlc1xyXG5cdFx0dGhpcy5ydWxlcy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuaW5zZXJ0KCBydWxlQmFnKSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKiBDbGVhcnMgYWxsIENTUyBydWxlIG9iamVjdHMgZGVmaW5lZCBpbiB0aGlzIGNvbnRhaW5lci4gKi9cclxuXHRwdWJsaWMgY2xlYXIoKTogdm9pZFxyXG5cdHtcclxuICAgICAgICAvLyBpbXBvcnQgYW5kIG5hbWVzcGFjZSBydWxlcyBjYW4gb25seSBleGlzdCBpbiB0aGUgdG9wLWxldmVsIHN0eWxlIGRlZmluaXRpb24gY2xhc3NcclxuXHRcdGlmICghdGhpcy5wc2QpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuaW1wb3J0cy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuY2xlYXIoKSk7XHJcblx0XHRcdHRoaXMubmFtZXNwYWNlcy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuY2xlYXIoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy52YXJSb290UnVsZSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR0aGlzLnJ1bGVzLmZvckVhY2goIHJ1bGUgPT4gcnVsZS5jbGVhcigpKTtcclxuXHJcblx0XHQvLyBkZWFjdGl2YXRlIGltcG9ydGVkIHN0eWxlc2hlZXRzXHJcblx0XHRmb3IoIGxldCByZWYgb2YgdGhpcy5yZWZzKVxyXG5cdFx0XHRyZWZbc3ltUkNdLmRlYWN0aXZhdGUoKTtcclxuXHR9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgdGhpcyBzdHlsZXNoZWV0IGludG8gRE9NLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnNlcnRCZWZvcmUgT3B0aW9uYWwgSFRNTCBlbGVtZW50IGJlZm9yZSB3aGljaCB0aGUgbmV3ICc8c3R5bGU+JyBlbGVtZW50IHNob3VsZCBiZVxyXG4gICAgICogaW5zZXJ0ZWQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBuZXcgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGFzIHRoZSBsYXN0IGVsZW1lbnQgdW5kZXIgdGhlXHJcbiAgICAgKiAnPGhlYWQ+JyBlbGVtZW50LlxyXG4gICAgICovXHJcblx0cHVibGljIGFjdGl2YXRlKCBpbnNlcnRCZWZvcmU/OiBJTWltY3NzU3R5bGVFbGVtZW50KTogdm9pZFxyXG5cdHtcclxuICAgICAgICAvLyBhY3RpdmF0aW9uIGNvbnRleHQgbWF5IG5vdCBleGlzdCBpZiB0aGUgY29kZSBpcyBleGVjdXRpbmcgb24gYSBzZXJ2ZXIgYW5kIFNTUiBoYXNcclxuICAgICAgICAvLyBub3QgYmVlbiBzdGFydGVkXHJcblx0XHRpZiAoIXNfYWN0aXZhdGlvbkNvbnRleHQgfHwgKyt0aGlzLnJlZkNvdW50ID4gMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBvbmx5IHRoZSB0b3AtbGV2ZWwgbm90LWVtYmVkZGVkIHN0eWxlIGRlZmluaXRpb25zIGNyZWF0ZSB0aGUgYDxzdHlsZT5gIGVsZW1lbnRcclxuICAgICAgICBpZiAoIXRoaXMucGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lYylcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxtID0gdGhpcy5lYy5lbG07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlbWVzIGFyZSBpbnNlcnRlZCBiZWZvcmUgdGhlIHNwZWNpYWwgcGxhY2Vob2xkZXIgZWxlbWVudCwgd2hpY2ggaXMgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhlIHRvcCBvZiB0aGUgJzxoZWFkPicgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2QgaW5zdGFuY2VvZiBUaGVtZURlZmluaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlID0gc19hY3RpdmF0aW9uQ29udGV4dD8uZ2V0VGhlbWVQbGFjZWhvbGRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZWxtID0gc19hY3RpdmF0aW9uQ29udGV4dD8uY3JlYXRlU3R5bGVFbG0oIHRoaXMubmFtZSwgaW5zZXJ0QmVmb3JlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuZWxtID0gdGhpcy5wYy5lbG07XHJcblxyXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0aGVtZSBjbGFzcyBhY3RpdmF0aW9uLCBjaGVjayB3aGV0aGVyIHRoZSBpbnN0YW5jZSBpcyBzZXQgYXMgdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyBvbmUgZm9yIGl0cyB0aGVtZSBiYXNlIGNsYXNzLiBJZiBubywgdGhlbiBkZWFjdGl2YXRlIHRoZSB0aGVtZSBpbnN0YW5jZSBjdXJyZW50bHkgc2V0XHJcbiAgICAgICAgLy8gYXMgYWN0aXZlLiBJbiBhbnkgY2FzZSwgc2V0IG91ciBuZXcgaW5zdGFuY2UgYXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgb25lLiBXZSBpZ25vcmVcclxuICAgICAgICAvLyB0aGVtZSBkZWNsYXJhdGlvbiBjbGFzc2VzIC0gdGhvc2UgdGhhdCBkaXJlY3RseSBkZXJpdmUgZnJvbSBUaGVtZURlZmluaXRpb25cclxuICAgICAgICBpZiAodGhpcy5zZCBpbnN0YW5jZW9mIFRoZW1lRGVmaW5pdGlvbiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5zZGMpICE9PSBUaGVtZURlZmluaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgdGhlbWVDbGFzcyA9IHRoaXMuc2Rbc3ltQ2xhc3NdIGFzIHVua25vd24gYXMgSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFRoZW1lRGVmaW5pdGlvbj47XHJcbiAgICAgICAgICAgIGlmICh0aGVtZUNsYXNzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3Vyckluc3RhbmNlID0gZ2V0Q3VycmVudFRoZW1lKCB0aGVtZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJySW5zdGFuY2UgJiYgY3Vyckluc3RhbmNlICE9PSB0aGlzLnNkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyQ29udGFpbmVyID0gY3Vyckluc3RhbmNlW3N5bVJDXSBhcyBSdWxlQ29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJDb250YWluZXIuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUaGVtZSggdGhpcy5zZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5zZXJ0KCB0aGlzLmVsbSEpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cdC8qKiBSZW1vdmVzIHRoaXMgc3R5bGVzaGVldCBmcm9tIERPTS4gKi9cclxuXHRwdWJsaWMgZGVhY3RpdmF0ZSgpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIC8vIGd1YXJkIGZyb20gZXh0cmEgZGVhY3RpdmF0ZSBjYWxsc1xyXG5cdFx0aWYgKHRoaXMucmVmQ291bnQgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLy8gI2lmIERFQlVHXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBgRXh0cmEgY2FsbCB0byBkZWFjdGl2YXRlKCkgZm9yIHN0eWxlIGRlZmluaXRpb24gY2xhc3MgJyR7dGhpcy5uYW1lfSdgKTtcclxuICAgICAgICAgICAgLy8vICNlbmRpZlxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcblx0XHRpZiAoLS10aGlzLnJlZkNvdW50ID4gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIC8vIG9ubHkgdGhlIHRvcC1sZXZlbCBub3QtZW1iZWRkZWQgc3R5bGUgZGVmaWl0aW9ucyBjcmVhdGUgdGhlIGA8c3R5bGU+YCBlbGVtZW50XHJcbiAgICAgICAgaWYgKCF0aGlzLnBzZCAmJiAhdGhpcy5lYylcclxuICAgICAgICAgICAgdGhpcy5lbG0hLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmVsbSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRoZW1lIGNsYXNzIGRlYWN0aXZhdGlvbiwgY2hlY2sgd2hldGhlciB0aGUgaW5zdGFuY2UgaXMgc2V0IGFzIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gb25lIGZvciBpdHMgdGhlbWUgYmFzZSBjbGFzcy4gSWYgeWVzLCByZW1vdmUgaXQgYXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgb25lLlxyXG4gICAgICAgIGlmICh0aGlzLnNkIGluc3RhbmNlb2YgVGhlbWVEZWZpbml0aW9uICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLnNkYykgIT09IFRoZW1lRGVmaW5pdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCB0aGVtZUNsYXNzID0gdGhpcy5zZFtzeW1DbGFzc10gYXMgdW5rbm93biBhcyBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VGhlbWVEZWZpbml0aW9uPjtcclxuICAgICAgICAgICAgaWYgKHRoZW1lQ2xhc3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJySW5zdGFuY2UgPSBnZXRDdXJyZW50VGhlbWUoIHRoZW1lQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJJbnN0YW5jZSA9PT0gdGhpcy5zZClcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDdXJyZW50VGhlbWUoIHRoZW1lQ2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuICAgICAqIFN0eWxlIERlZmluaXRpb24gLSBpbnN0YW5jZSBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB0aGF0IHRoaXMgY29udGFpbmVyIGlzXHJcbiAgICAgKiBhdHRhY2hlZCB0by5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBzZDogSVN0eWxlRGVmaW5pdGlvbjtcclxuXHJcblx0LyoqIFN0eWxlIERlZmluaXRpb24gQ2xhc3MgdG8gd2hvc2UgaW5zdGFuY2UgdGhpcyBjb250YWluZXIgaXMgYXR0YWNoZWQuICovXHJcblx0cHVibGljIHNkYzogSVN0eWxlRGVmaW5pdGlvbkNsYXNzXHJcblxyXG5cdC8qKlxyXG4gICAgICogTmFtZSBvZiB0aGlzIGNvbnRhaW5lciwgd2hpY2gsIGRlcGVuZGluZyBvbiB0aGUgbW9kZSwgaXMgZWl0aGVyIHRha2VuIGZyb20gdGhlIGNsYXNzXHJcbiAgICAgKiBkZWZpbml0aW9uIG5hbWUgb3IgZ2VuZXJhdGVkIHVuaXF1ZWx5LlxyXG4gICAgICovXHJcblx0cHVibGljIG5hbWU6IHN0cmluZ1xyXG5cclxuXHQvKiogRW1iZWRkaW5nIENvbnRhaW5lciB0aGF0IGlzIGVtYmVkZGluZyBvdXIgaW5zdGFuY2UgKHRoYXQgaXMsIHRoZSBpbnN0YW5jZSBjb3JyZXNwb25kaW5nXHJcbiAgICAgKiB0byBvdXIgY29udGFpbmVyKS4gSWYgZGVmaW5lZCwgdGhpcyBjb250YWluZXIncyBgPHN0eWxlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGluc2VydCBDU1NcclxuICAgICAqIHJ1bGVzIGludG8gaW5zdGVhZCBvZiB0b3BMZXZlbENvbnRhaW5lci5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBlYz86IEVtYmVkZGluZ0NvbnRhaW5lcjtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBQYXJlbnQgU3R5bGUgRGVmaW5pdGlvbiAtIGluc3RhbmNlIG9mIHRoZSBwYXJlbnQgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBpbiB0aGUgY2hhaW4gb2ZcclxuICAgICAqIGdyb3VwaW5nIHJ1bGVzIHRoYXQgbGVhZCB0byB0aGlzIHJ1bGUgY29udGFpbmVyLiBGb3IgdG9wLWxldmVsIHN0eWxlIGRlZmluaXRpb25zLCB0aGlzIGlzXHJcbiAgICAgKiB1bmRlZmluZWQuXHJcbiAgICAgKi9cclxuXHRwcml2YXRlIHBzZD86IElTdHlsZURlZmluaXRpb247XHJcblxyXG5cdC8qKiBQYXJlbnQgQ29udGFpbmVyIC0gcnVsZSBjb250YWluZXIgdGhhdCBiZWxvbmdzIHRvIHRoZSBwYXJlbnQgc3R5bGUgZGVmaW50aW9uLiBJZiBvdXJcclxuICAgICAqIGNvbnRhaW5lciBpcyB0b3AtbGV2ZWwsIHRoaXMgcHJvcGVydHkgaXMgdW5kZWZpbmVkLlxyXG4gICAgICovXHJcblx0cHJpdmF0ZSBwYz86IFJ1bGVDb250YWluZXI7XHJcblxyXG5cdC8vIExpc3Qgb2YgcmVmZXJlbmNlcyB0byBvdGhlciBzdHlsZSBkZWZpbml0aW9ucyBjcmVhZWQgdmlhIHRoZSAkdXNlIGZ1bmN0aW9uLlxyXG5cdHByaXZhdGUgcmVmczogU3R5bGVEZWZpbml0aW9uW10gPSBbXTtcclxuXHJcblx0Ly8gTGlzdCBvZiBAaW1wb3J0IHJ1bGVzXHJcblx0cHJpdmF0ZSBpbXBvcnRzOiBJbXBvcnRSdWxlW10gPSBbXTtcclxuXHJcblx0Ly8gTGlzdCBvZiBAbmFtZXNwYWNlIHJ1bGVzXHJcblx0cHJpdmF0ZSBuYW1lc3BhY2VzOiBOYW1lc3BhY2VSdWxlW10gPSBbXTtcclxuXHJcblx0Ly8gTGlzdCBvZiBjdXN0b20gdmFyaWFibGUgcnVsZXMuXHJcblx0cHJpdmF0ZSB2YXJzOiBWYXJSdWxlW10gPSBbXTtcclxuICAgIHB1YmxpYyBnZXRWYXJzKCk6IFZhclJ1bGVbXSB7IHJldHVybiB0aGlzLnZhcnM7IH1cclxuXHJcblx0Ly8gTGlzdCBvZiBydWxlcyB0aGF0IGFyZSBub3QgaW1wb3J0cywgbmFtZXNwYWNlcywgY3VzdG9tIHZhcnMsIHJlZmVyZW5jZXMgb3IgZ3JvdXBpbmcgcnVsZXMuXHJcblx0cHJpdmF0ZSBydWxlczogUnVsZVtdID0gW107XHJcblxyXG5cdC8vIFwiOnJvb3RcIiBydWxlIHdoZXJlIGFsbCBjdXN0b20gQ1NTIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzIGNvbnRhaW5lciBhcmUgZGVmaW5lZC5cclxuXHRwcml2YXRlIHZhclJvb3RSdWxlOiBDU1NTdHlsZVJ1bGUgfCB1bmRlZmluZWQ7XHJcblxyXG5cdC8vIFJlZmVyZW5jZSBjb3VudCBvZiBhY3RpdmF0aW9uIHJlcXVlc3RzLlxyXG5cdHByaXZhdGUgcmVmQ291bnQ6IG51bWJlciA9IDA7XHJcblxyXG5cdC8vIE9iamVjdCByZXByZXNlbnRpbmcgZWl0aGVyIERPTSBzdHlsZSBlbGVtZW50IGZvciBjbGllbnQgYWN0aXZhdGlvbiBjb250ZXh0IG9yIHNlcmlhbGl6YXRpb25cclxuICAgIC8vIGltcGxlbWVudGF0aW9uLlxyXG5cdHB1YmxpYyBlbG0/OiBJTWltY3NzU3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5cclxuXHJcbmNvbnN0IGdldFJvb3RDc3NGb3JWYXJzID0gKHZhcnM6IFZhclJ1bGVbXSk6IHN0cmluZyA9PlxyXG4gICAgYDpyb290IHske3ZhcnMubWFwKCB2YXJPYmogPT4gdmFyT2JqLnRvQ3NzKCkpLmZpbHRlciggdiA9PiAhIXYpLmpvaW4oXCI7XCIpfX1gO1xyXG5cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIE5hbWUgZ2VuZXJhdGlvblxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0byB1c2Ugb3B0aW1pemVkIChzaG9ydCkgcnVsZSBuYW1lcy4gSWYgeWVzLCB0aGUgbmFtZXNcclxuICogd2lsbCBiZSBjcmVhdGVkIGJ5IGFwcGVuZGluZyBhIHVuaXF1ZSBudW1iZXIgdG8gdGhlIGdpdmVuIHByZWZpeC4gSWYgdGhlIHByZWZpeCBpcyBub3RcclxuICogc3BlY2lmaWVkLCB0aGUgc3RhbmRhcmQgcHJlZml4IFwiblwiIHdpbGwgYmUgdXNlZC5cclxuICogQHBhcmFtIGVuYWJsZVxyXG4gKiBAcGFyYW0gcHJlZml4XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29uZmlnTmFtZXMgPSAobWV0aG9kOiBOYW1lR2VuZXJhdGlvbk1ldGhvZCwgcHJlZml4Pzogc3RyaW5nKTogdm9pZCA9PlxyXG57XHJcblx0c19uYW1lR2VuZXJhdG9uTWV0aG9kID0gbWV0aG9kO1xyXG5cdHNfdW5pcXVlU3R5bGVOYW1lc1ByZWZpeCA9IHByZWZpeCA/IHByZWZpeCA6IFwiblwiO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0byB1c2Ugb3B0aW1pemVkIG5hbWVzIGZvciBzdHlsZSBlbGVtZW50cyAoY2xhc3NlcywgIGFuaW1hdGlvbnMsIGV0Yy4pXHJcbiAqIEJ5IGRlZmF1bHQgdGhpcyBmbGFnIGlzIHRydWUgaW4gdGhlIFJlbGVhc2UgYnVpbGQgb2YgdGhlIGxpYnJhcnkgYW5kIGZhbHNlIGluIHRoZSBEZWJ1ZyBidWlsZC5cclxuICovXHJcbmxldCBzX25hbWVHZW5lcmF0b25NZXRob2QgPSBOYW1lR2VuZXJhdGlvbk1ldGhvZC5PcHRpbWl6ZWQ7XHJcblxyXG4vLy8gI2lmIERFQlVHXHJcbnNfbmFtZUdlbmVyYXRvbk1ldGhvZCA9IE5hbWVHZW5lcmF0aW9uTWV0aG9kLlVuaXF1ZVNjb3BlZDtcclxuLy8vICNlbmRpZlxyXG5cclxuLyoqXHJcbiAqIFByZWZpeCB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHVuaXF1ZSBzdHlsZSBuYW1lcy4gSWYgdW5kZWZpbmVkLCBhIHN0YW5kYXJkIHByZWZpeCBcIm5cIiB3aWxsIGJlIHVzZWQuXHJcbiAqL1xyXG5sZXQgc191bmlxdWVTdHlsZU5hbWVzUHJlZml4ID0gXCJuXCI7XHJcblxyXG4vKiogTmV4dCBudW1iZXIgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyB1bmlxdWUgaWRlbnRpZmllcnMuICovXHJcbmxldCBzX25leHRVbmlxdWVJRCA9IDE7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgbmFtZSB0byB1c2UgZm9yIHRoZSBnaXZlbiBydWxlIGZyb20gdGhlIGdpdmVuIHN0eWxlIHNoZWV0LlxyXG4gKi9cclxuY29uc3QgZ2VuZXJhdGVOYW1lID0gKHNoZWV0TmFtZTogc3RyaW5nLCBydWxlTmFtZTogc3RyaW5nKTogc3RyaW5nID0+XHJcbntcclxuXHRzd2l0Y2goIHNfbmFtZUdlbmVyYXRvbk1ldGhvZClcclxuICAgIHtcclxuXHRcdGNhc2UgTmFtZUdlbmVyYXRpb25NZXRob2QuVW5pcXVlU2NvcGVkOiByZXR1cm4gYCR7c2hlZXROYW1lfV8ke3J1bGVOYW1lfV8ke3NfbmV4dFVuaXF1ZUlEKyt9YDtcclxuXHRcdGNhc2UgTmFtZUdlbmVyYXRpb25NZXRob2QuT3B0aW1pemVkOiByZXR1cm4gZ2VuZXJhdGVVbmlxdWVOYW1lKCk7XHJcbiAgICAgICAgY2FzZSBOYW1lR2VuZXJhdGlvbk1ldGhvZC5TY29wZWQ6IHJldHVybiBgJHtzaGVldE5hbWV9XyR7cnVsZU5hbWV9YDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgdW5pcXVlIG5hbWUsIHdoaWNoIGNhbiBiZSB1c2VkIGVpdGhlciBmb3Igc3R5bGUgZWxlbWVudCdzIElEIG9yIG9yIGNsYXNzLFxyXG4gKiBpZGVudGlmaWVyIG9yIGFuaW1hdGlvbiBuYW1lLiBOYW1lcyBhcmUgZ2VuZXJhdGVkIHVzaW5nIGEgc2ltcGxlIGluY3JlbWVudGluZyBudW1iZXIuXHJcbiAqL1xyXG5jb25zdCBnZW5lcmF0ZVVuaXF1ZU5hbWUgPSAocHJlZml4Pzogc3RyaW5nKTogc3RyaW5nID0+XHJcblx0KHByZWZpeCA/IHByZWZpeCA6IHNfdW5pcXVlU3R5bGVOYW1lc1ByZWZpeCkgKyBzX25leHRVbmlxdWVJRCsrO1xyXG5cclxuXHJcblxyXG4vLyBMb29rcyB1cCBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvZiB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvblxyXG4vLyBjbGFzcy4gSWYgZm91bmQgYW5kIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIHJ1bGUsIHRoZW4gcmV0dXJucyB0aGUgbmFtZSBhc3NpZ25lZCBmb3IgaXQuXHJcbmNvbnN0IGZpbmROYW1lRm9yUnVsZUluUHJvdG90eXBlQ2hhaW4gPSAoZGVmaW5pdGlvbkNsYXNzOiBJU3R5bGVEZWZpbml0aW9uQ2xhc3MsIHJ1bGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+XHJcbntcclxuXHRpZiAoIWRlZmluaXRpb25DbGFzcylcclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHQvLyBsb29wIG92ZXIgcHJvdG90eXBlc1xyXG4gICAgZm9yKCBsZXQgYmFzZUNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBkZWZpbml0aW9uQ2xhc3MpO1xyXG4gICAgICAgICAgICBiYXNlQ2xhc3MgIT09IFN0eWxlRGVmaW5pdGlvbiAmJiBiYXNlQ2xhc3MgIT09IFRoZW1lRGVmaW5pdGlvbjtcclxuICAgICAgICAgICAgICAgIGJhc2VDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiggYmFzZUNsYXNzKSlcclxuXHR7XHJcblx0XHQvLyBjaGVjayBpZiB0aGUgYmFzZSBjbGFzcyBhbHJlYWR5IGhhcyBhbiBhc3NvY2lhdGVkIGluc3RhbmNlOyBpZiB5ZXMsIGNoZWNrIHdoZXRoZXJcclxuXHRcdC8vIGl0IGhhcyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIHJ1bGUgbmFtZS4gSWYgeWVzLCB0aGVuIHVzZSB0aGlzIHJ1bGUncyBhbHJlYWR5XHJcbiAgICAgICAgLy8gZ2VuZXJhdGVkIG5hbWUgKGlmIGV4aXN0cykuXHJcblx0XHRpZiAoYmFzZUNsYXNzLmhhc093blByb3BlcnR5KHN5bUluc3RhbmNlKSlcclxuXHRcdHtcclxuICAgICAgICAgICAgbGV0IGJhc2VJbnN0ID0gYmFzZUNsYXNzW3N5bUluc3RhbmNlXTtcclxuXHRcdFx0aWYgKGJhc2VJbnN0ICYmICBiYXNlSW5zdFtydWxlTmFtZV0gIT0gbnVsbCAmJiBcIm5hbWVcIiBpbiBiYXNlSW5zdFtydWxlTmFtZV0pXHJcblx0XHRcdFx0cmV0dXJuIGJhc2VJbnN0W3J1bGVOYW1lXS5uYW1lO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFByb2Nlc3NpbmcgZnVuY3Rpb25zXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gc3R5bGVzaGVldCBkZWZpbml0aW9uIGNsYXNzIG9yIGluc3RhbmNlIGFuZCBhc3NpZ25zIG5hbWVzIHRvIGl0cyBydWxlcy5cclxuICogSWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0eWxlIGRlZmluaXRpb24gY2xhc3Mgd2UgY2hlY2sgd2hldGhlciB0aGVyZSBpcyBhbiBpbnN0YW5jZSBhbHJlYWR5XHJcbiAqIGNyZWF0ZWQgZm9yIGl0IGFzIGEgY2xhc3Mgd2lsbCBoYXZlIG9ubHkgYSBzaW5nbGUgYXNzb2NpYXRlZCBpbnN0YW5lIG5vIG1hdHRlciBob3cgbWFueSB0aW1lc1xyXG4gKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cclxuICpcclxuICogSWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgKGFuIGluc3RhbmNlIG9mIHRoZSBTdHlsZURlZmluaXRpb24gY2xhc3MpIHRoZW4gd2UgY2hlY2sgd2hldGhlclxyXG4gKiBpdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC4gSWYgeWVzLCB3ZSBqdXN0IHJldHVybiBpdCBiYWNrOyBpZiBubywgd2UgYXNzaWduIG5ldyB1bmlxdWUgbmFtZXNcclxuICogdG8gaXRzIHJ1bGVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHByb2Nlc3NTRCA9IChpbnN0T3JDbGFzczogSVN0eWxlRGVmaW5pdGlvbiB8IElTdHlsZURlZmluaXRpb25DbGFzcyxcclxuXHQgICAgcGFyZW50PzogSVN0eWxlRGVmaW5pdGlvbik6IElTdHlsZURlZmluaXRpb24gPT5cclxuXHQvLyBpbnN0T3JDbGFzcyBoYXMgdHlwZSBcIm9iamVjdFwiIGlmIGl0IGlzIGFuIGluc3RhbmNlIGFuZCBcImZ1bmN0aW9uXCIgaWYgaXQgaXMgYSBjbGFzc1xyXG5cdHR5cGVvZiBpbnN0T3JDbGFzcyA9PT0gXCJvYmplY3RcIiA/IGluc3RPckNsYXNzIDogcHJvY2Vzc0NsYXNzKCBpbnN0T3JDbGFzcywgcGFyZW50KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBieSBjcmVhdGluZyBpdHMgaW5zdGFuY2UgYW5kIGFzc29jaWF0aW5nIGFcclxuICogcnVsZSBjb250YWluZXIgb2JqZWN0IHdpdGggaXQuIFRoZSBjbGFzcyB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgaW5zdGFuY2UgdXNpbmcgYVxyXG4gKiBTeW1ib2wgcHJvcGVydHkuIFRoZSBwYXJlbnQgcGFyYW1ldGVyIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc3R5bGUgZGVmaWl0aW9uXHJcbiAqIG9iamVjdCBvciBudWxsIGlmIHRoZSBnaXZlbiBjbGFzcyBpcyBpdHNlbGYgYSB0b3AtbGV2ZWwgY2xhc3MgKHRoYXQgaXMsIGlzIG5vdCBhIGNsYXNzXHJcbiAqIHRoYXQgZGVmaW5lcyBydWxlcyB3aXRoaW4gbmVzdGVkIGdyb3VwaW5nIHJ1bGVzKS5cclxuICovXHJcbmNvbnN0IHByb2Nlc3NDbGFzcyA9IChzZGM6IElTdHlsZURlZmluaXRpb25DbGFzcywgcGFyZW50PzogSVN0eWxlRGVmaW5pdGlvbik6IElTdHlsZURlZmluaXRpb24gPT5cclxue1xyXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGRlZmluaXRpb24gY2xhc3MgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYW4gaW5zdGFuY2UuIE5vdGUgdGhhdCB3ZVxyXG4gICAgLy8gdXNlIGhhc093blByb3BlcnR5KCkgYmVjYXVzZSBvdGhlcndpc2UsIHRoaXMgY291bGQgcmV0dXJuIGluc3RhbmNlIGZvciB0aGUgYmFzZSBzdHlsZVxyXG4gICAgLy8gZGVmaW5pdGlvbiBjbGFzcy5cclxuXHRpZiAoc2RjLmhhc093blByb3BlcnR5KHN5bUluc3RhbmNlKSlcclxuICAgICAgICByZXR1cm4gc2RjW3N5bUluc3RhbmNlXSBhcyBJU3R5bGVEZWZpbml0aW9uO1xyXG5cclxuICAgIC8vIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgYWxsIGJhc2UgY2xhc3NlcyBzbyB0aGF0IHJ1bGUgbmFtZXMgYXJlIGdlbmVyYXRlZC4gV2UgZG9uJ3QgYWN0aXZhdGUgc3R5bGVzXHJcbiAgICAvLyBmb3IgdGhlc2UgY2xhc3NlcyBiZWNhdXNlIGRlcml2ZWQgY2xhc3NlcyB3aWxsIGhhdmUgYWxsIHRoZSBydWxlcyBmcm9tIGFsbCB0aGUgYmFzZSBjbGFzc2VzXHJcbiAgICAvLyBhcyB0aGVpciBvd24gYW5kIHNvIHRoZXNlIHJ1bGVzIHdpbGwgYmUgYWN0aXZhdGVkIGFzIHBhcnQgb2YgdGhlIGRlcml2ZWQgY2xhc3MuXHJcbiAgICBsZXQgYmFzZUNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBzZGMpO1xyXG4gICAgaWYgKGJhc2VDbGFzcyAhPT0gU3R5bGVEZWZpbml0aW9uICYmIGJhc2VDbGFzcyAhPT0gVGhlbWVEZWZpbml0aW9uKVxyXG4gICAgICAgIHByb2Nlc3NDbGFzcyggYmFzZUNsYXNzLCBwYXJlbnQpO1xyXG5cclxuICAgIHRyeVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIGRlZmluaXRpb24gY2xhc3NcclxuICAgICAgICBzX3Byb2Nlc3NpbmdTdHlsZURlZmluaXRpb25DbGFzcyA9IHRydWU7XHJcbiAgICAgICAgbGV0IHNkID0gbmV3IHNkYyggcGFyZW50KTtcclxuXHJcbiAgICAgICAgLy8gYXNzb2NpYXRlIHRoZSBkZWZpbml0aW9uIGNsYXNzIHdpdGggdGhlIGNyZWF0ZWQgZGVmaW5pdGlvbiBpbnN0YW5jZVxyXG4gICAgICAgIHNkY1tzeW1JbnN0YW5jZV0gPSBzZDtcclxuICAgICAgICBzZFtzeW1DbGFzc10gPSBzZGM7XHJcbiAgICAgICAgcmV0dXJuIHNkO1xyXG4gICAgfVxyXG4gICAgZmluYWxseVxyXG4gICAge1xyXG4gICAgICAgIHNfcHJvY2Vzc2luZ1N0eWxlRGVmaW5pdGlvbkNsYXNzID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZSBhbmQgYXNzaWducyBuYW1lcyB0byBpdHMgcnVsZXMuIElmIHRoZVxyXG4gKiBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCwgd2UgZG8gbm90aGluZzsgb3RoZXJ3aXNlLCB3ZSBhc3NpZ24gbmV3IHVuaXF1ZSBuYW1lc1xyXG4gKiB0byBpdHMgcnVsZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0VmFyc0Zyb21TRCA9IChpbnN0T3JDbGFzczogSVN0eWxlRGVmaW5pdGlvbiB8IElTdHlsZURlZmluaXRpb25DbGFzcyk6IElWYXJSdWxlW10gPT5cclxuICAgIChwcm9jZXNzU0QoIGluc3RPckNsYXNzKVtzeW1SQ10gYXMgUnVsZUNvbnRhaW5lcikuZ2V0VmFycygpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQWN0aXZhdGVzIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGFuZCBpbnNlcnRzIGFsbCBpdHMgcnVsZXMgaW50byBET00uIElmIHRoZSBpbnB1dCBvYmplY3QgaXNcclxuICogbm90IGEgc3R5bGUgZGVmaW5pdGlvbiBidXQgYSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLCBvYnRhaW4gc3R5bGUgZGVmaW5pdGlvbiBieSBjYWxsaW5nIHRoZSAkdXNlXHJcbiAqIGZ1bmN0aW9uLiBOb3RlIHRoYXQgZWFjaCBzdHlsZSBkZWZpbml0aW9uIG9iamVjdCBtYWludGFpbnMgYSByZWZlcmVuY2UgY291bnRlciBvZiBob3cgbWFueSB0aW1lc1xyXG4gKiBpdCB3YXMgYWN0aXZhdGVkIGFuZCBkZWFjdGl2YXRlZC4gVGhlIHJ1bGVzIGFyZSBpbnNlcnRlZCB0byBET00gb25seSB3aGVuIHRoaXMgcmVmZXJlbmNlIGNvdW50ZXJcclxuICogZ29lcyBmcm9tIDAgdG8gMS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBhY3RpdmF0ZVNEID0gKGluc3RhbmNlOiBJU3R5bGVEZWZpbml0aW9uKTogdm9pZCA9PlxyXG57XHJcblx0bGV0IHJ1bGVDb250YWluZXIgPSBpbnN0YW5jZVtzeW1SQ107XHJcblx0aWYgKCFydWxlQ29udGFpbmVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyBpZiB0aGlzIGNvbnRhaW5lciBoYXMgYW4gZW1iZWRkaW5nIGNvbnRhaW5lciwgYWN0aXZhdGUgdGhlIGVtYmVkZGluZyBjb250YWluZXI7IG90aGVyd2lzZSxcclxuICAgIC8vIGFjdGl2YXRlIHRoZSBydWxlIGNvbnRhaW5lciBpdHNlbGYuXHJcbiAgICAocnVsZUNvbnRhaW5lci5lYyA/PyBydWxlQ29udGFpbmVyKS5hY3RpdmF0ZSgpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEZWFjdGl2YXRlcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBieSByZW1vdmluZyBpdHMgcnVsZXMgZnJvbSBET00uIE5vdGUgdGhhdCBlYWNoIHN0eWxlXHJcbiAqIGRlZmluaXRpb24gb2JqZWN0IG1haW50YWlucyBhIHJlZmVyZW5jZSBjb3VudGVyIG9mIGhvdyBtYW55IHRpbWVzIGl0IHdhcyBhY3RpdmF0ZWQgYW5kXHJcbiAqIGRlYWN0aXZhdGVkLiBUaGUgcnVsZXMgYXJlIHJlbW92ZWQgZnJvbSBET00gb25seSB3aGVuIHRoaXMgcmVmZXJlbmNlIGNvdW50ZXIgZ29lcyBmcm9tIDEgdG8gMC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWFjdGl2YXRlU0QgPSAoaW5zdGFuY2U6IElTdHlsZURlZmluaXRpb24pOiB2b2lkID0+XHJcbntcclxuXHRsZXQgcnVsZUNvbnRhaW5lciA9IGluc3RhbmNlW3N5bVJDXTtcclxuXHRpZiAoIXJ1bGVDb250YWluZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIC8vIGlmIHRoaXMgY29udGFpbmVyIGhhcyBhbiBlbWJlZGRpbmcgY29udGFpbmVyLCBkZWFjdGl2YXRlIHRoZSBlbWJlZGRpbmcgY29udGFpbmVyOyBvdGhlcndpc2UsXHJcbiAgICAvLyBkZWFjdGl2YXRlIHRoZSBydWxlIGNvbnRhaW5lciBpdHNlbGYuXHJcbiAgICAocnVsZUNvbnRhaW5lci5lYyA/PyBydWxlQ29udGFpbmVyKS5kZWFjdGl2YXRlKCk7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEVtYmVkZGluZ1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBTeW1ib2wgdXNlZCBpbiBzdHlsZSBkZWZpbml0aW9uIGNsYXNzZXMgdG8gcG9pbnQgdG8gYW4gZW1iZWRkaW5nIGNvbnRhaW5lciAqL1xyXG5sZXQgc3ltRW1iZWRkaW5nQ29udGFpbmVyID0gU3ltYm9sKFwiZWNcIik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgRW1iZWRkaW5nQ29udGFpbmVyIGNsYXNzIGNvbnRhaW5zIG11bHRpcGxlIHN0eWxlIGRlZmluaXRpb24gY2xhc3Nlcywgd2hpY2ggYXJlIGFjdGl2YXRlZCBhbmRcclxuICogZGVhY3RpdmF0ZWQgdG9nZXRoZXIgdW5kZXIgYSBzaW5nbGUgYDxzdHlsZT5gIG5vZGUuIFN0eWxlIGRlZmluaXRpb24gY2xhc3NlcyBhcmUgYWRkZWQgdG8gdGhlXHJcbiAqIGVtYmVkZGluZyBjb250YWluZXIgYnkgYmVpbmcgZGVjb3JhdGVkIHdpdGggdGhlIGBAZW1iZWRkZWRgIGRlY29yYXRvci5cclxuICovXHJcbmNsYXNzIEVtYmVkZGluZ0NvbnRhaW5lclxyXG57XHJcbiAgICAvKiogSUQgdG8gdXNlIGZvciB0aGUgYDxzdHlsZT5gIGVsZW1lbnQgKi9cclxuICAgIHByaXZhdGUgaWQ6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiBhY3RpdmF0ZWQgc3R5bGUgZGVmaW5pdGlvbnMgYmVsb25naW5nIHRvIHRoaXMgY29udGFpbmVyLiBUaGlzIG51bWJlciBpc1xyXG4gICAgICogaW5jcmVtZW50ZWQgdXBvbiBhY3RpdmF0aW9uIGFuZCBkZWNyZW1lbnRlZCB1cG9uIGRlYWN0aXZhdGlvbiBvZiBzdHlsZSBkZWZpbml0aW9ucy4gV2hlblxyXG4gICAgICogdGhpcyBudW1iZXIgZ29lcyBmcm9tIDAgdG8gMSwgdGhlIGA8c3R5bGU+YCBlbGVtZW50IGlzIGNyZWF0ZWQgYW5kIGFsbCBydWxlcyBmcm9tIGFsbFxyXG4gICAgICogc3R5bGUgZGVmaW5pdGlvbnMgYXJlIGluc2VydGVkIGludG8gaXQuIFdoZW4gdGhpcyBudW1iZXIgZ29lcyBmcm9tIDEgdG8gMCwgdGhlIGA8c3R5bGU+YFxyXG4gICAgICogZWxlbWVudCBpcyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlZkNvdW50OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIENvbGxlY3Rpb24gb2Ygc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIFwiZW1iZWRkZWRcIiBpbiB0aGlzIGNvbnRhaW5lciAqL1xyXG4gICAgcHJpdmF0ZSBzZGNzOiBTZXQ8SVN0eWxlRGVmaW5pdGlvbkNsYXNzPjtcclxuXHJcblx0Ly8gRE9NIHN0eWxlIGVsZW1udFxyXG5cdHB1YmxpYyBlbG0/OiBJTWltY3NzU3R5bGVFbGVtZW50O1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCBpZDogc3RyaW5nKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnNkY3MgPSBuZXcgU2V0PElTdHlsZURlZmluaXRpb25DbGFzcz4oKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB0byB0aGUgbGlzdCBvZiBlbWJlZGRlZCBjbGFzc2VzLiBJZiB0aGUgY29udGFpbmVyIGlzXHJcbiAgICAgKiBjdXJyZW50bHkgYWN0aXZhdGVkLCB0aGUgY2xhc3Mgd2lsbCBiZSBhY3RpdmF0ZWQgdG9vLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKCBjbHM6IElTdHlsZURlZmluaXRpb25DbGFzcyk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICAvLyBhZGQgdGhlIGNsYXNzIHRvIG91ciBjb250YWluZXJcclxuICAgICAgICB0aGlzLnNkY3MuYWRkKCBjbHMpO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIHN5bWJvbCBvbiBvdXIgY2xhc3MgdG8gcG9pbnQgdG8gdGhlIGNvbnRhaW5lclxyXG4gICAgICAgIGNsc1tzeW1FbWJlZGRpbmdDb250YWluZXJdID0gdGhpcztcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGVtYmVkZGluZyBjb250YWluZXIgaXMgY3VycmVudGx5IGFjdGl2YXRlZCwgd2UgbmVlZCB0byBhY3RpdmF0ZSB0aGUgYWRkZWRcclxuICAgICAgICAvLyBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIHVzaW5nIHRoZSBjdXJyZW50bHkgZGVmYXVsdCBhY3RpdmF0b3JcclxuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA+IDApXHJcbiAgICAgICAgICAgIGdldEFjdGl2YXRvcigpLmFjdGl2YXRlKCBwcm9jZXNzQ2xhc3MoIGNscykhKTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBJbnNlcnRzIGFsbCBzdHlsZXNoZWV0cyBpbiB0aGlzIGNvbnRhaW5lciBpbnRvIERPTS5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBhY3RpdmF0ZSgpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIC8vIG9ubHkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgYWN0aXZhdGlvbiBjYWxsLCBjcmVhdGUgdGhlIHN0eWxlIGVsZW1lbnQgYW5kIGluc2VydCBhbGxcclxuICAgICAgICAvLyBydWxlcyBmcm9tIGFsbCB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzLlxyXG5cdFx0aWYgKCsrdGhpcy5yZWZDb3VudCA9PT0gMSlcclxuXHRcdHtcclxuICAgICAgICAgICAgdGhpcy5lbG0gPSBzX2FjdGl2YXRpb25Db250ZXh0Py5jcmVhdGVTdHlsZUVsbSggdGhpcy5pZCk7XHJcblxyXG4gICAgICAgICAgICBmb3IoIGxldCBjbHMgb2YgdGhpcy5zZGNzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZpbml0aW9uIGNsYXNzIG1heSBiZSBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBhbiBpbnN0YW5jZTsgaWYgbm90IC1cclxuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgaXQgbm93LlxyXG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gY2xzLmhhc093blByb3BlcnR5KHN5bUluc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gY2xzW3N5bUluc3RhbmNlXVxyXG4gICAgICAgICAgICAgICAgICAgIDogcHJvY2Vzc0NsYXNzKGNscyk7XHJcblxyXG4gICAgICAgICAgICAgICAgKGluc3RhbmNlW3N5bVJDXSBhcyBSdWxlQ29udGFpbmVyKS5hY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIHN0eWxlc2hlZXRzIGluIHRoaXMgY29udGFpbmVyIGludG8gRE9NLlxyXG4gICAgICovXHJcblx0cHVibGljIGRlYWN0aXZhdGUoKTogdm9pZFxyXG5cdHtcclxuICAgICAgICAvLyBvbmx5IGlmIHRoaXMgaXMgdGhlIGxhc3QgZGVhY3RpdmF0aW9uIGNhbGwsIHJlbW92ZSB0aGUgc3R5bGUgZWxlbWVudCBhbmQgcmVtb3ZlIGFsbFxyXG4gICAgICAgIC8vIHJ1bGVzIGZyb20gYWxsIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzZXMuXHJcblx0XHRpZiAoLS10aGlzLnJlZkNvdW50ID09PSAwKVxyXG5cdFx0e1xyXG4gICAgICAgICAgICB0aGlzLmVsbT8ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxtID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgZm9yKCBsZXQgY2xzIG9mIHRoaXMuc2RjcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5pdGlvbiBjbGFzcyBtdXN0IGJlIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGFuIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNscy5oYXNPd25Qcm9wZXJ0eShzeW1JbnN0YW5jZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgKGNsc1tzeW1JbnN0YW5jZV1bc3ltUkNdIGFzIFJ1bGVDb250YWluZXIpLmRlYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogTWFwIG9mIGNhdGVnb3J5IG5hbWVzIHRvIGVtYmVkZGluZyBjb250YWluZXIgb2JqZWN0cyBjb250YWluaW5nIHN0eWxlIGRlZmluaXRpb25zIGZvciB0aGUgZ2l2ZW5cclxuICogY2F0ZWdvcnkuXHJcbiAqL1xyXG5sZXQgc19lbWJlZGRpbmdDb250YWluZXJzID0gbmV3IE1hcDxzdHJpbmcsRW1iZWRkaW5nQ29udGFpbmVyPigpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGZvciBzdHlsZSBkZWZpbml0aW9uIGNsYXNzZXMgdGhhdCB3aWxsIGJlIGVtYmVkZGVkIGludG8gYW4gZW1iZWRkaW5nXHJcbiAqIGNvbnRhaW5lciBmb3IgdGhlIGdpdmVuIGNhdGVnb3J5LiBBbGwgc3R5bGUgZGVmaW5pdGlvbnMgZm9yIGEgZ2l2ZW4gY2F0ZWdvcnkgd2lsbCBiZSBhY3RpdmF0ZWRcclxuICogYW5kIGRlYWN0aXZhdGVkIHRvZ2V0aGVyIGFuZCB0aGVpciBydWxlcyB3aWxsIGJlIGluc2VydGVkIGludG8gYSBzaW5nbGUgYDxzdHlsZT5gIGVsZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZW1iZWRkZWREZWNvcmF0b3IgPSAoY2F0ZWdvcnk6IHN0cmluZywgdGFyZ2V0OiBJU3R5bGVEZWZpbml0aW9uQ2xhc3MpOiBhbnkgPT5cclxue1xyXG4gICAgLy8gY2hlY2sgd2hldGhlciB3ZSBhbHJlYWR5IGhhdmUgY29udGFpbmVyIGZvciB0aGlzIGNhdGVnb3J5OyBpZiBub3QsIGFkZCBpdFxyXG4gICAgbGV0IGVjID0gc19lbWJlZGRpbmdDb250YWluZXJzLmdldCggY2F0ZWdvcnkpO1xyXG4gICAgaWYgKCFlYylcclxuICAgIHtcclxuICAgICAgICAvLyBnZW5lcmF0ZSB1bmlxdWUgSUQgZm9yIG91ciBjb250YWluZXIsIHdoaWNoIHdpbGwgYmUgdGhlIElEIG9mIHRoZSBgPHN0eWxlPmAgZWxlbWVudFxyXG4gICAgICAgIGxldCBpZCA9IGAke2NhdGVnb3J5fV8ke3NfbmV4dFVuaXF1ZUlEKyt9YDtcclxuICAgICAgICBlYyA9IG5ldyBFbWJlZGRpbmdDb250YWluZXIoIGlkKTtcclxuICAgICAgICBzX2VtYmVkZGluZ0NvbnRhaW5lcnMuc2V0KCBjYXRlZ29yeSwgZWMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBvdXIgY2xhc3MgdG8gdGhlIGNvbnRhaW5lclxyXG4gICAgZWMuYWRkKCB0YXJnZXQpO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBSdWxlIHZpcnR1YWxpemF0aW9uLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhIHJ1bGUgaWYgaXQgaXMgZGVmaW5lZCBhbmQgdXNlZCBpbiB0aGUgc2FtZSBzdHlsZVxyXG4gKiBkZWZpbml0aW9uIGNsYXNzIGJ1dCB0aGVuIGlzIG92ZXJyaWRkZW4gaW4gYSBkZXJpdmVkIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBwcm9ibGVtXHJcbiAqIHRoaXMgc29sdmVzIGlzIHRoaXM6IHdoZW4gYSBydWxlIGlzIGRlZmluZWQgaW4gYSBiYXNlIGNsYXNzIGFuZCB0aGVuIG92ZXJyaWRkZW4gaW4gYSBkZXJpdmVkXHJcbiAqIGNsYXNzLCB3aGVuIGFuIGluc3RhbmNlIG9mIHRoZSBkZXJpdmVkIGNsYXNzIGlzIGNyZWF0ZWQsIHRoZSBydWxlcyB0aGF0IGFyZSBjcmVhdGVkIGluIHRoZVxyXG4gKiBiYXNlIGFuZCBkZXJpdmVkIGNsYXNzZXMgc2VlIGRpZmZlcmVudCB2YWx1ZXMgb2YgdGhlIHJ1bGUuIFNpbmNlIG91ciBydWxlcyBhcmUgZGVmaW5lZCBhc1xyXG4gKiBwYXJ0IG9mIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGJhc2UgY2xhc3MgY29uc3RydWN0b3IncyBjb2RlIG9ubHkgc2VlcyB0aGUgdmFsdWUgYXNzaWduZWQgaW4gdGhhdFxyXG4gKiBjb2RlLiBJZiBhbm90aGVyIHJ1bGUgaW4gdGhlIGJhc2UgY2xhc3MgdXNlcyB0aGlzIGZpcnN0IHJ1bGUsIHRoaXMgdmFsdWUgaXMgcmVtZW1iZXJlZC5cclxuICpcclxuICogVGhlIGB2aXJ0dWFsaXplYCBmdW5jdGlvbiBjcmVhdGVzIGEgUHJveHkgb2JqZWN0IGZvciB0aGUgcnVsZSB3aXRoIHRoZSBoYW5kbGVyIHRoYXQga2VlcHMgdGhlXHJcbiAqIG1vc3QgcmVjZW50IHZhbHVlIHNldC4gVGh1cyB3aGVuIGEgcnVsZSBpbiB0aGUgYmFzZSBjbGFzcydzIGNvbnN0cnVjdG9yIHVzZXMgYSB2aXJ0dWFsaXplZFxyXG4gKiBydWxlLCB0aGUgZmlyc3QgcnVsZSB3aWxsIHNlZSB0aGUgb3ZlcnJpZGRlbiB2YWx1ZSBvZiB0aGUgcnVsZSB3aGVuIGFjY2Vzc2VkIGluIHRoZVxyXG4gKiBwb3N0LWNvbnN0cnVjdG9yIGNvZGUuXHJcbiAqL1xyXG5jb25zdCB2aXJ0dWFsaXplID0gKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcpOiB2b2lkID0+XHJcbntcclxuICAgIC8vIHdlIG1heSBkaXJlY3RseSBjcmVhdGUgdGhlIGhhbmRsZXIgYW5kIHRoZSBwcm94eSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkXHJcbiAgICAvLyBmb3IgZXZlcnkgU3R5bGVEZWZpbml0aW9uIGluc3RhbmNlIChhcyBvcHBvc2VkIHRvIG9uY2UgcGVyIGNsYXNzKS5cclxuICAgIGxldCBoYW5kbGVyID0gbmV3IFZpcnRIYW5kbGVyKCk7XHJcbiAgICBoYW5kbGVyLnggPSBuZXcgUHJveHkoIHt9LCBoYW5kbGVyKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIC8vIHJldHVybiB0aGUgcHJveHkgb2JqZWN0XHJcbiAgICAgICAgZ2V0KCk6IGFueSB7IHJldHVybiBoYW5kbGVyLng7IH0sXHJcblxyXG4gICAgICAgIC8vIHNldCB0aGUgbmV3IHZhbHVlIHRvIHRoZSBoYW5kbGVyIHNvIHRoYXQgaXQgd2lsbCB1c2UgaXQgZnJvbSBub3cgb24uXHJcbiAgICAgICAgc2V0KHYpOiB2b2lkIHsgaGFuZGxlci50ID0gdjsgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVyIGZvciB0aGUgcHJveHkgY3JlYXRlZCBieSB0aGUgYHZpcnR1YWxpemVgIGZ1bmN0aW9uLiBJdCBrZWVwcyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhXHJcbiAqIHJ1bGUgc28gdGhhdCB0aGUgbW9zdCByZWNlbnQgdmFsdWUgaXMgdXNlZCB3aGVuZXZlciB0aGUgcHJveHkgaXMgYWNjZXNzZWQuXHJcbiAqL1xyXG5jbGFzcyBWaXJ0SGFuZGxlciBpbXBsZW1lbnRzIFByb3h5SGFuZGxlcjxhbnk+XHJcbntcclxuICAgIC8vIFByb3h5IG9iamVjdCwgd2hpY2ggd29ya3Mgd2l0aCB0aGlzIGhhbmRsZXJcclxuICAgIHB1YmxpYyB4OiBhbnk7XHJcblxyXG4gICAgLy8gdGhlIGxhdGVzdCB0YXJnZXQgb2JqZWN0IHRvIHVzZSBmb3IgYWxsIHByb3h5IGhhbmRsZXIgb3BlcmF0aW9uc1xyXG4gICAgcHVibGljIHQ6IGFueTtcclxuXHJcbiAgICAvLyBpbnRlcmVzdGluZyB0aGluZ3MgaGFwcGVuIGluIHRoZSBnZXQgbWV0aG9kXHJcbiAgICBnZXQoIHQ6IGFueSwgcDogUHJvcGVydHlLZXksIHI6IGFueSk6IGFueVxyXG4gICAge1xyXG4gICAgICAgIC8vIGlmIG91ciB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCBhbmQgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBhIHdlbGwta25vd24gc3ltYm9sXHJcbiAgICAgICAgLy8gdG9QcmltaXRpdmUgd2UgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlciBudWxsIG9yIHVuZGVmaW5lZC4gVGhpcyB3aWxsIGhlbHBcclxuICAgICAgICAvLyBpZiBvdXIgcHJveHkgZWl0aGVyIHBhcnRpY2lwYXRlIGluIGFuIGFyaXRobWV0aWMgZXhwcmVzc2lvbiBvciBpcyBjb21iaW5lZCB3aXRoIGFcclxuICAgICAgICAvLyBzdHJpbmcuXHJcbiAgICAgICAgaWYgKHRoaXMudCA9PSBudWxsICYmIHAgPT09IFN5bWJvbC50b1ByaW1pdGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMudDtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdCBwcm9wZXJ0eTsgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBhbiBleGNlcHRpb25cclxuICAgICAgICAvLyB3aWxsIGJlIHRocm93biAtIHdoaWNoIGlzIGV4cGVjdGVkLlxyXG4gICAgICAgIGxldCBwdiA9IFJlZmxlY3QuZ2V0KCB0aGlzLnQsIHAsIHIpO1xyXG5cclxuICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdGVkIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24sIGJpbmQgdGhlIG9yaWdpbmFsIG1ldGhvZCB0byB0aGUgdGFyZ2V0IG9iamVjdFxyXG4gICAgICAgIHJldHVybiB0eXBlb2YgcHYgPT09IFwiZnVuY3Rpb25cIiA/IHB2LmJpbmQoIHRoaXMudCkgOiBwdjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGUgcmVzdCBvZiB0aGUgbWV0aG9kcyBtb3N0bHkgZGVsZWdhdGUgdGhlIGNhbGxzIHRvIHRoZSBsYXRlc3QgdGFyZ2V0IGluc3RlYWQgb2YgdGhlXHJcbiAgICAvLyBvcmlnaW5hbCB0YXJnZXQuIEluIHNvbWUgY2FzZXMsIHdlIGNoZWNrIHdoZXRoZXIgdGhlIHRhcmdldCBpcyBudWxsIG9yIHVuZGVmaW5lZCBzbyB0aGF0XHJcbiAgICAvLyB3ZSBkb24ndCB0aHJvdyBleGNlcHRpb25zIHdoZXJlIHdlIGNhbiBhdm9pZCBpdC5cclxuXHJcbiAgICBnZXRQcm90b3R5cGVPZiggdDogYW55KTogb2JqZWN0IHwgbnVsbFxyXG4gICAgICAgIHsgcmV0dXJuIHRoaXMudCA9PSBudWxsID8gbnVsbCA6IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoIHRoaXMudCk7IH1cclxuICAgIC8vIHNldFByb3RvdHlwZU9mKHQ6IGFueSwgdjogYW55KTogYm9vbGVhblxyXG4gICAgLy8gICAgIHsgcmV0dXJuIFJlZmxlY3Quc2V0UHJvdG90eXBlT2YoIHRoaXMudCwgdik7IH1cclxuICAgIC8vIGlzRXh0ZW5zaWJsZSh0OiBhbnkpOiBib29sZWFuXHJcbiAgICAvLyAgICAgeyByZXR1cm4gdGhpcy50ID09IG51bGwgPyBmYWxzZSA6IFJlZmxlY3QuaXNFeHRlbnNpYmxlKCB0aGlzLnQpOyB9XHJcbiAgICAvLyBwcmV2ZW50RXh0ZW5zaW9ucyh0OiBhbnkpOiBib29sZWFuXHJcbiAgICAvLyAgICAgeyByZXR1cm4gdGhpcy50ID09IG51bGwgPyBmYWxzZSA6IFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnMoIHRoaXMudCk7IH1cclxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0OiBhbnksIHA6IFByb3BlcnR5S2V5KTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkXHJcbiAgICAgICAgeyByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMudCwgcCk7IH1cclxuICAgIGhhcyh0OiBhbnksIHA6IFByb3BlcnR5S2V5KTogYm9vbGVhblxyXG4gICAgICAgIHsgcmV0dXJuIHRoaXMudCA9PSBudWxsID8gZmFsc2UgOiBSZWZsZWN0LmhhcyggdGhpcy50LCBwKTsgfVxyXG4gICAgc2V0KCB0OiBhbnksIHA6IFByb3BlcnR5S2V5LCB2OiBhbnksIHI6IGFueSk6IGJvb2xlYW5cclxuICAgICAgICB7IHJldHVybiBSZWZsZWN0LnNldCggdGhpcy50LCBwLCB2LCByKTsgfVxyXG4gICAgZGVsZXRlUHJvcGVydHkodDogYW55LCBwOiBQcm9wZXJ0eUtleSk6IGJvb2xlYW5cclxuICAgICAgICB7IHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KCB0aGlzLnQsIHApOyB9XHJcbiAgICBkZWZpbmVQcm9wZXJ0eSh0OiBhbnksIHA6IFByb3BlcnR5S2V5LCBhdHRyczogUHJvcGVydHlEZXNjcmlwdG9yKTogYm9vbGVhblxyXG4gICAgICAgIHsgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMudCwgcCwgYXR0cnMpOyB9XHJcbiAgICBvd25LZXlzKHQ6IGFueSk6IEFycmF5TGlrZTxzdHJpbmcgfCBzeW1ib2w+XHJcbiAgICAgICAgeyByZXR1cm4gUmVmbGVjdC5vd25LZXlzKCB0aGlzLnQpOyB9XHJcbiAgICAvLyBhcHBseSh0OiBhbnksIHRoaXNBcmc6IGFueSwgYXJncz86IGFueSk6IGFueVxyXG4gICAgLy8gICAgIHsgcmV0dXJuIHRoaXMudC5hcHBseSggdGhpc0FyZywgYXJncyk7IH1cclxuICAgIC8vIGNvbnN0cnVjdCh0OiBhbnksIGFyZ3M6IGFueSwgbmV3VGFyZ2V0PzogYW55KTogb2JqZWN0XHJcbiAgICAvLyAgICAgeyByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoIHRoaXMudCwgYXJncywgbmV3VGFyZ2V0KTsgfVxyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBUaGVtaW5nIHN1cHBvcnQuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIE1hcCBvZiB0aGVtIGRlZmluaXRpb24gY2xhc3NlcyB0byB0aGUgaW5zdGFuY2VzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgZm9yIHRoZXNlIGNsYXNzZXMuXHJcbiAqL1xyXG5sZXQgc190aGVtZUluc3RhbmNlTWFwID0gbmV3IE1hcDxJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VGhlbWVEZWZpbml0aW9uPixUaGVtZURlZmluaXRpb24+KCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0aGVtZSBiYXNlIGNsYXNzIGZvciB0aGUgZ2l2ZW4gdGhlbWUgY2xhc3MuXHJcbiAqIEBwYXJhbSB0aGVtZUNsYXNzIFRoZW1lRGVmaW5pdGlvbi1kZXJpdmVkIGNsYXNzXHJcbiAqIEByZXR1cm5zIFRoZW1lIGJhc2UgY2xhc3MuXHJcbiAqL1xyXG5jb25zdCBnZXRUaGVtZUJhc2VDbGFzcyA9ICh0aGVtZUNsYXNzOiBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VGhlbWVEZWZpbml0aW9uPik6IElTdHlsZURlZmluaXRpb25DbGFzczxUaGVtZURlZmluaXRpb24+IHwgdW5kZWZpbmVkID0+XHJcbntcclxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgbm90IHBhc3NlZCB0aGUgVGhlbWVEZWZpbml0aW9uIGNsYXNzIGl0c2VsZlxyXG4gICAgaWYgKHRoZW1lQ2xhc3MgPT09IFRoZW1lRGVmaW5pdGlvbilcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vIGxvb3Agb3ZlciBwcm90b3R5cGVzIHVudGlsIHdlIGZpbmQgdGhlIGNsYXNzLCB3aGljaCBkZXJpdmVzIGRpcmVjdGx5IGZyb20gVGhlbWVEZWZpbml0aW9uLlxyXG4gICAgLy8gVGhpcyBpcyB0aGUgdGhlbWUgYmFzZSBjbGFzc1xyXG4gICAgbGV0IHRoZW1lQmFzZUNsYXNzID0gdGhlbWVDbGFzcztcclxuICAgIGZvciggbGV0IGNscyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiggdGhlbWVDbGFzcyk7IGNscyAhPT0gVGhlbWVEZWZpbml0aW9uOyBjbHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGNscykpXHJcbiAgICAgICAgdGhlbWVCYXNlQ2xhc3MgPSBjbHM7XHJcblxyXG4gICAgcmV0dXJuIHRoZW1lQmFzZUNsYXNzO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0aGVtZSBkZWZpbml0aW9uIG9iamVjdCwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2YXRlZCBmb3IgdGhlIGdpdmVuIHRoZW1lLlxyXG4gKiBAcGFyYW0gdGhlbWVDbGFzcyBUaGVtZSBkZWZpbml0aW9uIGNsYXNzXHJcbiAqIEByZXR1cm5zIFRoZW1lIGluc3RhbmNlLCB3aGljaCBpcyBjdXJyZW50bHkgYWN0aXZhdGVkIGZvciB0aGUgZ2l2ZW4gdGhlbWUgY2xhc3Mgb3IgbnVsbFxyXG4gKiBpZiBubyBpc3RhbmNlIGlzIGN1cnJlbnRseSBhY3RpdmF0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFRoZW1lID0gKHRoZW1lQ2xhc3M6IElTdHlsZURlZmluaXRpb25DbGFzczxUaGVtZURlZmluaXRpb24+KTogVGhlbWVEZWZpbml0aW9uIHwgdW5kZWZpbmVkID0+XHJcbntcclxuICAgIGxldCB0aGVtZUJhc2VDbGFzcyA9IGdldFRoZW1lQmFzZUNsYXNzKHRoZW1lQ2xhc3MpXHJcbiAgICByZXR1cm4gdGhlbWVCYXNlQ2xhc3MgJiYgc190aGVtZUluc3RhbmNlTWFwLmdldCggdGhlbWVCYXNlQ2xhc3MpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSB0aGVtZSBkZWZpbml0aW9uIG9iamVjdCBhcyB0aGUgaW5zdGFuY2UgdGhhdCBpcyBjdXJyZW50bHkgYWN0aXZhdGVkIGZvciB0aGVcclxuICogY29ycmVzcG9uZGluZyBiYXNlIHRoZW1lIGNsYXNzLlxyXG4gKiBAcGFyYW0gdGhlbWUgdGhlbWUgaW5zdGFuY2UgdG8gc2V0IGFzIGN1cnJlbnQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGJhc2UgdGhlbWUgY2xhc3NcclxuICovXHJcbmNvbnN0IHNldEN1cnJlbnRUaGVtZSA9ICh0aGVtZTogVGhlbWVEZWZpbml0aW9uKTogdm9pZCA9PlxyXG57XHJcbiAgICBsZXQgdGhlbWVCYXNlQ2xhc3MgPSBnZXRUaGVtZUJhc2VDbGFzcyggdGhlbWUuY29uc3RydWN0b3IgYXMgSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFRoZW1lRGVmaW5pdGlvbj4pO1xyXG4gICAgdGhlbWVCYXNlQ2xhc3MgJiYgc190aGVtZUluc3RhbmNlTWFwLnNldCggdGhlbWVCYXNlQ2xhc3MsIHRoZW1lKTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhIHRoZW1lIGRlZmluaXRpb24gb2JqZWN0IHNldCBhcyB0aGUgaW5zdGFuY2UgdGhhdCBpcyBjdXJyZW50bHkgYWN0aXZhdGVkIGZvciB0aGVcclxuICogY29ycmVzcG9uZGluZyBiYXNlIHRoZW1lIGNsYXNzLlxyXG4gKiBAcGFyYW0gdGhlbWVDbGFzcyBUaGVtZSBkZWZpbml0aW9uIGNsYXNzXHJcbiAqL1xyXG5jb25zdCByZW1vdmVDdXJyZW50VGhlbWUgPSAodGhlbWVDbGFzczogSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFRoZW1lRGVmaW5pdGlvbj4pOiB2b2lkID0+XHJcbntcclxuICAgIGxldCB0aGVtZUJhc2VDbGFzcyA9IGdldFRoZW1lQmFzZUNsYXNzKCB0aGVtZUNsYXNzKTtcclxuICAgIHRoZW1lQmFzZUNsYXNzICYmIHNfdGhlbWVJbnN0YW5jZU1hcC5kZWxldGUoIHRoZW1lQmFzZUNsYXNzKTtcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ2xpZW50LXNpZGUgcmVuZGVyaW5nIGltcGxlbWVudGF0aW9uXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFN0eWxlIGVsZW1lbnQgdGhhdCBkaXZpZGVzIGJldHdlZW4gdGhlbWUgYW5kIG5vbi10aGVtZSBzdHlsZSBlbGVtZW50cy4gVGhpcyBpcyBuZWVkZWQgdG8gYWx3YXlzXHJcbiAqIHBsYWNlIHRoZW1lIHN0eWxlcyBiZWZvcmUgdGhlIG5vbi10aGVtZSBvbmVzLlxyXG4gKi9cclxubGV0IHNfY2xpZW50VGhlbWVQbGFjZWhvbGRlckVsbTogSU1pbWNzc1N0eWxlRWxlbWVudCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuXHJcbi8qKlxyXG4gKiBJRCBvZiB0aGUgc3R5bGUgZWxlbWVudCB0aGF0IGRpdmlkZXMgYmV0d2VlbiB0aGVtZSBhbmQgbm9uLXRoZW1lIHN0eWxlIGVsZW1lbnRzLlxyXG4gKi9cclxuY29uc3Qgc190aGVtZVBsYWNlaG9sZGVyRWxtSUQgPSBcIl9fbWltY3NzX3RoZW1lc19fXCI7XHJcblxyXG5cclxuXHJcbi8vIEluc2VydHMgdGhlIGdpdmVuIHJ1bGUgaW50byB0aGUgZ2l2ZW4gcGFyZW50IGdyb3VwaW5nIHJ1bGUgb3Igc3R5bGVzaGVldC5cclxuY29uc3QgYWRkRG9tUnVsZSA9IChydWxlVGV4dDogc3RyaW5nLCBwYXJlbnQ6IENTU1N0eWxlU2hlZXQgfCBDU1NHcm91cGluZ1J1bGUpOiBDU1NSdWxlIHwgbnVsbCA9PlxyXG57XHJcbiAgICB0cnlcclxuICAgIHtcclxuICAgICAgICBsZXQgaW5kZXggPSBwYXJlbnQuaW5zZXJ0UnVsZSggcnVsZVRleHQsIHBhcmVudC5jc3NSdWxlcy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQuY3NzUnVsZXNbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgY2F0Y2goIHgpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvciggYENhbm5vdCBhZGQgQ1NTIHJ1bGUgJyR7cnVsZVRleHR9J2AsIHgpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENsaWVudC1zaWRlIGltcGxlbWVudGF0aW9uIG9mIGFjdGl2YXRpb24gY29udGV4dC5cclxuICovXHJcbmNsYXNzIENsaWVudEFjdGl2YXRpb25Db250ZXh0IGltcGxlbWVudHMgSUFjdGl2YXRpb25Db250ZXh0XHJcbntcclxuICAgIGdldFRoZW1lUGxhY2Vob2xkZXIoKTogSU1pbWNzc1N0eWxlRWxlbWVudFxyXG4gICAge1xyXG4gICAgICAgIGlmICghc19jbGllbnRUaGVtZVBsYWNlaG9sZGVyRWxtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGRvbUVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic3R5bGVcIik7XHJcbiAgICAgICAgICAgIGRvbUVsbS5pZCA9IHNfdGhlbWVQbGFjZWhvbGRlckVsbUlEO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZSggZG9tRWxtLCBkb2N1bWVudC5oZWFkLmZpcnN0RWxlbWVudENoaWxkKTtcclxuICAgICAgICAgICAgc19jbGllbnRUaGVtZVBsYWNlaG9sZGVyRWxtID0gbmV3IENsaWVudE1pbWNzc1N0eWxlRWxlbWVudCggZG9tRWxtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzX2NsaWVudFRoZW1lUGxhY2Vob2xkZXJFbG07XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlU3R5bGVFbG0oIGlkOiBzdHJpbmcsIGluc2VydEJlZm9yZT86IElNaW1jc3NTdHlsZUVsZW1lbnQpOiBJTWltY3NzU3R5bGVFbGVtZW50XHJcbiAgICB7XHJcbiAgICAgICAgbGV0IGRvbUVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic3R5bGVcIik7XHJcbiAgICAgICAgZG9tRWxtLmlkID0gaWQ7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoIGRvbUVsbSwgaW5zZXJ0QmVmb3JlID8gaW5zZXJ0QmVmb3JlLmRvbUVsbSA6IG51bGwpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50TWltY3NzU3R5bGVFbGVtZW50KCBkb21FbG0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2xpZW50LXNpZGUgaW1wbGVtZW50YXRpb24gb2YgYW4gb2JqZWN0IHRvIHdoaWNoIHJ1bGVzIGNhbiBiZSBhZGRlZC5cclxuICovXHJcbmFic3RyYWN0IGNsYXNzIENsaWVudE1pbWNzc1J1bGVCYWcgaW1wbGVtZW50cyBJTWltY3NzUnVsZUJhZ1xyXG57XHJcbiAgICBjb25zdHJ1Y3RvciggcHVibGljIGRvbVJ1bGVCYWc6IENTU1N0eWxlU2hlZXQgfCBDU1NHcm91cGluZ1J1bGUpIHt9XHJcblxyXG4gICAgYWRkKCBydWxlVGV4dDogc3RyaW5nKTogSU1pbWNzc1J1bGUgfCBudWxsXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IGNzc1J1bGUgPSBhZGREb21SdWxlKCBydWxlVGV4dCwgdGhpcy5kb21SdWxlQmFnKTtcclxuICAgICAgICByZXR1cm4gY3NzUnVsZSA/IG5ldyBDbGllbnRNaW1jc3NSdWxlKCBjc3NSdWxlKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkR3JvdXAoIHNlbGVjdG9yOiBzdHJpbmcpOiBJTWltY3NzR3JvdXBpbmdSdWxlIHwgbnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCBjc3NSdWxlID0gYWRkRG9tUnVsZSggYCR7c2VsZWN0b3J9IHt9YCwgdGhpcy5kb21SdWxlQmFnKTtcclxuICAgICAgICByZXR1cm4gY3NzUnVsZSA/IG5ldyBDbGllbnRNaW1jc3NHcm91cGluZ1J1bGUoIGNzc1J1bGUpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBhZGRLZXlmcmFtZXMoIG5hbWU6IHN0cmluZyk6IElNaW1jc3NLZXlmcmFtZXNSdWxlIHwgbnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCBjc3NSdWxlID0gYWRkRG9tUnVsZSggYEBrZXlmcmFtZXMgJHtuYW1lfSB7fWAsIHRoaXMuZG9tUnVsZUJhZyk7XHJcbiAgICAgICAgcmV0dXJuIGNzc1J1bGUgPyBuZXcgQ2xpZW50TWltY3NzS2V5ZnJhbWVzUnVsZSggY3NzUnVsZSkgOiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2xpZW50LXNpZGUgaW1wbGVtZW50YXRpb24gb2YgYSBzdHlsZSBlbGVtZW50LlxyXG4gKi9cclxuY2xhc3MgQ2xpZW50TWltY3NzU3R5bGVFbGVtZW50IGV4dGVuZHMgQ2xpZW50TWltY3NzUnVsZUJhZyBpbXBsZW1lbnRzIElNaW1jc3NTdHlsZUVsZW1lbnRcclxue1xyXG4gICAgY29uc3RydWN0b3IoIHB1YmxpYyBkb21FbG06IEhUTUxTdHlsZUVsZW1lbnQpXHJcbiAgICB7XHJcbiAgICAgICAgc3VwZXIoIGRvbUVsbS5zaGVldCEpXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKCk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRvbUVsbT8ucmVtb3ZlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGllbnQtc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGJhc2UgaW50ZXJmYWNlIGZvciBDU1MgcnVsZS5cclxuICovXHJcbmNsYXNzIENsaWVudE1pbWNzc1J1bGUgaW1wbGVtZW50cyBJTWltY3NzUnVsZVxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgY3NzUnVsZTogQ1NTUnVsZSB8IG51bGwpIHt9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGllbnQtc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGdyb3VwaW5nIHJ1bGUgdG8gd2hpY2ggcnVsZXMgY2FuIGJlIGFkZGVkLlxyXG4gKi9cclxuY2xhc3MgQ2xpZW50TWltY3NzR3JvdXBpbmdSdWxlIGV4dGVuZHMgQ2xpZW50TWltY3NzUnVsZUJhZyBpbXBsZW1lbnRzIElNaW1jc3NHcm91cGluZ1J1bGVcclxue1xyXG4gICAgY29uc3RydWN0b3IoIHB1YmxpYyBjc3NSdWxlOiBDU1NSdWxlKVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKCBjc3NSdWxlIGFzIENTU0dyb3VwaW5nUnVsZSlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsaWVudC1zaWRlIGltcGxlbWVudGF0aW9uIG9mIGtleWZyYW1lcyBydWxlIHRvIHdoaWNoIGZyYW1lcyBjYW4gYmUgYWRkZWQuXHJcbiAqL1xyXG5jbGFzcyBDbGllbnRNaW1jc3NLZXlmcmFtZXNSdWxlIGV4dGVuZHMgQ2xpZW50TWltY3NzUnVsZVxyXG57XHJcbiAgICBhZGRGcmFtZSggZnJhbWVUZXh0OiBzdHJpbmcpOiBJTWltY3NzUnVsZSB8IG51bGxcclxuICAgIHtcclxuICAgICAgICB0cnlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICh0aGlzLmNzc1J1bGUgYXMgQ1NTS2V5ZnJhbWVzUnVsZSkuYXBwZW5kUnVsZSggZnJhbWVUZXh0KTtcclxuICAgICAgICAgICAgbGV0IGNzc0ZyYW1lUnVsZSA9ICh0aGlzLmNzc1J1bGUgYXMgQ1NTS2V5ZnJhbWVzUnVsZSkuY3NzUnVsZXMuaXRlbShcclxuICAgICAgICAgICAgICAgICh0aGlzLmNzc1J1bGUgYXMgQ1NTS2V5ZnJhbWVzUnVsZSkuY3NzUnVsZXMubGVuZ3RoIC0gMSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY3NzRnJhbWVSdWxlID8gbmV3IENsaWVudE1pbWNzc1J1bGUoIGNzc0ZyYW1lUnVsZSkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCh4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggXCJDYW5ub3QgYWRkIENTUyBrZXlmcmFtZSBydWxlXCIsIHgpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gSHlkcmF0aW9uLXNpZGUgcmVuZGVyaW5nIGltcGxlbWVudGF0aW9uXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIEh5ZHJhdGlvbi1zaWRlIGltcGxlbWVudGF0aW9uIG9mIGFjdGl2YXRpb24gY29udGV4dC5cclxuICovXHJcbmNsYXNzIEh5ZHJhdGlvbkFjdGl2YXRpb25Db250ZXh0IGltcGxlbWVudHMgSUFjdGl2YXRpb25Db250ZXh0XHJcbntcclxuICAgIGdldFRoZW1lUGxhY2Vob2xkZXIoKTogSU1pbWNzc1N0eWxlRWxlbWVudFxyXG4gICAge1xyXG4gICAgICAgIGlmICghc19jbGllbnRUaGVtZVBsYWNlaG9sZGVyRWxtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGRvbUVsbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBzX3RoZW1lUGxhY2Vob2xkZXJFbG1JRCkgYXMgSFRNTFN0eWxlRWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKGRvbUVsbSlcclxuICAgICAgICAgICAgICAgIHNfY2xpZW50VGhlbWVQbGFjZWhvbGRlckVsbSA9IG5ldyBIeWRyYXRpb25NaW1jc3NTdHlsZUVsZW1lbnQoIGRvbUVsbSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJUaGVtZSBwbGFjZWhvbGRlciBlbGVtZW50IHdhcyByZXF1ZXN0ZWQgYnV0IHdhcyBub3QgZm91bmRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc19jbGllbnRUaGVtZVBsYWNlaG9sZGVyRWxtO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVN0eWxlRWxtKCBpZDogc3RyaW5nLCBpbnNlcnRCZWZvcmU/OiBJTWltY3NzU3R5bGVFbGVtZW50KTogSU1pbWNzc1N0eWxlRWxlbWVudFxyXG4gICAge1xyXG4gICAgICAgIGxldCBkb21FbG0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggaWQpIGFzIEhUTUxTdHlsZUVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGRvbUVsbSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIeWRyYXRpb25NaW1jc3NTdHlsZUVsZW1lbnQoIGRvbUVsbSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIGBTdHlsZSBlbGVtZW50IHdpdGggSUQgJyR7aWR9JyB3YXMgcmVxdWVzdGVkIGJ1dCB3YXMgbm90IGZvdW5kYCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIeWRyYXRpb24tc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBvYmplY3QgdG8gd2hpY2ggcnVsZXMgY2FuIGJlIGFkZGVkLlxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgSHlkcmF0aW9uTWltY3NzUnVsZUJhZyBpbXBsZW1lbnRzIElNaW1jc3NSdWxlQmFnXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKCBwdWJsaWMgZG9tUnVsZUJhZzogQ1NTU3R5bGVTaGVldCB8IENTU0dyb3VwaW5nUnVsZSkge31cclxuXHJcbiAgICBhZGQoIHJ1bGVUZXh0OiBzdHJpbmcpOiBJTWltY3NzUnVsZSB8IG51bGxcclxuICAgIHtcclxuICAgICAgICBsZXQgY3NzUnVsZSA9IHRoaXMuZG9tUnVsZUJhZy5jc3NSdWxlc1t0aGlzLmluZGV4KytdO1xyXG4gICAgICAgIHJldHVybiBjc3NSdWxlID8gbmV3IEh5ZHJhdGlvbk1pbWNzc1J1bGUoIGNzc1J1bGUpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBhZGRHcm91cCggc2VsZWN0b3I6IHN0cmluZyk6IElNaW1jc3NHcm91cGluZ1J1bGUgfCBudWxsXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IGNzc1J1bGUgPSB0aGlzLmRvbVJ1bGVCYWcuY3NzUnVsZXNbdGhpcy5pbmRleCsrXTtcclxuICAgICAgICByZXR1cm4gY3NzUnVsZSA/IG5ldyBIeWRyYXRpb25NaW1jc3NHcm91cGluZ1J1bGUoIGNzc1J1bGUpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBhZGRLZXlmcmFtZXMoIG5hbWU6IHN0cmluZyk6IElNaW1jc3NLZXlmcmFtZXNSdWxlIHwgbnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCBjc3NSdWxlID0gdGhpcy5kb21SdWxlQmFnLmNzc1J1bGVzW3RoaXMuaW5kZXgrK107XHJcbiAgICAgICAgcmV0dXJuIGNzc1J1bGUgPyBuZXcgSHlkcmF0aW9uTWltY3NzS2V5ZnJhbWVzUnVsZSggY3NzUnVsZSkgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluZGV4IG9mIHRoZSBydWxlIGluIHRoZSBsaXN0IG9mIHJ1bGVzIHVuZGVyIHRoZSBzdHlsZXNoZWV0IG9yIGdyb3VwaW5nIHJ1bGVcclxuICAgIHByaXZhdGUgaW5kZXggPSAwO1xyXG59XHJcblxyXG4vKipcclxuICogSHlkcmF0aW9uLXNpZGUgaW1wbGVtZW50YXRpb24gb2YgYSBzdHlsZSBlbGVtZW50LlxyXG4gKi9cclxuY2xhc3MgSHlkcmF0aW9uTWltY3NzU3R5bGVFbGVtZW50IGV4dGVuZHMgSHlkcmF0aW9uTWltY3NzUnVsZUJhZyBpbXBsZW1lbnRzIElNaW1jc3NTdHlsZUVsZW1lbnRcclxue1xyXG4gICAgY29uc3RydWN0b3IoIHB1YmxpYyBkb21FbG06IEhUTUxTdHlsZUVsZW1lbnQpXHJcbiAgICB7XHJcbiAgICAgICAgc3VwZXIoIGRvbUVsbS5zaGVldCEpXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKCk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICB0aGlzLmRvbUVsbT8ucmVtb3ZlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIeWRyYXRpb24tc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGJhc2UgaW50ZXJmYWNlIGZvciBDU1MgcnVsZS5cclxuICovXHJcbmNsYXNzIEh5ZHJhdGlvbk1pbWNzc1J1bGUgaW1wbGVtZW50cyBJTWltY3NzUnVsZVxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgY3NzUnVsZTogQ1NTUnVsZSB8IG51bGwpIHt9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIeWRyYXRpb24tc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGdyb3VwaW5nIHJ1bGUgdG8gd2hpY2ggcnVsZXMgY2FuIGJlIGFkZGVkLlxyXG4gKi9cclxuY2xhc3MgSHlkcmF0aW9uTWltY3NzR3JvdXBpbmdSdWxlIGV4dGVuZHMgSHlkcmF0aW9uTWltY3NzUnVsZUJhZyBpbXBsZW1lbnRzIElNaW1jc3NHcm91cGluZ1J1bGVcclxue1xyXG4gICAgY29uc3RydWN0b3IoIHB1YmxpYyBjc3NSdWxlOiBDU1NSdWxlKVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKCBjc3NSdWxlIGFzIENTU0dyb3VwaW5nUnVsZSlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEh5ZHJhdGlvbi1zaWRlIGltcGxlbWVudGF0aW9uIG9mIGtleWZyYW1lcyBydWxlIHRvIHdoaWNoIGZyYW1lcyBjYW4gYmUgYWRkZWQuXHJcbiAqL1xyXG5jbGFzcyBIeWRyYXRpb25NaW1jc3NLZXlmcmFtZXNSdWxlIGV4dGVuZHMgSHlkcmF0aW9uTWltY3NzUnVsZVxyXG57XHJcbiAgICBhZGRGcmFtZSggZnJhbWVUZXh0OiBzdHJpbmcpOiBJTWltY3NzUnVsZSB8IG51bGxcclxuICAgIHtcclxuICAgICAgICBsZXQgY3NzRnJhbWVSdWxlID0gKHRoaXMuY3NzUnVsZSBhcyBDU1NLZXlmcmFtZXNSdWxlKS5jc3NSdWxlc1t0aGlzLmluZGV4KytdO1xyXG4gICAgICAgIHJldHVybiBjc3NGcmFtZVJ1bGUgPyBuZXcgSHlkcmF0aW9uTWltY3NzUnVsZSggY3NzRnJhbWVSdWxlKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW5kZXggb2YgdGhlIGZyYW1lIGluIHRoZSBsaXN0IG9mIGZyYW1lcyB1bmRlciB0aGUga2V5ZnJhbWVzIHJ1bGVcclxuICAgIHByaXZhdGUgaW5kZXggPSAwO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBTZXJ2ZXItc2lkZSByZW5kZXJpbmcgaW1wbGVtZW50YXRpb25cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogU2VydmVyLXNpZGUgaW1wbGVtZW50YXRpb24gb2YgYWN0aXZhdGlvbiBjb250ZXh0LlxyXG4gKi9cclxuY2xhc3MgU2VydmVyQWN0aXZhdGlvbkNvbnRleHQgaW1wbGVtZW50cyBJU2VydmVyQWN0aXZhdGlvbkNvbnRleHRcclxue1xyXG4gICAgZ2V0VGhlbWVQbGFjZWhvbGRlcigpOiBJTWltY3NzU3R5bGVFbGVtZW50XHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRoZW1lRWxtKVxyXG4gICAgICAgICAgICB0aGlzLmVsbXMuc3BsaWNlKCAwLCAwLCB0aGlzLnRoZW1lRWxtID0gbmV3IFNlcnZlck1pbWNzc1N0eWxlRWxlbWVudChzX3RoZW1lUGxhY2Vob2xkZXJFbG1JRCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy50aGVtZUVsbTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVTdHlsZUVsbSggaWQ6IHN0cmluZywgaW5zZXJ0QmVmb3JlPzogSU1pbWNzc1N0eWxlRWxlbWVudCk6IElNaW1jc3NTdHlsZUVsZW1lbnRcclxuICAgIHtcclxuICAgICAgICBsZXQgZWxtID0gbmV3IFNlcnZlck1pbWNzc1N0eWxlRWxlbWVudChpZCk7XHJcbiAgICAgICAgaWYgKGluc2VydEJlZm9yZSlcclxuICAgICAgICAgICAgdGhpcy5lbG1zLnNwbGljZSggdGhpcy5lbG1zLmluZGV4T2YoIGluc2VydEJlZm9yZSBhcyBTZXJ2ZXJNaW1jc3NTdHlsZUVsZW1lbnQpLCAwLCBlbG0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5lbG1zLnB1c2goIGVsbSk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbG07XHJcbiAgICB9XHJcblxyXG4gICAgc2VyaWFsaXplKCk6IHN0cmluZ1xyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsbXMubWFwKCBlbG0gPT4gZWxtLnNlcmlhbGl6ZSgpKS5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZWxtczogU2VydmVyTWltY3NzU3R5bGVFbGVtZW50W10gPSBbXTtcclxuICAgIHByaXZhdGUgdGhlbWVFbG0/OiBTZXJ2ZXJNaW1jc3NTdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXJ2ZXItc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBvYmplY3QgdG8gd2hpY2ggcnVsZXMgY2FuIGJlIGFkZGVkLlxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgU2VydmVyTWltY3NzUnVsZUJhZyBpbXBsZW1lbnRzIElNaW1jc3NSdWxlQmFnXHJcbntcclxuICAgIGFkZCggcnVsZVRleHQ6IHN0cmluZyk6IElNaW1jc3NSdWxlIHwgbnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCBydWxlID0gbmV3IFNlcnZlck1pbWNzc1J1bGUoIHJ1bGVUZXh0KTtcclxuICAgICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGU7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkR3JvdXAoIHNlbGVjdG9yOiBzdHJpbmcpOiBJTWltY3NzR3JvdXBpbmdSdWxlIHwgbnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCBydWxlID0gbmV3IFNlcnZlck1pbWNzc0dyb3VwaW5nUnVsZSggc2VsZWN0b3IpO1xyXG4gICAgICAgIHRoaXMucnVsZXMucHVzaChydWxlKTtcclxuICAgICAgICByZXR1cm4gcnVsZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRLZXlmcmFtZXMoIG5hbWU6IHN0cmluZyk6IElNaW1jc3NLZXlmcmFtZXNSdWxlIHwgbnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCBydWxlID0gbmV3IFNlcnZlck1pbWNzc0tleWZyYW1lc1J1bGUoIG5hbWUpO1xyXG4gICAgICAgIHRoaXMucnVsZXMucHVzaChydWxlKTtcclxuICAgICAgICByZXR1cm4gcnVsZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXJpYWxpemUoKTogc3RyaW5nXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZXMubWFwKCBydWxlID0+IHJ1bGUuc2VyaWFsaXplKCkpLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBydWxlczogKFNlcnZlck1pbWNzc1J1bGUgfCBTZXJ2ZXJNaW1jc3NHcm91cGluZ1J1bGUgfCBTZXJ2ZXJNaW1jc3NLZXlmcmFtZXNSdWxlKVtdID0gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXJ2ZXItc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHN0eWxlIGVsZW1lbnQuXHJcbiAqL1xyXG5jbGFzcyBTZXJ2ZXJNaW1jc3NTdHlsZUVsZW1lbnQgZXh0ZW5kcyBTZXJ2ZXJNaW1jc3NSdWxlQmFnIGltcGxlbWVudHMgSU1pbWNzc1N0eWxlRWxlbWVudFxyXG57XHJcbiAgICBjb25zdHJ1Y3RvciggcHVibGljIGlkOiBzdHJpbmcpIHsgc3VwZXIoKTsgfVxyXG4gICAgcHVibGljIGRvbUVsbTogSFRNTFN0eWxlRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gICAgcmVtb3ZlKCk6IHZvaWQge31cclxuXHJcbiAgICBzZXJpYWxpemUoKTogc3RyaW5nXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGA8c3R5bGUgaWQ9XCIke3RoaXMuaWR9XCI+JHtzdXBlci5zZXJpYWxpemUoKX08L3N0eWxlPmA7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXJ2ZXItc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGJhc2UgaW50ZXJmYWNlIGZvciBDU1MgcnVsZS5cclxuICovXHJcbmNsYXNzIFNlcnZlck1pbWNzc1J1bGUgaW1wbGVtZW50cyBJTWltY3NzUnVsZVxyXG57XHJcbiAgICBjb25zdHJ1Y3RvciggcHVibGljIHJ1bGVUZXh0OiBzdHJpbmcpIHt9XHJcbiAgICBwdWJsaWMgY3NzUnVsZTogQ1NTUnVsZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIHNlcmlhbGl6ZSgpOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydWxlVGV4dDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNlcnZlci1zaWRlIGltcGxlbWVudGF0aW9uIG9mIGEgZ3JvdXBpbmcgcnVsZSB0byB3aGljaCBydWxlcyBjYW4gYmUgYWRkZWQuXHJcbiAqL1xyXG5jbGFzcyBTZXJ2ZXJNaW1jc3NHcm91cGluZ1J1bGUgZXh0ZW5kcyBTZXJ2ZXJNaW1jc3NSdWxlQmFnIGltcGxlbWVudHMgSU1pbWNzc0dyb3VwaW5nUnVsZVxyXG57XHJcbiAgICBjb25zdHJ1Y3RvciggcHVibGljIHNlbGVjdG9yOiBzdHJpbmcpIHsgc3VwZXIoKTsgfVxyXG4gICAgcHVibGljIGNzc1J1bGU6IENTU1J1bGUgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBzZXJpYWxpemUoKTogc3RyaW5nXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc2VsZWN0b3J9eyR7c3VwZXIuc2VyaWFsaXplKCl9fWA7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXJ2ZXItc2lkZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGtleWZyYW1lcyBydWxlIHRvIHdoaWNoIGZyYW1lcyBjYW4gYmUgYWRkZWQuXHJcbiAqL1xyXG5jbGFzcyBTZXJ2ZXJNaW1jc3NLZXlmcmFtZXNSdWxlIGltcGxlbWVudHMgSU1pbWNzc0tleWZyYW1lc1J1bGVcclxue1xyXG4gICAgY29uc3RydWN0b3IoIHB1YmxpYyBuYW1lOiBzdHJpbmcpIHt9XHJcbiAgICBwdWJsaWMgY3NzUnVsZTogQ1NTUnVsZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGFkZEZyYW1lKCBmcmFtZVRleHQ6IHN0cmluZyk6IElNaW1jc3NSdWxlIHwgbnVsbFxyXG4gICAge1xyXG4gICAgICAgIGxldCBmcmFtZSA9IG5ldyBTZXJ2ZXJNaW1jc3NSdWxlKCBmcmFtZVRleHQpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzLnB1c2goIGZyYW1lKTtcclxuICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2VyaWFsaXplKCk6IHN0cmluZ1xyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBgQGtleWZyYW1lcyAke3RoaXMubmFtZX17JHt0aGlzLmZyYW1lcy5tYXAoIGZyYW1lID0+IGZyYW1lLnNlcmlhbGl6ZSgpKS5qb2luKFwiXCIpfX1gO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZnJhbWVzOiBTZXJ2ZXJNaW1jc3NSdWxlW10gPSBbXTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ2xpZW50IGFjdGl2YXRpb24gY29udGV4dC4gSW4gdGhlIGNsaWVudCBlbnZpcm9ubWVudCwgaXQgaXMgQ2xpZW50QWN0aXZhdGlvbkNvbnRleHQgaW5zdGFuY2U7XHJcbiAqIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQsIGl0IGlzIHVuZGVmaW5lZC5cclxuICovXHJcbmNvbnN0IHNfY2xpZW50QWN0aXZhdGlvbkNvbnRleHQgPSBkb2N1bWVudD8uaGVhZCA/IG5ldyBDbGllbnRBY3RpdmF0aW9uQ29udGV4dCgpIDogdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIEFjdGl2YXRpb24gY29udGV4dCB0byB1c2UuIEluIHRoZSBjbGllbnQgZW52aXJvbm1lbnQsIGl0IGlzIGJ5IGRlZmF1bHQgQ2xpZW50QWN0aXZhdGlvbkNvbnRleHRcclxuICogYnV0IGNhbiBiZSBjaGFuZ2VkICh0ZW1wb3JhcmlseSkgdG8gSHlkcmF0aW9uQWN0aXZhdGlvbkNvbnRleHQuIEluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQsIGl0XHJcbiAqIGlzIGJ5IGRlZmF1bHQgdW5kZWZpbmVkLCBidXQgY2FuIGJlIGNoYW5nZWQgdG8gU2VydmVyQWN0aXZhdGlvbkNvbnRleHQuXHJcbiAqL1xyXG5sZXQgc19hY3RpdmF0aW9uQ29udGV4dDogSUFjdGl2YXRpb25Db250ZXh0IHwgdW5kZWZpbmVkID0gc19jbGllbnRBY3RpdmF0aW9uQ29udGV4dDtcclxuXHJcbi8qKlxyXG4gKiBTY2hlZHVsZXIgdHlwZSByZW1lbWJlcmVkIHVwb24gc3RhcnRpbmcgU1NSIG9yIGh5ZHJhdGlvbiBwcm9jZXNzLiBUaGlzIHdpbGwgYmUgdXNlZCB0byByZXN0b3JlXHJcbiAqIHRoZSBzY2VkdWxlciB3aGVuIFNTUiBvciBoeWRyYXRpb24gcHJvY2VzcyBpcyBzdG9wcGVkLlxyXG4gKi9cclxubGV0IHNfcmVtZW1iZXJlZFNjaGVkdWxlclR5cGU6IG51bWJlciA9IDA7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHNlcnZlci1zaWRlIGFjdGl2YXRpb24gY29udGV4dC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vbi1kZWZhdWx0IGFjdGl2YXRpb24gY29udGV4dCBpc1xyXG4gKiBhbHJlYWR5IHNldC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzX3N0YXJ0U1NSID0gKCk6IHZvaWQgPT5cclxue1xyXG4gICAgaWYgKHNfYWN0aXZhdGlvbkNvbnRleHQgIT09IHNfY2xpZW50QWN0aXZhdGlvbkNvbnRleHQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1NSIGFscmVhZHkgc3RhcnRlZFwiKTtcclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBzX2FjdGl2YXRpb25Db250ZXh0ID0gbmV3IFNlcnZlckFjdGl2YXRpb25Db250ZXh0KCk7XHJcbiAgICAgICAgc19yZW1lbWJlcmVkU2NoZWR1bGVyVHlwZSA9IHNldERlZmF1bHRTY2hlZHVsZXIoIFNjaGVkdWxlclR5cGUuU3luYyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdG9wcyBzZXJ2ZXItc2lkZSBhY3RpdmF0aW9uIGZ1bmN0aW9uYWxpdHkgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCBzZXJpYWxpemVkIHN0eWxlcy4gVGhlXHJcbiAqIHN0cmluZyBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGA8aGVhZD5gIGVsZW1lbnQgdXNpbmcgYGluc2VydEFkamFjZW50SFRNTCgpYCBtZXRob2QuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiBTU1IgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQuXHJcbiAqIEByZXR1cm5zIFN0cmluZyBjb250YWluaW5nIHNlcmlhbGl6ZWQgc3R5bGVzXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc19zdG9wU1NSID0gKCk6IHN0cmluZyA9PlxyXG57XHJcbiAgICBpZiAoIXNfYWN0aXZhdGlvbkNvbnRleHQgfHwgIShzX2FjdGl2YXRpb25Db250ZXh0IGluc3RhbmNlb2YgU2VydmVyQWN0aXZhdGlvbkNvbnRleHQpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNTUiBub3Qgc3RhcnRlZFwiKTtcclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICAvLyByZXN0b3JlIHNjaGVkdWxlciB0eXBlIGV4aXN0ZWQgYmVmb3JlIHdlIHN0YXJ0ZWQgU1NSXHJcbiAgICAgICAgc2V0RGVmYXVsdFNjaGVkdWxlciggc19yZW1lbWJlcmVkU2NoZWR1bGVyVHlwZSk7XHJcbiAgICAgICAgc19yZW1lbWJlcmVkU2NoZWR1bGVyVHlwZSA9IDA7XHJcblxyXG4gICAgICAgIGxldCBzID0gc19hY3RpdmF0aW9uQ29udGV4dC5zZXJpYWxpemUoKTtcclxuICAgICAgICBzX2FjdGl2YXRpb25Db250ZXh0ID0gc19jbGllbnRBY3RpdmF0aW9uQ29udGV4dDtcclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogU2V0cyBoeWRyYXRpb24gYWN0aXZhdGlvbiBjb250ZXh0LiBUaHJvd3MgYW4gZXJyb3IgaWYgbm9uLWRlZmF1bHQgYWN0aXZhdGlvbiBjb250ZXh0IGlzXHJcbiAqIGFscmVhZHkgc2V0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNfc3RhcnRIeWRyYXRpb24gPSAoKTogdm9pZCA9PlxyXG57XHJcbiAgICBpZiAoc19hY3RpdmF0aW9uQ29udGV4dCAhPT0gc19jbGllbnRBY3RpdmF0aW9uQ29udGV4dClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIeWRyYXRpb24gYWxyZWFkeSBzdGFydGVkXCIpO1xyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIHNfYWN0aXZhdGlvbkNvbnRleHQgPSBuZXcgSHlkcmF0aW9uQWN0aXZhdGlvbkNvbnRleHQoKTtcclxuICAgICAgICBzX3JlbWVtYmVyZWRTY2hlZHVsZXJUeXBlID0gc2V0RGVmYXVsdFNjaGVkdWxlciggU2NoZWR1bGVyVHlwZS5TeW5jKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFN0b3BzIGh5ZHJhdGlvbiBhY3RpdmF0aW9uIGZ1bmN0aW9uYWxpdHkgYW5kIHJlc3RvcmUgdGhlIGRlZmF1bHQgYWN0aXZhdGlvbiBjb250ZXh0LlxyXG4gKiBAcmV0dXJucyBTdHJpbmcgY29udGFpbmluZyBzZXJpYWxpemVkIHN0eWxlc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNfc3RvcEh5ZHJhdGlvbiA9ICgpOiB2b2lkID0+XHJcbntcclxuICAgIGlmICghc19hY3RpdmF0aW9uQ29udGV4dCB8fCAhKHNfYWN0aXZhdGlvbkNvbnRleHQgaW5zdGFuY2VvZiBIeWRyYXRpb25BY3RpdmF0aW9uQ29udGV4dCkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSHlkcmF0aW9uIG5vdCBzdGFydGVkXCIpO1xyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIC8vIHJlc3RvcmUgc2NoZWR1bGVyIHR5cGUgZXhpc3RlZCBiZWZvcmUgd2Ugc3RhcnRlZCBTU1JcclxuICAgICAgICBzZXREZWZhdWx0U2NoZWR1bGVyKCBzX3JlbWVtYmVyZWRTY2hlZHVsZXJUeXBlKTtcclxuICAgICAgICBzX3JlbWVtYmVyZWRTY2hlZHVsZXJUeXBlID0gMDtcclxuXHJcbiAgICAgICAgc19hY3RpdmF0aW9uQ29udGV4dCA9IHNfY2xpZW50QWN0aXZhdGlvbkNvbnRleHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtcclxuICAgIElTdHlsZVJ1bGUsIElWYXJSdWxlLCBEZXBlbmRlbnRSdWxlcywgSU5hbWVkRW50aXR5LCBJQ2xhc3NSdWxlLCBJSURSdWxlLCBJU3R5bGVEZWZpbml0aW9uLFxyXG4gICAgSVBhZ2VSdWxlLFxyXG4gICAgSVByZWZpeGVkTmFtZWRFbnRpdHlcclxufSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgRXh0ZW5kZWRJU3R5bGVzZXQsIFN0eWxlc2V0LCBWYXJUZW1wbGF0ZU5hbWUsIEN1c3RvbVZhcl9TdHlsZVR5cGUsIEV4dGVuZGVkVmFyVmFsdWUsXHJcbiAgICBDb21iaW5lZFN0eWxlc2V0LCBQYXJlbnRDbGFzc1R5cGUsIElTdHlsZXNldFxyXG59IGZyb20gXCIuLi9hcGkvU3R5bGVzZXRzXCJcclxuaW1wb3J0IHtDc3NTZWxlY3RvciwgSVBhcmFtZXRlcml6ZWRQc2V1ZG9FbnRpdHlGdW5jLCBQYWdlUHNldWRvQ2xhc3N9IGZyb20gXCIuLi9hcGkvQ29yZVR5cGVzXCJcclxuaW1wb3J0IHtSdWxlLCBJTWltY3NzUnVsZUJhZ30gZnJvbSBcIi4vUnVsZVwiO1xyXG5pbXBvcnQge2NhbWVsVG9EYXNoLCBmZG8ycywgc3ltVjJTfSBmcm9tIFwiLi4vaW1wbC9VdGlsc1wiO1xyXG5pbXBvcnQge3Mycywgc3Ayc30gZnJvbSBcIi4uL2ltcGwvU3R5bGVJbXBsXCJcclxuaW1wb3J0IHtnZXRBY3RpdmF0b3J9IGZyb20gXCIuLi9pbXBsL1NjaGVkdWxpbmdJbXBsXCI7XHJcbmltcG9ydCB7c2VsZWN0b3Iyc30gZnJvbSBcIi4uL2ltcGwvQ29yZUltcGxcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBTdHlsZVJ1bGUgY2xhc3MgaXMgdXNlZCBhcyBhIGJhc2UgY2xhc3MgZm9yIHJ1bGVzIHRoYXQgY29udGFpbiBhIHN0eWxlIHJ1bGUuIFRoaXMgY2xhc3NcclxuICogaW1wbGVtZW50cyB0aGUgcGFyc2luZyBvZiB0aGUgQ29tYmluZWRTdHlsZXNldCBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3R5bGVSdWxlIGV4dGVuZHMgUnVsZSBpbXBsZW1lbnRzIElTdHlsZVJ1bGVcclxue1xyXG5cdC8vIFRoZSBzdHlsZXNldCBjYW4gYmUgYW4gQ29tYmluZWRTdHlsZXNldCBmb3IgbWFueSBydWxlczsgaG93ZXZlciwgZm9yIHNvbWUgaXQgaXMganVzdFxyXG5cdC8vIG9mIHRoZSBTdHlsZXNldCB0eXBlLlxyXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24sIGlucHV0U3R5bGVzZXQ/OiBTdHlsZXNldCB8IFN0eWxlc2V0W10pXHJcblx0e1xyXG5cdFx0c3VwZXIoc2QpO1xyXG5cclxuXHRcdHRoaXMuc3R5bGVzZXQgPSB7fTtcclxuXHRcdHRoaXMuZGVwZW5kZW50UnVsZXMgPSB7fTtcclxuXHJcblx0XHRpZiAoaW5wdXRTdHlsZXNldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KCBpbnB1dFN0eWxlc2V0KSlcclxuICAgICAgICAgICAgICAgIGlucHV0U3R5bGVzZXQuZm9yRWFjaCggdiA9PiB0aGlzLnBhcnNlKCBzZCwgdikpO1xyXG4gICAgICAgICAgICBlbHNlXHJcblx0XHRcdCAgICB0aGlzLnBhcnNlKCBzZCwgaW5wdXRTdHlsZXNldCk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB0aGUgb2JqZWN0IHRvIHBhcnRpY3BhdGUgaW4gXCJ2MnNcIiBzZXJpYWxpemF0aW9uLiBXaGVuZXZlciB0aGVcclxuICAgICAqIFN0eWxlUnVsZS1kZXJpdmVkIG9iamVjdCBpcyBlbmNvdW50ZXJlZCBieSB0aGUgYHYyc2AgZnVuY3Rpb24sIHRoZSBydWxlJ3Mgc2VsZWN0b3Igd2lsbCBiZVxyXG4gICAgICogdXNlZC5cclxuICAgICAqL1xyXG4gICAgW3N5bVYyU10oKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuc2VsZWN0b3JUZXh0OyB9XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBHb2VzIG92ZXIgcHJvcGVydGllcyBpbiB0aGUgZ2l2ZW4gc3R5bGVzZXQgYW5kIHBhcnNlcyB0aGVtIGludG8gcHJvcGVyIHN0eWxlc2V0LCBzZXQgb2ZcclxuXHQgKiBpbXBvcnRhbnQgcHJvcGVydGllcyBhbmQgZGVwZW5kZW50IHJ1bGVzLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgcGFyc2UoIHNkOiBJU3R5bGVEZWZpbml0aW9uLCBpbnB1dFN0eWxlc2V0OiBTdHlsZXNldCk6IHZvaWRcclxuXHR7XHJcblx0XHRmb3IoIGxldCBwcm9wTmFtZSBpbiBpbnB1dFN0eWxlc2V0KVxyXG5cdFx0e1xyXG5cdFx0XHRsZXQgcHJvcFZhbCA9IGlucHV0U3R5bGVzZXRbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAocHJvcFZhbCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BOYW1lID09PSBcIitcIilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIGlzIGEgc2luZ2xlIFN0eWxlUnVsZSBvciBhbiBhcnJheSBvZiBTdHlsZVJ1bGVzIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50UnVsZXMgPSBwcm9wVmFsIGluc3RhbmNlb2YgU3R5bGVSdWxlID8gW3Byb3BWYWxdIDogcHJvcFZhbCBhcyBTdHlsZVJ1bGVbXTtcclxuICAgICAgICAgICAgICAgIGZvciggbGV0IHBhcmVudCBvZiBwYXJlbnRSdWxlcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZVN0eWxlc2V0cyggdGhpcy5zdHlsZXNldCwgcGFyZW50LnN0eWxlc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlEZXBSdWxlcyggcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCItLVwiKVxyXG4gICAgICAgICAgICAgICAgbWVyZ2VDdXN0b21Qcm9wcyggdGhpcy5zdHlsZXNldCwgcHJvcFZhbCBhcyBDdXN0b21WYXJfU3R5bGVUeXBlW10pO1xyXG5cdFx0XHRlbHNlIGlmIChwcm9wTmFtZS5zdGFydHNXaXRoKFwiOlwiKSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdC8vIGlmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiB0aGlzIGlzIGFuIGFycmF5IG9mIHR1cGxlcyByZXByZXNlbnRpbmdcclxuXHRcdFx0XHQvLyBwYXJhbWV0ZXJpc2VkIHBzZXVkbyBlbnRpdGllcyB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgcGFyYW1ldGVyIHZhbHVlXHJcblx0XHRcdFx0Ly8gKHN0cmluZykgYW5kIHRoZSBzZWNvbmQgdGhlIENvbWJpbmVkU3R5bGVzZXQuIE90aGVyd2lzZSwgdGhlIHZhbHVlIGlzIGp1c3QgYVxyXG5cdFx0XHRcdC8vIENvbWJpbmVkU3R5bGVzZXQuXHJcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbCkpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dGhpcy5kZXBlbmRlbnRSdWxlc1twcm9wTmFtZV0gPSBwcm9wVmFsLm1hcChcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHR1cGxlOiBbYW55LCBDb21iaW5lZFN0eWxlc2V0IHwgQ29tYmluZWRTdHlsZXNldFtdXSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZXBSdWxlKHNkLCBwcm9wTmFtZSwgdHVwbGVbMF0sIHR1cGxlWzFdLCB0aGlzKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHRoaXMuZGVwZW5kZW50UnVsZXNbcHJvcE5hbWVdID0gbmV3IERlcFJ1bGUoIHNkLCBcIiZcIiArIHByb3BOYW1lLCB1bmRlZmluZWQsXHJcblx0XHRcdFx0XHRcdHByb3BWYWwgYXMgQ29tYmluZWRTdHlsZXNldCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAocHJvcE5hbWUuaW5jbHVkZXMoXCImXCIpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBhbiBhcnJheSBvZiB0d28tZWxlbWVudCB0dXBsZXMgd2l0aCBzZWxlY3RvciBhbmQgc3R5bGVzZXRcclxuICAgICAgICAgICAgICAgIGxldCB0dXBsZXMgPSBwcm9wVmFsIGFzIFtDc3NTZWxlY3RvciwgQ29tYmluZWRTdHlsZXNldCB8IENvbWJpbmVkU3R5bGVzZXRbXV1bXTtcclxuICAgICAgICAgICAgICAgIGlmICh0dXBsZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVudFJ1bGVzW3Byb3BOYW1lXSA9IHR1cGxlcy5tYXAoIHR1cGxlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1NlbGVjdG9yID0gcHJvcE5hbWUgPT09IFwiJlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHR1cGxlWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByb3BOYW1lLnN0YXJ0c1dpdGgoXCImXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcHJvcE5hbWUsIHR1cGxlWzBdXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW3R1cGxlWzBdLCBwcm9wTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVwUnVsZSggc2QsIG5ld1NlbGVjdG9yLCB1bmRlZmluZWQsIHR1cGxlWzFdLCB0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblx0XHRcdGVsc2UgaWYgKHRoaXMucGFyc2VTUCggcHJvcE5hbWUsIHByb3BWYWwpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Ly8gdGhpcyBpcyBhIHJlZ3VsYXIgQ1NTIHByb3BlcnR5OiBjb3B5IHRoZSBwcm9wZXJ0eSB2YWx1ZSB0byBvdXIgaW50ZXJuYWwgc3R5bGVzZXRcclxuICAgICAgICAgICAgICAgIG1lcmdlUHJvcFZhbHVlcyggdGhpcy5zdHlsZXNldCwgcHJvcE5hbWUsIHByb3BWYWwpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBydWxlLlxyXG5cdHB1YmxpYyBwcm9jZXNzKCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoRGVwUnVsZSggKGRlcFJ1bGU6IERlcFJ1bGUpID0+IGRlcFJ1bGUucHJvY2VzcyggbnVsbCkpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBDb252ZXJ0cyB0aGUgcnVsZSB0byBDU1Mgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnVsZS5cclxuXHRwdWJsaWMgdG9Dc3MoKTogc3RyaW5nXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0b3JUZXh0ICsgczJzKCB0aGlzLnN0eWxlc2V0KTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gSW5zZXJ0cyB0aGlzIHJ1bGUgaW50byB0aGUgZ2l2ZW4gcGFyZW50IHJ1bGUgb3Igc3R5bGVzaGVldC5cclxuXHRwdWJsaWMgaW5zZXJ0KCBydWxlQmFnOiBJTWltY3NzUnVsZUJhZyk6IHZvaWRcclxuXHR7XHJcblx0XHRpZiAoT2JqZWN0LmtleXModGhpcy5zdHlsZXNldCkubGVuZ3RoID4gMClcclxuXHRcdFx0dGhpcy5jc3NSdWxlID0gcnVsZUJhZy5hZGQoIHRoaXMudG9Dc3MoKSk/LmNzc1J1bGUgYXMgQ1NTU3R5bGVSdWxlO1xyXG5cclxuICAgICAgICAvLyBpbnNlcnQgZGVwZW5kZW50IHJ1bGVzIHVuZGVyIHRoZSBzYW1lIHBhcmVudFxyXG4gICAgICAgIHRoaXMuZm9yRWFjaERlcFJ1bGUoIChkZXBSdWxlOiBEZXBSdWxlKSA9PiBkZXBSdWxlLmluc2VydCggcnVsZUJhZykpO1xyXG5cdH1cclxuXHJcblx0Ly8gQ2xlcnMgdGhlIENTUyBydWxlIG9iamVjdC5cclxuXHRwdWJsaWMgY2xlYXIoKTogdm9pZFxyXG5cdHtcclxuXHRcdHN1cGVyLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIGRlcGVuZGVudCBydWxlc1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaERlcFJ1bGUoIChkZXBSdWxlOiBEZXBSdWxlKSA9PiBkZXBSdWxlLmNsZWFyKCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gSW52b2tlIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgZGVwZW5kZW50IHJ1bGVzLlxyXG5cdHByaXZhdGUgZm9yRWFjaERlcFJ1bGUoIGZ1bmM6IChkZXBSdWxlOiBEZXBSdWxlKSA9PiB2b2lkKTogdm9pZFxyXG5cdHtcclxuXHRcdGZvciggbGV0IHByb3BOYW1lIGluIHRoaXMuZGVwZW5kZW50UnVsZXMpXHJcblx0XHR7XHJcblx0XHRcdGxldCBwcm9wVmFsID0gdGhpcy5kZXBlbmRlbnRSdWxlc1twcm9wTmFtZV0gYXMgRGVwUnVsZSB8IERlcFJ1bGVbXTtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbCkpXHJcbiAgICAgICAgICAgICAgICBmb3IoIGxldCBkZXBSdWxlIG9mIHByb3BWYWwpIGZ1bmMoIGRlcFJ1bGUpO1xyXG5cdFx0XHRlbHNlXHJcbiAgICAgICAgICAgICAgICBmdW5jKCBwcm9wVmFsKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0LyoqIENTUyBydWxlIHNlbGVjdG9yIHN0cmluZyAqL1xyXG5cdHB1YmxpYyBnZXQgc2VsZWN0b3JUZXh0KCk6IHN0cmluZ1xyXG5cdHtcclxuXHRcdGlmICh0aGlzLl9zZWwgPT0gbnVsbClcclxuXHRcdFx0dGhpcy5fc2VsID0gdGhpcy5nZXRTZWwoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc2VsO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBDb3BpZXMgZGVwZW5kZW50IHJ1bGVzIGZyb20gYW5vdGhlciBzdHlsZSBydWxlIG9iamVjdC5cclxuXHRwcm90ZWN0ZWQgY29weURlcFJ1bGVzKCBzcmM6IFN0eWxlUnVsZSk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgbGV0IHNyc0RlcFJ1bGVzID0gc3JjLmRlcGVuZGVudFJ1bGVzO1xyXG4gICAgICAgIGxldCB0aGlzRGVwUnVsZXMgPSB0aGlzLmRlcGVuZGVudFJ1bGVzO1xyXG5cdFx0Zm9yKCBsZXQgcHJvcE5hbWUgaW4gc3JzRGVwUnVsZXMpXHJcblx0XHR7XHJcblx0XHRcdGxldCBzcmNSdWxlT3JBcnIgPSBzcnNEZXBSdWxlc1twcm9wTmFtZV0gYXMgRGVwUnVsZSB8IERlcFJ1bGVbXTtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc3JjUnVsZU9yQXJyKSlcclxuXHRcdFx0e1xyXG4gICAgICAgICAgICAgICAgaWYgKHNyY1J1bGVPckFyci5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aGlzQXJyID0gdGhpc0RlcFJ1bGVzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNBcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEZXBSdWxlc1twcm9wTmFtZV0gPSB0aGlzQXJyID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciggbGV0IHNyY0RlcFJ1bGUgb2Ygc3JjUnVsZU9yQXJyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQXJyLnB1c2goIHNyY0RlcFJ1bGUuY2xvbmUoIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhpc0RlcFJ1bGVzW3Byb3BOYW1lXSA9IHNyY1J1bGVPckFyci5jbG9uZSggdGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUuXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGdldFNlbCgpOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gQWxsb3dzIHRoZSBkZXJpdmVkIGNsYXNzZXMgdG8gcHJvY2VzcyBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgdGhlIFN0eWxlUnVsZSBkb2Vzbid0IGtub3cgYWJvdXQuXHJcbiAgICAvLyBJZiBmYWxzZSBpcyByZXR1cm5lZCwgdGhlIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHN0eWxlc2V0LlxyXG5cdHByb3RlY3RlZCBwYXJzZVNQKCBwcm9wTmFtZTogc3RyaW5nLCBwcm9wVmFsOiBhbnkpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzL3JlcGxhY2VzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gQ1NTIHByb3BlcnR5IGluIHRoaXMgcnVsZS5cclxuXHQgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBDU1MgcHJvcGVydHkuXHJcblx0ICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSBvZiB0aGUgQ1NTIHByb3BlcnR5LlxyXG5cdCAqIEBwYXJhbSBpbXBvcnRhbnQgRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gc2V0IHRoZSBcIiFpbXBvcnRhbnRcIiBmbGFnIG9uIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuXHQgKiBAcGFyYW0gc2NoZWR1bGVyVHlwZSBJRCBvZiBhIHJlZ2lzdGVyZWQgc2NoZWR1bGVyIHR5cGUgdGhhdCBpcyB1c2VkIHRvIHdyaXRlIHRoZSBwcm9wZXJ0eVxyXG5cdCAqIHZhbHVlIHRvIHRoZSBET00uIElmIHVuZGVmaW5lZCwgdGhlIGN1cnJlbnQgZGVmYXVsdCBzY2hlZHVsZXIgd2lsbCBiZSB1c2VkLlxyXG5cdCAqL1xyXG4gICAgcHVibGljIHNldFByb3A8SyBleHRlbmRzIGtleW9mIElTdHlsZXNldD4oIG5hbWU6IEssIHZhbHVlPzogRXh0ZW5kZWRJU3R5bGVzZXRbS10gfCBudWxsLFxyXG4gICAgICAgIGltcG9ydGFudD86IGJvb2xlYW4sIHNjaGVkdWxlclR5cGU/OiBudW1iZXIpOiB2b2lkXHJcblx0e1xyXG5cdFx0Ly8gZmlyc3Qgc2V0L3JlbW92ZSB0aGUgdmFsdWUgaW4gb3VyIGludGVybmFsIHN0eWxlc2V0IG9iamVjdFxyXG5cdFx0aWYgKHZhbHVlID09IG51bGwpXHJcblx0XHRcdGRlbGV0ZSB0aGlzLnN0eWxlc2V0W25hbWVdO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aGlzLnN0eWxlc2V0W25hbWVdID0gaW1wb3J0YW50ID8geyBcIiFcIjogdmFsdWUgYXMgYW55IH0gOiB2YWx1ZSBhcyBhbnk7XHJcblxyXG5cdFx0Ly8gc2Vjb25kLCBpZiBDU1NSdWxlIGFscmVkeSBleGlzdHMsIHNldC9yZW1vdmUgdGhlIHByb3BlcnR5IHZhbHVlIHRoZXJlXHJcblx0XHRpZiAodGhpcy5jc3NSdWxlKVxyXG4gICAgICAgIHtcclxuXHRcdCAgICBnZXRBY3RpdmF0b3Ioc2NoZWR1bGVyVHlwZSkudXBkYXRlU3R5bGUoIHRoaXMuY3NzUnVsZSwgY2FtZWxUb0Rhc2goIG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBzcDJzKCBuYW1lLCB2YWx1ZSksIGltcG9ydGFudCk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzL3JlcGxhY2VzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY3VzdG9tIENTUyBwcm9wZXJ0eSBpbiB0aGlzIHJ1bGUuXHJcblx0ICogQHBhcmFtIHZhck9iaiBJVmFyUnVsZSBvYmplY3QgZGVmaW5pbmcgYSBjdXN0b20gQ1NTIHByb3BlcnR5LlxyXG5cdCAqIEBwYXJhbSB2YXJWYWx1ZSBOZXcgdmFsdWUgb2YgdGhlIGN1c3RvbSBDU1MgcHJvcGVydHkuXHJcblx0ICogQHBhcmFtIGltcG9ydGFudCBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0byBzZXQgdGhlIFwiIWltcG9ydGFudFwiIGZsYWcgb24gdGhlIHByb3BlcnR5IHZhbHVlLlxyXG5cdCAqIEBwYXJhbSBzY2hlZHVsZXJUeXBlIElEIG9mIGEgcmVnaXN0ZXJlZCBzY2hlZHVsZXIgdHlwZSB0aGF0IGlzIHVzZWQgdG8gd3JpdGUgdGhlIHByb3BlcnR5XHJcblx0ICogdmFsdWUgdG8gdGhlIERPTS4gSWYgdW5kZWZpbmVkLCB0aGUgY3VycmVudCBkZWZhdWx0IHNjaGVkdWxlciB3aWxsIGJlIHVzZWQuXHJcblx0ICovXHJcblx0cHVibGljIHNldEN1c3RvbVByb3A8SyBleHRlbmRzIFZhclRlbXBsYXRlTmFtZT4oIHZhck9iajogSVZhclJ1bGU8Sz4sIHZhbHVlOiBFeHRlbmRlZFZhclZhbHVlPEs+LFxyXG5cdFx0aW1wb3J0YW50PzogYm9vbGVhbiwgc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWRcclxuXHR7XHJcblx0XHRpZiAoIXZhck9iailcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdC8vIGZpcnN0IHNldC9yZW1vdmUgdGhlIHZhbHVlIGluIG91ciBpbnRlcm5hbCBzdHlsZXNldCBvYmplY3RcclxuXHRcdGxldCBjdXJyQ3VzdG9tUHJvcHMgPSB0aGlzLnN0eWxlc2V0W1wiLS1cIl0gYXMgQ3VzdG9tVmFyX1N0eWxlVHlwZVtdO1xyXG5cdFx0aWYgKGN1cnJDdXN0b21Qcm9wcyB8fCB2YWx1ZSAhPSBudWxsKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbClcclxuXHRcdFx0e1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gY3VyckN1c3RvbVByb3BzLmZpbmRJbmRleCggaXRlbSA9PiBpdGVtWzBdID09PSB2YXJPYmopO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyckN1c3RvbVByb3BzLnNwbGljZSggaW5kZXgsIDEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKCFjdXJyQ3VzdG9tUHJvcHMpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2V0W1wiLS1cIl0gPSBbW3Zhck9iaiwgdmFsdWVdXTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjdXJyQ3VzdG9tUHJvcHMuZmluZEluZGV4KCBpdGVtID0+IGl0ZW1bMF0gPT09IHZhck9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMClcclxuICAgICAgICAgICAgICAgICAgICBjdXJyQ3VzdG9tUHJvcHNbaW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyckN1c3RvbVByb3BzLnB1c2goIFt2YXJPYmosIHZhbHVlXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWNvbmQsIGlmIENTU1J1bGUgYWxyZWR5IGV4aXN0cywgc2V0L3JlbW92ZSB0aGUgcHJvcGVydHkgdmFsdWUgdGhlcmVcclxuXHRcdGlmICh0aGlzLmNzc1J1bGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRBY3RpdmF0b3Ioc2NoZWR1bGVyVHlwZSkudXBkYXRlU3R5bGUoIHRoaXMuY3NzUnVsZSwgdmFyT2JqLmNzc05hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHNwMnMoIHZhck9iai50ZW1wbGF0ZSwgdmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgaW1wb3J0YW50KTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKiBTT00gc3R5bGUgcnVsZSAqL1xyXG5cdHB1YmxpYyBjc3NSdWxlOiBDU1NTdHlsZVJ1bGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIE9iamVjdCBjb250YWluaW5nIGRlcGVuZGVudCBydWxlcy4gUHJvcGVydHkgbmFtZXMgYXJlIHRha2VuIGZyb20gc3BlY2lhbCBwcm9wZXJ0aWVzXHJcblx0ICogb2YgdGhlIENvbWJpbmVkU3R5bGVzZXQuIFRoaXMgb2JqZWN0IGFsbG93cyBjYWxsZXJzIHRvIGFjY2VzcyBkZXBlbmRlbnQgcnVsZXMgdG8gY2hhbmdlXHJcblx0ICogc3R5bGUgcHJvcGVydHkgdmFsdWVzIHByb2dyYW1tYXRpY2FsbHkuXHJcblx0ICovXHJcblx0cHVibGljIGRlcGVuZGVudFJ1bGVzOiBEZXBlbmRlbnRSdWxlcztcclxuXHJcblx0Ly8gUmVzdWx0YW50IG9iamVjdCBkZWZpbmluZyBwcm9wZXJ0aWVzIHRvIGJlIGluc2VydGVkIGludG8gRE9NLlxyXG5cdHByb3RlY3RlZCBzdHlsZXNldDogU3R5bGVzZXQ7XHJcblxyXG5cdC8vIFNlbGVjdG9yIHN0cmluZyBjYWNoZWQgYWZ0ZXIgaXQgaXMgZmlyc3Qgb2J0YWluZWQuIE5lZWRlZCB0byBub3QgaW52b2tlIGdldFNlbGVjdG9yU3RyaW5nXHJcblx0Ly8gbXVsdGlwbGUgdGltZXMgaW4gdGhlIHByZXNlbmNlIG9mIGRlcGVuZGVudCBydWxlcy5cclxuXHRwcml2YXRlIF9zZWw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgRGVwZW5kZW50UnVsZSBjbGFzcyBkZXNjcmliZXMgYSBzdHlsZXNldCB0aGF0IGRlcGVuZHMgb24gdGhlIGNvbnRhaW5pbmcgc3R5bGUgcnVsZS4gVGhpc1xyXG4gKiBpcyB1c2VkIGZvciBwc2V1ZG8gY2xhc3NlcywgcHNldWRvIGVsZW1lbnRzLCBjb21iaW5hdG9ycyBhbmQgb3RoZXIgc2VsZWN0b3JzIHRoYXQgY29tYmluZSB0aGVcclxuICogY29udGFpbmluZyBydWxlJ3Mgc2VsZWN0b3Igd2l0aCBhZGRpdGlvbmFsIHNlbGVjdG9yIGl0ZW1zLlxyXG4gKi9cclxuY2xhc3MgRGVwUnVsZSBleHRlbmRzIFN0eWxlUnVsZVxyXG57XHJcblx0Ly8gZm9yIHJlZ3VsYXIgc2VsZWN0b3JzLCBwc2V1ZG8gY2xhc3NlcyBhbmQgcHNldWRvIGVsZW1lbnRzLCB0aGUgc2VsZWN0b3IgYWxyZWFkeSBjb250YWluc1xyXG5cdC8vIHRoZSBhbXBlcnNhbmQgYW5kIHRoZSBzZWxlY3RvclBhcmFtIGlzIHVuZGVmaW5lZC4gRm9yIHBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzZXMsIHBzZXVkb1xyXG5cdC8vIGVsZW1lbnRzIGFuZCBjb21iaW5hdG9ycywgdGhlIHNlbGVjdG9yUGFyYW0gaXMgZGVmaW5lZCBhbmQgdGhlIHNlbGVjdG9yIGlzIGp1c3QgdGhlIGVudGl0eVxyXG5cdC8vIG5hbWUuXHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgc2VsZWN0b3I6IENzc1NlbGVjdG9yLCBwYXJhbT86IGFueSwgc3R5bGVzZXQ/OiBDb21iaW5lZFN0eWxlc2V0IHwgQ29tYmluZWRTdHlsZXNldFtdLFxyXG5cdFx0cGFyZW50PzogU3R5bGVSdWxlKVxyXG5cdHtcclxuXHRcdHN1cGVyKCBzZCwgc3R5bGVzZXQpO1xyXG5cdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5wYXJhbSA9IHBhcmFtO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBDcmVhdGVzIGEgY29weSBvZiB0aGUgcnVsZSBidXQgd2l0aCBuZXcgcGFyZW50IChjb250YWluaW5nIHJ1bGUpLlxyXG5cdHB1YmxpYyBjbG9uZSggY29udGFpbmluZ1J1bGU6IFN0eWxlUnVsZSk6IERlcFJ1bGVcclxuXHR7XHJcblx0XHRsZXQgbmV3UnVsZSA9IG5ldyBEZXBSdWxlKCB0aGlzLnNkLCB0aGlzLnNlbGVjdG9yLCB0aGlzLnBhcmFtLCB1bmRlZmluZWQsIGNvbnRhaW5pbmdSdWxlKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGEgbmV3bHkgY3JlYXRlZCBvYmplY3Qgc28gd2UgZG9uJ3QgaGF2ZSBhbnkgcHJvcGVydGllcyBpblxyXG5cdFx0Ly8gb3VyIG93biBzdHlsZXNldCB5ZXRcclxuXHRcdG1lcmdlU3R5bGVzZXRzKCBuZXdSdWxlLnN0eWxlc2V0LCB0aGlzLnN0eWxlc2V0KTtcclxuXHRcdG5ld1J1bGUuY29weURlcFJ1bGVzKCB0aGlzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1J1bGU7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUuXHJcblx0cHVibGljIGdldFNlbCgpOiBzdHJpbmdcclxuXHR7XHJcblx0XHRsZXQgcGFyZW50U2VsZWN0b3IgPSB0aGlzLnBhcmVudCEuc2VsZWN0b3JUZXh0O1xyXG5cdFx0aWYgKHRoaXMucGFyYW0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyB0aGUgXCJwYXJhbVwiIHZhbHVlIGlzIG9ubHkgc2V0IGZvciBwYXJhbWV0ZXJpemVkIHBzZXVkbyBlbnRpdGllcywgc28gd2UgY29udmVydCBpdCB0b1xyXG4gICAgICAgICAgICAvLyB0aGUgXCJmdW5jXCIgb2JqZWN0IGZvcm0uIFdlIGFsc28ga25vdyB0aGF0IHRoZSBzZWxlY3RvciBpcyBhIHN0cmluZyAtIG5hbWUgb2YgdGhlIGVudGl0eS5cclxuXHRcdFx0cmV0dXJuIGAke3BhcmVudFNlbGVjdG9yfSR7ZmRvMnMoe2ZuOiB0aGlzLnNlbGVjdG9yIGFzIHN0cmluZywgcDogdGhpcy5wYXJhbX0gYXMgSVBhcmFtZXRlcml6ZWRQc2V1ZG9FbnRpdHlGdW5jPGFueT4pfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuXHRcdHtcclxuXHRcdFx0Ly8gY29udmVydCBzZWxlY3RvciB0byBzdHJpbmcuXHJcblx0XHRcdGxldCBzZWxlY3RvciA9IHNlbGVjdG9yMnMoIHRoaXMuc2VsZWN0b3IpO1xyXG5cclxuXHRcdFx0Ly8gaWYgdGhlIHNlbGVjdG9yIHN0cmluZyBkb2Vzbid0IGhhdmUgYW55IG9jY3VycmVuY2VzIG9mIHRoZSBhbXBlcnNhbmQgc3ltYm9sLCB3ZVxyXG5cdFx0XHQvLyBzaW1wbHkgYXBwZW5kIHRoZSBzZWxlY3RvciB0byB0aGUgcGFyZW50IHNlbGVjdG9yOyBvdGhlcndpc2UsIHdlIHJlcGxhY2UgYWxsXHJcblx0XHRcdC8vIG9jY3VycmVuY2VzIG9mIHRoZSBhbXBlcnNhbmQgc3ltYm9sIGluIHRoZSBzZWxlY3RvciBzdHJpbmcgd2l0aCB0aGUgc2VsZWN0b3JcclxuXHRcdFx0Ly8gc3RyaW5nIG9mIHRoZSBwYXJlbnQgcnVsZS5cclxuXHRcdFx0cmV0dXJuIHNlbGVjdG9yLmluZGV4T2YoIFwiJlwiKSA8IDBcclxuXHRcdFx0XHQ/IGAke3BhcmVudFNlbGVjdG9yfSR7c2VsZWN0b3J9YFxyXG5cdFx0XHRcdDogc2VsZWN0b3IucmVwbGFjZSggLyYvZywgcGFyZW50U2VsZWN0b3IpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBQYXJlbnQgc3R5bGUgcnVsZSBvZiB3aGljaCB0aGlzIHJ1bGUgaXMgZGVwZW5kZW50LlxyXG5cdHB1YmxpYyBwYXJlbnQ/OiBTdHlsZVJ1bGU7XHJcblxyXG5cdC8vIFBhcnRpYWwgc2VsZWN0b3IgdGhhdCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIHBhcmVudCBzZWxlY3Rvci5cclxuXHRwcml2YXRlIHNlbGVjdG9yOiBDc3NTZWxlY3RvcjtcclxuXHJcblx0Ly8gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNlbGVjdG9yIC0gdXNlZCBmb3IgcGFyYW1ldGVyaXplZCBwc2V1ZG8gY2xhc3NlcyBhbmQgZWxlbWVudHMuXHJcblx0cHJpdmF0ZSBwYXJhbT86IGFueTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIEFic3RyYWN0UnVsZSBjbGFzcyBkZXNjcmliZXMgYSBzdHlsZXNldCB0aGF0IGNhbiBvbmx5IGJlIHVzZWQgYXMgYSBiYXNlIGZvciBvdGhlciBzdHlsZVxyXG4gKiBydWxlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFJ1bGUgZXh0ZW5kcyBTdHlsZVJ1bGVcclxue1xyXG5cdC8vIE92ZXJyaWRlcyB0aGUgU3R5bGVSdWxlJ3MgaW1wbGVtZW50YXRpb24gdG8gZG8gbm90aGluZy4gTm8gQ1NTU3R5bGVSdWxlIGlzIGNyZWF0ZWQgZm9yXHJcblx0Ly8gYWJzdHJhY3QgcnVsZXMuXHJcblx0cHVibGljIGluc2VydCggcnVsZUJhZzogSU1pbWNzc1J1bGVCYWcpOiB2b2lkIHt9XHJcblxyXG5cdC8vIE92ZXJyaWRlcyB0aGUgU3R5bGVSdWxlJ3MgaW1wbGVtZW50YXRpb24gdG8gZG8gbm90aGluZy5cclxuXHRwdWJsaWMgY2xlYXIoKTogdm9pZCB7fVxyXG5cclxuICAgIC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUuXHJcblx0cHVibGljIGdldFNlbCgpOiBzdHJpbmcgeyByZXR1cm4gXCJcIjsgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgTmFtZWRTdHlsZVJ1bGUgY2xhc3MgaXMgYSBiYXNlIGZvciBzdHlsZSBydWxlIGNsYXNzZXMgdGhhdCBhcmUgYWxzbyBuYW1lZCBlbnRpdGllcyAtIHN1Y2hcclxuICogYXMgY2xhc3MgcnVsZSBhbmQgSUQgcnVsZS5cclxuICovXHJcbmFic3RyYWN0IGNsYXNzIE5hbWVkU3R5bGVSdWxlIGV4dGVuZHMgU3R5bGVSdWxlIGltcGxlbWVudHMgSVByZWZpeGVkTmFtZWRFbnRpdHlcclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24sIHN0eWxlc2V0PzogQ29tYmluZWRTdHlsZXNldCB8IENvbWJpbmVkU3R5bGVzZXRbXSxcclxuICAgICAgICBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJTmFtZWRFbnRpdHkpXHJcblx0e1xyXG5cdFx0c3VwZXIoIHNkLCBzdHlsZXNldCk7XHJcblx0XHR0aGlzLm5hbWVPdmVycmlkZSA9IG5hbWVPdmVycmlkZTtcclxuXHR9XHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuXHRwdWJsaWMgcHJvY2VzcyggcnVsZU5hbWU6IHN0cmluZyB8IG51bGwpOiB2b2lkXHJcblx0e1xyXG5cdFx0c3VwZXIucHJvY2VzcyggcnVsZU5hbWUpO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IHRoaXMucmMuZ2V0U2NvcGVkTmFtZSggcnVsZU5hbWUsIHRoaXMubmFtZU92ZXJyaWRlKTtcclxuICAgICAgICB0aGlzLmNzc05hbWUgPSB0aGlzLnByZWZpeCArIHRoaXMubmFtZTtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUuXHJcblx0cHVibGljIGdldFNlbCgpOiBzdHJpbmdcclxuXHR7XHJcblx0XHRyZXR1cm4gdGhpcy5jc3NOYW1lO1xyXG5cdH1cclxuXHJcblx0Ly8gSW1wbGVtZW50YXRpb24gb2YgdGhlIHRvU3RyaW5nIG1ldGhvZCByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBydWxlICh3aXRob3V0IHRoZSBDU1MgcHJlZml4KS5cclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMubmFtZTtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgcHJlZml4IHRoYXQgaXMgcHV0IGJlZm9yZSB0aGUgZW50aXR5IG5hbWUgdG8gY3JlYXRlIGEgQ1NTIG5hbWUgdXNlZCBpbiBzdHlsZSBydWxlXHJcblx0Ly8gc2VsZWN0b3JzLlxyXG5cdHB1YmxpYyBwcmVmaXg6IFwiLlwiIHwgXCIjXCI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJ1bGUncyBuYW1lIC0gdGhpcyBpcyBhIHVuaXF1ZSBuYW1lIHRoYXQgaXMgYXNzaWduZWQgYnkgdGhlIE1pbWNzcyBpbmZyYXN0dWN0dXJlLiBUaGlzIG5hbWVcclxuXHQgKiBkb2Vzbid0IGhhdmUgdGhlIHByZWZpeCB0aGF0IGlzIHVzZWQgd2hlbiByZWZlcnJpbmcgdG8gY2xhc3NlcyAoLiksIElEcyAoIykgYW5kIGN1c3RvbSBDU1NcclxuXHQgKiBwcm9wZXJ0aWVzICgtLSkuXHJcblx0ICovXHJcblx0cHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogUnVsZSdzIG5hbWUgLSB0aGlzIGlzIGEgbmFtZSB0aGF0IGhhcyB0aGUgcHJlZml4IHRoYXQgaXMgdXNlZCB3aGVuIHJlZmVycmluZyB0byBjbGFzc2VzICguKSxcclxuXHQgKiBJRHMgKCMpIGFuZCBjdXN0b20gQ1NTIHByb3BlcnRpZXMgKC0tKS4gRm9yIGFuaW1hdGlvbnMsIHRoaXMgbmFtZSBpcyB0aGUgc2FtZSBhcyBpbiB0aGVcclxuXHQgKiBgbmFtZWAgcHJvcGVydHkuXHJcblx0ICovXHJcblx0cHVibGljIGNzc05hbWU6IHN0cmluZztcclxuXHJcblx0Ly8gTmFtZSBvciBuYW1lZCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgYSBuYW1lIGZvciB0aGlzIHJ1bGUuIElmIHRoaXMgcHJvcGVydHlcclxuXHQvLyBpcyBub3QgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBiZSB1bmlxdWVseSBnZW5lcmF0ZWQuXHJcblx0cHJvdGVjdGVkIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElOYW1lZEVudGl0eTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIENsYXNzUnVsZSBjbGFzcyBkZXNjcmliZXMgYSBzdHlsZXNldCB0aGF0IGFwcGxpZXMgdG8gZWxlbWVudHMgaWRlbnRpZmllZCBieSBhIENTUyBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDbGFzc1J1bGUgZXh0ZW5kcyBOYW1lZFN0eWxlUnVsZSBpbXBsZW1lbnRzIElDbGFzc1J1bGUsIElQcmVmaXhlZE5hbWVkRW50aXR5XHJcbntcclxuXHQvLyBQcmVmaXggZm9yIENTUyBjbGFzc2VzLlxyXG5cdHB1YmxpYyBwcmVmaXg6IFwiLlwiID0gXCIuXCI7XHJcblxyXG4gICAgLy8gQWxsb3dzIHRoZSBkZXJpdmVkIGNsYXNzZXMgdG8gcHJvY2VzcyBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgdGhlIFN0eWxlUnVsZSBkb2Vzbid0IGtub3cgYWJvdXQuXHJcbiAgICAvLyBJZiByZXR1cm5zIGZhbHNlLCB0aGUgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgc3R5bGVzZXQuXHJcblx0cHJvdGVjdGVkIHBhcnNlU1AoIHByb3BOYW1lOiBzdHJpbmcsIHByb3BWYWw6IGFueSk6IGJvb2xlYW5cclxuICAgIHtcclxuICAgICAgICBpZiAocHJvcE5hbWUgPT0gXCIrK1wiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IHJ1bGVzID0gcHJvcFZhbCBhcyBQYXJlbnRDbGFzc1R5cGUgfCBQYXJlbnRDbGFzc1R5cGVbXTtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRzID0gQXJyYXkuaXNBcnJheShydWxlcykgPyBydWxlcyA6IFtydWxlc107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VTUCggcHJvcE5hbWUsIHByb3BWYWwpO1xyXG4gICAgfVxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKTogdm9pZFxyXG5cdHtcclxuXHRcdHN1cGVyLnByb2Nlc3MoIHJ1bGVOYW1lKTtcclxuXHJcbiAgICAgICAgLy8gYnkgbm93IG91ciBuYW1lIGFuZCBjc3NOYW1lIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldCB0byByZWZsZWN0IGEgc2luZ2xlIG5hbWUuIE5vd1xyXG4gICAgICAgIC8vIGxvb2sgYXQgdGhlIHBhcmVudCBjbGFzcyBydWVzIGRlZmluZWQgdXNpbmcgdGhlIFwiKytcIiBwcm9wZXJ0eSBhbmQgdGFrZSBuYW1lcyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIHJlZmVyZW5jZWQgY2xhc3MgcnVsZXMgYW5kIGFwcGVuZCB0aGVtIHRvIHRoZSBuYW1lLlxyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgKz0gXCIgXCIgKyB0aGlzLnBhcmVudHMubWFwKCB2ID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA6IHYubmFtZSkuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgIHRoaXMuY3NzTmFtZSA9IFwiLlwiICsgdGhpcy5uYW1lLnJlcGxhY2UoIC8gL2csIFwiLlwiKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuICAgIC8vIHJlbWVtYmVyZWQgdmFsdWUgb2YgdGhlIFwiKytcIiBwcm9wZXJ0eSBvZiB0aGUgaW5wdXQgc3R5bGVzZXRcclxuICAgIHByaXZhdGUgcGFyZW50cz86IFBhcmVudENsYXNzVHlwZVtdO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgSURSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIHN0eWxlc2V0IHRoYXQgYXBwbGllcyB0byBlbGVtZW50cyBpZGVudGlmaWVkIGJ5IGFuIElELlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIElEUnVsZSBleHRlbmRzIE5hbWVkU3R5bGVSdWxlIGltcGxlbWVudHMgSUlEUnVsZSwgSVByZWZpeGVkTmFtZWRFbnRpdHlcclxue1xyXG5cdC8vIFByZWZpeCBmb3IgQ1NTIGVsZW1lbnQgaWRlbnRpZmllcnMuXHJcblx0cHVibGljIHByZWZpeDogXCIjXCIgPSBcIiNcIjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFNlbGVjdG9yUnVsZSB0eXBlIGRlc2NyaWJlcyBhIHN0eWxlc2V0IHRoYXQgYXBwbGllcyB0byBlbGVtZW50cyBpZGVudGlmaWVkIGJ5IGEgQ1NTIHNlbGVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yUnVsZSBleHRlbmRzIFN0eWxlUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgc2VsZWN0b3I6IENzc1NlbGVjdG9yLFxyXG4gICAgICAgIHN0eWxlc2V0PzogQ29tYmluZWRTdHlsZXNldCB8IENvbWJpbmVkU3R5bGVzZXRbXSlcclxuXHR7XHJcblx0XHRzdXBlciggc2QsIHN0eWxlc2V0KTtcclxuXHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUuXHJcblx0cHVibGljIGdldFNlbCgpOiBzdHJpbmdcclxuXHR7XHJcblx0XHRyZXR1cm4gc2VsZWN0b3IycyggdGhpcy5zZWxlY3Rvcik7XHJcblx0fVxyXG5cclxuXHQvLyBzZWxlY3RvciBvYmplY3QgZm9yIHRoaXMgcnVsZS5cclxuXHRwcml2YXRlIHNlbGVjdG9yOiBDc3NTZWxlY3RvcjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFBhZ2VSdWxlIGNsYXNzIHJlcHJlc2VudHMgdGhlIENTUyBAcGFnZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhZ2VSdWxlIGV4dGVuZHMgU3R5bGVSdWxlIGltcGxlbWVudHMgSVBhZ2VSdWxlXHJcbntcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24sIHBzZXVkb0NsYXNzPzogUGFnZVBzZXVkb0NsYXNzLCBzdHlsZT86IFN0eWxlc2V0KVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKCBzZCwgc3R5bGUpO1xyXG4gICAgICAgIHRoaXMucHNldWRvQ2xhc3MgPSBwc2V1ZG9DbGFzcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBzZWxlY3RvciBwYXJ0IG9mIHRoZSBzdHlsZSBydWxlLlxyXG4gICAgcHVibGljIGdldFNlbCgpOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYEBwYWdlICR7dGhpcy5wc2V1ZG9DbGFzcyA/IHRoaXMucHNldWRvQ2xhc3MgOiBcIlwifWA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNPTSBwYWdlIHJ1bGUgKi9cclxuICAgIHB1YmxpYyBjc3NSdWxlOiBDU1NQYWdlUnVsZTtcclxuXHJcbiAgICAvKiogT3B0aW9uYWwgbmFtZSBvZiB0aGUgcGFnZSBwc2V1ZG8gc3R5bGUgKGUuZy4gXCJcIjpmaXJzdFwiKSAqL1xyXG4gICAgcHVibGljIHBzZXVkb0NsYXNzPzogUGFnZVBzZXVkb0NsYXNzO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBNZXJnZXMgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugc3R5bGVzZXQgdG8gdGhlIHRhcmdldCBzdHlsZXNldC4gQWxsIHJlZ3VsYXIgcHJvcGVydGllcyBhcmVcclxuICogcmVwbGFjZWQuIFRoZSBcIi0tXCIgcHJvcGVydHkgZ2V0cyBzcGVjaWFsIHRyZWF0bWVudCBiZWNhdXNlIGl0IGlzIGFuIGFycmF5LlxyXG4gKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBTdHlsZXNldCBvYmplY3QgLSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQ7XHJcbiAqIEBwYXJhbSBzb3VyY2UgU291cmNlIFN0eWxlc2V0IG9iamVjdCAtIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cclxuICogQHBhcmFtIHNvdXJjZVxyXG4gKi9cclxuY29uc3QgbWVyZ2VTdHlsZXNldHMgPSAodGFyZ2V0OiBTdHlsZXNldCwgc291cmNlOiBTdHlsZXNldCk6IHZvaWQgPT5cclxue1xyXG4gICAgLy8gY29weSBhbGwgb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2VcclxuICAgIGlmIChPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCA9PT0gMClcclxuICAgICAgICBPYmplY3QuYXNzaWduKCB0YXJnZXQsIHNvdXJjZSk7XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZm9yKCBsZXQgcHJvcE5hbWUgaW4gc291cmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcIi0tXCIpXHJcbiAgICAgICAgICAgICAgICBtZXJnZUN1c3RvbVByb3BzKCB0YXJnZXQsIHNvdXJjZVtwcm9wTmFtZV0hKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbWVyZ2VQcm9wVmFsdWVzKCB0YXJnZXQsIHByb3BOYW1lLCBzb3VyY2VbcHJvcE5hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyBcIi0tXCIgcHJvcGVydHkgZnJvbSB0aGUgc291cmNlIHN0eWxlc2V0IHRvIHRoZSB0YXJnZXQgc3R5bGVzZXQuXHJcbiAqL1xyXG5jb25zdCBtZXJnZUN1c3RvbVByb3BzID0gKHRhcmdldDogU3R5bGVzZXQsIHNvdXJjZVZhcnM6IEN1c3RvbVZhcl9TdHlsZVR5cGVbXSk6IHZvaWQgPT5cclxue1xyXG4gICAgbGV0IHRhcmdldFZhcnMgPSB0YXJnZXRbXCItLVwiXTtcclxuICAgIHRhcmdldFtcIi0tXCJdID0gIXRhcmdldFZhcnMgPyBzb3VyY2VWYXJzLnNsaWNlKCkgOiB0YXJnZXRWYXJzLmNvbmNhdCggc291cmNlVmFycyk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogTWVyZ2VzIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgZnJvbSB0aGUgc291cmNlIHN0eWxlc2V0IHRvIHRoZSB0YXJnZXQgc3R5bGVzZXQuIE5vdGUgdGhhdFxyXG4gKiBib3RoIHNvdXJjZSBvciB0YXJnZXQgdmFsdWUgY2FuIGJlIGVpdGhlciBzaW5nbGUgdmFsdWUgb3IgYW4gb2JqZWN0IHdpdGggdGhlIGBcIltdXCJgIHByb3BlcnR5XHJcbiAqIHRoYXQgY29udGFpbnMgbXVsdGlwbGUgdmFsdWVzLlxyXG4gKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBTdHlsZXNldCBvYmplY3QgLSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAqIEBwYXJhbSBwcm9wTmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cclxuICogQHBhcmFtIHNvdXJjZVZhbCBWYWx1ZSBmcm9tIHRoZSBzb3VyY2Ugc3R5bGVzZXQgdG8gbWVyZ2Ugd2l0aCB0aGUgdGFyZ2V0IHZhbHVlIC0gY2Fubm90IGJlIG51bGxcclxuICogb3IgdW5kZWZpbmVkLlxyXG4gKi9cclxuY29uc3QgbWVyZ2VQcm9wVmFsdWVzID0gKHRhcmdldDogU3R5bGVzZXQsIHByb3BOYW1lOiBzdHJpbmcsIHNvdXJjZVZhbDogYW55KTogdm9pZCA9PlxyXG57XHJcbiAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W3Byb3BOYW1lXTtcclxuICAgIGlmICh0YXJnZXRWYWwgPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICAvLyBpZiBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgb3IgaXRzIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBqdXN0XHJcbiAgICAgICAgLy8gdGFrZSB0aGUgc291cmNlJ3MgdmFsdWVcclxuICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0gc291cmNlVmFsO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGxldCB0YXJnZXRBcnJheTogYW55W10gPSB0YXJnZXRWYWxbXCJbXVwiXTtcclxuICAgICAgICBpZiAoIXRhcmdldEFycmF5KVxyXG4gICAgICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0geyBcIltdXCI6IHRhcmdldEFycmF5ID0gW3RhcmdldFZhbF0gfTtcclxuXHJcbiAgICAgICAgbGV0IHNvdXJjZUFycmF5OiBhbnlbXSA9IHNvdXJjZVZhbFtcIltdXCJdO1xyXG4gICAgICAgIGlmICghc291cmNlQXJyYXkpXHJcbiAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2goIHNvdXJjZVZhbCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKCAuLi5zb3VyY2VBcnJheSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4iLCJpbXBvcnQge0lWYXJSdWxlLCBJQ29uc3RSdWxlLCBJU3R5bGVEZWZpbml0aW9ufSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiXHJcbmltcG9ydCB7VmFyVGVtcGxhdGVOYW1lLCBFeHRlbmRlZFZhclZhbHVlLCBJU3ludGF4VHlwZVN0eWxlc2V0fSBmcm9tIFwiLi4vYXBpL1N0eWxlc2V0c1wiXHJcbmltcG9ydCB7c3Ayc30gZnJvbSBcIi4uL2ltcGwvU3R5bGVJbXBsXCJcclxuaW1wb3J0IHtJTWltY3NzUnVsZUJhZywgUnVsZSwgUnVsZUxpa2V9IGZyb20gXCIuL1J1bGVcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBWYXJCYXNlUnVsZSBjbGFzcyBjb250YWlucyBmdW5jdGlvbmFsaXR5IGNvbW1vbiBmb3IgVmFyUnVsZSBjbGFzcyBkZXNjcmliaW5nIGEgY3VzdG9tIENTU1xyXG4gKiBwcm9wZXJ0eSBkZWZpbml0aW9uIGluIHRoZSBgOnJvb3RgIHJ1bGUgYW5kIGZvciBQcm9wZXJ0eVJ1bGUgY2xhc3MgZGVzY3JpYmluZyB0aGUgYEBwcm9wZXJ0eWBcclxuICogYXQtcnVsZS5cclxuICovXHJcbmFic3RyYWN0IGNsYXNzIFZhckJhc2VSdWxlPEsgZXh0ZW5kcyBWYXJUZW1wbGF0ZU5hbWUgPSBhbnk+IGV4dGVuZHMgUnVsZSBpbXBsZW1lbnRzIElWYXJSdWxlPEs+XHJcbntcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24sIHRlbXBsYXRlOiBLLCB2YWx1ZT86IEV4dGVuZGVkVmFyVmFsdWU8Sz4sIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElWYXJSdWxlPEs+KVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKHNkKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMubmFtZU92ZXJyaWRlID0gbmFtZU92ZXJyaWRlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGlzIHNwZWNpZmllZCBhcyBhIHZhbHVlIG9mIGEgc3R5bGUgcHJvcGVydHkuXHJcbiAgICAvLyBXZSByZXR1cm4gdGhlIHZhcigtLW5hbWUpIGV4cHJlc3Npb24uXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGB2YXIoJHt0aGlzLmNzc05hbWV9KWA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBydWxlLlxyXG4gICAgcHVibGljIHByb2Nlc3MoIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKTogdm9pZFxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMucmMuZ2V0U2NvcGVkTmFtZSggcnVsZU5hbWUsIHRoaXMubmFtZU92ZXJyaWRlKTtcclxuICAgICAgICB0aGlzLmNzc05hbWUgPSBcIi0tXCIgKyB0aGlzLm5hbWU7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFZhbHVlKCk6IEV4dGVuZGVkVmFyVmFsdWU8Sz5cclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG5ldyB2YWx1ZSBvZiB0aGlzIGN1c3RvbSBDU1MgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGUgQ1NTIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIHNjaGVkdWxlclR5cGUgSUQgb2YgYSByZWdpc3RlcmVkIHNjaGVkdWxlciB0eXBlIHRoYXQgaXMgdXNlZCB0byB3cml0ZSB0aGUgcHJvcGVydHlcclxuICAgICAqIHZhbHVlIHRvIHRoZSBET00uIElmIHVuZGVmaW5lZCwgdGhlIGN1cnJlbnQgZGVmYXVsdCBzY2hlZHVsZXIgd2lsbCBiZSB1c2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VmFsdWUoIHZhbHVlOiBFeHRlbmRlZFZhclZhbHVlPEs+LCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5yYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBpbXBvcnRhbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiIVwiIGluICh2YWx1ZSBhcyBhbnkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtcIiFcIl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmMuc2V0VmFyVmFsdWUoIHRoaXMuY3NzTmFtZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlID09IG51bGxcclxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgICAgICAgICA6IHNwMnMoIHRoaXMudGVtcGxhdGUsIHZhbHVlKSwgaW1wb3J0YW50LCBzY2hlZHVsZXJUeXBlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8vIE5hbWUgb2YgYSBub24tY3VzdG9tIENTUyBwcm9wZXJ0eSB3aG9zZSB0eXBlIGRldGVybWluZXMgdGhlIHR5cGUgb2YgdGhlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgIHB1YmxpYyB0ZW1wbGF0ZTogSztcclxuXHJcblx0Ly8gUHJlZml4IGZvciBDU1MgY2xhc3Nlcy5cclxuXHRwdWJsaWMgcHJlZml4OiBcIi0tXCIgPSBcIi0tXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdWxlJ3MgbmFtZSAtIHRoaXMgaXMgYSB1bmlxdWUgbmFtZSB0aGF0IGlzIGFzc2lnbmVkIGJ5IHRoZSBNaW1jc3MgaW5mcmFzdHVjdHVyZS4gVGhpcyBuYW1lXHJcbiAgICAgKiBkb2Vzbid0IGhhdmUgdGhlIHByZWZpeCB0aGF0IGlzIHVzZWQgd2hlbiByZWZlcnJpbmcgdG8gY2xhc3NlcyAoLiksIElEcyAoIykgYW5kIGN1c3RvbSBDU1NcclxuICAgICAqIHByb3BlcnRpZXMgKC0tKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1c3RvbSBDU1MgcHJvcGVydHkgbmFtZSBwcmVmaXhlZCB3aXRoIGBcIi0tXCJgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3NzTmFtZTogc3RyaW5nO1xyXG5cclxuICAgIC8vIFZhbHVlIG9mIHRoZSBjdXN0b20gQ1NTIHByb3BlcnR5LlxyXG4gICAgcHJvdGVjdGVkIHZhbHVlPzogRXh0ZW5kZWRWYXJWYWx1ZTxLPjtcclxuXHJcbiAgICAvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG4gICAgLy8gaXMgbm90IGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgYmUgdW5pcXVlbHkgZ2VuZXJhdGVkLlxyXG4gICAgcHJvdGVjdGVkIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElWYXJSdWxlPEs+O1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgVmFyUnVsZSBjbGFzcyBkZXNjcmliZXMgYSBjdXN0b20gQ1NTIHByb3BlcnR5LiBWYXJSdWxlIGlzIG5vdCBhIHJlYWwgQ1NTIHJ1bGU7IGhvd2V2ZXIsIGluXHJcbiAqIG1hbnkgYXNwZWN0cyBpdCByZXBlYXRzIHRoZSBSdWxlJ3MgZnVuY3Rpb25hbGl0eS4gSW4gcGFydGljdWxhciBpdCBoYXMgdGhlIHByb2Nlc3MgZnVuY3Rpb24gdGhhdFxyXG4gKiBhbGxvd3MgaXQgdG8gb2J0YWluIGFuIGFjdHVhbCBuYW1lLCB3aGljaCB3aWxsIGJlIHVzZWQgd2hlbiBkZWZpbmluZyBhbmQgdXNpbmcgdGhpcyBjdXN0b21cclxuICogcHJvcGVydHkgaW4gQ1NTLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFZhclJ1bGU8SyBleHRlbmRzIFZhclRlbXBsYXRlTmFtZSA9IGFueT4gZXh0ZW5kcyBWYXJCYXNlUnVsZTxLPlxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgdGVtcGxhdGU6IEssIHZhbHVlPzogRXh0ZW5kZWRWYXJWYWx1ZTxLPixcclxuICAgICAgICBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJVmFyUnVsZTxLPilcclxuXHR7XHJcbiAgICAgICAgc3VwZXIoIHNkLCB0ZW1wbGF0ZSwgdmFsdWUsIG5hbWVPdmVycmlkZSk7XHJcblx0fVxyXG5cclxuXHJcbiAgICAvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuICAgIC8vIHN0eWxlIGRlZmluaXRpb24gY2xhc3MsIHRvIHdoaWNoIHRoaXMgcnVsZSBiZWxvbmdzLCBpcyBhY3RpdmF0ZWQuXHJcbiAgICBwdWJsaWMgaW5zZXJ0KCBydWxlQmFnOiBJTWltY3NzUnVsZUJhZyk6IHZvaWQge31cclxuXHJcblxyXG5cclxuXHQvLyBDb252ZXJ0cyB0aGUgcnVsZSB0byBDU1Mgc3RyaW5nLlxyXG5cdHB1YmxpYyB0b0NzcygpOiBzdHJpbmcgfCBudWxsXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgPT0gbnVsbCA/IG51bGwgOiBgJHt0aGlzLmNzc05hbWV9OiAke3NwMnMoIHRoaXMudGVtcGxhdGUsIHRoaXMudmFsdWUpfWA7XHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUHJvcGVydHlSdWxlIGNsYXNzIGRlc2NyaWJlcyB0aGUgYEBwcm9wZXJ0eWAgYXQtcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eVJ1bGU8SyBleHRlbmRzIGtleW9mIElTeW50YXhUeXBlU3R5bGVzZXQgPSBhbnksIFQgZXh0ZW5kcyBLIHwgW3N0cmluZ10gPSBhbnk+IGV4dGVuZHMgVmFyQmFzZVJ1bGU8Sz5cclxue1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgc3ludGF4OiBULCBpbml0VmFsdWU/OiBFeHRlbmRlZFZhclZhbHVlPEs+LCBpbmhlcml0czogYm9vbGVhbiA9IHRydWUsXHJcbiAgICAgICAgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSVZhclJ1bGU8Sz4pXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3ludGF4KSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN1cGVyKCBzZCwgXCIqXCIgYXMgSywgaW5pdFZhbHVlLCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3VwZXIoIHNkLCBzeW50YXggYXMgSywgaW5pdFZhbHVlLCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5oZXJpdHMgPSBpbmhlcml0cztcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuXHQvLyBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLCB0byB3aGljaCB0aGlzIHJ1bGUgYmVsb25ncywgaXMgYWN0aXZhdGVkLlxyXG5cdHB1YmxpYyBpbnNlcnQoIHJ1bGVCYWc6IElNaW1jc3NSdWxlQmFnKTogdm9pZFxyXG4gICAge1xyXG5cdFx0bGV0IHJ1bGVUZXh0ID0gYEBwcm9wZXJ0eSAke3RoaXMuY3NzTmFtZX17c3ludGF4Oicke3RoaXMuc3ludGF4fSc7YCArXHJcbiAgICAgICAgICAgIGBpbmhlcml0czoke3RoaXMuaW5oZXJpdHN9O2luaXRpYWwtdmFsdWU6JHtzcDJzKCB0aGlzLnRlbXBsYXRlLCB0aGlzLnZhbHVlKX07fWA7XHJcblxyXG4gICAgICAgIHRoaXMuY3NzUnVsZSA9IHJ1bGVCYWcuYWRkKCBydWxlVGV4dCk/LmNzc1J1bGUgYXMgQ1NTUnVsZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgY3VzdG9tIHByb3BlcnR5IHJlZ2lzdHJhdGlvbiBpbmhlcml0cyBieSBkZWZhdWx0LlxyXG5cdHByaXZhdGUgc3ludGF4OiBzdHJpbmc7XHJcblxyXG5cdC8vIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjdXN0b20gcHJvcGVydHkgcmVnaXN0cmF0aW9uIGluaGVyaXRzIGJ5IGRlZmF1bHQuXHJcblx0cHJpdmF0ZSBpbmhlcml0czogYm9vbGVhbjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIElDb25zdFJ1bGUgaW50ZXJmYWNlIHJlcHJlc2VudHMgYSBcImNvbnN0YW50XCIgdGhhdCBjYW4gYmUgdXNlZCBhbnl3aGVyZSB0aGUgdHlwZSBkZWZpbmVkIGJ5XHJcbiAqIHRoZSBgdGVtcGxhdGVgIHBhcmFtZXRlciBjYW4gYmUgdXNlZC4gVGhlc2UgYXJlIGNhbGxlZCBjb25zdGFudHMsIGJlY2F1c2UgdGhleSBwcm92aWRlIHRoZVxyXG4gKiBjb252ZW5pZW50IGFuZCBsaWdodHdlaWdodCB3YXkgb2YgZGVmaW5pbmcgdmFsdWVzIHRoYXQgYXJlIHVuY2hhbmdlZCBkdXJpbmcgdGhlIGFwcGxpY2F0aW9uXHJcbiAqIGxpZmV0aW1lLiBBbHRob3VnaCBjb25zdGFudHMgYXJlIGRlZmluZWQgdmVyeSBzaW1pbGFybHkgdG8gY3VzdG9tIHByb3BlcnRpZXMgKHNlZSB0aGVcclxuICogW1tJVmFyUnVsZV1dIGZ1bmN0aW9uKSwgdGhleSBjYW5ub3QgcGFydGljaXBhdGUgaW4gdGhlIGNhc2NhZGUgYW5kIGNhbm5vdCBiZSByZWRlZmluZWQgdW5kZXJcclxuICogZWxlbWVudHMuIENvbnN0YW50IGNhbiwgaG93ZXZlciwgdXNlIGFueSBleHByZXNzaW9uIHRoYXQgc2F0aXNmaWVzIHRoZSB0eXBlIGRlZmluZWQgYnkgdGhlXHJcbiAqIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIGluY2x1ZGluZyBvdGhlciBjb25zdGFudHMsIGN1c3RvbSBwcm9wZXJ0aWVzIGFuZCBmdW5jdGlvbnMuXHJcbiAqIE9iamVjdHMgaW1wbGVtZW50aW5nIHRoaXMgaW50ZXJmYWNlIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBbWyRjb25zdF1dIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbnN0UnVsZTxLIGV4dGVuZHMgVmFyVGVtcGxhdGVOYW1lID0gYW55PiBleHRlbmRzIFJ1bGVMaWtlIGltcGxlbWVudHMgSUNvbnN0UnVsZTxLPlxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZDogSVN0eWxlRGVmaW5pdGlvbiwgdGVtcGxhdGU6IEssIHZhbHVlPzogRXh0ZW5kZWRWYXJWYWx1ZTxLPilcclxuXHR7XHJcbiAgICAgICAgc3VwZXIoc2QpO1xyXG5cdFx0dGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMucyA9IHNwMnMoIHRlbXBsYXRlLCB2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGlzIHNwZWNpZmllZCBhcyBhIHZhbHVlIG9mIGEgc3R5bGUgcHJvcGVydHkuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuczsgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcblx0ICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxyXG5cdCAqL1xyXG4gICAgcHVibGljIGdldFZhbHVlKCk6IEV4dGVuZGVkVmFyVmFsdWU8Sz5cclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBOYW1lIG9mIGEgbm9uLWN1c3RvbSBDU1MgcHJvcGVydHkgd2hvc2UgdHlwZSBkZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRoZSBjdXN0b20gcHJvcGVydHkgdmFsdWUuXHJcblx0cHVibGljIHRlbXBsYXRlOiBLO1xyXG5cclxuXHQvLyBDb25zdGFudCdzIHZhbHVlIGFzIGEgc3RyaW5nLlxyXG5cdHByaXZhdGUgdmFsdWU/OiBFeHRlbmRlZFZhclZhbHVlPEs+O1xyXG5cclxuXHQvLyBDb25zdGFudCdzIHZhbHVlIGFzIGEgc3RyaW5nLlxyXG5cdHByaXZhdGUgczogc3RyaW5nO1xyXG59XHJcblxyXG5cclxuXHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gVHlwZSBkZWZpbml0aW9ucyBmb3IgbWltY3NzXHJcblxyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvQ29yZVR5cGVzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9OdW1lcmljVHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL0NvbG9yVHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL1NoYXBlVHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL0ZvbnRUeXBlc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvTWVkaWFUeXBlc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvUnVsZVR5cGVzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9TY2hlZHVsaW5nVHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL1N0eWxlVHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL1N0eWxlc2V0c1wiO1xyXG5cclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL0NvcmVBUElcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL051bWVyaWNBUElcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL0NvbG9yQVBJXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9TaGFwZUFQSVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvUnVsZUFQSVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvU2NoZWR1bGluZ0FQSVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvU3R5bGVBUElcIjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==