(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["mimcss"] = factory();
	else
		root["mimcss"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/api/ColorAPI.js":
/*!*****************************!*\
  !*** ./lib/api/ColorAPI.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Colors": () => (/* binding */ Colors),
/* harmony export */   "registerColor": () => (/* binding */ registerColor),
/* harmony export */   "rgb": () => (/* binding */ rgb),
/* harmony export */   "hsl": () => (/* binding */ hsl),
/* harmony export */   "lab": () => (/* binding */ lab),
/* harmony export */   "lch": () => (/* binding */ lch),
/* harmony export */   "colorContrast": () => (/* binding */ colorContrast),
/* harmony export */   "colorMix": () => (/* binding */ colorMix),
/* harmony export */   "alpha": () => (/* binding */ alpha)
/* harmony export */ });
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");

/**
 * Object whose property names are the well-known Web color names while values correspond to the
 * hexadecimal representation of the RGB separations (without an alpha mask). The properties of
 * this object can be used wherever the [[CssColor]] type can be used. Since the properties are
 * of the `number` type, they can be used for manipulating the color value.
*/
const Colors = {
    black: 0x000000,
    silver: 0xc0c0c0,
    gray: 0x808080,
    white: 0xffffff,
    maroon: 0x800000,
    red: 0xff0000,
    purple: 0x800080,
    fuchsia: 0xff00ff,
    green: 0x008000,
    lime: 0x00ff00,
    olive: 0x808000,
    yellow: 0xffff00,
    navy: 0x000080,
    blue: 0x0000ff,
    teal: 0x008080,
    aqua: 0x00ffff,
    orange: 0xffa500,
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    blanchedalmond: 0xffebcd,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    oldlace: 0xfdf5e6,
    olivedrab: 0x6b8e23,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    whitesmoke: 0xf5f5f5,
    yellowgreen: 0x9acd32,
    rebeccapurple: 0x663399,
};
/**
 * Object where we keep the registered custom colors. We need it to determine whether the color
 * is a standard or a custom one.
 */
const customColors = {};
/**
 * Registers a new custom color or changes the value of the existing custom color. The name of the
 * custom color should have been already added to the [[INamedColors]] interface using the module
 * augmentation technique. Note that values of standard Web colors cannot be changed.
 *
 * @param name Color name. This name cannot be a name of the standard Web color.
 * @param value Color value to assign to the given named color.
 * @returns Flag indicating whether the operation was successful.
 */
const registerColor = (name, value) => {
    if (!name || value == null)
        return false;
    // try to retrieve this name from the CustomColors object. Non-undefined value means that
    // we already have this color registered.
    let customValue = customColors[name];
    // if the color name already exists in the Colors object we will only allow changing its
    // value if this is a custom color.
    if (name in Colors && customValue != null)
        return false;
    // add the value to the Colors and CustomColors objects
    Colors[name] = value;
    customColors[name] = value;
    return true;
};
/**
 * Converts color value from the numeric representation to the CSS color string.
 */
let colorNumber2s = (val) => {
    // if the number is negative, remember that fact and get the positive number
    let isNegative = val < 0;
    let n = isNegative ? -val : val;
    // if the number has a floating point part, separate it into alpha channel
    let a = 0;
    if (!Number.isInteger(n)) {
        let k = Math.floor(n);
        // a = Math.round( (n - k) * 100);
        a = Math.round((n - k) * 255);
        n = k;
    }
    // If the number was negative we revert the color by negating all the bits. In any case,
    // we clear everything beyond the first three bytes.
    n = isNegative ? ~(0xFF000000 | n) : 0x00FFFFFF & n;
    let s = "#" + n.toString(16).padStart(6, "0");
    return a ? s + a.toString(16).padStart(2, "0") : s;
};
/**
 * Converts color style value to the CSS string. We convert numeric values to the #RRGGBBAA
 * representation. If a string value is a custom color added via INamedColors module
 * augmentation we get its number from the `custmColors` object and also convert it to the
 * #RRGGBBAA representation. Standard named colors as well as are returned as is.
 */
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[11] = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    str: v => v in customColors ? colorNumber2s(customColors[v]) : v,
    num: colorNumber2s
});
/**
 * Converts color style value to the CSS string. We convert numeric values to the #RRGGBBAA
 * representation. If a string value is a custom color added via INamedColors module
 * augmentation we get its number from the `custmColors` object and also convert it to the
 * #RRGGBBAA representation. Standard named colors as well as are returned as is.
 */
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[30] = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { any: 11 /* Color */ });
/**
 * Converts the color separation value to a CSS string.
 */
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[28] = (c) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(c, {
    num: c => {
        c = c < 0 ? -c : c;
        return (c === 0 || c >= 1) ? "" + c : (Math.round(c * 100) + "%");
    }
});
/**
 * Converts the color specified as red, green, blue separation values and an optional alpha
 * mask to a CSS color representation. Each color separation can be represented as a number with
 * the following meaning:
 *   - Integer number -255 to 255. Numbers beyond this range will be clamped. Negative numbers
 *     will be inverted.
 *   - Floating number -1.0 to 1.0 non-inclusive, which is multiplied by 100 treated as percentage.
 *     Floating numbers beyond this range will be rounded and treated as integer numbers. Negative
 *     numbers will be inverted.
 *
 * The alpha mask can be one of the following:
 *   - Floating number 0 to 1 inclusive.
 *   - Integer or floating number 1 to 100, which is divided by 100. Floating numbers will be
 *     rounded. Numbers beyond this range will be clamped.
 *   - The sign of alpha is ignored; that is, only the absolute value is considered.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb()
 *
 * @param r Red separation value.
 * @param g Green separation value.
 * @param b Blue separation value.
 * @param a Optional alpha mask as a percentage value.
 * @return The `IRgbFunc` object representing the invocation of the `rgb()` CSS function
 */
const rgb = (r, g, b, a) => {
    return { fn: "rgb", r, g, b, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rgb = {
    p: [["r", 28 /* ColorSeparation */], ["g", 28 /* ColorSeparation */], ["b", 28 /* ColorSeparation */], ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Converts the color specified as hue-saturation-lightness components and an optional alpha
 * mask to a CSS color representation. This method should be used when defining CSS color
 * values in styleset properties.
 *
 * The Hue component is treated as the CSS `<angle>` type. Numbers are considered degrees.
 *
 * The Saturation and Lightness components are treated as percentages:
 *   - The sign is ignored; that is, only the absolute value is considered.
 *   - Floating number 0 to 1 inclusive are multiplied by 100 and treated as percentage.
 *   - Integer or floating number 1 to 100 are treated as percentage. Floating numbers will be
 *     rounded. Numbers beyond this range will be clamped to 100.
 *
 * The alpha mask can be one of the following:
 *   - Floating number 0 to 1 inclusive.
 *   - Integer or floating number 1 to 100, which is divided by 100. Floating numbers will be
 *     rounded. Numbers beyond this range will be clamped.
 *   - The sign of alpha is ignored; that is, only the absolute value is considered.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl()
 *
 * @param h Hue component as an angle value.
 * @param s Saturation component as a percentage value.
 * @param l Lightness component as a percentage value.
 * @param a Optional alpha mask as a percentage value.
 * @return The `IHslFunc` object representing the invocation of the `hsl()` CSS function
 */
const hsl = (h, s, l, a) => {
    return { fn: "hsl", h, s, l, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.hsl = {
    p: [["h", 4 /* Angle */], ["s", 2 /* Percent */], ["l", 2 /* Percent */], ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Converts the color specified as L\*a\*b\* components and an optional alpha
 * mask to a CSS color representation. This method should be used when defining CSS color
 * values in styleset properties.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lab()
 *
 * @param l CIE Lightness component
 * @param da Distance along the a axis in the Lab colorspace
 * @param db Distance along the b axis in the Lab colorspace
 * @param a Optional alpha mask as a percentage value.
 * @returns The `ILabFunc` object representing the invocation of the `lab()` CSS function
 */
const lab = (l, da, db, a) => {
    return { fn: "lab", l, da, db, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.lab = {
    p: [["l", 27 /* AlwaysPercent */], "da", "db", ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Converts the color specified as lightness-chroma-hue components and an optional alpha
 * mask to a CSS color representation. This method should be used when defining CSS color
 * values in styleset properties.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lch()
 *
 * @param l CIE Lightness component
 * @param c Chroma component
 * @param h Hue component as an angle value.
 * @param a Optional alpha mask as a percentage value.
 * @returns The `ILchFunc` object representing the invocation of the `lch()` CSS function
 */
const lch = (l, c, h, a) => {
    return { fn: "lch", l, c, h, a };
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.lch = {
    p: [["l", 27 /* AlwaysPercent */], "c", ["h", 4 /* Angle */], ["a", 2 /* Percent */, "/"]],
    s: " "
};
/**
 * Implements the `color-contrast()` CSS property.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-contrast()
 *
 * @param c Color to which the list of colors in the `vs` property will be compared
 * @param vs List of colors from which to select the most contrasting to the base color.
 * @returns The `IColorContrastFunc` object representing the invocation of the `color-contrast()`
 * CSS function
 */
const colorContrast = (c, ...vs) => ({ fn: "color-contrast", c, vs });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["color-contrast"] = {
    p: [
        ["c", (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, 11 /* Color */) + " vs"],
        ["vs", (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v, 11 /* Color */, ",")]
    ],
    s: " "
};
/**
 * Represents an invocation of the CSS `color-mix()` function. This interface is returned from the
 * [[colorMix]] function. Developers can use this structure wherever [[CssColor]] is accepted.
 */
class ColorMixFunc {
    constructor(c, p) {
        this.fn = "color-mix";
        this.c1 = [c, p];
    }
    with(c, p) { this.c2 = [c, p]; return this; }
    in(cs) { this.cs = cs; return this; }
}
/**
 * Implements the `color-mix()` CSS property.
 *
 * - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-nix()
 *
 * **Examples**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefnition
 * {
 *     // color-mix( "blue", "red")
 *     cls1 = this.$class({
 *         color: css.colorMix("blue").with("red");
 *     })
 *
 *     // color-mix( in srgb, "blue 30%", "red" 60%)
 *     cls2 = this.$class({
 *         color: css.colorMix("blue", 30).with("red", 60).in("srgb");
 *     })
 * }
 * ```
 *
 * @param cs Color space. Default is "lch".
 * @returns The `IColorMixBuilder` object that allows adding colors and optional percentages to mix
 */
const colorMix = (c, p) => new ColorMixFunc(c, p);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["color-mix"] = [
    ["cs", (v) => v ? "in " + (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v) : ""],
    ["c1", v => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[v[0], 11 /* Color */], [v[1], 2 /* Percent */]])],
    ["c2", v => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[v[0], 11 /* Color */], [v[1], 2 /* Percent */]])],
];
/**
 * Converts the given color and the alpha mask to the CSS Color representation. This
 * method should be used when defining CSS color values in styleset properties.
 *
 * The color can be specified as a numeric value or as a color name from the [[INamedColors]]
 * interface - including colors added using the module augmentation technique.
 *
 * The alpha mask is specified as a number:
 *   - The sign is ignored; that is, only the absolute value is considered.
 *   - Number 0 to 1 inclusive, which is treated as percentage.
 *   - Number 1 to 100 inclusive, which is treated as percentage.
 *   - Numbers greater than 100 are clamped to 100;
 *
 * **Examples**
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     // applying alpha to a numeric color
 *     cls1 = this.$class({ color: css.alpha( 0xAA00AA, 0.5) })
 *
 *     // applying alpha to a named color
 *     cls1 = this.$class({ color: css.alpha( "darkolivegreen", 0.5) })
 * }
 * ```
 * @param c Color value as either a number or a named color
 * @param a Alpha channel value
 */
const alpha = (c, a) => ({ fn: "alpha", c, a });
const alpha2s = (c, a) => {
    // if the alpha is 0, return transparent color
    if (a === 0)
        return "#0000";
    // convert color to numeric value (if it's not a number yet). If the color was given as a
    // string that we cannot find in the Colors object, return pure white.
    let n = typeof c === "string" ? Colors[c] : c;
    if (n == null)
        return "#FFF";
    // negative and positive values of alpha are treated identically, so convert to positive
    if (a < 0)
        a = -a;
    // convert alpha to a number with absolute value less than 1 (if it is not yet). If alpha
    // is 1 or 100, then set it to 0 because 0 in the colorNumberToString means "no alpha".
    a = a === 1 || a >= 100 ? 0 : a > 1 ? a / 100 : a;
    // make the new alpha
    return colorNumber2s(n >= 0 ? n + a : n - a);
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.alpha = (v) => alpha2s(v.c, v.a);


/***/ }),

/***/ "./lib/api/ColorTypes.js":
/*!*******************************!*\
  !*** ./lib/api/ColorTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/CoreAPI.js":
/*!****************************!*\
  !*** ./lib/api/CoreAPI.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selector": () => (/* binding */ selector),
/* harmony export */   "sel": () => (/* binding */ sel),
/* harmony export */   "steps": () => (/* binding */ steps),
/* harmony export */   "cubicBezier": () => (/* binding */ cubicBezier),
/* harmony export */   "raw": () => (/* binding */ raw),
/* harmony export */   "url": () => (/* binding */ url),
/* harmony export */   "cursor": () => (/* binding */ cursor),
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "counter": () => (/* binding */ counter),
/* harmony export */   "counters": () => (/* binding */ counters),
/* harmony export */   "usevar": () => (/* binding */ usevar)
/* harmony export */ });
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Selector functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns a string representation of a selector. This function is a tag function and must be
 * invoked with the template string without parentheses. This function can be used wherever the
 * [[CssSelector]] types are allowed. The parameters embedded into the string
 * must conform to the [[CssSelector]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     // css: ul > li {...}
 *     s1 = this.$style( css.selector`ul > li`, {...})
 *
 *     // css: ul.c1:hover {...}
 *     c1 = this.$class({...})
 *     s2 = this.$style( css.selector`ul.${this.c1}:hover`, {...})
 * }
 * ```
 */
const selector = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.tag2s)(parts, params);
/**
 * Array of attribute comparison operation strings - needed to check whether a string is an
 * attribute comparison operation.
 */
const attrComparisonOperations = ["=", "~=", "|=", "^=", "$=", "*="];
/**
 * Array of combinator symbols - needed to check whether a string is a combinator.
 */
const selectorCombinators = [",", " ", ">", "+", "~", "||"];
// SelectorProcessingInfo object that used several times, so it is "cached" here
const pseudoClassWithSelectorsInfo = { f: wrapAndAddSelectors, a: [","], p: ":" };
/**
 * Object containing information about how properties and methods of the ISelectorBuilder interface
 * should be converted to CssSelector values. If a name of the property is not in this object, it
 * is treated as a non-parameterized pseudo class.
 */
const selectorInfos = {
    // helper methods
    "attr": addAttrSelector,
    "and": { f: addSelectorsWithCombinators, a: [""] },
    "or": { f: addSelectorsWithCombinators, a: [","] },
    "child": { f: addSelectorsWithCombinators, a: [">"] },
    "desc": { f: addSelectorsWithCombinators, a: [" "] },
    "sib": { f: addSelectorsWithCombinators, a: ["~"] },
    "adj": { f: addSelectorsWithCombinators, a: ["+"] },
    // simple pseudo elements
    "after": 1 /* SimplePseudoElement */,
    "backdrop": 1 /* SimplePseudoElement */,
    "before": 1 /* SimplePseudoElement */,
    "cue": 1 /* SimplePseudoElement */,
    "firstLetter": 1 /* SimplePseudoElement */,
    "firstLine": 1 /* SimplePseudoElement */,
    "grammarError": 1 /* SimplePseudoElement */,
    "marker": 1 /* SimplePseudoElement */,
    "placeholder": 1 /* SimplePseudoElement */,
    "selection": 1 /* SimplePseudoElement */,
    "spellingError": 1 /* SimplePseudoElement */,
    // parameterized pseudo classes
    "dir": 2 /* ParameterizedPseudoClass */,
    // "has": pseudoClassWithSelectorsInfo,
    "host$": { f: wrapAndAddSelectors, a: [","], p: ":", n: ":host" },
    "hostContext": pseudoClassWithSelectorsInfo,
    "is": pseudoClassWithSelectorsInfo,
    "lang": 2 /* ParameterizedPseudoClass */,
    "not": pseudoClassWithSelectorsInfo,
    "nthChild": addNthPseudoClass,
    "nthLastChild": addNthPseudoClass,
    "nthOfType": addNthPseudoClass,
    "nthLastOfType": addNthPseudoClass,
    "where": pseudoClassWithSelectorsInfo,
    // parameterized pseudo elements
    "part": 3 /* ParameterizedPseudoElement */,
    "slotted": { f: wrapAndAddSelectors, a: [","], p: "::" },
};
/**
 * Proxy handler that serves as an implementation of the ISelectorBuilder interface.
 */
class SelectorBuilderHandler {
    constructor(items) {
        this.items = [];
        this.items = items;
    }
    get(t, propName, r) {
        if (typeof propName !== "string")
            return undefined;
        // the following makes our object to implement the ISelectorFunc interface
        if (propName === "fn")
            return "sel";
        else if (propName === "items")
            return this.items;
        let info = selectorInfos[propName];
        if (!info)
            return pushSelector.call(this, pseudoCamelTodDash(":", propName));
        else if (info === 1 /* SimplePseudoElement */)
            return pushSelector.call(this, pseudoCamelTodDash("::", propName));
        else if (info === 2 /* ParameterizedPseudoClass */)
            return addParameterizedPseudoEntity.bind(this, pseudoCamelTodDash(":", propName));
        else if (info === 3 /* ParameterizedPseudoElement */)
            return addParameterizedPseudoEntity.bind(this, pseudoCamelTodDash("::", propName));
        else if (typeof info === "function")
            return info.bind(this, propName);
        else {
            propName = info.n ?? (info.p ? pseudoCamelTodDash(info.p, propName) : propName);
            return info.f.bind(this, propName, ...info.a);
        }
    }
    ownKeys(t) { return SelectorBuilderHandler.keys; }
    has(t, p) { return SelectorBuilderHandler.keys.includes(p); }
}
// array of keys that are considered "own": these are the keys from the ISelectorFunc interface
SelectorBuilderHandler.keys = ["fn", "items"];
// adds an attribute selector
function addAttrSelector(propName, attrName, p2, p3, p4, p5) {
    return pushSelector.call(this, attrComparisonOperations.includes(p2)
        ? { fn: "attr-sel", name: attrName, val: p3, op: p2, cf: p4, ns: p5 }
        : { fn: "attr-sel", name: attrName, val: p2, cf: p3, ns: p4 });
}
// Pushes a selector for the given parameterized pseudo entity to the list of items
function addParameterizedPseudoEntity(entity, param) {
    return pushSelector.call(this, { fn: entity, p: param });
}
// Adds the given selectors intermingled with the given combinator to the list of items.
function addSelectorsWithCombinators(entity, combinator, ...newItems) {
    return pushSelectorsWithCombinators.call(this, combinator, true, ...newItems);
}
// Wraps the given selectors with the invocation of the given pseudo entity and pushes them
// to the list of items
function wrapAndAddSelectors(name, combinator, ...newItems) {
    this.items.push(name + "(");
    pushSelectorsWithCombinators.call(this, combinator, false, ...newItems);
    this.items.push(")");
    return this.proxy;
}
// Pushes the "nth" pseudo class with the given parameters to the list of items
function addNthPseudoClass(propName, p1, p2) {
    return pushSelector.call(this, { fn: pseudoCamelTodDash(":", propName), p: p2 != null ? [p1, p2] : p1 });
}
// Pushes the given selectors intermingled with the given combinator to the list of items. The
// "insertBefore" parameter indicates whether the combinator should be inserted before the first
// selector item.
function pushSelectorsWithCombinators(combinator, insertBefore, ...newItems) {
    if (insertBefore && combinator)
        this.items.push(combinator);
    for (let i = 0; i < newItems.length; i++) {
        if (i > 0 && combinator)
            this.items.push(combinator);
        this.items.push(newItems[i]);
    }
    return this.proxy;
}
// Pushes the given argument to the list of items
function pushSelector(item) {
    this.items.push(item);
    return this.proxy;
}
// combines the given prefix with the pseudo entity camel name converted to dash form
const pseudoCamelTodDash = (prefix, name) => prefix + (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.camelToDash)(name);
/**
 * Creates selector builder object that provides means to build complex selectors from multiple
 * selector items of all possible kinds including tags, classess, IDs, attributes, pseudo classes
 * and pseudo elements combined with CSS combinators. This function returns the [[ISelectorBuilder]]
 * interface, which has methods and properties for all selector items.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     cls = this.$class({...})
 *     myID = this.$id({...})
 *
 *     // produces CSS: label.cls1[data-item="myID"]:hover {...}
 *     s1 = this.$style( css.sel("label").and(this.cls1)).attr("for", this.myID).hover, {...})
 * }
 * ```
 * @param items List of selector items to initialize the complex selector. If multiple items are
 * specified, they are treated as list; that is, they are combined with the `","` combinator.
 * @returns
 */
const sel = (...items) => {
    let handler = new SelectorBuilderHandler(items);
    let proxy = new Proxy({}, handler);
    // the handler should reference the proxy in order to return it from methods (and properties)
    // to allow chain calls.
    handler.proxy = proxy;
    return proxy;
};
_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.fdo.sel = v => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.a2s)(v.items, { sep: "", recursive: true }, "");
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Animation and transition timing functions.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns a function representing an invocation of the CSS `steps()` function.
 *
 * @category Transition and Animation
 */
const steps = (n, j) => ({ fn: "steps", n, j });
_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.fdo.steps = ["n", "j"];
/**
* Returns a function representing an invocation of the CSS `cubic-bezier()` function.
*
* @category Transition and Animation
*/
const cubicBezier = (n1, n2, n3, n4) => ({ fn: "cubic-bezier", n1, n2, n3, n4 });
_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.fdo["cubic-bezier"] = ["n1", "n2", "n3", "n4"];
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * The `raw` function allows specifying arbitrary text for properties whose type normally doesn't
 * allow strings.This function is a tag function and must be invoked with the template string
 * without parentheses. The `raw` function can be used for any style property. Note, however, that
 * no validation checks are performed on the structure of the string. If the string isn't valid
 * for the style property, the property will not become part of the style rule inserted into the
 * DOM.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     poly = this.$class({
 *         clipPath: css.raw`polygon(50% 20%, 90% 80%, 10% 80%)`
 *     })
 * }
 * ```
 */
const raw = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.tag2s)(parts, params);
/**
 * Returns a function representing the CSS `url()` function. The string parameter
 * will be wrapped in a `url()` invocation. The function can also accept the IIDRule object to
 * create url(#element) invocation, which is often used to address SVG elements by their IDs.
 */
const url = (p) => ({ fn: "url", p });
_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.fdo.url = [["p", { str: 23 /* Quoted */ }]];
// Implementation
function cursor(url, x, y) {
    return { fn: "cursor", url, x, y };
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.fdo.cursor = (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.mv2s)([url(v.url), v.x, v.y]);
/**
 * Returns a function representing the `attr()` CSS function. It returns [[IStringProxy]] and
 * theoretically can be used in any style property wherever the CSS `<string>` type is accepted;
 * however, its use by browsers is currently limited to the `content` property. Also not all
 * browsers currently support type, units or fallback values.
 *
 * @param attrName Name of the attribute whose value should be returned.
 * @param typeOrUnit Optional type or unit keyword that determines the returned CSS type.
 * @param fallback Optional value that is used if the attribute is not found on the element.
 * @returns
 */
const attr = (attrName, typeOrUnit, fallback) => () => `attr(${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.mv2s)([(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.mv2s)([attrName, typeOrUnit]), fallback], ",")})`;
/**
 * Returns a representation of the CSS `counter()` function with an optional counter style.
 *
 * @param c Counter name or counter rule object
 * @returns ICounterFunc object representing the invocation of the `counter()` CSS function
 */
const counter = (counterObj, style) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.f2s)("counter", [counterObj, style]);
/**
 * Returns a representation of the CSS `counters()` function with the given separator and
 * an optional counter style.
 *
 * @param counterObj Counter name or counter rule object
 * @param sep Separator string between multiple counters
 * @param style Counter style
 * @returns ICounterFunc object representing the invocation of the `counter()` CSS function
 */
const counters = (counterObj, sep, style) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.f2s)("counters", [counterObj, [sep, 23 /* Quoted */], style]);
/**
 * Returns a function representing the invocation of the `var()` CSS function for the given custom
 * CSS property with optional fallbacks. Usually, when you want to refer to a custom CSS property
 * in style rules, it is enough to just refer to the style definition property created using the
 * [[$var]] function; however, if you want to provide a fallback value, you must use this function.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends StyleDefinition
 * {
 *     // create custom CSS property but without an assigned value; it can be assigned
 *     // later programmatically
 *     bgColor = this.$var( "color")
 *
 *     div = this.$tag( "div", {
 *         // use the custom CSS property with the given fallback value
 *         backgroundColor: css.usevar( this.bgColor, "beige")
 *     })
 * }
 * ```
 *
 * @typeparam K Key of the [[IVarTemplateStyleset]] interface that determines the type of the
 * custom CSS property and of the fallback value.
 * @param varObj Custom CSS property object created using the [[$var]] function.
 * @param fallback Fallback value that will be used if the custom CSS property isnt set.
 * @returns The `IRawProxy` callable interface, whcih allows the `usevar` function to be called
 * in any context.
 */
const usevar = (varObj, fallback) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.f2s)("var", [varObj.cssVarName, (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(varObj.template, fallback)]);


/***/ }),

/***/ "./lib/api/CoreTypes.js":
/*!******************************!*\
  !*** ./lib/api/CoreTypes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Basic types.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
;



/***/ }),

/***/ "./lib/api/FontTypes.js":
/*!******************************!*\
  !*** ./lib/api/FontTypes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/MediaTypes.js":
/*!*******************************!*\
  !*** ./lib/api/MediaTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/NumericAPI.js":
/*!*******************************!*\
  !*** ./lib/api/NumericAPI.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Num": () => (/* binding */ Num),
/* harmony export */   "Percent": () => (/* binding */ Percent),
/* harmony export */   "percent": () => (/* binding */ percent),
/* harmony export */   "Len": () => (/* binding */ Len),
/* harmony export */   "Q": () => (/* binding */ Q),
/* harmony export */   "ch": () => (/* binding */ ch),
/* harmony export */   "cm": () => (/* binding */ cm),
/* harmony export */   "em": () => (/* binding */ em),
/* harmony export */   "ex": () => (/* binding */ ex),
/* harmony export */   "ic": () => (/* binding */ ic),
/* harmony export */   "inch": () => (/* binding */ inch),
/* harmony export */   "lh": () => (/* binding */ lh),
/* harmony export */   "mm": () => (/* binding */ mm),
/* harmony export */   "pc": () => (/* binding */ pc),
/* harmony export */   "pt": () => (/* binding */ pt),
/* harmony export */   "px": () => (/* binding */ px),
/* harmony export */   "vb": () => (/* binding */ vb),
/* harmony export */   "vh": () => (/* binding */ vh),
/* harmony export */   "vi": () => (/* binding */ vi),
/* harmony export */   "vw": () => (/* binding */ vw),
/* harmony export */   "rem": () => (/* binding */ rem),
/* harmony export */   "rlh": () => (/* binding */ rlh),
/* harmony export */   "vmin": () => (/* binding */ vmin),
/* harmony export */   "vmax": () => (/* binding */ vmax),
/* harmony export */   "fr": () => (/* binding */ fr),
/* harmony export */   "Angle": () => (/* binding */ Angle),
/* harmony export */   "deg": () => (/* binding */ deg),
/* harmony export */   "rad": () => (/* binding */ rad),
/* harmony export */   "grad": () => (/* binding */ grad),
/* harmony export */   "turn": () => (/* binding */ turn),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "ms": () => (/* binding */ ms),
/* harmony export */   "s": () => (/* binding */ s),
/* harmony export */   "Resolution": () => (/* binding */ Resolution),
/* harmony export */   "dpi": () => (/* binding */ dpi),
/* harmony export */   "dpcm": () => (/* binding */ dpcm),
/* harmony export */   "dppx": () => (/* binding */ dppx),
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "Frequency": () => (/* binding */ Frequency),
/* harmony export */   "hz": () => (/* binding */ hz),
/* harmony export */   "khz": () => (/* binding */ khz),
/* harmony export */   "fitContent": () => (/* binding */ fitContent),
/* harmony export */   "ratio": () => (/* binding */ ratio),
/* harmony export */   "rect": () => (/* binding */ rect)
/* harmony export */ });
/* harmony import */ var _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/NumericImpl */ "./lib/impl/NumericImpl.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");


// Helper function for units conversion
const toUnitsProxy = (n, unit) => () => n + unit;
/**
 * The `Num` object contains methods that implement CSS mathematic functions on the `<number>`
 * CSS type. It implements the [[INumericMath]] interface and thus allows using the methods such
 * as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the [[CssNumber]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     // define custom CSS property - note that its value can be changed
 *     // programmatically
 *     columnQty = this.$var( "CssNumber", 3)
 *
 *     // max( 5, var(--columnQty))
 *     cls1 = this.$class({
 *         columns: css.Num.max( 5, this.columnQty)
 *     })
 * }
 * ```
 */
const Num = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.NumberMath;
/**
 * The `Percent` object contains methods that implement CSS mathematic functions on the
 * `<percentage>` CSS type. It implements the [[INumericMath]] interface and thus allows using
 * the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the
 * [[CssPercent]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     initialZoom = css.var( "CssPercent", 1.5)
 *
 *     // min( 0.5, var(--initialZoom))
 *     cls1 = this.$class({
 *         zoom: css.Percent.min( 0.5, this.initialZoom)
 *     })
 * }
 * ```
 */
const Percent = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.PercentMath;
/**
 * Creates percent value by appenfing the `"%"` sign to the given number. This function should be
 * used whenever a `<percentage>` CSS type is used for a style property or value.
 * @category Units
 */
const percent = (n) => toUnitsProxy(n, "%");
/**
 * The `Len` object contains methods that implement CSS mathematic functions on the
 * `<length> | <percentage>` CSS type. It implements the [[INumericMath]] interface and thus
 * allows using the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters
 * of the [[CssLength]] type.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends css.StyleDefinition
 * {
 *     defaultPadding = css.var( "CssLength", 8)
 *
 *     // calc( 200px - (2 * var(--defaultPadding)))
 *     cls1 = this.$class({
 *         width: css.Len.calc` 200px - (2 * ${this.defaultPadding})`
 *     })
 * }
 * ```
 */
const Len = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.LengthMath;
/**
 * Creates length value in quarters of an inch.
 * @category Units
 */
const Q = (n) => toUnitsProxy(n, "Q");
/**
 * Creates length value in ch units, which is equal to the used advance measure of the `“0”` (ZERO,
 * U+0030) glyph found in the font used to render it. (The advance measure of a glyph is its
 * advance width or height, whichever is in the inline axis of the element.)
 * @category Units
 */
const ch = (n) => toUnitsProxy(n, "ch");
/**
 * Creates length value in cantimeters.
 * @category Units
 */
const cm = (n) => toUnitsProxy(n, "cm");
/**
 * Creates length value in calculated font-sizes of the element.
 * @category Units
 */
const em = (n) => toUnitsProxy(n, "em");
/**
 * Creates length value in heights of lowercase letter 'x' in the font.
 * @category Units
 */
const ex = (n) => toUnitsProxy(n, "ex");
/**
 * Creates length value in ic units.
 * @category Units
 */
const ic = (n) => toUnitsProxy(n, "ic");
/**
 * Creates length value in inches.
 * @category Units
 */
const inch = (n) => toUnitsProxy(n, "in");
/**
 * Creates length value in line-heights of the element.
 * @category Units
 */
const lh = (n) => toUnitsProxy(n, "lh");
/**
 * Creates length value in millimeters.
 * @category Units
 */
const mm = (n) => toUnitsProxy(n, "mm");
/**
 * Creates length value in picas.
 * @category Units
 */
const pc = (n) => toUnitsProxy(n, "pc");
/**
 * Creates length value in points.
 * @category Units
 */
const pt = (n) => toUnitsProxy(n, "pt");
/**
 * Creates length value in pixels.
 * @category Units
 */
const px = (n) => toUnitsProxy(n, "px");
/**
 * Creates length value in 1% of the size of the initial containing block, in the direction
 * of the root element’s block axis.
 * @category Units
 */
const vb = (n) => toUnitsProxy(n, "vb");
/**
 * Creates length value in 1% of the height of the viewport's initial containing block.
 * @category Units
 */
const vh = (n) => toUnitsProxy(n, "vh");
/**
 * Creates length value in 1% of the size of the initial containing block, in the direction
 * of the root element’s inline axis.
 * @category Units
 */
const vi = (n) => toUnitsProxy(n, "vi");
/**
 * Creates length value in 1% of the width of the viewport's initial containing block.
 * @category Units
 */
const vw = (n) => toUnitsProxy(n, "vw");
/**
 * Creates length value in font-sizes of the root element (<html>).
 * @category Units
 */
const rem = (n) => toUnitsProxy(n, "rem");
/**
 * Creates length value in line-heights of the root element (<html>).
 * @category Units
 */
const rlh = (n) => toUnitsProxy(n, "rlh");
/**
 * Creates length value in the units which are a smaller value between vw and vh.
 * @category Units
 */
const vmin = (n) => toUnitsProxy(n, "vmin");
/**
 * Creates length value in the units which are a larger value between vw and vh.
 * @category Units
 */
const vmax = (n) => toUnitsProxy(n, "vmax");
/**
 * Creates length value for flex.
 * @category Units
 */
const fr = (n) => toUnitsProxy(n, "fr");
/**
 * The `Angle` object contains methods that implement CSS mathematic functions on the
 * `<angle> | <percentage>` CSS type. It implements the [[INumericMath]] interface and thus
 * allows using the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters
 * of the [[CssAngle]] type.
 */
const Angle = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.AngleMath;
/**
 * Creates angle value in degrees.
 * @category Units
 */
const deg = (n) => toUnitsProxy(n, "deg");
/**
 * Creates angle value in radians.
 * @category Units
 */
const rad = (n) => toUnitsProxy(n, "rad");
/**
 * Creates angle value in gradians.
 * @category Units
 */
const grad = (n) => toUnitsProxy(n, "grad");
/**
 * Creates angle value in turns.
 * @category Units
 */
const turn = (n) => toUnitsProxy(n, "turn");
/**
 * The `Time` object contains methods that implement CSS mathematic functions on the `<time>`
 * CSS type. It implements the [[INumericMath]] interface and thus allows using the methods such
 * as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the [[CssTime]] type.
 */
const Time = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.TimeMath;
/**
* Creates time value in milliseconds.
* @category Units
*/
const ms = (n) => toUnitsProxy(n, "ms");
/**
 * Creates time value in seconds.
 * @category Units
 */
const s = (n) => toUnitsProxy(n, "s");
/**
 * The `Resolution` object contains methods that implement CSS mathematic functions on the
 * `<resolution>` CSS type. It implements the [[INumericMath]] interface and thus allows using
 * the methods such as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the
 * [[CssResolution]] type.
 */
const Resolution = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.ResolutionMath;
/**
* Creates resolution value in DPI.
* @category Units
*/
const dpi = (n) => toUnitsProxy(n, "dpi");
/**
 * Creates resolution value in DPCM.
 * @category Units
 */
const dpcm = (n) => toUnitsProxy(n, "dpcm");
/**
 * Creates resolution value in DPPX.
 * @category Units
 */
const dppx = (n) => toUnitsProxy(n, "dppx");
/**
 * Creates resolution value in X.
 * @category Units
 */
const x = (n) => toUnitsProxy(n, "x");
/**
 * The `Frequency` object contains methods that implement CSS mathematic functions on the `<frequency>`
 * CSS type. It implements the [[INumericMath]] interface and thus allows using the methods such
 * as [[min]], [[max]], [[calc]] and [[clamp]] with parameters of the [[CssFrequency]] type.
 */
const Frequency = _impl_NumericImpl__WEBPACK_IMPORTED_MODULE_0__.FrequencyMath;
/**
* Creates frequency value in Hertz.
* @category Units
*/
const hz = (n) => toUnitsProxy(n, "hz");
/**
 * Creates frequency value in Kilo-Hertz.
 * @category Units
 */
const khz = (n) => toUnitsProxy(n, "khz");
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an [[IFitContentProxy]] function representing the `fit-content()` CSS function
 * ([MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/fit-content())).
 */
const fitContent = (size) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.f2s)("fit-content", [[size, 3 /* Length */]]);
/**
 * Returns an [[IAspectRatioProxy]] function representing the `<ratio>` CSS type.
 */
const ratio = (w, h) => () => [w, h].join("/");
/**
 * Returns an [[IRectProxy]] function representing the `rect()` CSS function used for the `clip`
 * style property.
 * @deprecated The CSS `clip` property and `rect()` function are deprecated.
 */
const rect = (top, right, bottom, left) => () => `rect(${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.a2s)([top, right, bottom, left], 3 /* Length */, ",")})`;


/***/ }),

/***/ "./lib/api/NumericTypes.js":
/*!*********************************!*\
  !*** ./lib/api/NumericTypes.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
;
;
;
;
;
;
;



/***/ }),

/***/ "./lib/api/RuleAPI.js":
/*!****************************!*\
  !*** ./lib/api/RuleAPI.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleDefinition": () => (/* binding */ StyleDefinition),
/* harmony export */   "embedded": () => (/* binding */ embedded),
/* harmony export */   "configNameGeneration": () => (/* binding */ configNameGeneration),
/* harmony export */   "classes": () => (/* binding */ classes),
/* harmony export */   "chooseClass": () => (/* binding */ chooseClass),
/* harmony export */   "virtual": () => (/* binding */ virtual),
/* harmony export */   "ThemeDefinition": () => (/* binding */ ThemeDefinition),
/* harmony export */   "activate": () => (/* binding */ activate),
/* harmony export */   "deactivate": () => (/* binding */ deactivate),
/* harmony export */   "getActiveTheme": () => (/* binding */ getActiveTheme)
/* harmony export */ });
/* harmony import */ var _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules/RuleContainer */ "./lib/rules/RuleContainer.js");
/* harmony import */ var _rules_StyleRules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules/StyleRules */ "./lib/rules/StyleRules.js");
/* harmony import */ var _rules_AnimationRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rules/AnimationRule */ "./lib/rules/AnimationRule.js");
/* harmony import */ var _rules_VarRule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rules/VarRule */ "./lib/rules/VarRule.js");
/* harmony import */ var _rules_CounterRules__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rules/CounterRules */ "./lib/rules/CounterRules.js");
/* harmony import */ var _rules_GridRules__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rules/GridRules */ "./lib/rules/GridRules.js");
/* harmony import */ var _rules_MiscRules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rules/MiscRules */ "./lib/rules/MiscRules.js");
/* harmony import */ var _rules_GroupRules__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../rules/GroupRules */ "./lib/rules/GroupRules.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");










/**
 * Symbol that is used by the `$parent` property in the StyleDefinition class that keeps reference
 * to the parnt style definition class. Developers can use this property to access rules in
 * the chain of nested grouping rules. We need this symbol to avoid enumerating the `$parent`
 * property when processing the rules in the style definition object.
 */
const symParent = Symbol("parent");
/**
 * The `StyleDefinition` class is a base for all classes that contain defininitions of CSS rules.
 * Style definition classes are regular TypeScript classes and as such can have any fields and
 * methods - both instance and static. Normally, however, they contain instance properties
 * initialized with functions returning style rules and at-rules, such as [[$class]],
 * [[$tag]], [[$media]], [[$counter]] and others.
 *
 * **Examples**
 *
 * ```typescript
 * // top-level style definition class
 * class MyStyles extends css.StyleDefinition
 * {
 *     cls = this.$class({ color: "red"})
 *
 *     // using style-definition class for @media rule
 *     ifNarrowScreen = this.$media( { maxWidth: 800 },
 *         class extends css.StyleDefinition<MyStyles>
 *         {
 *             cls = this.$class({ color: "pink"})
 *         }
 *     )
 * }
 * ```
 *
 * @typeparam P Parent style definition class. Parent of a top-level class is null.
 */
class StyleDefinition {
    /**
     * Style definition instances are created directly only by the *styled components* - that is,
     * components that use different styles for each instance. Otherwise, style definition
     * instances are created when either the [[$use]] method or [[activate]] function is called.
     * @param parent Reference to the parent style definition class
     */
    constructor(parent) {
        this[symParent] = parent;
        // instead of returning an instance of our class, the constructor returns a proxy. This
        // allows creating proxies for all properties defined in the class, which allows processing
        // the properties immediately upon definition.
        return new Proxy(this, new _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.RuleContainer(this));
    }
    /**
     * Refers to the instance of the style definition class which is the parnt of this style
     * definition object in the chain of style definition classes. Through this member, all rules
     * and other members defined in the parent definition class can be accessed. For top-level
     * style definitions, this property is always undefined. This property can also be undefined
     * if it was not provided to the constructor when creating the style definition class manually.
     *
     * The `$parent` reference is used when there is a need to refer from grouping rules (created
     * by `$media()` or `$support()` functions) to the rules defined in the parent style definition
     * class. If there are multiple nested grouping rules, then the constuct `this.$parent.$parent...`
     * allows reaching to rules defined in any ancestor style definition class.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     defaultColor = this.$var( "color", "blue")
     *
     *     ifSmallScreen = this.$media( { maxWidth: 600 },
     *         class extends css.StyleDefinition<MyStyles>
     *         {
     *             p = this.$style( "p", { color: this.$parent.defaultColor })
     *         }
     *     )
     * }
     * ```
     */
    get $parent() { return this[symParent]; }
    /**
     * Creates a new abstract rule, which defines a styleset that can be extended by other style rules.
     * Abstract rules don't have selectors and are not inserted into the DOM. Abstract rules can
     * themselves extend other rules - both abstract and non-abstract.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     colorBox = this.$abstract({
     *         backgroundColor: "orange",
     *         borderRadius: css.percent(10),
     *         border: [4, "solid", "red"],
     *         ":hover": {
     *             opacity: 0.7
     *         }
     *     })
     *
     *     box = this.$class({
     *         "+": this.colorBox,
     *         width: 200,
     *         height: 200,
     *     })
     *
     *     specialElm = this.$id({
     *         "+": this.colorBox,
     *         width: 600,
     *         height: 400,
     *     })
     * }
     * ```
     *
     * @param styleset One or more styleset objects that will be inherited by style rules that
     * extend this abstract rule.
     * @returns `IStyleRule` object that should be used by the derived rules in the `"+"` property.
     */
    $abstract(styleset) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_1__.AbstractRule(styleset);
    }
    /**
     * Creates a new class rule. The class name will be created when the rule is processed as part of
     * the style definition class. The name can be also overridden by providing either an explicit
     * name or another class rule. The function can be called without parameters just to "declare"
     * the class. Such class can be later used either in conditional grouping rules or in derived
     * style definition classes.
     *
     * The returned [[IClassRule]] interface has the `name` property that should be used to assign
     * the class to an HTML element
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     vbox = this.$class({
     *         display: "flex",
     *         flexDirection: "column",
     *         alignItems: "center"
     *     })
     * }
     * ...
     * let styles = css.activate( MyClasses);
     * ...
     * render
     * {
     *     return <div class={styles.vbox.name}>
     *         <span>Hello</span>
     *         <span>World!</span>
     *     </div>
     * }
     * ```
     *
     * @param styleset One or more styleset objects that define style properties of the class.
     * @param nameOverride string or another `IClassRule` object that determines the name of the class.
     * If this optional parameter is defined, the name will override the Mimcss name assignment
     * mechanism. This might be useful if there is a need for the class to match a name of another,
     * probably external, class.
     * @returns `IClassRule` object that should be used for getting the class name and for accessing
     * the style properties if needed.
     */
    $class(styleset, nameOverride) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_1__.ClassRule(styleset, nameOverride);
    }
    /**
     * Creates a new class name rule, which combines one or more other class names. This creates a
     * "synonym" that is easier to apply to an element's class attribute than an array of two or
     * more class rules.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // declare class - just to be used later
     *     spaced = css.class({gap: 8})
     *
     *     vbox = this.$class({
     *         display: "flex",
     *         flexDirection: "column"
     *     })
     *
     *     // use $classname rule to combine the names of classes vbox and spaced
     *     spacedVbox = this.$classname( this.vbox, this.spaced)
     * }
     * ...
     * let styles = css.activate( MyClasses);
     * ...
     * render
     * {
     *     // without spacedVbox, the class would be: {[styles.vbox.name, styles.spaced.name]}
     *     return <div class={styles.spacedVbox.name}>
     *         <span>Hello</span>
     *         <span>World!</span>
     *     </div>
     * }
     * ```
     *
     * @param ...classes List of class names specified either as a string or [[IClassRule]] or
     * [[IClassNameRule]] objects.
     * @returns `IClassNameRule` object whose `name` property contains the combined class name, e.g.
     * `"class1 class2"`. The `cssClassName` property contains the combined selector, e.g.
     * `".class1.class2"`.
     */
    $classname(...classes) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_6__.ClassNameRule(classes);
    }
    /**
     * Creates a new ID rule. The ID name will be created when the rule is processed as part of
     * the style definition class. The name can be also overridden by providing either an explicit
     * name or another ID rule. The function can be called without parameters just to "declare"
     * the ID. Such ID can be later used either in conditional grouping rules or in derived
     * style definition classes.
     *
     * The returned [[IIDRule]] interface has the `name` property that should be used to assign
     * the ID to an HTML element.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     container = this.$id({
     *         display: "flex",
     *         flexDirection: "column",
     *         alignItems: "center"
     *     })
     * }
     * ...
     * let styles = css.activate( MyClasses);
     * ...
     * render
     * {
     *     return <div id={styles.container.name}>
     *         <span>Hello</span>
     *         <span>World!</span>
     *     </div>
     * }
     * ```
     *
     * @param styleset One or more styleset objects that define style properties of the element.
     * @param nameOverride string or another `IIDRule` object that determines the name of the ID.
     * If this optional parameter is defined, the name will override the Mimcss name assignment
     * mechanism. This might be useful if there is a need for the ID to match a name of another ID.
     * @returns `IIDRule` object that should be used for getting the ID name and for accessing
     * the style properties if needed.
     */
    $id(styleset, nameOverride) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_1__.IDRule(styleset, nameOverride);
    }
    /**
     * Creates a new style rule for the given HTML or SVG element tags. The `tag` parameter specifies
     * either a single tag or an array of tags. In addition, an asterisk symbol (`"*"`) can be
     * specified to target all elements.
     *
     * When multiple tags are specified, they will be treated as a selector list; that is, they will
     * be separated by commas.
     *
     * **Examples:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // using string for selecting a single elemenet tag
     *     tr = this.$tag( "tr", {})
     *
     *     // using array for selecting multiple elemenet tags
     *     header123 = this.$tag( ["h1", "h2", "h3"], {})
     *
     *     // using asterisk to address all elements
     *     all = this.$tag( "*", {})
     * }
     * ```
     *
     * @param tag One or more element tags
     * @param styleset One or more styleset objects that define style properties for the tags.
     * @returns `IStyleRule` object representing the tag rule.
     */
    $tag(tag, styleset) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_1__.SelectorRule(Array.isArray(tag) ? tag.join(",") : tag, styleset);
    }
    /**
     * Creates a new style rule with an arbitrary complex selector. Selectors can be specified as
     * one or array of [[SelectorItem]] objects where each `SelectorItem` is one of the following
     * types:
     * - string - allows any content but lacks type-safety checks.
     * - any style rule, that is a rule that implements the [[IStyleRule]] interface. This allows
     *   using prevously defined tag, class, ID and other style rules as selector items
     * - [[selector]] function - a tag function that allows convenient mixing of free-format strings
     *   and strongly typed style rules.
     *
     * When multiple selector items are specified, they will be concatenated into a single string.
     *
     * Note that although style rules can be used for selecting element tags, the [[$tag]] function would
     * be more appropriate because it will catch misspellings of tag names.
     *
     * **Examples:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // using a string
     *     style1 = this.$style( "li::before", {})
     *
     *     id = this.$id()
     *     cls = this.$class()
     *
     *     // using an array of style rules. The selector will be "#id.cls"
     *     style2 = this.$style( [this.id, this.cls], {})
     *
     *     // using the selector function. The selector will be "#id > .cls"
     *     style3 = this.$style( css.selector`${this.id} > ${this.cls}`, {})
     *
     *     // using a string for selecting element tag.
     *     h1 = this.$style( "h1", {})
     * }
     * ```
     *
     * @param selector Style rule selector
     * @param styleset One or more styleset objects that define style properties for this selector.
     * @returns `IStyleRule` object representing the style rule.
     */
    $style(selector, styleset) {
        return new _rules_StyleRules__WEBPACK_IMPORTED_MODULE_1__.SelectorRule(selector, styleset);
    }
    /**
     * Creates new animation rule. The animation name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another animation rule. The function can be called without parameters just to
     * "declare" the animation. Such animation can be later used either in conditional grouping rules
     * or in derived style definition classes.
     *
     * The returned [[IAnimationRule]] interface represents an object that should be used when
     * using the keyframes name in the `animation-name` or `animation` style properties.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     vanish = this.$keyframes([
     *         [0, { opacity: 100 }],
     *     	   [100, { opacity: 0 }],
     *     ])
     *
     *     vanishingBlock = this.$class({
     *         animation: { name: this.vanish, duration: 2000, count: "infinite", direction: "alternate" }
     *     })
     * }
     * ```
     *
     * @param frames Array of [[AnimationFrame]] objects. Each animation frame contains a waypoint
     * and a styleset.
     * @param nameOverride String or another `IAnimationRule` object that determines the name of the
     * animation. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * another animation.
     * @returns `IAnimationRule` object that should be used for getting the animation name.
     */
    $keyframes(frames, nameOverride) {
        return new _rules_AnimationRule__WEBPACK_IMPORTED_MODULE_2__.AnimationRule(frames, nameOverride);
    }
    /**
     * Creates new custom variable object that defines a custom CSS property. The variable name will
     * be created when the rule is processed as part of the style definition class. The name can be
     * also overridden by providing either an explicit name or another custom variable rule. The
     * function can be called without specifying the value just to "declare" the variable. Such
     * variable can be later used either in conditional grouping rules or in derived style definition
     * classes.
     *
     * Custom properties defined using the `$var` function are included into the `:root {}` block;
     * however, they can be redefined with different values under any style rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // define and use custom CSS property
     *     importantTextColor = this.$var( "color", "red")
     *     important = this.$class({
     *         color: this.importantTextColor
     *     })
     *
     *     // use different value for the custom property under another CSS class
     *     special = this.$class({
     *         "+": this.important,
     *         "--": [ [this.importantTextColor, "maroon"] ]
     *     })
     * }
     * ```
     *
     * @param template Either a name of a style property (in camel-case) or a name of the property from
     * the [[IVarTemplateStyleset]] interface. The type corresponding to this property defines the type
     * of the second parameter.
     * @param value The value assigned to the property.
     * @param nameOverride String or another `IVarRule` object that determines the name of the
     * custom property. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing property.
     * @returns The `IVarRule` object that represents the custom property. Any usage of this object in
     * style properties or function parameters is substituted by the `var()` CSS function invocation.
     */
    $var(template, value, nameOverride) {
        return new _rules_VarRule__WEBPACK_IMPORTED_MODULE_3__.VarRule(template, value, nameOverride);
    }
    // implementation
    $property(syntax, initValue, inherits = true, nameOverride) {
        return new _rules_VarRule__WEBPACK_IMPORTED_MODULE_3__.PropertyRule(syntax, initValue, inherits, nameOverride);
    }
    /**
     * Creates a "constant" that can be used anywhere the type defined by the `template` parameter can
     * be used. They are called constants, because they provide a convenient and lightweight way of
     * defining values that are unchanged during the application lifetime. Although constants are
     * defined very similarly to custom properties (see the [[$var]] function), they cannot participate
     * in the cascade and cannot be redefined under style rules. Constant can use any expression that
     * satisfies the type defined by the `template` parameter including other constants, custom
     * properties and functions.
     *
     * No CSS rules are created for constants and, due to this fact, constants are preferable to custom
     * properties unless the intention is to change the variable value at run-time or to redefine its
     * value under different style rules.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     // defining and using custom CSS property
     *     defaultTextColor = this.$const( "color", "red")
     *     para = this.$style( "p", {
     *         color: this.defaultTextColor
     *     })
     * }
     * ```
     *
     * @param template Either a name of a style property (in camel-case) or a name of the property from
     * the [[IVarTemplateStyleset]] interface. The type corresponding to that property defines the type
     * of the second parameter.
     * @param value The value assigned to the constant.
     * @returns The `IConstRule` object that represents the value of the constant. The value is
     * computed once when the style definition is processed.
     */
    $const(template, value) {
        return new _rules_VarRule__WEBPACK_IMPORTED_MODULE_3__.ConstRule(template, value);
    }
    /**
     * Creates new counter object. The counter name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another counter rule.
     *
     * Counter rules don't create any CSS rules, but they create unique names that can be used
     * for `counter-reset` and `counter-increment` style properties. Counter rules are usually used
     * in conjunction with the [[counter]] and [[counters]] functions.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     counter = this.$counter()
     *     ol = this.$style( "ol", { counterReset: this.counter, listStyleType: "none" })
     *     li = this.$style( "li", {
     *         counterIncrement: this.counter,
     *         "::before": { content: css.counters( this.counter) }
     *     })
     * }
     * ```
     *
     * @param nameOverride String or another `ICounterRule` object that determines the name of the
     * counter. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing counter.
     * @returns The `ICounterRule` object that represents the counter.
     */
    $counter(nameOverride) {
        return new _rules_CounterRules__WEBPACK_IMPORTED_MODULE_4__.CounterRule(nameOverride);
    }
    /**
     * Creates new counter style rule. The counter style name will be created when the rule is
     * processed as part of the style definition class. The name can be also overridden by providing
     * either an explicit name or another counter style rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     counterStyle = this.$counterStyle({
     *         system: "cyclic",
     *         symbols: ["one", "two", "three"],
     *         suffix: " - "
     *     })
     * }
     * ```
     *
     * @param counterStyleset An object that defines counter style features.
     * @param nameOverride String or another `ICounterStyleRule` object that determines the name of the
     * counter style. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing counter style.
     * @returns The `ICounterStyleRule` object that represents the counter style.
     */
    $counterStyle(counterStyleset, nameOverride) {
        return new _rules_CounterRules__WEBPACK_IMPORTED_MODULE_4__.CounterStyleRule(counterStyleset, nameOverride);
    }
    /**
     * Creates a new grid line rule. The line name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another grid line rule. The grid line rules are used to define values of
     * style properties `grid-row-start/end` and `grid-column-start/end`.
     *
     * No CSS rule is created for grid lines - these objects are solely used for creating names, which
     * can be type-safely referred to from style rules.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     gridLineFirst = this.$gridline()
     *     gridLineLast = this.$gridline()
     *
     *     grid = this.$class({
     *         display: "grid",
     *         gridTemplateColumns: [ [this.gridLineFirst], "1fr", "2fr", [this.gridLineLast] ],
     *         gridTemplateRows: css.repeat( 2, "1fr"),
     *     })
     *
     *     first = this.$class({
     *         gridColumnStart: this.gridLineFirst,
     *     })
     *
     *     last = this.$class({
     *         gridColumnEnd: this.gridLineLast,
     *     })
     * }
     * ```
     *
     * @param nameOverride String or another `IGridLineRule` object that determines the name of the
     * line. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing grid line.
     * @param isStartEndOrNone Flag indicating whether the `"-start"` or `"-end"` suffix should be
     * appended to the rule name. If the flag is true, `"-start"` is appended; if the flag is false,
     * `"-end"` is appended; if the flag is undefined, no suffix is appended to the rule name.
     * @returns The `IGridLineRule` object that represents the grid line.
     */
    $gridline(nameOverride, isStartEndOrNone) {
        return new _rules_GridRules__WEBPACK_IMPORTED_MODULE_5__.GridLineRule(nameOverride, isStartEndOrNone);
    }
    /**
     * Creates a new grid area rule. The area name will be created when the rule is processed as
     * part of the style definition class. The name can be also overridden by providing either an
     * explicit name or another grid area rule. The grid area rules are used to define values of
     * style properties `grid-area`, `grid-row-start/end`, `grid-column-start/end` and
     * `grid-template-areas`.
     *
     * No CSS rule is created for grid areas - these objects are solely used for creating names, which
     * can be type-safely referred to from style rules.
     *
     * Every grid area defines two grid line rules in each direction, which can be accessed using the
     * [[IGridAreaRule.startLine]] and [[IGridAreaRule.endLine]] properties.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     headerArea = this.$gridarea();
     *     mainArea = this.$gridarea();
     *
     *     grid = this.$class({
     *         display: "grid",
     *         gridTemplateColumns: "1fr",
     *         gridTemplateRows: ["3em", "1fr"],
     *         gridTemplateAreas: [
     *             [this.headerArea, 1,1, 1,1],
     *             [this.mainArea, 2,1, 2,1],
     *         ],
     *     })
     *
     *     header = this.$class({
     *         gridArea: this.headerArea,
     *         backgroundColor: "blue"
     *     })
     *
     *     main = this.$class({
     *         gridArea: this.mainArea,
     *         backgroundColor: "lightgrey"
     *     })
     * }
     * ```
     *
     * @param nameOverride String or another `IGridAreaRule` object that determines the name of the
     * area. If this optional parameter is defined, the name will override the Mimcss name
     * assignment mechanism. This might be useful if there is a need for the name to match a name of
     * existing grid area.
     * @returns The `IGridAreaRule` object that represents the grid area.
     */
    $gridarea(nameOverride) {
        return new _rules_GridRules__WEBPACK_IMPORTED_MODULE_5__.GridAreaRule(nameOverride);
    }
    /**
     * Creates a new `@font-face` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     font = this.$fontface({
     *         fontFamily: "Roboto",
     *         fontStyle: "italic",
     *         fontWeight: 700,
     *         src: {url: 'roboto.woff', format: 'woff'}
     *     });
     * }
     * ```
     *
     * @param fontface Object implementing the `IFontFace` interface defining the parameter of the
     * font to use.
     * @returns The `IFontFaceRule` object that represents the @font-face rule.
     */
    $fontface(fontface) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_6__.FontFaceRule(fontface);
    }
    /**
     * Creates a new `@import` rule referencing the given CSS file.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     importedCssFiles = [
     *         this.$import( "common-3rdparty.css"),
     *         this.$import( "small-screen-3rdparty.css", {maxWidth: 600}),
     *     ]
     * }
     * ```
     *
     * @param url URL to the CSS file. Relative URLs are resolved relative to the base URL of the
     * page where the Mimcss library is invoked.
     * @returns The `IImportRule` object that represents the `@import` rule.
     */
    $import(url, mediaQuery, supportsQuery) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_6__.ImportRule(url, mediaQuery, supportsQuery);
    }
    /**
     * Creates new `@namespace` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     init = [
     *         this.$namespace( css.WebNamespaces.SVG, "svg")
     *     ]
     * }
     * ```
     *
     * @param namespace Namespace string - use the [[WebNamespaces]] for well-known namespaces.
     * @param prefix Prefix string to use for the namespace.
     * @returns The `INamespaceRule` object that represents the namespace rule.
     */
    $namespace(namespace, prefix) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_6__.NamespaceRule(namespace, prefix);
    }
    /**
     * Creates new `@page` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     init = [
     *         this.$page( ":first", { margin: "auto" })
     *     ]
     * }
     * ```
     *
     * @param pseudoClass Optional name of the page pseudo style.
     * @param styleset Styles to apply.
     * @returns The `IPageRule` object that represents the page rule.
     */
    $page(pseudoClass, styleset) {
        return new _rules_MiscRules__WEBPACK_IMPORTED_MODULE_6__.PageRule(pseudoClass, styleset);
    }
    /**
     * Creates a new `@supports` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     cls = this.$class({ color: "red"})
     *
     *     ifGridSupported = this.$media( { display: "grid" },
     *         class extends css.StyleDefinition<MyStyles>
     *         {
     *             cls = this.$class({ color: "pink"})
     *         }
     *     )
     * }
     * ```
     *
     * @param statement Supports statement containing one or more supports queries.
     * @param instOrClass Either style definition class or an instance of a style defintion class.
     * @returns `ISupportsRule` object representing the supports rule
     */
    $supports(statement, instOrClass) {
        return new _rules_GroupRules__WEBPACK_IMPORTED_MODULE_7__.SupportsRule(statement, instOrClass);
    }
    /**
     * Creates new `@media` rule.
     *
     * **Example:**
     *
     * ```typescript
     * class MyStyles extends css.StyleDefinition
     * {
     *     cls = this.$class({ color: "red"})
     *
     *     ifNarrowScreen = this.$media( { maxWidth: 800 },
     *         class extends css.StyleDefinition<MyStyles>
     *         {
     *             cls = this.$class({ color: "pink"})
     *         }
     *     )
     * }
     * ```
     *
     * @param statement Media statement containing one or more media queries.
     * @param instOrClass Either style definition class or an instance of a style defintion class.
     * @returns `IMediaRule` object representing the media rule
     */
    $media(statement, instOrClass) {
        return new _rules_GroupRules__WEBPACK_IMPORTED_MODULE_7__.MediaRule(statement, instOrClass);
    }
    /**
     * Processes the given style definition class or instance and creates unique names for all named
     * entities. For a given style definition class only a single instance is created, no matter how
     * many times this function is invoked. However, if an instance, which has not yet been processed,
     * is passed, then a new set of unique names will be created for it.
     *
     * The `$use` function is used to reference a style definition from another style definition, for
     * example:
     *
     * ```typescript
     * class CommonStyles extends css.StyleDefinition
     * {
     *     error = this.$class({ color: "red"})
     * }
     *
     * class PageStyles extends css.StyleDefinition
     * {
     *     common = this.$use( CommonStyles)
     *
     *     erroMessage = this.$class({
     *         "+": this.common.error,
     *         fontWeight: "bold"
     *     })
     * }
     * ```
     *
     * When the `$use` function is called, the rules from the referenced style definition are not
     * inserted into the DOM; they will be inserted when the style definition class that contains
     * the `$use` call is activated. The same style definition class can be used from several
     * other style definitions: as long as there is at least one referencing style definition that
     * is activated, the rules will be in the DOM; as soon as all referencing style definitions are
     * deactivated, the rules from the referenced definition are removed from the DOM.
     *
     * @param instOrClass Either style definition class or an instance of a style definition class.
     * @returns An instance of the style definition class, which will be activated and deactivated
     * along with the enclosing style definition.
     */
    $use(instOrClass) {
        return (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.processSD)(instOrClass);
    }
}
/**
 * Decorator function for style definition classes that will be embedded into an embedding
 * container for the given category. All style definitions for a given category will be activated
 * and deactivated together and their rules will be inserted into a single `<style>` element.
 *
 * **Example:**
 * ```typescript
 * @css.embedded("widgets")
 * class FirstWidgetStyles extends css.StyleDefinition {...}
 *
 * @css.embedded("widgets")
 * class SecondWidgetStyles extends css.StyleDefinition {...}
 * ```
 */
const embedded = (category) => 
// we return the function that is the actual decorator.
_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.embeddedDecorator.bind(undefined, category);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name generation.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Sets the method uses to generate names of CSS entities. If yes, the names will be created by
 * appending a unique number to the given prefix. If the prefix is not specified, the standard
 * prefix "n" will be used.
 *
 * By default the development version of the library (mimcss.dev.js) uses the [[UniqueScoped]]
 * method and the production version (mimcss.js) uses the [[Optimized]] method. This function can
 * be called to switch to the alternative method of name generation in either the development or
 * the production builds.
 *
 * @param method Indicates what method to use.
 * @param prefix Optional string that will serve as a prefix to which unique numbers will be added
 * to generate optimized names. Ignored if the `method` parameter is anything other than
 * [[NameGenerationMethod.Optimized]].
 */
const configNameGeneration = (method, prefix) => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.configNames)(method, prefix);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Helper functions.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Concatenates the names of the given classes into a single string that can be assigned to a
 * `class` property of an HTML element.
 *
 * @param classProps Variable argument list of either class names or class rule objects.
 * @returns The string that combines all class names (separated with space) from the input array.
 */
const classes = (...classProps) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_8__.v2s)(classProps, {
    obj: (v) => v.name,
    item: classes
});
/**
 * Chooses the first non-null name from the given list of classes.
 * @param classProps
 * @returns The first non-empty class name from the input array or null if all inputs are empty.
 */
const chooseClass = (...classProps) => {
    for (let classProp of classProps) {
        if (!classProp)
            continue;
        else if (typeof classProp === "string")
            return classProp;
        else if (Array.isArray(classProp)) {
            let name = chooseClass(classProp);
            if (name)
                return name;
        }
        else if (classProp.name)
            return classProp.name;
    }
    return null;
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Rule virtualization and theming.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Decorator that should be applied to a rule if it is defined and used in the same style
 * definition class but then is overridden in a derived style definition class. The problem
 * this solves is this: when a rule is defined in a base class and then overridden in a derived
 * class, when an instance of the derived class is created, the rules that are created in the
 * base and derived classes see different values of the rule. Since our rules are defined as
 * part of the constructor, the base class constructor's code only sees the value assigned in that
 * code. If another rule in the base class uses this first rule, this value is remembered.
 *
 * The `@virtual` decorator creates a Proxy object for the rule with the handler that keeps the
 * most recent value set. Thus when a rule in the base class's constructor uses a virtualized
 * rule, the first rule will see the overridden value of the rule when accessed in the
 * post-constructor code.
 *
 * @deprecated This decorator is deprecated as  all rules defined in style definition classes are
 * always virtualized.
 */
const virtual = (target, name) => { };
/**
 * The `ThemeDefinition` class is a base for all classes that define themes. In addition to
 * being a style definition class, themes provide some extra capabilities related to style
 * inheritance and theme activation.
 *
 * @typeparam P Parent style definition class. Parent of a top-level class is null.
 */
class ThemeDefinition extends StyleDefinition {
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Activation.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Activates the given style definition class or instance and inserts all its rules into DOM. If
 * the input object is not an instance but a class, which is not yet associated with an instance,
 * the instance is first created and processed. Note that each style definition instance maintains
 * a reference counter of how many times it was activated and deactivated. The rules are inserted
 * into DOM only upon first activation.
 */
const activate = (instOrClass, schedulerType) => {
    let instance = (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.processSD)(instOrClass);
    if (instance)
        (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_9__.getActivator)(schedulerType).activate(instance);
    return instance;
};
/**
 * Deactivates the given style definition instance by removing its rules from DOM. Note that each
 * style definition instance maintains a reference counter of how many times it was activated and
 * deactivated. The rules are removed from DOM only when this reference counter goes down to 0.
 */
const deactivate = (instance, schedulerType) => (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_9__.getActivator)(schedulerType).deactivate(instance);
/**
 * Returns the theme definition object, which is currently active for the given theme declaration
 * class.
 * @param themeClass Theme declaration class
 * @returns Theme instance, which is currently active for the given theme class or undefined
 * if no instance is currently active.
 */
const getActiveTheme = (themeClass) => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.getCurrentTheme)(themeClass);


/***/ }),

/***/ "./lib/api/RuleTypes.js":
/*!******************************!*\
  !*** ./lib/api/RuleTypes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/SchedulingAPI.js":
/*!**********************************!*\
  !*** ./lib/api/SchedulingAPI.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "forceDOMUpdate": () => (/* binding */ forceDOMUpdate),
/* harmony export */   "cancelDOMUpdate": () => (/* binding */ cancelDOMUpdate),
/* harmony export */   "getDefaultScheduler": () => (/* binding */ getDefaultScheduler),
/* harmony export */   "setDefaultScheduler": () => (/* binding */ setDefaultScheduler),
/* harmony export */   "registerScheduler": () => (/* binding */ registerScheduler),
/* harmony export */   "unregisterScheduler": () => (/* binding */ unregisterScheduler)
/* harmony export */ });
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Scheduling.
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Writes to DOM all style changes caused by the calls to the activate and deactivate functions
 * accumulated since the last activation of the given scheduling type.
 */
const forceDOMUpdate = (schedulerType) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.getActivator(schedulerType).forceDOMUpdate();
/**
 * Removes all scheduled activations caused by the calls to the activate and deactivate functions
 * accumulated since the last activation of the given scheduling type.
 */
const cancelDOMUpdate = (schedulerType) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.getActivator(schedulerType).cancelDOMUpdate();
/**
 * Returns the current default scheduler type.
 */
const getDefaultScheduler = () => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.getDefaultScheduler();
/**
 * Sets the default scheduling type that is used by activate and deactivate functions that are
 * called without explicitly providing value to the scheduling parameter. Returns the type of the
 * previous default activator or 0 if an error occurs (e.g. the given scheduler type ID is not
 * registered).
 */
const setDefaultScheduler = (schedulerType) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.setDefaultScheduler(schedulerType);
/**
 * Registers the given scheduler object and returns the scheduler type identifier, which
 * should be used when calling activate and deactivate functions.
 */
const registerScheduler = (scheduler) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.registerScheduler(scheduler);
/**
 * Unregisters a scheduler object with the given scheduler type identifier.
 */
const unregisterScheduler = (schedulerType) => _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_0__.unregisterScheduler(schedulerType);


/***/ }),

/***/ "./lib/api/SchedulingTypes.js":
/*!************************************!*\
  !*** ./lib/api/SchedulingTypes.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/ShapeAPI.js":
/*!*****************************!*\
  !*** ./lib/api/ShapeAPI.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearGradient": () => (/* binding */ linearGradient),
/* harmony export */   "radialGradient": () => (/* binding */ radialGradient),
/* harmony export */   "conicGradient": () => (/* binding */ conicGradient),
/* harmony export */   "crossFade": () => (/* binding */ crossFade),
/* harmony export */   "imageSet": () => (/* binding */ imageSet),
/* harmony export */   "registerPaintWorklet": () => (/* binding */ registerPaintWorklet),
/* harmony export */   "paint": () => (/* binding */ paint),
/* harmony export */   "brightness": () => (/* binding */ brightness),
/* harmony export */   "contrast": () => (/* binding */ contrast),
/* harmony export */   "grayscale": () => (/* binding */ grayscale),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "opacity": () => (/* binding */ opacity),
/* harmony export */   "saturate": () => (/* binding */ saturate),
/* harmony export */   "sepia": () => (/* binding */ sepia),
/* harmony export */   "blur": () => (/* binding */ blur),
/* harmony export */   "dropShadow": () => (/* binding */ dropShadow),
/* harmony export */   "hueRotate": () => (/* binding */ hueRotate),
/* harmony export */   "matrix": () => (/* binding */ matrix),
/* harmony export */   "matrix3d": () => (/* binding */ matrix3d),
/* harmony export */   "perspective": () => (/* binding */ perspective),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "rotate3d": () => (/* binding */ rotate3d),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleX": () => (/* binding */ scaleX),
/* harmony export */   "scaleY": () => (/* binding */ scaleY),
/* harmony export */   "scaleZ": () => (/* binding */ scaleZ),
/* harmony export */   "scale3d": () => (/* binding */ scale3d),
/* harmony export */   "skew": () => (/* binding */ skew),
/* harmony export */   "skewX": () => (/* binding */ skewX),
/* harmony export */   "skewY": () => (/* binding */ skewY),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "translateX": () => (/* binding */ translateX),
/* harmony export */   "translateY": () => (/* binding */ translateY),
/* harmony export */   "translateZ": () => (/* binding */ translateZ),
/* harmony export */   "translate3d": () => (/* binding */ translate3d),
/* harmony export */   "inset": () => (/* binding */ inset),
/* harmony export */   "circle": () => (/* binding */ circle),
/* harmony export */   "ellipse": () => (/* binding */ ellipse),
/* harmony export */   "polygon": () => (/* binding */ polygon),
/* harmony export */   "path": () => (/* binding */ path),
/* harmony export */   "ray": () => (/* binding */ ray),
/* harmony export */   "minmax": () => (/* binding */ minmax),
/* harmony export */   "repeat": () => (/* binding */ repeat),
/* harmony export */   "span": () => (/* binding */ span)
/* harmony export */ });
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Images and gradients.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
const gradientNameToString = (val) => `${val.repeat ? "repeating-" : ""}${val.fn}`;
const gradientStopsOrHintsToString = (val, math) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    item: {
        num: 11 /* Color */,
        arr: { 1: [math], any: [11 /* Color */, math, math] }
    },
    sep: ","
});
/**
 * Function returning the ILinearGradientBuilder interface representing the `linear-gradient` CSS functions.
 *
 * *Examples:*
 *
 * ```typescript
 * backgroundImage: linearGradient( "red", "blue")
 *
 * backgroundImage: linearGradient( ["red", 30], ["green", 50, 60], ["blue", 80]).repeating()
 *
 * backgroundImage: linearGradient( "red", "blue").to( 45)
 * ```
 *
 * @param stops Variable argument list specifying stops or hints that will be added to
 * the gradient definition.
 *
 * @category Image
 */
const linearGradient = (...stops) => new LinearGradientBuilder(stops);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["linear-gradient"] = {
    fn: gradientNameToString,
    f: (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([
        (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val.angle, { num: 4 /* Angle */, str: v => "to " + v }),
        gradientStopsOrHintsToString(val.stops, 3 /* Length */)
    ], ",")
};
/**
 * Function returning the IRadialGradient interface representing the `radial-gradient` CSS functions.
 *
 * *Examples:*
 *
 * ```typescript
 * backgroundImage: radialGradient( "red", "blue")
 *
 * backgroundImage: radialGradient( "red", "blue").circle( css.percent(30)).at( ["center", css.percent(65)])
 *
 * backgroundImage: radialGradient( "red", "blue").circle( 200).repeating()
 *
 * backgroundImage: radialGradient( "red", "blue").ellipse( "closest-side")
 * ```
 *
 * @param stops Variable argument list specifying stops or hints that will be added to
 * the gradient definition.
 *
 * @category Image
 */
const radialGradient = (...stops) => new RadialGradientBuilder(stops);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["radial-gradient"] = {
    fn: gradientNameToString,
    f: (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([
        (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([val.shape, [val.size, 13 /* MultiLengthWithSpace */], [val.pos, 9 /* AtPosition */]]),
        gradientStopsOrHintsToString(val.stops, 3 /* Length */)
    ], ",")
};
/**
 * Function returning the IConicGradient interface representing the `radial-gradient` CSS functions.
 *
 * *Examples:*
 *
 * ```typescript
 * backgroundImage: conicGradient( "red", "blue")
 *
 * backgroundImage: conicGradient().repeating().add( "red", "blue")
 *
 * backgroundImage: conicGradient( "red", "blue").from( 0.25).at( ["center", css.percent(65)])
 * ```
 *
 * @param stops Variable argument list specifying stops or hints that will be added to
 * the gradient definition.
 *
 * @category Image
 */
const conicGradient = (...stops) => new ConicGradientBuilder(stops);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["conic-gradient"] = {
    fn: gradientNameToString,
    f: (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([
        (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[val.angle, (v) => "from " + (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, 4 /* Angle */)], [val.pos, 9 /* AtPosition */]]),
        gradientStopsOrHintsToString(val.stops, 4 /* Angle */)
    ], ",")
};
/**
 * Base class for gradient implementation
 */
class GradientBuilder {
    constructor(stops) {
        this.stops = stops ?? [];
    }
    repeating(flag) {
        this.repeat = flag == null ? true : flag;
        return this;
    }
    add(...stopsOrHints) {
        this.stops.push(...stopsOrHints);
        return this;
    }
}
/**
 * Implements functionality of linear gradients
 */
class LinearGradientBuilder extends GradientBuilder {
    constructor() {
        super(...arguments);
        this.fn = "linear-gradient";
    }
    to(angle) { this.angle = angle; return this; }
}
/**
 * Implements functionality of radial gradients
 */
class RadialGradientBuilder extends GradientBuilder {
    constructor() {
        super(...arguments);
        this.fn = "radial-gradient";
    }
    circle(sizeOrExtent) {
        this.shape = "circle";
        this.size = sizeOrExtent;
        return this;
    }
    ellipse(...params) {
        this.shape = "ellipse";
        this.size =
            params.length === 1 ? params[0] :
                params.length === 2 ? [params[0], params[1]] :
                    undefined;
        return this;
    }
    extent(extent) { this.size = extent; return this; }
    at(pos) { this.pos = pos; return this; }
}
/**
 * Implements functionality of conic gradients
 */
class ConicGradientBuilder extends GradientBuilder {
    constructor() {
        super(...arguments);
        this.fn = "conic-gradient";
    }
    from(angle) { this.angle = angle; return this; }
    at(pos) { this.pos = pos; return this; }
}
/** Implementation */
function crossFade() {
    return new CrossFadeBuilder(...arguments);
}
/**
 * Implements functionality of cross-fade()
 */
class CrossFadeBuilder {
    constructor() {
        this.fn = "cross-fade";
        let p1 = arguments[0];
        if (Array.isArray(p1) && p1.length === 3) {
            // this is the old signature
            this.old = p1;
        }
        else {
            // this is the new signature
            this.add(...arguments);
        }
    }
    add(...images) {
        if (!this.images)
            this.images = [];
        for (let item of images)
            this.images.push(Array.isArray(item) ? item : [item]);
        return this;
    }
    color(c) { this.c = c; return this; }
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["cross-fade"] = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.f2s)("cross-fade", [
    val.images
        ? (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)([[val.images, { item: { arr: [0 /* Default */, 2 /* Percent */] }, sep: "," }], [val.c, 11 /* Color */]], ",")
        : (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val.old, { arr: [0 /* Default */, 0 /* Default */, 2 /* Percent */], sep: "," })
]);
/**
 * Returns an IImageSetFunc object representing the `image-set()` CSS function.
 *
 * @param items One or more items specifying an image and optionally image type and resolution.
 * @returns
 *
 * @category Image
 */
const imageSet = (...items) => ({ fn: "image-set", items });
const imageTypeToString = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    str: v => `type("${v.indexOf("/") > 0 ? val : "image/" + val}")`
});
const imageResolutionToString = (val) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    num: v => v + "x"
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["image-set"] = [
    [
        "items", {
            item: {
                str: 23 /* Quoted */,
                arr: {
                    1: [23 /* Quoted */],
                    2: [23 /* Quoted */, { str: imageTypeToString, num: imageResolutionToString }],
                    3: [23 /* Quoted */, imageTypeToString, imageResolutionToString],
                }
            },
            sep: ","
        }
    ]
];
/**
 * Registers a paint worklet with the given name, optional argument syntax and optional URL of
 * the worklet module. The worklet name should have been added to the [[IPaintWorklets]] interface
 * using the module augmentation technique. Although it is possible to use paint worklets without
 * adding them to the [[IPaintWorklets]] interface, this will prevent Mimcss from enforcing the
 * types of arguments when the [[paint]] function is invoked.
 * @param name Worklet name
 * @param syntax Tuple containing syntax definitions for worklet arguments.
 * @param url URL to the worklet module. If specified, the module will be automatically added.
 */
const registerPaintWorklet = async (name, syntax = [], url) => {
    if (CSS.paintWorklet) {
        if (!registeredPaintWorkletInfos[name]) {
            registeredPaintWorkletInfos[name] = { syntax, url };
            // if URL is specified use it to add worklet module
            if (url && !addedPaintWorkletModules.has(url)) {
                addedPaintWorkletModules.add(url);
                try {
                    await CSS.paintWorklet.addModule(url);
                }
                catch (x) {
                    console.error(`Error adding module '${url}' for paint worklet '${name}'`, x);
                }
            }
        }
    }
};
/**
 * Information about registered paint worklets.
 */
let registeredPaintWorkletInfos = {};
/**
 * Set of URLs of already added paint worklet modules.
 */
let addedPaintWorkletModules = new Set();
/**
 * Returns the IPaintFunc object describing an invocation of the `paint()` CSS function.
 *
 * @param name Paint worklet name.
 * @param args Parameters to be passed to the paint worklet.
 *
 * @category Image
 *
 * @ts-expect-error: Erroneously reports TS2370 although the rest's type is an array (a tuple) */
const paint = (name, ...args) => ({ fn: "paint", name: name, args: args });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.paint = (v) => {
    if (!v?.args?.length)
        return `paint(${v.name})`;
    let info = registeredPaintWorkletInfos[v.name];
    let buf = [];
    for (let i = 0; i < v.args.length; i++) {
        let syntax = info?.syntax[i];
        buf.push(syntax ? (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_1__.sp2s)(syntax, v.args[i]) : (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v.args[i]));
    }
    return `paint(${v.name},${buf.filter(v => !!v).join(",")})`;
};
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Filters
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an IFilterProxy function representing one of the filter CSS function.
 */
const filterPercent = (fn, p) => ({ fn, p });
/**
 * Returns an [[IPercentFilterFunc]] object representing the `brightness()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: brightness(150%)
 *     bright = this.$class({ filter: css.brightness(150)})
 *
 *     // filter: brightness(50%)
 *     dim = this.$class({ filter: css.brightness(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const brightness = (p) => filterPercent("brightness", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `contrast()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: contrast(150%)
 *     highContrast = this.$class({ filter: css.contrast(150)})
 *
 *     // filter: contrast(50%)
 *     lowContrast = this.$class({ filter: css.contrast(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const contrast = (p) => filterPercent("contrast", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `grayscale()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: grayscale(100%)
 *     gray = this.$class({ filter: css.grayscale(100)})
 *
 *     // filter: grayscale(50%)
 *     halfColor = this.$class({ filter: css.grayscale(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const grayscale = (p) => filterPercent("grayscale", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `invert()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: invert(100%)
 *     inverted = this.$class({ filter: css.invert(100)})
 *
 *     // filter: invert(75%)
 *     somewhatnverted = this.$class({ filter: css.invert(0.75)})
 *
 *     // filter: invert(50%)
 *     gray = this.$class({ filter: css.invert(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const invert = (p) => filterPercent("invert", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `opacity()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: opacity(50%)
 *     halfTransparent = this.$class({ filter: css.opacity(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const opacity = (p) => filterPercent("opacity", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `saturate()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: saturate(150%)
 *     superSaturated = this.$class({ filter: css.saturate(150)})
 *
 *     // filter: saturate(50%)
 *     underSaturated = this.$class({ filter: css.saturate(0.5)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const saturate = (p) => filterPercent("saturate", p);
/**
 * Returns an [[IPercentFilterFunc]] object representing the `sepia()` CSS function.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: sepia(100%)
 *     vintage = this.$class({ filter: css.sepia(100)})
 * }
 * ```
 *
 * @param p Value interpreted as percentage. Integer number is used as is while  floating point
 * numbers are multiplied by 100.
 * @returns The `IPercentFilterFunc` interface containing percentage value
 * @category Filter
 */
const sepia = (p) => filterPercent("sepia", p);
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.brightness = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.contrast = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.grayscale = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.invert = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.opacity = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.saturate =
    _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.sepia = 2 /* Percent */;
/**
 * Returns an [[IBlurFunc]] object representing the `blur()` CSS function parameters.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: blur(0)
 *     sharp = this.$class({ filter: css.blur(0)})
 *
 *     // filter: blur(2px)
 *     blurred = this.$class({ filter: css.blur(2)})
 *
 *     // filter: blur(1.5em)
 *     superBlurred = this.$class({ filter: css.blur(1.5)})
 * }
 * ```
 *
 * @param r Radius of the blur.
 * @returns The `IBlurFunc` interface containing the blur radius
 * @category Filter
 */
const blur = (r) => ({ fn: "blur", r });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.blur = 3 /* Length */;
/**
 * Returns an [[IDropShadowFunc]] object representing the `dropShadow()` CSS function parameters.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: drop-shadow(30px 10px 4px blue)
 *     blurredShadow = this.$class({ filter: css.dropShadow( 30, 10, "blue", 4)})
 *
 *     // filter: drop-shadow(2.5em -1.5em green)
 *     sharpShadow = this.$class({ filter: css.dropShadow( 2.5, -1.5, "green")})
 *
 *     // filter: drop-shadow(0 0 20px orange)
 *     haloShadow = this.$class({ filter: css.dropShadow( 0, 0, "orange", 20px)})
 * }
 * ```
 *
 * @param x Horizontal offset of the shadow.
 * @param y Vertical offset of the shadow.
 * @param color Color of the shadow. If undefined, the color of the shadow is taken from the color
 * property.
 * @param blur Value of the shadow's blurring. If undefined, the shadow will be sharp (not blurred).
 * @returns The `IDropShadowFunc` interface containing the shadow parameters.
 *
 * @category Filter
 */
const dropShadow = (x, y, color, blur) => ({ fn: "drop-shadow", x, y, color, blur });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["drop-shadow"] = {
    p: ["x", "y", "blur", ["color", 11 /* Color */]],
    do: 3 /* Length */,
    s: " "
};
/**
 * Returns an [[IHueRotateFunc]] object representing the `hue-rotate()` CSS function parameters.
 *
 * **Example**
 *
 * ```tsx
 * class MyStyles extends css.StyleDefinition
 * {
 *     // filter: hue-rotate(90deg)
 *     toTheRight = this.$class({ filter: css.hueRotate(90)})
 *
 *     // filter: hue-rotate(-0.25turn)
 *     toTheLeft = this.$class({ filter: css.blur(-0.25)})
 * }
 * ```
 *
 * @param a The relative change in hue of the input sample.
 * @returns The `IHueRotateFunc` interface containing the hue rotation angle
 * @category Filter
 */
const hueRotate = (a) => ({ fn: "hue-rotate", a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["hue-rotate"] = 4 /* Angle */;
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Transforms
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an IMatrixFunc object representing the `matrix()` CSS function.
 *
 * @category Transform
 */
const matrix = (a, b, c, d, tx, ty) => ({ fn: "matrix", a, b, c, d, tx, ty });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.matrix = ["a", "b", "c", "d", "tx", "ty"];
/**
 * Returns an IMatrix3dFunc function representing the `matrix3d()` CSS function.
 *
 * @category Transform
 */
const matrix3d = (a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) => ({ fn: "matrix3d", a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4 });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.matrix = ["a1", "b1", "c1", "d1", "a2", "b2", "c2", "d2", "a3", "b3", "c3", "d3", "a4", "b4", "c4", "d4"];
/**
 * Returns an IPerspectiveFunc function representing the `perspective()` CSS function.
 *
 * @category Transform
 */
const perspective = (d) => ({ fn: "perspective", d });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.perspective = 3 /* Length */;
/**
 * Returns an IRotateFunc function representing the `rotate()` CSS function.
 *
 * @category Transform
 */
const rotate = (a) => ({ fn: "rotate", a });
/**
 * Returns an ITransformProxy function representing the `rotateX()` CSS function.
 *
 * @category Transform
 */
const rotateX = (a) => ({ fn: "rotateX", a });
/**
 * Returns an ITransformProxy function representing the `rotateY()` CSS function.
 *
 * @category Transform
 */
const rotateY = (a) => ({ fn: "rotateY", a });
/**
 * Returns an ITransformProxy function representing the `rotateZ()` CSS function.
 *
 * @category Transform
 */
const rotateZ = (a) => ({ fn: "rotateZ", a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotate = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotateX = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotateY = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotateZ = 4 /* Angle */;
/**
 * Returns an IRotate3dFunc function representing the `rotate3d()` CSS function.
 *
 * @category Transform
 */
const rotate3d = (x, y, z, a) => ({ fn: "rotate3d", x, y, z, a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.rotate3d = ["x", "y", "z", ["a", 4 /* Angle */]];
/**
 * Returns an IScaleFunc function representing the `scale()` CSS function.
 *
 * @category Transform
 */
const scale = (sx, sy) => ({ fn: "scale", sx, sy });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.scale = ["sx", "sy"];
/**
 * Returns an IScale1dFunc function representing the `scaleX()` CSS function.
 *
 * @category Transform
 */
const scaleX = (s) => ({ fn: "scaleX", s });
/**
 * Returns an IScale1dFunc function representing the `scaleY()` CSS function.
 *
 * @category Transform
 */
const scaleY = (s) => ({ fn: "scaleY", s });
/**
 * Returns an IScale1dFunc function representing the `scaleZ()` CSS function.
 *
 * @category Transform
 */
const scaleZ = (s) => ({ fn: "scaleZ", s });
/**
 * Returns an IScale3dFunc function representing the `scale3d()` CSS function.
 *
 * @category Transform
 */
const scale3d = (sx, sy, sz) => ({ fn: "scale3d", sx, sy, sz });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.scale3d = ["sx", "sy", "sz"];
/**
 * Returns an ISkewFunc function representing the `skew()` CSS function.
 *
 * @category Transform
 */
const skew = (ax, ay) => ({ fn: "skew", ax, ay });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.skew = {
    p: ["ax", "ay"],
    do: 4 /* Angle */
};
/**
 * Returns an ISkew1dFunc function representing the `skewX()` CSS function.
 *
 * @category Transform
 */
const skewX = (a) => ({ fn: "skewX", a });
/**
 * Returns an ISkew1dFunc function representing the `skewY()` CSS function.
 *
 * @category Transform
 */
const skewY = (a) => ({ fn: "skewY", a });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.skewX = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.skewY = 4 /* Angle */;
/**
 * Returns an ITranslateFunc function representing the `translate()` CSS function.
 *
 * @category Transform
 */
const translate = (x, y) => ({ fn: "translate", x, y });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translate = {
    p: ["x", "y"],
    do: 3 /* Length */
};
/**
 * Returns an ITranslate1dFunc function representing the `translateX()` CSS function.
 *
 * @category Transform
 */
const translateX = (d) => ({ fn: "translateX", d });
/**
 * Returns an ITranslate1dFunc function representing the `translateY()` CSS function.
 *
 * @category Transform
 */
const translateY = (d) => ({ fn: "translateY", d });
/**
 * Returns an ITranslate1dFunc function representing the `translateZ()` CSS function.
 *
 * @category Transform
 */
const translateZ = (d) => ({ fn: "translateZ", d });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translateX = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translateY = _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translateZ = 3 /* Length */;
/**
 * Returns an ITranslate3dFunc function representing the `translate3d()` CSS function.
 *
 * @category Transform
 */
const translate3d = (x, y, z) => ({ fn: "translate3d", x, y, z });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.translate3d = {
    p: ["x", "y", "z"],
    do: 3 /* Length */
};
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Basic shapes
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns an IInsetBuilder object representing the `inset()` CSS function.
 *
 * *Example:*
 *
 * ```typescript
 * clipPath: inset( css.percent(15))
 *
 * clipPath: inset( 10, 12, 14, 16).round( 8)
 * ```
 *
 * @category Basic Shape
 */
const inset = (o1, o2, o3, o4) => ({
    fn: "inset", o1, o2, o3, o4,
    round(r) { this.r = r; return this; }
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.inset = {
    p: ["o1", "o2", "o3", "o4", ["r", v => "round " + _impl_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[20](v)]],
    do: 3 /* Length */,
    s: " "
};
/**
 * Returns an ICircleBuilder object representing the `circle()` CSS function.
 *
 * *Example:*
 *
 * ```typescript
 * clipPath: circle( 100)
 *
 * clipPath: circle( 100).at( ["center", css.percent(30)])
 * ```
 *
 * @category Basic Shape
 */
const circle = (r) => ({
    fn: "circle", r,
    at(pos) { this.pos = pos; return this; }
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.circle = {
    p: [["r", 3 /* Length */], ["pos", 9 /* AtPosition */]],
    s: " "
};
// implementation
function ellipse() {
    return {
        fn: "ellipse", rx: arguments[0], ry: arguments[1],
        at(pos) { this.pos = pos; return this; }
    };
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.ellipse = {
    p: ["rx", "ry", ["pos", 9 /* AtPosition */]],
    do: 3 /* Length */,
    s: " "
};
/**
 * Returns an IPolygon object representing the `polygon()` CSS function.
 *
 * *Example:*
 *
 * ```typescript
 * clipPath: css.polygon( [0,100], [50,0], [100,100])
 *
 * clipPath: css.polygon( [0,100], [50,0], [100,100]).fill( "evenodd")
 * ```
 *
 * @category Basic Shape
 */
const polygon = (...points) => ({
    fn: "polygon", points: points ?? [],
    add(...points) { this.points.push(...points); return this; },
    fill(rule) { this.rule = rule; return this; }
});
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.polygon = [
    "rule",
    ["points", { item: 13 /* MultiLengthWithSpace */, sep: "," }],
];
/**
 * Returns an IPathBuilder object that allows building a CSS path.
 *
 * @category Basic Shape
 */
const path = (fillRule) => new PathBuilder(fillRule);
/**
 * The IPathBuilder interface represents the object that accumulates path commands that are then
 * converted to a string parameter of the CSS `path()` function.
 */
class PathBuilder {
    constructor(rule) {
        this.fn = "path";
        this.items = [];
        this.rule = rule;
    }
    // Adds the given command and parameters to the path.
    add(command, params) {
        this.items.push([command, params]);
        return this;
    }
    M(...params) { return this.add("M", params); }
    m(...params) { return this.add("m", params); }
    L(...params) { return this.add("L", params); }
    l(...params) { return this.add("l", params); }
    H(...params) { return this.add("H", params); }
    h(...params) { return this.add("h", params); }
    V(...params) { return this.add("V", params); }
    v(...params) { return this.add("v", params); }
    C(...params) { return this.add("C", params); }
    c(...params) { return this.add("c", params); }
    S(...params) { return this.add("S", params); }
    s(...params) { return this.add("s", params); }
    Q(...params) { return this.add("Q", params); }
    q(...params) { return this.add("q", params); }
    T(...params) { return this.add("T", params); }
    t(...params) { return this.add("t", params); }
    A(...params) { return this.add("A", params); }
    a(...params) { return this.add("a", params); }
    z() { return this.add("z"); }
}
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.path = ["rule", ["items", (v) => `"${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v)}"`]];
/**
 * Returns an IRay object representing invocation of the `ray()` CSS function.
 *
 * @category Basic Shape
 */
const ray = (angle, size, contain) => ({ fn: "ray", angle, size, contain });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.ray = {
    p: [
        ["angle", 4 /* Angle */],
        ["size", 3 /* Length */],
        ["contain", (v) => (v ? "contain" : "")]
    ],
    s: " "
};
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Grids
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
* Returns an IMinMax function representing the `minmax()` CSS function.
*
* @category Grid
*/
const minmax = (min, max) => ({ fn: "minmax", min, max });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.minmax = [["min", 3 /* Length */], ["max", 3 /* Length */]];
/**
 * Returns an IRepeat function representing the `repeat()` CSS function.
 *
 * @category Grid
 */
const repeat = (count, ...tracks) => ({ fn: "repeat", count, tracks });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.repeat = ["count", ["tracks", { item: 22 /* GridTrack */ }]];
/**
 * Returns an IGridSpanFunc function representing the `span` expression for grid layouts. If the first
 * parameter is a number, the second parameter (if defined) must be a name; if the first parameter
 * is a name, the second parameter (if defined) must be a number.
 *
 * @category Grid
 */
const span = (p1, p2) => ({ fn: "span", p1, p2 });
_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo.span = (v) => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_0__.mv2s)(["span", v.p1, v.p2]);


/***/ }),

/***/ "./lib/api/ShapeTypes.js":
/*!*******************************!*\
  !*** ./lib/api/ShapeTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/StyleAPI.js":
/*!*****************************!*\
  !*** ./lib/api/StyleAPI.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerStyleProperty": () => (/* binding */ registerStyleProperty),
/* harmony export */   "getStylePropValue": () => (/* binding */ getStylePropValue),
/* harmony export */   "setElementStyle": () => (/* binding */ setElementStyle),
/* harmony export */   "setElementStringStyle": () => (/* binding */ setElementStringStyle),
/* harmony export */   "stylesetToString": () => (/* binding */ stylesetToString),
/* harmony export */   "stylesetToStringStyleset": () => (/* binding */ stylesetToStringStyleset),
/* harmony export */   "diffStylesets": () => (/* binding */ diffStylesets),
/* harmony export */   "media": () => (/* binding */ media),
/* harmony export */   "mediaToString": () => (/* binding */ mediaToString),
/* harmony export */   "supports": () => (/* binding */ supports),
/* harmony export */   "supportsToString": () => (/* binding */ supportsToString),
/* harmony export */   "createCssSerializer": () => (/* binding */ createCssSerializer),
/* harmony export */   "serializeToCSS": () => (/* binding */ serializeToCSS)
/* harmony export */ });
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");
/* harmony import */ var _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rules/RuleContainer */ "./lib/rules/RuleContainer.js");
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");





///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Styleset manipulation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Registers the given function to be used for converting values of the given style property to
 * string. The `registerStyleProperty` function must be used after adding the property to the
 * [[IStyleset]] interface via the module augmentation technique if the conversion to string
 * requires non-standard operations. This function should not be called for propeties whose
 * values only include numbers, strings, functions returning a string, objects whose `toString`
 * method produces the necessary string or arrays of the above types.
 *
 * This function can be used for style properties that are not yet supported by Mimcss. This is
 * also the way to support properties with vendor prefixes.
 */
const registerStyleProperty = (name, toStringFunc) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s_registerSP)(name, toStringFunc);
/**
 * Converts the given value corresponding to the given style property to a CSS string.
 * @param stylePropName Style property name that determines how the value should be converted
 * to a CSS compliant string.
 * @param stylePropValue Value to convert.
 */
const getStylePropValue = (stylePropName, stylePropValue) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(stylePropName, stylePropValue);
// Sets style property on HTML or SVG element
const setElementStyleProp = (elm, name, value, schedulerType) => (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_1__.scheduleStyleUpdate)(elm, name, (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(name, value), false, schedulerType);
/**
 * Sets values of the style properties from the given Styleset object to the `style` attribute
 * of the given HTML element.
 * @param elm HTML/SVG element whose styles will be set.
 * @param styleset Styleset object which provides values for style properties.
 */
const setElementStyle = (elm, styleset, schedulerType) => setElementStringStyle(elm, styleset ? stylesetToStringStyleset(styleset) : null, schedulerType);
/**
 * Sets values of the style properties from the given StringStyleset object to the `style` attribute
 * of the given HTML element.
 * @param elm HTML/SVG element whose styles will be set.
 * @param styleset [[StringStyleset]] object which provides values for style properties.
 */
const setElementStringStyle = (elm, styleset, schedulerType) => (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_1__.scheduleStyleUpdate)(elm, null, styleset, false, schedulerType);
/**
 * Serializes the given [[Styleset]] to a string.
 * @param styleset
 */
const stylesetToString = (styleset) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.styleset2s)(styleset);
/**
 * Converts the given [[Styleset]] object into an object, where each Styleset's property is
 * converted to its string value.
 * @param styleset
 */
const stylesetToStringStyleset = (styleset) => (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(styleset);
/**
 * Compares two Styleset objects by converting style properties to strings and returns an object
 * that contains string values of properties that were new or have different values in the new
 * styleset and undefined values for properties that exist in the old styleset but don't exist
 * in the new one.
 * @param oldStyleset
 * @param newStyleset
 * @returns StringStyleset object with properties that have different values in the old and new
 * stylesets. Properties that existed in the old but don't exist in the new styleset, will have
 * their values set to `"unset"`. If there is no differences between the two stylesets null is
 * returned.
 */
const diffStylesets = (oldStyleset, newStyleset) => {
    if (!oldStyleset && !newStyleset)
        return null;
    else if (!oldStyleset)
        return (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(newStyleset);
    else if (!newStyleset)
        return (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(oldStyleset);
    // first convert both stylesets to their string versions
    let oldStringStyleset = (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(oldStyleset);
    let newStringStyleset = (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.s2ss)(newStyleset);
    let updateVal = null;
    // loop over keys in the old style object and find those that are not in the new one. These
    // will be removed.
    for (let key in oldStringStyleset) {
        let newStringVal = newStringStyleset[key];
        if (newStringVal == null) {
            updateVal = updateVal || {};
            updateVal[key] = "unset";
        }
        else {
            let oldStringVal = oldStringStyleset[key];
            if (oldStringVal !== newStringVal) {
                updateVal = updateVal || {};
                updateVal[key] = newStringVal;
            }
        }
    }
    // loop over keys in the new style object and find those that are not in the old one. These
    // will be added.
    for (let key in newStringStyleset) {
        let oldStringVal = oldStringStyleset[key];
        if (oldStringVal == null) {
            updateVal = updateVal || {};
            updateVal[key] = newStringStyleset[key];
        }
    }
    return updateVal;
};
// functions on HTML and SVG element prototypes
HTMLElement.prototype.setStyleProp = setThisElementStyleProp;
SVGElement.prototype.setStyleProp = setThisElementStyleProp;
HTMLElement.prototype.setStyleset = setThisElementStyle;
SVGElement.prototype.setStyleset = setThisElementStyle;
// Sets style property on HTML or SVG element
function setThisElementStyleProp(name, value, schedulerType) {
    setElementStyleProp(this, name, value, schedulerType);
}
function setThisElementStyle(styleset, schedulerType) {
    setElementStyle(this, styleset, schedulerType);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// @media and @supports queries.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Tag function that represents a media query. This function allows expressing media queries in
 * a natural string form while embedding media feature values in type safe manner. The string can
 * contain any media expressions while the embedded objects must be of type [[IMediaFeatureset]].
 * Multiple features in the feature set will be expanded into clauses combined with the "and"
 * operator.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends StyleDefinition
 * {
 *     // screen and (min-width: 400px) and (max-width: 600px) and (orientation: portrait)
 *     ifNarrowDevice = this.$media(
 *         css.media`screen and ${{width:[400,600], orientation: "portrait"}}`, ...)
 * }
 * ```
 */
const media = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_4__.tag2s)(parts, params, v => typeof v === "string" ? v : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_3__.media2s)(v));
/**
 * Converts the given media query value to the CSS media query string. This function can be used
 * by libraries that allow specifying [[MediaStatement]] for the `media` attribute of elements
 * such as `<link>`, `<style>` and `<source>`
 */
const mediaToString = (query) => (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_3__.media2s)(query);
/**
 * Tag function that represents a supports query. This function allows expressing supports
 * queries in a natural string form while embedding media feature values in type safe manner. The
 * string can contain any supports expressions while the embedded objects must be of type
 * Styleset. Multiple properties in the styleset will be expanded into clauses combined with the
 * "or" operator.
 *
 * **Example:**
 *
 * ```typescript
 * class MyStyles extends StyleDefinition
 * {
 *     // not (transform-origin: 30px 30px 30px)
 *     ifNoTransformOrigin = this.$supports(
 *         css.supports`not (${{transform-origin: [30, 30, 30]}})`, ...)
 * }
 * ```
 */
const supports = (parts, ...params) => () => (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_4__.tag2s)(parts, params, v => typeof v === "string" ? v : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_3__.supports2s)(v));
/**
 * Converts the given supports query value to the CSS supports query string.
 */
const supportsToString = (query) => (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_3__.supports2s)(query);
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Style serialization.
//
///////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Creates a new ICssSerializer object that allows adding style definition classes
 * and instances and serializing them to a string. This can be used for server-side rendering when
 * the resultant string can be set as the content of a `<style>` element.
 */
const createCssSerializer = () => new CssSerializer();
/**
 * Serializes one or more style definition classes and instances and returns their CSS string
 * representation. This can be used for server-side rendering when the resultant string can be
 * set as the content of a `<style>` element.
 */
const serializeToCSS = (...args) => {
    if (args.length === 0)
        return "";
    let serializer = new CssSerializer();
    args.forEach(instOrClass => serializer.add(instOrClass));
    return serializer.serialize();
};
/**
 * The StyleSerializer class allows adding style definition classes and objects
 * and serializing them to a single string. This can be used for server-side rendering when
 * the resultant string can be set as the content of a `<style>` element.
 */
class CssSerializer {
    constructor() {
        // Set of style definition instances. This is needed to not add style definitions more than once
        this.sds = new Set();
    }
    /**
     * Adds style definition class or instance.
     */
    add(instOrClass) {
        let instance = (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_2__.processSD)(instOrClass);
        if (!instance || this.sds.has(instance))
            return;
        this.sds.add(instance);
    }
    /**
     * Returns concatenated string representation of all CSS rules added to the context.
     */
    serialize() {
        if (this.sds.size === 0)
            return "";
        let ctx = new RuleSerializationContext();
        this.sds.forEach(instance => ctx.addSD(instance));
        return ctx.tl + ctx.ntl;
    }
}
/**
 * The RuleSerializationContext class implements the IRuleSerializationContext interface and
 * accumulates text of serialized CSS rules.
 */
class RuleSerializationContext {
    constructor() {
        // String buffer that accumulates top-level rule texts.
        this.tl = "";
        // String buffer that accumulates non-top-level rule texts.
        this.ntl = "";
        // Set of style definition instances that were already serialized in this context.
        this.sds = new Set();
    }
    // Adds rule text
    addRule(s, isTopLevelRule) {
        if (isTopLevelRule)
            this.tl += s;
        else
            this.ntl += s;
    }
    // Adds rule text
    addSD(instance) {
        if (!this.sds.has(instance)) {
            this.sds.add(instance);
            (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_2__.serializeSD)(instance, this);
        }
    }
}


/***/ }),

/***/ "./lib/api/StyleTypes.js":
/*!*******************************!*\
  !*** ./lib/api/StyleTypes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/api/Stylesets.js":
/*!******************************!*\
  !*** ./lib/api/Stylesets.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./lib/impl/CoreImpl.js":
/*!******************************!*\
  !*** ./lib/impl/CoreImpl.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selector2s": () => (/* binding */ selector2s)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS selector.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Returns a string representation of a selector.
 */
const selector2s = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { sep: "", recursive: true });
// Converting attribute selector definition to string
_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo["attr-sel"] = (v) => `[${v.ns ? (typeof v.ns === "string" ? v.ns : v.ns.prefix) + "|" : ""}${v.name}` +
    (v.val == null ? "]" : `${v.op ?? "="}"${v.val}"${v.cf ? " " + v.cf : ""}]`);
// Converting "nth" pseudo classes to string
_Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-child"] = _Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-last-child"] = _Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-of-type"] = _Utils__WEBPACK_IMPORTED_MODULE_0__.fdo[":nth-last-of-type"] = [
    ["p", {
            arr: [
                v => v + "n",
                v => !v ? "" : v > 0 ? "+" + v : "-" + -v
            ],
            sep: ""
        }]
];
// // Converting pseudo entities that accept CssSelector to string
// fdo[":is"] = fdo[":has"] = fdo[":host-context"] = fdo[":not"] = fdo[":where"] = fdo["::slotted"] = [
//     ["p", selector2s]
//     // ["p", {sep: ",", recursive: true}]
// ]


/***/ }),

/***/ "./lib/impl/MiscImpl.js":
/*!******************************!*\
  !*** ./lib/impl/MiscImpl.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "media2s": () => (/* binding */ media2s),
/* harmony export */   "supports2s": () => (/* binding */ supports2s),
/* harmony export */   "fontFace2s": () => (/* binding */ fontFace2s),
/* harmony export */   "counterStyleset2s": () => (/* binding */ counterStyleset2s)
/* harmony export */ });
/* harmony import */ var _StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @media rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given media query object to the CSS media query string
 */
const media2s = (statement) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(statement, {
    any: mediaQuery2s,
    sep: ","
});
/**
 * Converts the given media query object to the CSS media query string
 */
const mediaQuery2s = (query) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.propSet2s)(query, mediaFeatureInfos, {
    separator: " and ",
    propFunc: mediaFeature2s,
});
/**
 * Converts the given media feature to the CSS media query string
 */
const mediaFeature2s = (dashName, camelName, val, options) => {
    if (val == null)
        return "";
    // if defaultValue is defined and the property value is equal to it, no value should be returned.
    let defaultValue = mediaFeatureDefaultValues.get(camelName);
    if (defaultValue !== undefined && val === defaultValue)
        return dashName;
    let isRange = rangeMediaFeatures.has(camelName);
    if (isRange && Array.isArray(val)) {
        return `(${"min-" + dashName}:${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(val[0], options)}) and (${"max-" + dashName}:${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(val[1], options)})`;
        // this syntax is not widely supported yet
        // return `${s1} <= ${dashName} <= ${s2}`;
    }
    else
        return `(${dashName}:${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(val, options)})`;
};
const mediaFeatureInfos = {
    aspectRatio: {
        num: (v) => v + "/1"
    },
    height: 3 /* Length */,
    minHeight: 3 /* Length */,
    maxHeight: 3 /* Length */,
    resolution: 6 /* Resolution */,
    minResolution: 6 /* Resolution */,
    maxResolution: 6 /* Resolution */,
    width: 3 /* Length */,
    minWidth: 3 /* Length */,
    maxWidth: 3 /* Length */,
};
// Set of media features that allow range of values
const rangeMediaFeatures = new Set(["aspectRatio", "color", "colorIndex", "height", "monochrome", "resolution", "width"]);
// Map of media features to default values
const mediaFeatureDefaultValues = new Map([
    ["color", 0],
    ["colorIndex", 0],
    ["monochrome", 0]
]);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @supports rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/** Converts the given supports statement to its string representation */
const supports2s = (statement) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(statement, {
    any: supportsQuery2s,
    sep: " or "
});
/** Converts the given supports query to its string representation */
const supportsQuery2s = (query) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(query, {
    obj: (v) => {
        let propNames = Object.keys(v);
        if (propNames.length === 0)
            return "";
        return `(${propNames.map((propName) => `${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.camelToDash)(propName)}:${(0,_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(propName, query[propName])}`).join(") and (")})`;
    }
});
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @font-face rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given font face object to the CSS style string.
 */
const fontFace2s = (fontface) => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.propSet2s)(fontface, fontFacePropertyInfos);
_Utils__WEBPACK_IMPORTED_MODULE_1__.wkf[24] = v => (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(v, {
    num: v => `oblique ${_Utils__WEBPACK_IMPORTED_MODULE_1__.wkf[4](v)}`,
    arr: v => `oblique ${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.a2s)(v, 4 /* Angle */)}`
});
/**
 * Map of property names to the V2SOptions objects describing custom actions necessary to
 * convert the property value to the CSS-compliant string.
 */
const fontFacePropertyInfos = {
    ascentOverride: 2 /* Percent */,
    descentOverride: 2 /* Percent */,
    fontStretch: { any: 2 /* Percent */ },
    fontStyle: 24 /* FontStyle */,
    fontWeight: { any: 1 /* Number */ },
    lineGapOverride: 2 /* Percent */,
    src: {
        any: {
            obj: [
                ["local", v => `local(${v})`],
                ["url", v => `url(${v})`],
                ["format", {
                        any: v => `format(\"${v}\")`,
                        sep: ","
                    }]
            ]
        },
        sep: ","
    },
    sizeAdjust: 2 /* Percent */,
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSS @counter-style rule.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given counter styleset property to the CSS style string. Property name can be in
 * either dash or camel form.
 */
const counterStylesetProp2s = (propName, propVal, includeName) => {
    if (!propName)
        return "";
    // convert the value to string based on the information object for the property (if defined)
    let stringValue = (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(propVal, counterStylePropertyInfos[(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.dashToCamel)(propName)]);
    // if the resulting string is empty and the name should be included, then we return
    // "name:; otherwise we will return an empty string.
    if (!stringValue && includeName)
        stringValue = "";
    return includeName ? `${(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.camelToDash)(propName)}:${stringValue}` : stringValue;
};
/**
 * Converts the given counter styleset object to the CSS media query string
 */
const counterStyleset2s = (counterStyleset) => {
    if (!counterStyleset)
        return "";
    let s = "";
    for (let name in counterStyleset)
        s += counterStylesetProp2s(name, counterStyleset[name], true) + ";";
    return s;
};
/**
* Map of property names to the V2SOptions objects describing custom actions necessary to
* convert the property value to the CSS-compliant string.
*/
const counterStylePropertyInfos = {
    system: {
        num: v => "fixed " + v,
        arr: v => "extends " + (0,_Utils__WEBPACK_IMPORTED_MODULE_1__.v2s)(v[0])
    },
    negative: {
        any: 23 /* Quoted */
    },
    prefix: 23 /* Quoted */,
    suffix: 23 /* Quoted */,
    range: {
        arr2: { sep: "," }
    },
    pad: {
        item: 23 /* Quoted */
    },
    symbols: {
        item: 23 /* Quoted */
    },
    additiveSymbols: {
        arr2: { item: { item: 23 /* Quoted */ }, sep: "," },
        any: 23 /* Quoted */
    },
};


/***/ }),

/***/ "./lib/impl/NumericImpl.js":
/*!*********************************!*\
  !*** ./lib/impl/NumericImpl.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NumericMath": () => (/* binding */ NumericMath),
/* harmony export */   "NumberMath": () => (/* binding */ NumberMath),
/* harmony export */   "PercentMath": () => (/* binding */ PercentMath),
/* harmony export */   "LengthMath": () => (/* binding */ LengthMath),
/* harmony export */   "AngleMath": () => (/* binding */ AngleMath),
/* harmony export */   "TimeMath": () => (/* binding */ TimeMath),
/* harmony export */   "ResolutionMath": () => (/* binding */ ResolutionMath),
/* harmony export */   "FrequencyMath": () => (/* binding */ FrequencyMath)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Numbers
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts a single numeric value to a CSS string optionally appending units that can be different
 * for integer and floating point numbers.
 * @param n Number to convert to string representation.
 * @param intUnit Units to append if the number is integer.
 * @param floatUnit Units to append if the number is floating point.
 */
const numberToString = (n, intUnit = "", floatUint = "") => n + (Number.isInteger(n) ? intUnit : floatUint);
/**
 * The NumericMath class contains methods that implement CSS mathematic functions on the
 * numeric CSS types. When arguments for these functions are of the number JavaScript type they
 * are converted to strings by calling a function specified in the constructor.
 */
class NumericMath {
    constructor(n2s) {
        this.n2s = n2s;
    }
    v2s(val) {
        return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { num: this.n2s });
    }
    mv2s(val, separator) {
        return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
            any: v => this.v2s(v),
            sep: separator
        });
    }
    /** Creates CssLength value from the number and the given unit. */
    units(n, unit) {
        return () => n + unit;
    }
    min(...params) {
        return () => this.m("min", params);
    }
    max(...params) {
        return () => this.m("max", params);
    }
    clamp(min, pref, max) {
        // return () => mathFunc( "clamp", [min, pref, max], this.n2s);
        return () => this.m("clamp", [min, pref, max]);
    }
    calc(formulaParts, ...params) {
        return () => `calc(${(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.tag2s)(formulaParts, params, (v) => this.v2s(v))})`;
    }
    m(name, params) {
        return `${name}(${this.mv2s(params, ",")})`;
    }
}
/**
 * The NumberMath object contains methods that implement CSS mathematic functions on the `<number>`
 * CSS type.
 */
const NumberMath = new NumericMath(n => n.toString());
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[1] = v => NumberMath.v2s(v);
/**
 * The PercentMath object contains methods that implement CSS mathematic functions on the
 * `<percentage>` CSS type by appending a "%" unit suffix. If the number is between -1 and 1 (non
 * inclusive), multiplies the number by 100.
 */
const PercentMath = new NumericMath(n => (n >= 1 || n <= -1 ? n : Math.round(n * 100)) + "%");
/**
 * Converts the given number to string using the following rules:
 * - if the number is between -1 and 1 (non inclusive), multiplies the number by 100 and appends "%"
 * - otherwise, converts the number to string without appending any units.
 */
const unitlessOrPercentToString = (n) => n >= 1 || n <= -1 ? n.toString() : (Math.round(n * 100) + "%");
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[2] = v => PercentMath.v2s(v);
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[17] = unitlessOrPercentToString;
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[27] = v => v + "%";
/**
 * The LengthMath object contains methods that implement CSS mathematic functions on the `<length>`
 * CSS type by appending a length unit suffix.
 * Integer numbers use "px"; floating point numbers use "em".
 */
const LengthMath = new NumericMath(n => numberToString(n, "px", "em"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[3] = v => LengthMath.v2s(v);
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[13] = v => LengthMath.mv2s(v, " ");
/**
 * The AngleMath object contains methods that implement CSS mathematic functions on the `<angle>`
 * CSS type by appending an angle unit suffix.
 * Integer numbers use "deg"; floating point numbers use "turn".
 */
const AngleMath = new NumericMath(n => numberToString(n, "deg", "turn"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[4] = v => AngleMath.v2s(v);
/**
 * The TimeMath object contains methods that implement CSS mathematic functions on the `<time>`
 * CSS type by appending a time unit suffix.
 * Integer numbers use "ms"; floating point numbers use "s".
 */
const TimeMath = new NumericMath(n => numberToString(n, "ms", "s"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[5] = v => TimeMath.v2s(v);
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[14] = v => TimeMath.mv2s(v, ",");
/**
 * The ResolutionMath object contains methods that implement CSS mathematic functions on the
 * `<resolution>` CSS type by appending a resolution unit suffix.
 * Integer numbers use "dpi"; floating point numbers use "x".
 */
const ResolutionMath = new NumericMath(n => numberToString(n, "dpi", "x"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[6] = v => ResolutionMath.v2s(v);
/**
 * The FrequencyMath object contains methods that implement CSS mathematic functions on the
 * `<frequency>` CSS type by appending a frequency unit suffix.
 * Integer numbers use "Hz"; floating point numbers use "kHz".
 */
const FrequencyMath = new NumericMath(n => numberToString(n, "Hz", "kHz"));
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[7] = v => FrequencyMath.v2s(v);
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Size, Point, Position, Radius
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// // Converts single position style value to the CSS string.
// const pos2s = (val: Extended<CssPosition>): string => v2s( val, { any: WKF.Length });
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[8] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, { any: 3 /* Length */ });
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[9] = (v) => v == null ? "" : "at " + _Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[8](v);
/**
 * Converts multi-position style value to the CSS string.
 */
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[12] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    arr2: { any: 8 /* Position */, sep: "," },
    any: 8 /* Position */
});
// Converts corner radius style value to the CSS string.
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[18] = (v) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, { any: 3 /* Length */ });
/**
 * Converts border radius style value to the CSS string.
 */
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[20] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    arr2: { any: { any: 3 /* Length */ }, sep: "/" },
    any: 3 /* Length */
});


/***/ }),

/***/ "./lib/impl/SchedulingImpl.js":
/*!************************************!*\
  !*** ./lib/impl/SchedulingImpl.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scheduleStyleUpdate": () => (/* binding */ scheduleStyleUpdate),
/* harmony export */   "getActivator": () => (/* binding */ getActivator),
/* harmony export */   "getDefaultScheduler": () => (/* binding */ getDefaultScheduler),
/* harmony export */   "setDefaultScheduler": () => (/* binding */ setDefaultScheduler),
/* harmony export */   "registerScheduler": () => (/* binding */ registerScheduler),
/* harmony export */   "unregisterScheduler": () => (/* binding */ unregisterScheduler)
/* harmony export */ });
/* harmony import */ var _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rules/RuleContainer */ "./lib/rules/RuleContainer.js");

/**
 * Set the value of either a single property or a set of properties in the given
 * CSS style object.
 */
const updateStyleProperty = (ruleOrElm, name, value, important) => {
    if (!name && value == null) {
        if (ruleOrElm instanceof CSSStyleRule)
            ruleOrElm.cssText = "";
        else
            ruleOrElm.removeAttribute("style");
    }
    else if (name) {
        if (value == null)
            ruleOrElm.style.removeProperty(name);
        else
            ruleOrElm.style.setProperty(name, value, important ? "important" : undefined);
    }
    else {
        let styleset = value;
        for (let propName in styleset)
            ruleOrElm.style[propName] = styleset[propName];
    }
};
/**
 * The SynchronousActivator class represents the synchronous activation mechanism, which writes
 * style changes to the DOM when the activate and deactivate functions are called.
 */
class SynchronousActivator {
    /**
     * Instructs to activate the given style definition instance. This method is called when the
     * activate function is called for this activation mechanism.
     * @param definition
     */
    activate(definition) {
        (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.activateSD)(definition);
    }
    /**
     * Instructs to deactivate the given style definition instance. This method is called when the
     * deactivate function is called for this activation mechanism.
     * @param definition
     */
    deactivate(definition) {
        (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.deactivateSD)(definition);
    }
    /**
     * Instructs to set the value of either a single property or a set of properties in the given
     * CSS style object.
     */
    updateStyle(ruleOrElm, name, value, important) {
        updateStyleProperty(ruleOrElm, name, value, important);
    }
    /**
     * Performs activation/deactivation for all style definitions accumulated since the last
     * activation/deactivation. This method is called when the forceDOMUpdate function is called
     * for this activation mechanism.
     */
    forceDOMUpdate() { }
    /**
     * Cancels activation/deactivation for all style definitions accumulated since the last
     * activation/deactivation. This method is called when the cancelDOMUpdate function is called
     * for this activation mechanism.
     */
    cancelDOMUpdate() { }
}
/**
 * The SchedulingActivator class keeps a map of StyleDefinition instances that are scheduled for
 * activation or deactivation. Each instance is mapped to a refernce count, which is incremented
 * upon the activate calls and decremented upon the deactivate calls. When the doActivation
 * method is called The style definition will be either activated or deactivated based on whether
 * the reference count is positive or negative.
 */
class SchedulingActivator {
    constructor(scheduler) {
        // Array of functions that will be invoked when the scheduled update runs.
        this.actions = [];
        if (scheduler) {
            scheduler.init(() => this.doDOMUpdate());
            this.scheduler = scheduler;
        }
    }
    /**
     * Instructs to activate the given style definition instance.
     */
    activate(definition) {
        if (this.isSchedulingNeeded)
            this.scheduler.scheduleDOMUpdate();
        this.actions.push(() => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.activateSD)(definition));
    }
    /**
     * Instructs to deactivate the given style definition instance.
     */
    deactivate(definition) {
        if (this.isSchedulingNeeded)
            this.scheduler.scheduleDOMUpdate();
        this.actions.push(() => (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.deactivateSD)(definition));
    }
    /**
     * Instructs to set the value of either a single property or a set of properties in the given
     * CSS style object.
     */
    updateStyle(ruleOrElm, name, value, important) {
        if (this.isSchedulingNeeded)
            this.scheduler.scheduleDOMUpdate();
        this.actions.push(() => updateStyleProperty(ruleOrElm, name, value, important));
    }
    /**
     * Performs activation/deactivation for all style definitions in our internal map.
     */
    forceDOMUpdate() {
        if (this.actions.length > 0) {
            this.doDOMUpdate();
            this.scheduler && this.scheduler.cancelDOMUpdate();
        }
    }
    /**
     * Cancels activation/deactivation for all style definitions accumulated since the last
     * activation/deactivation.
     */
    cancelDOMUpdate() {
        if (this.actions.length > 0) {
            this.actions = [];
            this.scheduler && this.scheduler.cancelDOMUpdate();
        }
    }
    get isSchedulingNeeded() {
        return !!this.scheduler && !this.actions.length;
    }
    /**
     * Performs activation/deactivation and property set operations accumulated internally. This
     * method should be used by the derived classes when scheduled activations should be performed.
     */
    doDOMUpdate() {
        // update style properties
        for (let action of this.actions)
            action();
        this.actions = [];
    }
}
/**
 * The AnimationFrameScheduler implements scheduling using animation frames.
 */
class AnimationFrameScheduler {
    constructor() {
        // Handle returned by requestAnimationFrame function.
        this.h = 0;
        /**
         * Is invoked when animation frame should be executed.
         */
        this.onFrame = () => {
            this.h = 0;
            this.cb();
        };
    }
    /**
     * Initializes the scheduler object and provides the callback that should be invoked when the
     * scheduler decides to make changes to the DOM.
     */
    init(doDOMUpdate) {
        this.cb = doDOMUpdate;
    }
    /**
     * Is invoked when the scheduler needs to schedule its callback or event.
     */
    scheduleDOMUpdate() {
        this.h = requestAnimationFrame(this.onFrame);
    }
    /**
     * Is invoked when the scheduler needs to cancels its scheduled callback or event.
     */
    cancelDOMUpdate() {
        if (this.h > 0) {
            cancelAnimationFrame(this.h);
            this.h = 0;
        }
    }
}
/**
 * Schedules the update of the value of the given CSS property in the given rule.
 */
const scheduleStyleUpdate = (ruleOrElm, name, value, important, schedulerType) => getActivator(schedulerType).updateStyle(ruleOrElm, name, value, important);
/**
 * Returns the activator for the given scheduler type. If scheduler type is not specified returns
 * the activator currently set as default. If, for some reason, the default activator is not set,
 * returns the synchronous activator.
 */
const getActivator = (schedulerType) => (schedulerType == null ? s_defaultActivator : s_registeredActivators.get(schedulerType)) ?? s_synchronousActivator;
/**
 * Returns the current default scheduler type.
 */
const getDefaultScheduler = () => s_defaultSchedulerType;
/**
 * Sets the default scheduling type that is used by activate and deactivate functions that are
 * called without explicitly providing value to the scheduling parameter. Returns the type of the
 * previous default activator or 0 if an error occurs (e.g. the given scheduler type ID is not
 * registered).
 */
const setDefaultScheduler = (schedulerType) => {
    // check that the given number is in our map of registered activators
    let activator = s_registeredActivators.get(schedulerType);
    if (!activator)
        return 0;
    let prevSchedulerType = s_defaultSchedulerType;
    s_defaultSchedulerType = schedulerType;
    s_defaultActivator = activator;
    return prevSchedulerType;
};
/**
 * Registers the given scheduler object and returns the scheduler type identifier, which
 * should be used when calling activate and deactivate functions.
 */
const registerScheduler = (scheduler) => {
    // get the registration ID for this scheduler
    let id = s_nextCustomSchedulerType++;
    s_registeredActivators.set(id, new SchedulingActivator(scheduler));
    return id;
};
/**
 * Unregisters a scheduler object with the given scheduler type identifier.
 */
const unregisterScheduler = (id) => {
    if (id >= s_firstCustomSchedulerType) {
        s_registeredActivators.delete(id);
        // if the deleted scheduler was our default one, we set the default to SYNC
        if (s_defaultSchedulerType === id) {
            s_defaultSchedulerType = 1 /* Sync */;
            s_defaultActivator = s_synchronousActivator;
        }
    }
};
/**
 * Current default scheduler. This scheduler will be used if scheduler type is not explicitly
 * specified in calls such as activate or IStyleRule.setProp.
 */
let s_defaultSchedulerType = 1 /* Sync */;
/**
 * Synchronous activator instance.
 */
const s_synchronousActivator = new SynchronousActivator();
/**
 * Current default activator. This activator will be used if scheduler type is not explicitly
 * specified in calls such as activate or IStyleRule.setProp.
 */
let s_defaultActivator = s_synchronousActivator;
/**
 * Scheduler type identifier to be assigned to the first custom scheduler to be registered.
 * All custom scheduler identifiers are greater or equal to this number.
 */
const s_firstCustomSchedulerType = 1001;
/**
 * Scheduler type identifier to be assigned to the next custom scheduler to be registered.
 */
let s_nextCustomSchedulerType = s_firstCustomSchedulerType;
/**
 * Map of registered built-in and custom activators.
 */
const s_registeredActivators = new Map();
/**
 * Register built-in and custom activators.
 */
s_registeredActivators.set(1 /* Sync */, s_synchronousActivator);
s_registeredActivators.set(2 /* AnimationFrame */, new SchedulingActivator(new AnimationFrameScheduler()));
s_registeredActivators.set(3 /* Manual */, new SchedulingActivator());


/***/ }),

/***/ "./lib/impl/StyleImpl.js":
/*!*******************************!*\
  !*** ./lib/impl/StyleImpl.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sp2s": () => (/* binding */ sp2s),
/* harmony export */   "styleset2s": () => (/* binding */ styleset2s),
/* harmony export */   "s2ss": () => (/* binding */ s2ss),
/* harmony export */   "s_registerSP": () => (/* binding */ s_registerSP)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rules/RuleContainer */ "./lib/rules/RuleContainer.js");


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Functions for converting CSS property types to strings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
const borderImageToString = (val) => {
    // if width is specified, but slice is not, we need to set slice to the default 100% value;
    // if outset is specified but width is not. we need to set width to the default 1 value;
    let valCopy = Object.assign({}, val);
    if (val.slice == null && (val.width != null || val.outset != null))
        valCopy.slice = "100%";
    if (val.width == null && val.outset != null)
        valCopy.width = 1;
    return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.o2s)(valCopy, [
        "source",
        "slice",
        ["width", undefined, "/"],
        ["outset", undefined, "/"],
        "repeat",
        "mode"
    ]);
};
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[25] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    obj: [
        ["inset", (v) => v ? "inset" : ""],
        ["x", 3 /* Length */],
        ["y", 3 /* Length */],
        ["blur", 3 /* Length */],
        ["spread", 3 /* Length */],
        ["color", 11 /* Color */]
    ]
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[26] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    obj: 25 /* BoxShadowSingle */,
    item: 25 /* BoxShadowSingle */,
    sep: ","
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[19] = (val) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    num: 3 /* Length */,
    arr: arr => {
        let numbersProcessed = 0;
        return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(arr, item => typeof item === "number"
            ? (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(item, numbersProcessed++ ? 11 /* Color */ : 3 /* Length */)
            : (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(item));
    },
});
const gridTemplateAreasToString = (val) => 
// val can be array of strings or GridTemplateArea_Definition touples
(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
    arr: v => typeof v[0] === "string" ? (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v, 23 /* Quoted */) : createGridTemplateAreasFromDefinitions(v)
});
/**
 * Converts the array of GridTemplateArea_Definition objects to a string that is suitable for
 * the grid-template-areas format.
 */
const createGridTemplateAreasFromDefinitions = (defs) => {
    // calculate total size of the matrix from the areas' sizes
    let rowCount = 0, colCount = 0;
    for (let def of defs) {
        rowCount = Math.max(rowCount, def[3]);
        colCount = Math.max(colCount, def[4]);
    }
    if (rowCount === 0 || colCount === 0)
        return "";
    // create array of rows where every element is an array of cells
    let matrix = new Array(rowCount);
    for (let i = 0; i < rowCount; i++)
        matrix[i] = new Array(colCount);
    // go over definitions and fill the appropriate places in the cells with area names
    for (let def of defs) {
        let name = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(def[0]);
        for (let i = def[1]; i <= def[3]; i++) {
            for (let j = def[2]; j <= def[4]; j++)
                matrix[i - 1][j - 1] = name;
        }
    }
    // go over our matrix and for every row create a quoted string. Since our cell arrays may be
    // sparse, use dot for the undefined cells
    let s = "";
    for (let i = 0; i < rowCount; i++) {
        let rowNames = [];
        for (let j = 0; j < rowCount; j++) {
            let name = matrix[i][j];
            rowNames.push(name ? name : ".");
        }
        s += `"${rowNames.join(" ")}"\n`;
    }
    return s;
};
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[22] = (v) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, {
    num: 3 /* Length */,
    arr: v => `[${(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.a2s)(v)}]`
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[21] = (v) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(v, {
    num: 3 /* Length */,
    item: 22 /* GridTrack */
});
_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[29] = (val) => {
    return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(val, {
        obj: v => `url(#${v.name})`
    });
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Functions for handling Stylesets.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts the given style property to the CSS style string. Property name can be in either
 * dash or camel form.
 */
const sp2s = (propName, propVal) => {
    if (!propName)
        return "";
    // handle special properties "!" and "[]"
    let impFlag = false;
    if (typeof propVal === "object") {
        if ("!" in propVal) {
            // if the property value is an object with the "!" property, then the actual value is
            // the value of this property and we also need to set the "!important" flag.
            propVal = propVal["!"];
            impFlag = true;
        }
        else if ("[]" in propVal) {
            // If the property value is an object with the "[]" property, then we take the last
            // value from this property's array.
            let arr = propVal["[]"];
            if (!arr || arr.length === 0)
                return "";
            // recurse with the last value from the array
            return sp2s(propName, arr[arr.length - 1]);
        }
    }
    // convert the value to string based on the information object for the property (if defined)
    let stringValue = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.v2s)(propVal, stylePropertyInfos[(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(propName)]);
    if (!stringValue)
        return "";
    if (impFlag)
        stringValue += " !important";
    return stringValue;
};
/** Converts the given styleset to its string representation */
const styleset2s = (styleset) => {
    if (!styleset)
        return "{}";
    let s = "{";
    // enumerate all styleset properties retrieving also vendor-prefixed variants
    forAllPropsInStylset(styleset, (name, value, isCustom, isPrefixed) => {
        s += isCustom
            ? `${name}:${value};`
            : `${isPrefixed ? "-" : ""}${(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.camelToDash)(name)}:${value};`;
    });
    return s + "}";
};
/**
 * Converts the given Styleset object into a StringStyleset object, where each Styleset's property
 * is converted to its string value.
 */
const s2ss = (styleset) => {
    // enumerate all styleset properties without retrieving vendor-prefixed variants
    let res = {};
    forAllPropsInStylset(styleset, (name, value) => { res[name] = value; });
    return res;
};
/**
 * Extracts name, template and string tuples from the given custom CSS property definition.
 * @param customVars
 */
const getVarsNTVs = (customVars) => {
    if (Array.isArray(customVars)) {
        let varName;
        let template;
        let value;
        if (customVars.length === 2) {
            varName = customVars[0].name;
            template = customVars[0].template;
            value = customVars[1];
        }
        else {
            varName = customVars[0];
            template = customVars[1];
            value = customVars[2];
        }
        if (!varName || !template)
            return [];
        if (!varName.startsWith("--"))
            varName = "--" + varName;
        return [[varName, template, sp2s(template, value)]];
    }
    else {
        let varRules = (0,_rules_RuleContainer__WEBPACK_IMPORTED_MODULE_1__.getVarsFromSD)(customVars);
        return varRules.map(varRule => [varRule.cssVarName, varRule.template,
            sp2s(varRule.template, varRule.getValue())]);
    }
};
/**
 * For each property - regular and custom - in the given styleset invokes the appropriate
 * function that gets the property name and the value converted to string.
 * @param styleset
 * @param callback
 * @param getPrefixedVariants Flag indicating whether we need to retrieve property variants with
 * vendor prefixes
 */
const forAllPropsInStylset = (styleset, callback) => {
    for (let propName in styleset) {
        // special handling of the "--" property, which is an array where each item is
        // a two-item or three-item array
        if (propName === "--") {
            let customVars = styleset[propName];
            for (let customVar of customVars) {
                if (!customVar)
                    continue;
                // in each tuple, the first element is var name, the second is template property and
                // the third is the value;
                let ntvs = getVarsNTVs(customVar);
                for (let ntv of ntvs)
                    callback(ntv[0], ntv[2], true, false);
            }
        }
        else {
            let propVal = styleset[propName];
            if (propVal == null)
                continue;
            else {
                // check whether the property contains an array of values behind the object with
                // the "[]" property. If not, convert the single value to an array, so that we can
                // iterate over it.
                let propArray = propVal["[]"];
                if (!propArray)
                    propArray = [propVal];
                for (let propVal of propArray) {
                    // get the string representation of the property value
                    let propString = sp2s(propName, propVal);
                    if (!propString)
                        continue;
                    // get vendor-prefixed variants
                    let variants = getPrefixVariants(propName, propString);
                    if (variants) {
                        for (let variant of variants)
                            callback(variant[0], variant[1], false, variant[0] !== propName);
                    }
                    // invoke the callback for the originally found prop name and with (perhaps updated)
                    // value
                    callback(propName, propString, false, false);
                }
            }
        }
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Registry of CSS properties that specifies how their values should be converted to strings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
const s_registerSP = (name, toStringFunc) => name in stylePropertyInfos ? false : (stylePropertyInfos[name] = toStringFunc, true);
/**
 * Map of property names to the V2SOptions objects describing custom actions necessary to
 * convert the property value to the CSS-compliant string.
 */
const stylePropertyInfos = {
    accentColor: 11 /* Color */,
    animation: {
        any: { obj: [
                ["duration", 5 /* Time */],
                "func",
                ["delay", 5 /* Time */],
                ["count", 1 /* Number */],
                "direction",
                "mode",
                "state",
                "name"
            ] },
        sep: ",",
    },
    animationDelay: 14 /* MultiTimeWithComma */,
    animationDuration: 14 /* MultiTimeWithComma */,
    animationIterationCount: 15 /* OneOrManyWithComma */,
    animationFillMode: 15 /* OneOrManyWithComma */,
    animationName: 15 /* OneOrManyWithComma */,
    animationPlayState: 15 /* OneOrManyWithComma */,
    animationTimingFunction: 15 /* OneOrManyWithComma */,
    background: {
        num: 11 /* Color */,
        any: {
            num: 11 /* Color */,
            obj: [
                ["color", 11 /* Color */],
                "image",
                ["position", 8 /* Position */],
                ["size", 13 /* MultiLengthWithSpace */, "/"],
                "repeat",
                "attachment",
                "origin",
                "clip"
            ]
        },
        sep: ",",
    },
    backgroundAttachment: 15 /* OneOrManyWithComma */,
    backgroundBlendMode: 15 /* OneOrManyWithComma */,
    backgroundClip: 15 /* OneOrManyWithComma */,
    backgroundColor: 11 /* Color */,
    backgroundImage: 15 /* OneOrManyWithComma */,
    backgroundOrigin: 15 /* OneOrManyWithComma */,
    backgroundPosition: 12 /* MultiPosition */,
    backgroundPositionX: 12 /* MultiPosition */,
    backgroundPositionY: 12 /* MultiPosition */,
    backgroundRepeat: 15 /* OneOrManyWithComma */,
    backgroundSize: {
        num: 3 /* Length */,
        item: { any: 3 /* Length */ },
        sep: ","
    },
    baselineShift: 3 /* Length */,
    blockSize: 3 /* Length */,
    border: 19 /* Border */,
    borderBlock: 19 /* Border */,
    borderBlockColor: 30 /* Colors */,
    borderBlockEnd: 19 /* Border */,
    borderBlockEndColor: 11 /* Color */,
    borderBlockEndWidth: 3 /* Length */,
    borderBlockStart: 19 /* Border */,
    borderBlockStartColor: 11 /* Color */,
    borderBlockStartWidth: 3 /* Length */,
    borderBlockWidth: 3 /* Length */,
    borderBottom: 19 /* Border */,
    borderBottomColor: 11 /* Color */,
    borderBottomLeftRadius: 18 /* Radius */,
    borderBottomRightRadius: 18 /* Radius */,
    borderBottomWidth: 3 /* Length */,
    borderColor: 30 /* Colors */,
    borderEndEndRadius: 18 /* Radius */,
    borderEndStartRadius: 18 /* Radius */,
    borderImage: {
        obj: borderImageToString,
    },
    borderInline: 19 /* Border */,
    borderInlineColor: 30 /* Colors */,
    borderInlineEnd: 19 /* Border */,
    borderInlineEndColor: 11 /* Color */,
    borderInlineEndWidth: 3 /* Length */,
    borderInlineStart: 19 /* Border */,
    borderInlineStartColor: 11 /* Color */,
    borderInlineStartWidth: 3 /* Length */,
    borderInlineWidth: 3 /* Length */,
    borderLeft: 19 /* Border */,
    borderLeftColor: 11 /* Color */,
    borderLeftWidth: 3 /* Length */,
    borderRadius: 20 /* BorderRadius */,
    borderRight: 19 /* Border */,
    borderRightColor: 11 /* Color */,
    borderRightWidth: 3 /* Length */,
    borderSpacing: 13 /* MultiLengthWithSpace */,
    borderStartEndRadius: 18 /* Radius */,
    borderStartStartRadius: 18 /* Radius */,
    borderTop: 19 /* Border */,
    borderTopColor: 11 /* Color */,
    borderTopLeftRadius: 18 /* Radius */,
    borderTopRightRadius: 18 /* Radius */,
    borderTopWidth: 3 /* Length */,
    borderWidth: 13 /* MultiLengthWithSpace */,
    bottom: 3 /* Length */,
    boxShadow: 26 /* BoxShadow */,
    caretColor: 11 /* Color */,
    clip: {
        arr: v => `rect(${_Utils__WEBPACK_IMPORTED_MODULE_0__.wkf[13](v)}`
    },
    color: 11 /* Color */,
    columnGap: 3 /* Length */,
    columnRule: 19 /* Border */,
    columnRuleColor: 11 /* Color */,
    columnRuleWidth: 13 /* MultiLengthWithSpace */,
    columnWidth: 3 /* Length */,
    content: {
        str: 23 /* Quoted */,
        item: 23 /* Quoted */
    },
    cursor: 15 /* OneOrManyWithComma */,
    fill: 11 /* Color */,
    fillOpacity: 2 /* Percent */,
    flex: {
        num: 3 /* Length */,
        arr: {
            3: [1 /* Number */, 1 /* Number */, 3 /* Length */]
        }
    },
    flexBasis: 3 /* Length */,
    floodColor: 11 /* Color */,
    font: {
        item: 3 /* Length */,
        obj: [
            ["style", 24 /* FontStyle */],
            "variant",
            "weight",
            "stretch",
            ["size", 3 /* Length */],
            ["lineHeight", undefined, "/"],
            "family"
        ]
    },
    fontSize: 3 /* Length */,
    fontStretch: 2 /* Percent */,
    fontStyle: 24 /* FontStyle */,
    gap: 13 /* MultiLengthWithSpace */,
    gridColumnGap: 3 /* Length */,
    gridGap: 13 /* MultiLengthWithSpace */,
    gridRowGap: 3 /* Length */,
    gridArea: 16 /* OneOrManyWithSlash */,
    gridAutoColumns: 21 /* GridAxis */,
    gridAutoRows: 21 /* GridAxis */,
    gridColumn: 16 /* OneOrManyWithSlash */,
    gridRow: 16 /* OneOrManyWithSlash */,
    gridTemplateAreas: gridTemplateAreasToString,
    gridTemplateColumns: 21 /* GridAxis */,
    gridTemplateRows: 21 /* GridAxis */,
    height: 3 /* Length */,
    inlineSize: 3 /* Length */,
    inset: 13 /* MultiLengthWithSpace */,
    insetBlock: 13 /* MultiLengthWithSpace */,
    insetBlockEnd: 3 /* Length */,
    insetBlockStart: 3 /* Length */,
    insetInline: 13 /* MultiLengthWithSpace */,
    insetInlineEnd: 3 /* Length */,
    insetInlineStart: 3 /* Length */,
    left: 3 /* Length */,
    letterSpacing: 3 /* Length */,
    lightingColor: 11 /* Color */,
    margin: 13 /* MultiLengthWithSpace */,
    marginBlock: 13 /* MultiLengthWithSpace */,
    marginBlockEnd: 3 /* Length */,
    marginBlockStart: 3 /* Length */,
    marginBottom: 3 /* Length */,
    marginInline: 13 /* MultiLengthWithSpace */,
    marginInlineEnd: 3 /* Length */,
    marginInlineStart: 3 /* Length */,
    marginLeft: 3 /* Length */,
    marginRight: 3 /* Length */,
    marginTop: 3 /* Length */,
    markerEnd: 29 /* Marker */,
    markerMid: 29 /* Marker */,
    markerStart: 29 /* Marker */,
    maskBorder: {
        obj: borderImageToString,
    },
    maskClip: 15 /* OneOrManyWithComma */,
    maskComposite: 15 /* OneOrManyWithComma */,
    maskImage: 15 /* OneOrManyWithComma */,
    maskMode: 15 /* OneOrManyWithComma */,
    maskOrigin: 15 /* OneOrManyWithComma */,
    maskPosition: 12 /* MultiPosition */,
    maskRepeat: 15 /* OneOrManyWithComma */,
    maskSize: {
        num: 3 /* Length */,
        item: { any: 3 /* Length */ },
        sep: ","
    },
    maxBlockSize: 3 /* Length */,
    maxHeight: 3 /* Length */,
    maxInlineSize: 3 /* Length */,
    maxWidth: 3 /* Length */,
    minBlockSize: 3 /* Length */,
    minHeight: 3 /* Length */,
    minInlineSize: 3 /* Length */,
    minWidth: 3 /* Length */,
    objectPosition: 8 /* Position */,
    offset: {
        obj: [
            ["position", 8 /* Position */],
            "path",
            ["distance", 3 /* Length */],
            ["rotate", { any: 4 /* Angle */ }],
            ["anchor", 8 /* Position */, "/"],
        ]
    },
    offsetAnchor: 8 /* Position */,
    offsetDistance: 3 /* Length */,
    offsetPosition: 8 /* Position */,
    offsetRotate: {
        any: 4 /* Angle */
    },
    outline: 19 /* Border */,
    outlineColor: 11 /* Color */,
    outlineOffset: 3 /* Length */,
    overflowClipMargin: 3 /* Length */,
    padding: 13 /* MultiLengthWithSpace */,
    paddingBlock: 13 /* MultiLengthWithSpace */,
    paddingBlockEnd: 3 /* Length */,
    paddingBlockStart: 3 /* Length */,
    paddingBottom: 3 /* Length */,
    paddingInline: 13 /* MultiLengthWithSpace */,
    paddingInlineEnd: 3 /* Length */,
    paddingInlineStart: 3 /* Length */,
    paddingLeft: 3 /* Length */,
    paddingRight: 3 /* Length */,
    paddingTop: 3 /* Length */,
    perspective: 3 /* Length */,
    perspectiveOrigin: 13 /* MultiLengthWithSpace */,
    quotes: {
        item: {
            str: 23 /* Quoted */,
            item: 23 /* Quoted */,
        }
    },
    right: 3 /* Length */,
    rotate: {
        num: 4 /* Angle */,
        arr: {
            2: [0 /* Default */, 4 /* Angle */],
            any: [0 /* Default */, 0 /* Default */, 0 /* Default */, 4 /* Angle */],
        }
    },
    rowGap: 3 /* Length */,
    scrollMargin: 13 /* MultiLengthWithSpace */,
    scrollMarginBlock: 13 /* MultiLengthWithSpace */,
    scrollMarginBlockEnd: 3 /* Length */,
    scrollMarginBlockStart: 3 /* Length */,
    scrollMarginBottom: 3 /* Length */,
    scrollMarginInline: 13 /* MultiLengthWithSpace */,
    scrollMarginInlineEnd: 3 /* Length */,
    scrollMarginInlineStart: 3 /* Length */,
    scrollMarginLeft: 3 /* Length */,
    scrollMarginRight: 3 /* Length */,
    scrollMarginTop: 3 /* Length */,
    scrollPadding: 13 /* MultiLengthWithSpace */,
    scrollPaddingBlock: 13 /* MultiLengthWithSpace */,
    scrollPaddingBlockEnd: 3 /* Length */,
    scrollPaddingBlockStart: 3 /* Length */,
    scrollPaddingBottom: 3 /* Length */,
    scrollPaddingInline: 13 /* MultiLengthWithSpace */,
    scrollPaddingInlineEnd: 3 /* Length */,
    scrollPaddingInlineStart: 3 /* Length */,
    scrollPaddingLeft: 3 /* Length */,
    scrollPaddingRight: 3 /* Length */,
    scrollPaddingTop: 3 /* Length */,
    scrollbarColor: {
        item: 11 /* Color */
    },
    shapeMargin: 3 /* Length */,
    stopColor: 11 /* Color */,
    stroke: 11 /* Color */,
    textCombineUpright: {
        num: v => `digits ${v}`
    },
    textDecoration: {
        num: 11 /* Color */,
        obj: [
            "line",
            "style",
            ["color", 11 /* Color */],
            ["thickness", 3 /* Length */],
        ]
    },
    textDecorationColor: 11 /* Color */,
    textDecorationThickness: 3 /* Length */,
    textEmphasis: 11 /* Color */,
    textEmphasisColor: 11 /* Color */,
    textFillColor: 11 /* Color */,
    textIndent: 13 /* MultiLengthWithSpace */,
    textShadow: 26 /* BoxShadow */,
    textSizeAdjust: 2 /* Percent */,
    textStrokeColor: 11 /* Color */,
    textStrokeWidth: 3 /* Length */,
    top: 3 /* Length */,
    transformOrigin: 13 /* MultiLengthWithSpace */,
    transition: {
        any: { obj: [
                ["property", _Utils__WEBPACK_IMPORTED_MODULE_0__.camelToDash],
                ["duration", 5 /* Time */],
                "func",
                ["delay", 5 /* Time */]
            ] },
        sep: ",",
    },
    transitionDelay: 14 /* MultiTimeWithComma */,
    transitionDuration: 14 /* MultiTimeWithComma */,
    transitionTimingFunction: 15 /* OneOrManyWithComma */,
    translate: 13 /* MultiLengthWithSpace */,
    verticalAlign: 3 /* Length */,
    width: 3 /* Length */,
    willChange: {
        str: _Utils__WEBPACK_IMPORTED_MODULE_0__.camelToDash
    },
    wordSpacing: 3 /* Length */,
    zoom: 2 /* Percent */,
    // properties for CSS syntax values
    "<number>#": 15 /* OneOrManyWithComma */,
    "<length>": 3 /* Length */,
    "<length>+": 13 /* MultiLengthWithSpace */,
    "<length>#": { any: 3 /* Length */, sep: "," },
    "<percentage>": 2 /* Percent */,
    "<percentage>+": { any: 2 /* Percent */ },
    "<percentage>#": { any: 2 /* Percent */, sep: "," },
    "<length-percentage>": 3 /* Length */,
    "<length-percentage>+": 13 /* MultiLengthWithSpace */,
    "<length-percentage>#": { any: 3 /* Length */, sep: "," },
    "<angle>": 4 /* Angle */,
    "<angle>+": { any: 4 /* Angle */ },
    "<angle>#": { any: 4 /* Angle */, sep: "," },
    "<time>": 5 /* Time */,
    "<time>+": { any: 5 /* Time */ },
    "<time>#": 14 /* MultiTimeWithComma */,
    "<resolution>": 6 /* Resolution */,
    "<resolution>+": { any: 6 /* Resolution */ },
    "<resolution>#": { any: 6 /* Resolution */, sep: "," },
    "<color>": 11 /* Color */,
    "<color>+": { any: 11 /* Color */ },
    "<color>#": { any: 11 /* Color */, sep: "," },
    "<image>#": 15 /* OneOrManyWithComma */,
    "<custom-ident>#": 15 /* OneOrManyWithComma */,
    // special properties for IVarRule types
    "<string>": 23 /* Quoted */,
    "<frequency>": 7 /* Frequency */,
    "<size>": 3 /* Length */,
    "<point>": 13 /* MultiLengthWithSpace */,
    "<position>": 8 /* Position */,
    "<multi-position>": 12 /* MultiPosition */,
    "<radius>": 18 /* Radius */,
};
// Vendor prefixes with indexes from the VendorPrefix enumeration. The first one is only here to
// allow the first enumeration value to be 1 and not zero.
const vendorPrefixStrings = ["", "webkit", "moz", "ms"];
const getPrefixVariants = (name, value) => {
    let info = propPrefixInfos[name];
    if (!info)
        return null;
    if (typeof info === "string")
        return [[info, value]];
    if (typeof info === "number")
        return [[(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(`${vendorPrefixStrings[info]}-${name}`), value]];
    let variants = [];
    for (let item of info) {
        if (typeof item === "string")
            variants.push([item, value]);
        else if (typeof item === "number")
            variants.push([(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(`${vendorPrefixStrings[item]}-${name}`), value]);
        else {
            let prefixString = vendorPrefixStrings[item.p];
            // determine whether the property name should be prefixed. Note that even if we decide
            // here that it should not be prefixed, it can change when we go over property values.
            let shouldPrefixProperty = !item.valsOnly;
            // if property values are defined, try to replace them with prefixed versions. Note that
            // this can also set the flag indicating that the property name should be prefixed too.
            let newPropValue = "";
            if (value && item.vals) {
                for (let valueInfo of item.vals) {
                    let valueToSearch = valueInfo.val;
                    if (value.indexOf(valueToSearch) < 0)
                        continue;
                    if (valueInfo.mode !== 2 /* PropertyOnly */) {
                        newPropValue = value.split(valueToSearch).join(valueInfo.alt ? valueInfo.alt : `-${prefixString}-${valueToSearch}`);
                        value = newPropValue;
                    }
                    if (valueInfo.mode !== 1 /* ValueOnly */)
                        shouldPrefixProperty = true;
                }
            }
            let newPropName = "";
            if (shouldPrefixProperty)
                newPropName = item.alt ? item.alt : (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.dashToCamel)(`${prefixString}-${name}`);
            if (newPropName || newPropValue)
                variants.push([newPropName || name, newPropValue || value]);
        }
    }
    return variants.length > 0 ? variants : null;
};
// Prefix information for size-like properties that accept "stretch" value
const sizePrefixInfos = [
    { p: 1 /* webkit */, valsOnly: true, vals: [{ val: "stretch", mode: 1 /* ValueOnly */, alt: "-webkit-fill-available" }] },
];
// Prefix information for properties that accept "cross-fade" and "image-set" functions (that is, images)
const imageFuncsPrefixInfo = {
    p: 1 /* webkit */, valsOnly: true, vals: [
        { val: "cross-fade", mode: 1 /* ValueOnly */ },
        { val: "image-set", mode: 1 /* ValueOnly */ }
    ]
};
const imageFuncsPrefixInfos = [imageFuncsPrefixInfo];
const propPrefixInfos = {
    appearance: [1 /* webkit */, 2 /* moz */],
    backgroundClip: [
        { p: 1 /* webkit */, valsOnly: true, vals: [{ val: "text", mode: 2 /* PropertyOnly */ }] }
    ],
    blockSize: sizePrefixInfos,
    boxDecorationBreak: 1 /* webkit */,
    background: imageFuncsPrefixInfos,
    backgroundImage: imageFuncsPrefixInfos,
    borderImage: imageFuncsPrefixInfos,
    borderImageSource: imageFuncsPrefixInfos,
    clipPath: 1 /* webkit */,
    colorAdjust: "webkitPrintColorAdjust",
    content: imageFuncsPrefixInfos,
    height: sizePrefixInfos,
    hyphens: [1 /* webkit */, 2 /* moz */, 3 /* ms */],
    initialLetter: 1 /* webkit */,
    inlineSize: sizePrefixInfos,
    lineClamp: 1 /* webkit */,
    mask: 1 /* webkit */,
    maskBorder: ["webkitMaskBoxImage", imageFuncsPrefixInfo],
    maskBorderOutset: "webkitMaskBoxImageOutset",
    maskBorderRepeat: "webkitMaskBoxImageRepeat",
    maskBorderSlice: "webkitMaskBoxImageSlice",
    maskBorderSource: "webkitMaskBoxImageSource",
    maskBorderWidth: "webkitMaskBoxImageWidth",
    maskClip: 1 /* webkit */,
    maskComposite: 1 /* webkit */,
    maskImage: [1 /* webkit */, imageFuncsPrefixInfo],
    maskMode: 1 /* webkit */,
    maskOrigin: 1 /* webkit */,
    maskPosition: 1 /* webkit */,
    maskRepeat: 1 /* webkit */,
    maskSize: 1 /* webkit */,
    maskType: 1 /* webkit */,
    maxBlockSize: sizePrefixInfos,
    maxHeight: sizePrefixInfos,
    maxInlineSize: sizePrefixInfos,
    maxWidth: sizePrefixInfos,
    minBlockSize: sizePrefixInfos,
    minHeight: sizePrefixInfos,
    minInlineSize: sizePrefixInfos,
    minWidth: sizePrefixInfos,
    shapeOutside: imageFuncsPrefixInfos,
    scrollbarColor: 1 /* webkit */,
    scrollbarWidth: 1 /* webkit */,
    textEmphasis: 1 /* webkit */,
    textEmphasisColor: 1 /* webkit */,
    textEmphasisPosition: 1 /* webkit */,
    textEmphasisStyle: 1 /* webkit */,
    textFillColor: 1 /* webkit */,
    textOrientation: 1 /* webkit */,
    textSizeAdjust: [1 /* webkit */, 2 /* moz */, 3 /* ms */],
    textStroke: 1 /* webkit */,
    textStrokeColor: 1 /* webkit */,
    textStrokeWidth: 1 /* webkit */,
    userSelect: [
        { p: 1 /* webkit */, vals: [{ val: "none", mode: 2 /* PropertyOnly */ }] }
    ],
    width: sizePrefixInfos,
};


/***/ }),

/***/ "./lib/impl/Utils.js":
/*!***************************!*\
  !*** ./lib/impl/Utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dashToCamel": () => (/* binding */ dashToCamel),
/* harmony export */   "camelToDash": () => (/* binding */ camelToDash),
/* harmony export */   "symV2S": () => (/* binding */ symV2S),
/* harmony export */   "wkf": () => (/* binding */ wkf),
/* harmony export */   "v2s": () => (/* binding */ v2s),
/* harmony export */   "a2s": () => (/* binding */ a2s),
/* harmony export */   "t2s": () => (/* binding */ t2s),
/* harmony export */   "o2s": () => (/* binding */ o2s),
/* harmony export */   "mv2s": () => (/* binding */ mv2s),
/* harmony export */   "f2s": () => (/* binding */ f2s),
/* harmony export */   "tag2s": () => (/* binding */ tag2s),
/* harmony export */   "propSet2s": () => (/* binding */ propSet2s),
/* harmony export */   "fdo": () => (/* binding */ fdo),
/* harmony export */   "fdo2s": () => (/* binding */ fdo2s)
/* harmony export */ });
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Case conversions for property names.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Converts dashe-case to camelCase, e.g. font-size to fontSize.
 * @param dash
 */
const dashToCamel = (dash) => !dash ? dash : dash.replace(/-([a-zA-Z])/g, (x, $1) => $1.toUpperCase());
/**
 * Converts camelCase to dash-case, e.g. fontSize to font-size.
 * @param camel
 */
const camelToDash = (camel) => camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Conversion of values to strings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Symbol under which a function is defined that converts an object to a string. We need a special
 * symbol because the standard method toString exists on every object and we only want some to
 * explicitly provide this support.
 */
const symV2S = Symbol();
/**
 * Array of well known conversion functions. Indexes are the identifier of well known functions
 * from the WellKnownFunc enumeration
 */
let wkf = new Array(31 /* Last */);
/**
 * Converts a value of an arbitrary type to a single string. The options parameter
 * can define how specific types are converted.
 */
const v2s = (val, options) => {
    // if options is not specified, do standard processing
    if (options == null) {
        if (typeof val === "string")
            return val;
        else if (Array.isArray(val))
            return a2s(val);
        else if (typeof val === "function")
            return v2s(val());
        else if (val == null)
            return "";
        else if (typeof val[symV2S] === "function")
            return val[symV2S]();
        else if (typeof val.fn === "string")
            return fdo2s(val);
        else
            return val.toString();
    }
    // do different things for different types of options
    if (typeof options == "number")
        return wkf[options] ? wkf[options](val) : "";
    else if (typeof options == "function")
        return options(val);
    else {
        // processing with options. For all types except null and string, if the type-specific
        // property is not defined, use options.any if defined.
        let newOptions = undefined;
        if (val == null)
            return options.nil ? typeof options.nil === "string" ? options.nil : options.nil(val) : "";
        else if (typeof val === "number")
            newOptions = options.num ?? options.any;
        else if (typeof val === "function")
            return v2s(val());
        else if (Array.isArray(val)) {
            if (val.length === 0)
                return "";
            else if (typeof options.arr === "object") // this can also be an array
                return t2s(val, options.arr, options.sep);
            else if (options.arr2 && Array.isArray(val[0]))
                newOptions = options.arr2;
            else if (options.arr)
                newOptions = options.arr;
            else
                return a2s(val, options.item ?? options.any ?? (options.recursive ? options : undefined), options.sep);
        }
        else if (typeof val === "object") {
            if (typeof val[symV2S] === "function")
                return val[symV2S]();
            else if (typeof val.fn === "string")
                return fdo2s(val);
            else if (options.obj || options.any) {
                if (Array.isArray(options.obj))
                    return o2s(val, options.obj, options.sep);
                else
                    newOptions = options.obj ?? options.any;
            }
            else
                return val.toString();
        }
        else if (typeof val === "string")
            newOptions = options.str ?? options.any;
        else if (typeof val === "boolean")
            return options.bool ? options.bool(val) : val.toString();
        else
            return "";
        return v2s(val, newOptions);
    }
};
wkf[0 /* Default */] = v2s;
wkf[15 /* OneOrManyWithComma */] = v => v2s(v, { sep: "," });
wkf[16 /* OneOrManyWithSlash */] = v => v2s(v, { sep: "/" });
wkf[23 /* Quoted */] = v => typeof v === "string" ? `"${v}"` : v2s(v);
/**
 * Converts the given array to a single string by converting every item using the given otions
 * and joining the results with the given delimiter.
 */
const a2s = (val, options, separator = " ") => !val || val.length === 0
    ? ""
    : val.map(v => v2s(v, options)).filter(v => !!v).join(separator);
/**
 * Converts the given array to a single string by converting every item using the given otions
 * and joining the results with the given delimiter.
 */
const t2s = (val, options, separator = " ") => {
    let v2sOptions = Array.isArray(options) ? options : (options[val.length] ?? options.any);
    if (!v2sOptions)
        return a2s(val, undefined, separator);
    let buf = [];
    for (let i = 0; i < v2sOptions.length; i++)
        buf.push(v2s(val[i], v2sOptions[i]));
    return buf.filter(v => !!v).join(separator);
};
/**
 * Converts properties of the given object to string by converting each property from the options
 * array and joining them using the given separator.
 * @param val Object to convert to string
 * @param options array of property names or tuples with property names, options and prefixes.
 * @param separator Separator character.
 * @param defaultOptions - V2SOptions for those properties in the "params" array that don't
 * define their own. This should be used in the case when all function parameters are of the
 * same type
 * @param defaultPrefix - prefix to use for those properties in the "params" array that don't
 * define their own prefix
 */
const o2s = (val, options, separator, defaultOptions, defaultPrefix) => {
    if (val == null)
        return "";
    let params = [];
    for (let nameOrTuple of options) {
        // get the name of the property in the value to be converted and the corresponding value;
        // if the properties value is not defined, skip it.
        let propName = typeof nameOrTuple === "string" ? nameOrTuple : nameOrTuple[0];
        let propVal = val[propName];
        if (propVal == null)
            continue;
        // check whether we have a prefix
        let prefix = typeof nameOrTuple === "string" ? defaultPrefix : nameOrTuple[2];
        if (prefix)
            params.push(prefix);
        let options = typeof nameOrTuple === "string" ? defaultOptions : nameOrTuple[1];
        params.push(v2s(propVal, options));
    }
    return params.filter(v => !!v).join(separator ?? " ");
};
/**
 * Converts the given array of values to a single string according to the specified options and
 * using the given separator. For each item in the array, the v2s function is called to convert
 * it to string.
 * @param values
 * @param separator
 */
const mv2s = (values, separator = " ") => {
    if (values == null || values.length === 0)
        return "";
    let arr = [];
    for (let item of values) {
        let val;
        let options;
        if (Array.isArray(item)) {
            val = item[0];
            options = item[1];
        }
        else
            val = item;
        if (val || (options && options.nil))
            arr.push(v2s(val, options));
    }
    return arr.filter(v => !!v).join(separator);
};
/**
 * Converts the given values as parameters to the given CSS function invocation.
 * @param name
 * @param values
 * @param separator
 */
const f2s = (name, values, separator = ",") => `${name}(${mv2s(values, separator)})`;
/**
 * The tag2s is a tag function helper that converts the template string with
 * parameters to a string using the given options object.
 */
const tag2s = (parts, params, options) => {
    // number of parameters is always 1 less than the number of string parts
    let paramsLen = params.length;
    if (paramsLen === 0)
        return parts[0];
    let s = "";
    for (let i = 0; i < paramsLen; i++)
        s += parts[i] + v2s(params[i], options);
    // add the last part
    return s + parts[paramsLen];
};
/**
 * Converts the given property set object to the CSS style string.
 */
const propSet2s = (val, infos, options) => v2s(val, {
    obj: v => {
        let propNames = Object.keys(v);
        if (propNames.length === 0)
            return "";
        let func = options?.propFunc ?? propInPropSet2s;
        let arr = propNames.map((propName) => {
            let dashPropName = camelToDash(propName);
            let camelPropName = dashToCamel(propName);
            return func(dashPropName, camelPropName, v[propName], infos[camelPropName]);
        });
        return (options?.prefix ?? "") + `${arr.join(options?.separator ?? ";")}` + (options?.suffix ?? "");
    }
});
// convert the value to string based on the information object for the property (if defined)
const propInPropSet2s = (dashName, camelName, val, options) => `${dashName}:${v2s(val, options)}`;
// This object is filled in in the XxxAPI files where the functions corresponding to CSS functions
// are defined.
const fdo = {};
/**
 * Converts the given function definition object to string. Conversion is performed according
 * to the type found in the "fdo" object for the property name equal to the "fn" property of
 * the given value. If no such property exist in the "fdo" object, all object's properties except
 * "fn" will be converted to strings using v2s and concatenated with comma.
 *
 * @param val Function definition object that has the "fn" property defining the function name.
 * @returns String representation of CSS function invocation.
 */
const fdo2s = (val) => {
    let options = fdo[val.fn];
    if (!options)
        return goOverProps(val);
    else if (typeof options === "number")
        return goOverProps(val, options);
    else if (typeof options === "function")
        return options(val);
    else if (Array.isArray(options))
        return `${val.fn}(${o2s(val, options, ",")})`;
    else {
        let fn = options.fn;
        fn = !fn ? val.fn : typeof fn === "string" ? fn : fn(val);
        return options.p
            ? `${fn}(${o2s(val, options.p, options.s ?? ",", options.do, options.dp)})`
            : options.f
                ? `${fn}(${options.f(val)})`
                : "";
    }
};
/**
 * Helper function that goes over the props of the given object except the "fn" property,
 * serializes all the props using the given options and concatenates them with the given
 * separator (comma by default).
 * @param val
 * @param options
 * @param sep
 * @returns
 */
const goOverProps = (val, options, sep) => {
    let buf = [];
    for (let p in val) {
        if (p !== "fn")
            buf.push(v2s(val[p], options));
    }
    return `${val.fn}(${buf.filter(v => !!v).join(sep ?? ",")})`;
};


/***/ }),

/***/ "./lib/rules/AnimationRule.js":
/*!************************************!*\
  !*** ./lib/rules/AnimationRule.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationRule": () => (/* binding */ AnimationRule)
/* harmony export */ });
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _StyleRules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StyleRules */ "./lib/rules/StyleRules.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");



/**
 * The AnimationRule class describes a @keyframes CSS rule.
 */
class AnimationRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.Rule {
    constructor(frames, nameOverride) {
        super();
        if (frames)
            this.frameRules = frames.map(frame => new AnimationFrameRule(frame[0], frame[1]));
        this.nameOverride = nameOverride;
    }
    // This function is called to convert an object to a string. Animation rule returns its name.
    toString() { return this.name; }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.name = container.getScopedName(ruleName, this.nameOverride);
        for (let keyframeRule of this.frameRules)
            keyframeRule.process(container, ruleName);
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(parent) {
        if (!this.frameRules)
            return;
        this.cssRule = _Rule__WEBPACK_IMPORTED_MODULE_0__.Rule.toDOM(`@keyframes ${this.name} {}`, parent);
        let cssKeyframesRule = this.cssRule;
        for (let frameRule of this.frameRules) {
            try {
                cssKeyframesRule.appendRule(frameRule.toCss());
                // although the cssRule in the frame is typed as CSSStyleRule, we know that in
                // practice, it is of the CSSKeyframeRule type.
                frameRule.cssRule = this.cssRule.cssRules.item(this.cssRule.cssRules.length - 1);
            }
            catch (x) {
                console.error("Cannot add CSS keyframe rule", x);
            }
        }
    }
    // Serializes this rule to a string.
    serialize(ctx) {
        if (!this.frameRules)
            return;
        ctx.addRule(`@keyframes ${this.name} {`);
        for (let frameRule of this.frameRules)
            ctx.addRule(frameRule.toCss());
        ctx.addRule("}");
    }
}
/**
 * The AnimationFrameRule class represents a single keyframe clause in the animation rule.
 */
class AnimationFrameRule extends _StyleRules__WEBPACK_IMPORTED_MODULE_1__.StyleRule {
    constructor(waypoint, styleset) {
        super(styleset);
        this.waypoint = waypoint;
    }
    // Returns the selector part of the style rule.
    getSel() {
        return (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_2__.v2s)(this.waypoint, { any: 2 /* Percent */, sep: "," });
    }
    /**
     * SOM keyframe rule. Although the cssRule in the frame is typed as CSSStyleRule, we know that
     * in practice, it is of the CSSKeyframeRule type.
     */
    get cssKeyframeRule() { return this.cssRule; }
    ;
}


/***/ }),

/***/ "./lib/rules/CounterRules.js":
/*!***********************************!*\
  !*** ./lib/rules/CounterRules.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CounterRule": () => (/* binding */ CounterRule),
/* harmony export */   "CounterStyleRule": () => (/* binding */ CounterStyleRule)
/* harmony export */ });
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");


/**
 * The CounterRule class describes a named counter definition. Use this rule to create
 * counter objects that can be used in counter-increment, counter-reset and counter-set style
 * properties. No CSS rule is created for counters - they are needed only to provide type-safe
 * counter definitions.
 */
class CounterRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike {
    constructor(nameOverride) {
        super();
        this.nameOverride = nameOverride;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the counter name.
    toString() { return this.name; }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.name = container.getScopedName(ruleName, this.nameOverride);
    }
    /** Name of the counter */
    get counterName() { return this.name; }
}
/**
 * The CounterStyleRule class describes the CSS @nounter-style at-rule.
 */
class CounterStyleRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(counterStyleset, nameOverride) {
        super();
        this.counterStyleset = counterStyleset ?? {};
        this.nameOverride = nameOverride;
    }
    /** Name of the counter */
    get counterStyleName() { return this.name; }
    // This function is used when the object is specified as a value in a style property or in
    // another counter style rule. We return the counter style name.
    toString() { return this.name; }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.name = container.getScopedName(ruleName, this.nameOverride);
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(parent) {
        this.cssRule = _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule.toDOM(this.toCss(), parent);
    }
    // Serializes this rule to a string.
    serialize(ctx) {
        ctx.addRule(this.toCss());
    }
    // Serializes this rule to a string.
    toCss() {
        return `@counter-style ${this.name} {${(0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.counterStyleset2s)(this.counterStyleset)}}`;
    }
}


/***/ }),

/***/ "./lib/rules/GridRules.js":
/*!********************************!*\
  !*** ./lib/rules/GridRules.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GridLineRule": () => (/* binding */ GridLineRule),
/* harmony export */   "GridAreaRule": () => (/* binding */ GridAreaRule)
/* harmony export */ });
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");

/**
 * The GridLineRule class describes a named grid line definition. No CSS rule is created for grid
 * lines - they are needed only to provide type-safe grid line definitions.
 */
class GridLineRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.RuleLike {
    // if the nameOverride is an area rule object, the isStartEndOrNone flag is always defined
    // because this constructor can only be invoked for the start and end lines of the GridAreaRule
    // object.
    constructor(nameOverride, isStartEndOrNone) {
        super();
        this.nameOverride = nameOverride;
        this.isStartEndOrNone = isStartEndOrNone;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the line name.
    toString() { return this.name; }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        let name;
        let areaName;
        let isStartEndOrNone = this.isStartEndOrNone;
        let nameOverride = this.nameOverride;
        if (nameOverride instanceof GridLineRule) {
            name = nameOverride.name;
            this.isStartEndOrNone = nameOverride.isStartEndOrNone;
            areaName = nameOverride.areaName;
        }
        else if (nameOverride instanceof GridAreaRule) {
            name = nameOverride.name + (isStartEndOrNone === true ? "-start" : isStartEndOrNone === false ? "-end" : "");
            areaName = nameOverride.name;
        }
        else {
            name = container.getScopedName(ruleName, nameOverride);
            // if the obtained name doesn't have "-start" or "-end" but the isStartEndOrNone flag is
            // defined (that is, it is either start or end line), we need to append the suffix. If the
            // obtained name already has "-start" or "-end" and the isStartEndOrNone flag is not
            // defined, we set this flag to either true or false depending on the suffix. Note that if
            // the nameOverride is an area rule object, the isStartEndOrNone flag is always defined.
            let nameHasStart = name.endsWith("-start");
            let nameHasEnd = name.endsWith("-end");
            if (nameHasStart) {
                this.isStartEndOrNone = true;
                areaName = name.substr(0, name.length - 6 /* "-start".length */);
            }
            else if (nameHasEnd) {
                isStartEndOrNone = false;
                areaName = name.substr(0, name.length - 4 /* "-end".length */);
            }
            else if (isStartEndOrNone === true) {
                areaName = name;
                name += "-start";
            }
            else if (isStartEndOrNone === false) {
                areaName = name;
                name += "-end";
            }
        }
        this.name = name;
        this.areaName = areaName;
        this.isStartEndOrNone = isStartEndOrNone;
    }
}
/**
 * The GridAreaRule class describes a named grid area definition. No CSS rule is created for grid
 * areas - they are needed only to provide type-safe grid area definitions.
 */
class GridAreaRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.RuleLike {
    // if the nameOverride is an area rule object, the isStartEndOrNone flag is always defined
    // because this constructor can only be invoked for the start and end lines of the GridAreaRule
    // object.
    constructor(nameOverride) {
        super();
        this.nameOverride = nameOverride;
        // create line rules
        this.startLine = new GridLineRule(this, true);
        this.endLine = new GridLineRule(this, false);
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the area name.
    toString() { return this.name; }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.name = container.getScopedName(ruleName, this.nameOverride);
        // process line rules
        this.startLine.process(container, null);
        this.endLine.process(container, null);
    }
}


/***/ }),

/***/ "./lib/rules/GroupRules.js":
/*!*********************************!*\
  !*** ./lib/rules/GroupRules.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GroupRule": () => (/* binding */ GroupRule),
/* harmony export */   "SupportsRule": () => (/* binding */ SupportsRule),
/* harmony export */   "MediaRule": () => (/* binding */ MediaRule)
/* harmony export */ });
/* harmony import */ var _RuleContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleContainer */ "./lib/rules/RuleContainer.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");



/**
 * The GroupRule class serves as a base class for all grouping CSS rules.
 */
class GroupRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(instOrClass) {
        super();
        this.instOrClass = instOrClass;
    }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        // container to which our groupng rule belongs becomes the parent container for the
        // style definition instance
        this.sc = (0,_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.getRCfromSD)(this._sd = (0,_RuleContainer__WEBPACK_IMPORTED_MODULE_0__.processSD)(this.instOrClass, container.getDef()));
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(parent) {
        let selector = this.getSel();
        if (!selector)
            return;
        this.cssRule = _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule.toDOM(`${selector} {}`, parent);
        // insert sub-rules
        if (this.cssRule)
            this.sc.insert(this.cssRule);
    }
    // Serializes this rule to a string.
    serialize(ctx) {
        let selector = this.getSel();
        if (!selector)
            return;
        ctx.addRule(`${selector} {`);
        // insert sub-rules
        this.sc.serialize(ctx);
        ctx.addRule("}");
    }
    // Condition of this grouping rule.
    get condition() {
        if (!this._cond)
            this._cond = this.getCond();
        return this._cond ?? "";
    }
    // Clers the CSS rule object.
    clear() {
        super.clear();
        // clear sub-rules
        this.sc.clear();
    }
    // Instance of the style definition class defining the rules under this grouping rule
    get sd() { return this._sd; }
}
/**
 * The SupportRule class describes a CSS @supports rule.
 */
class SupportsRule extends GroupRule {
    constructor(statement, instOrClass) {
        super(instOrClass);
        this.stmt = statement;
    }
    /** Flag indicated whether the browser supports this rule's query */
    get isSupported() {
        return CSS.supports(this.condition);
    }
    // Returns the condition string of this grouping rule.
    getCond() {
        return (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__.supports2s)(this.stmt);
    }
    // Returns the selector string of this grouping rule.
    getSel() {
        return `@supports ${this.condition}`;
    }
}
/**
 * The MediaRule class describes a CSS @media rule.
 */
class MediaRule extends GroupRule {
    constructor(statement, instOrClass) {
        super(instOrClass);
        // cached MediaQueryList object created for the media statement
        this._mql = null;
        this.stmt = statement;
    }
    // Returns the condition string of this grouping rule.
    getCond() {
        return (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_2__.media2s)(this.stmt);
    }
    // Returns the selector string of this grouping rule.
    getSel() {
        return `@media ${this.condition}`;
    }
    /**
     * Returns `MediaQueryList` object that allows programmatic checking whether the document matches
     * the media statement and also allows listening to its `change` event.
     */
    get mql() {
        if (!this._mql)
            this._mql = window.matchMedia(this.condition);
        return this._mql;
    }
}


/***/ }),

/***/ "./lib/rules/MiscRules.js":
/*!********************************!*\
  !*** ./lib/rules/MiscRules.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImportRule": () => (/* binding */ ImportRule),
/* harmony export */   "NamespaceRule": () => (/* binding */ NamespaceRule),
/* harmony export */   "FontFaceRule": () => (/* binding */ FontFaceRule),
/* harmony export */   "PageRule": () => (/* binding */ PageRule),
/* harmony export */   "ClassNameRule": () => (/* binding */ ClassNameRule)
/* harmony export */ });
/* harmony import */ var _impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/MiscImpl */ "./lib/impl/MiscImpl.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _StyleRules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StyleRules */ "./lib/rules/StyleRules.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");





/**
 * The MiscRule class serves as a base class for simple rules.
 */
class MiscRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(isTopLevelRule) {
        super();
        this.isTopLevelRule = isTopLevelRule;
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(parent) {
        this.cssRule = _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule.toDOM(this.toCss(), parent);
    }
    // Serializes this rule to a string.
    serialize(ctx) {
        ctx.addRule(this.toCss(), this.isTopLevelRule);
    }
}
/**
 * The ImportRule class describes a CSS @import rule.
 */
class ImportRule extends MiscRule {
    constructor(url, mediaStatement, supportsStatement) {
        // this is a top-level rule
        super(true);
        this.url = url;
        this.mediaStatement = mediaStatement;
        this.supportsStatement = supportsStatement;
    }
    // Returns CSS string for this rule.
    toCss() {
        let url;
        if (this.url.startsWith("url") || this.url.startsWith("\"") || this.url.startsWith("'"))
            url = this.url;
        else
            url = `url(${this.url})`;
        let supportsQueryString = !this.supportsStatement ? "" : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.supports2s)(this.supportsStatement);
        if (supportsQueryString && !supportsQueryString.startsWith("supports"))
            supportsQueryString = `supports( ${supportsQueryString} )`;
        let mediaQueryString = !this.mediaStatement ? "" : (0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.media2s)(this.mediaStatement);
        return `@import ${url} ${supportsQueryString} ${mediaQueryString}`;
    }
}
/**
 * The NamespaceRule class describes a CSS @namespace rule.
 */
class NamespaceRule extends MiscRule {
    constructor(namespace, prefix) {
        // this is a top-level rule
        super(true);
        this.namespace = namespace;
        this.prefix = prefix;
    }
    // Returns CSS string for this rule.
    toCss() {
        let url = this.namespace.startsWith("url(") ? this.namespace : `url(${this.namespace})`;
        return `@namespace ${this.prefix ? this.prefix : ""} ${url}`;
    }
}
/**
 * The FontFaceRule class describes a @font-face CSS rule.
 */
class FontFaceRule extends MiscRule {
    constructor(fontface) {
        super();
        this.fontface = fontface;
    }
    // Returns CSS string for this rule.
    toCss() {
        return `@font-face {${(0,_impl_MiscImpl__WEBPACK_IMPORTED_MODULE_0__.fontFace2s)(this.fontface)}}`;
    }
}
/**
 * The PageRule class represents the CSS @page rule.
 */
class PageRule extends _StyleRules__WEBPACK_IMPORTED_MODULE_2__.StyleRule {
    constructor(pseudoClass, style) {
        super(style);
        this.pseudoClass = pseudoClass;
    }
    // Returns the selector part of the style rule.
    getSel() {
        return `@page ${this.pseudoClass ? this.pseudoClass : ""}`;
    }
}
/**
 * The PageRule class represents the CSS @page rule.
 */
class ClassNameRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike {
    constructor(classes) {
        super();
        this.classes = classes;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the CSS class name.
    [_impl_Utils__WEBPACK_IMPORTED_MODULE_3__.symV2S]() { return this.cssClassName; }
    /** CSS rule selector string */
    get selectorText() {
        return this.cssClassName;
    }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.name = this.classes.map(cls => typeof cls === "string" ? cls : cls.name).join(" ");
        this.cssClassName = "." + this.classes.map(cls => typeof cls === "string" ? cls : cls.name).join(".");
    }
    // Implementation of the toString method returns the combined name of the classes (without
    // the CSS prefixes).
    toString() {
        return this.name;
    }
}


/***/ }),

/***/ "./lib/rules/Rule.js":
/*!***************************!*\
  !*** ./lib/rules/Rule.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuleLike": () => (/* binding */ RuleLike),
/* harmony export */   "Rule": () => (/* binding */ Rule)
/* harmony export */ });
/**
 * The RuleLike abstract class is a base for all "rules" defined in the style definition classes -
 * whether they correspond to real CSS rules (and thus derive from the Rule class) or not (such as
 * counters, grid lines and grid areas).
 */
class RuleLike {
    // Processes the rule.
    process(c, ruleName) {
        this.c = c;
        this.ruleName = ruleName;
    }
}
/**
 * The Rule class is used as a base class for all rules.
 */
class Rule extends RuleLike {
    // Clers the CSS rule object. This method is called when the style definition class, to which
    // this rule belongs, is deactivated.
    clear() { this.cssRule = null; }
    // Inserts the given rule into the given parent grouping rule or stylesheet.
    static toDOM(ruleText, parent) {
        try {
            let index = parent.insertRule(ruleText, parent.cssRules.length);
            return parent.cssRules[index];
        }
        catch (x) {
            console.error(`Cannot add CSS rule '${ruleText}'`, x);
            return null;
        }
    }
}


/***/ }),

/***/ "./lib/rules/RuleContainer.js":
/*!************************************!*\
  !*** ./lib/rules/RuleContainer.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuleContainer": () => (/* binding */ RuleContainer),
/* harmony export */   "configNames": () => (/* binding */ configNames),
/* harmony export */   "processSD": () => (/* binding */ processSD),
/* harmony export */   "getVarsFromSD": () => (/* binding */ getVarsFromSD),
/* harmony export */   "getRCfromSD": () => (/* binding */ getRCfromSD),
/* harmony export */   "activateSD": () => (/* binding */ activateSD),
/* harmony export */   "deactivateSD": () => (/* binding */ deactivateSD),
/* harmony export */   "serializeSD": () => (/* binding */ serializeSD),
/* harmony export */   "embeddedDecorator": () => (/* binding */ embeddedDecorator),
/* harmony export */   "getCurrentTheme": () => (/* binding */ getCurrentTheme)
/* harmony export */ });
/* harmony import */ var _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/RuleAPI */ "./lib/api/RuleAPI.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _VarRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VarRule */ "./lib/rules/VarRule.js");
/* harmony import */ var _MiscRules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MiscRules */ "./lib/rules/MiscRules.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");





// Define symbols that are used for keeping important information on the style definition
// instances that we don't want to be visible to developers.
/** Symbol on the style definition class pointing to the singleton instance. */
const symInstance = Symbol("sd");
/**
 * Symbol on the style definition instance pointing to the RuleContainer object that is
 * responsible for processing rules.
 */
const symContainer = Symbol("rc");
/**
 * Symbol on the style definition instance pointing to the StyleDefinition class for which
 * this instance was created.
 */
const symClass = Symbol("sdc");
/**
 * Element that is created at the top of the "<head>" element before any theme is activated. When
 * themes are activated, their '<style>' elements are created before this element.
 */
let s_themePlaceholderElm;
/**
 * Flag indicating that a rule container is created not directly (as for styled components)
 * but from the processClass function. This variable is set to true before instantiating the
 * style definition class (and thus the RuleCOntainer object) and is set back to false after
 * it is used in the RuleContainer constructor.
 */
let s_processingStyleDefinitionClass = false;
/**
 * The RuleContainer class is a shadow structure that accompanies every processed style definition
 * object. Since StyleDefinition class is an exported class visible to developers, we don't want
 * to have a lot of functionality in it. The RuleContainer object is linked to the StyleDefinition
 * object via the [symContainer] symbol. It contains all the functionality for parsing rule
 * definitions, name assignment and activation/deactivation.
 */
class RuleContainer {
    constructor(sd) {
        // Array of names of properties that would be considered "own" properties of the style
        // definition object. This array keeps the  property names in the order they are defined
        // in the class
        this.keys = [];
        // List of references to other style definitions creaed via the $use function.
        this.refs = [];
        // List of @import rules
        this.imports = [];
        // List of @namespace rules
        this.namespaces = [];
        // List of custom variable rules.
        this.vars = [];
        // List of rules that are not imports, namespaces, custom vars, references or grouping rules.
        this.otherRules = [];
        // List of rule-like objects.
        this.ruleLikes = [];
        // Reference count of activation requests.
        this.refCount = 0;
        // DOM style elemnt
        this.elm = null;
        this.sd = sd;
        this.sdc = sd.constructor;
        this.parent = sd.$parent;
        this.ec = this.sdc[symEmbeddingContainer];
        // get parent and top level containers
        if (this.parent) {
            this.pc = this.parent[symContainer];
            this.tlc = this.pc.tlc;
        }
        else
            this.tlc = this;
        // get the name for our container. If the container is created for a class from the
        // processClass function, then the flag s_processingStyleDefinitionClass is defined
        // and the name isgenerated depending on the current generation method. If this flag is
        // false, that means that the container is created from a direct "new" call on the style
        // definition class and the name is generated uniquely.
        let name;
        if (s_processingStyleDefinitionClass) {
            s_processingStyleDefinitionClass = false;
            name = !this.sdc.name || s_nameGeneratonMethod === 2 /* Optimized */
                ? generateUniqueName()
                : this.sdc.name;
            // associate the definition class with the created definition instance
            this.sdc[symInstance] = sd;
            sd[symClass] = this.sdc;
        }
        else {
            name = generateUniqueName();
            if (s_nameGeneratonMethod !== 2 /* Optimized */ && this.sdc.name)
                name += "_" + this.sdc.name;
        }
        // Style Definition instance points to this rule container
        sd[symContainer] = this;
        // if our container has parent container, prefix our name with the upper one
        this.name = this.pc ? `${this.pc.name}_${name}` : name;
    }
    // ProxyHandler method, whcih virtualizes all non-array properties
    set(t, p, v, r) {
        if (typeof p === "symbol" || typeof p === "number" || p in t /*t[p] !== undefined*/)
            return Reflect.set(t, p, v, r);
        else {
            // we don't virtualize arrays because there is no trap for isArray() method, which
            // we use later in the processProperty() method.
            if (!Array.isArray(v))
                virtualize(t, p);
            t[p] = v;
            this.keys.push(p);
            return true;
        }
    }
    // Processes the properties of the style definition instance. This creates names for classes,
    // IDs, animations and custom variables.
    process() {
        // loop over the properties of the definition object and process them.
        for (let propName of this.keys)
            this.processProperty(propName, this.sd[propName]);
        this.processed = true;
    }
    // Processes the properties of the style definition instance. This creates names for classes,
    // IDs, animations and custom variables.
    processProperty(propName, propVal) {
        if (propVal instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.StyleDefinition) {
            processInstance(propVal);
            this.refs.push(propVal);
        }
        // else if (propVal instanceof Array)
        else if (Array.isArray(propVal)) {
            // loop over array elements and recursively process them. Index becomes part of the
            // rule name.
            let i = 0;
            for (let item of propVal)
                this.processProperty(`${propName}_${i++}`, item);
        }
        else {
            if (propVal instanceof _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike) {
                propVal.process(this, propName);
                if (propVal instanceof _VarRule__WEBPACK_IMPORTED_MODULE_2__.VarRule)
                    this.vars.push(propVal);
                else if (propVal instanceof _MiscRules__WEBPACK_IMPORTED_MODULE_3__.ImportRule)
                    this.imports.push(propVal);
                else if (propVal instanceof _MiscRules__WEBPACK_IMPORTED_MODULE_3__.NamespaceRule)
                    this.namespaces.push(propVal);
                else if (propVal instanceof _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule)
                    this.otherRules.push(propVal);
                else
                    this.ruleLikes.push(propVal);
            }
        }
    }
    /** Returns the instance of the stylesheet definition class */
    getDef() {
        return this.sd;
    }
    // Sets the given value for the custom CSS roperty with the given name.
    setVarValue(name, value, important, schedulerType) {
        if (this.varRootRule)
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.scheduleStyleUpdate)(this.varRootRule, name, value, important, schedulerType);
    }
    /**
     * Generates a globally unique CSS name for the given rule name unless this rule name already
     * exists either in a base class or in the chain of parent grouping rules.
     */
    getScopedName(ruleName, nameOverride) {
        if (nameOverride)
            return typeof nameOverride === "string" ? nameOverride : nameOverride.name;
        else if (!ruleName)
            return generateUniqueName();
        else if (ruleName in this.sd && "name" in this.sd[ruleName])
            return this.sd[ruleName].name;
        else {
            // find out if there is a rule with this name defined in a stylesheet instance created
            // for a class from the prototype chain of the style definition class. Otherwise, if
            // there is a parent container, recurse to it; otherwise, generate the name.
            let existingName = findNameForRuleInPrototypeChain(this.sdc, ruleName);
            if (existingName)
                return existingName;
            else if (this.pc)
                return this.pc.getScopedName(ruleName);
            else
                return generateName(this.name, ruleName);
        }
    }
    /** Inserts all rules defined in this container to either the style sheet or grouping rule. */
    insert(sheetOrGroupingRule) {
        // insert @import and @namespace rules as they must be before other rules. If the parent is a grouping
        // rule, don't insert @import and @namespace rules at all
        if (sheetOrGroupingRule instanceof CSSStyleSheet) {
            this.imports.forEach(rule => rule.insert(sheetOrGroupingRule));
            this.namespaces.forEach(rule => rule.insert(sheetOrGroupingRule));
        }
        // activate referenced style definitions
        for (let ref of this.refs)
            ref[symContainer].activate(this.elm);
        // insert our custom variables into the ":root" rule
        if (this.vars.length > 0) {
            this.varRootRule = _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule.toDOM(getRootCssForVars(this.vars), sheetOrGroupingRule);
        }
        // insert all other rules
        this.otherRules.forEach(rule => rule.insert(sheetOrGroupingRule));
    }
    /** Clears all CSS rule objects defined in this container. */
    clear() {
        // import and namespace rules can only exist in the top-level style definition class
        if (!this.parent) {
            this.imports.forEach(rule => rule.clear());
            this.namespaces.forEach(rule => rule.clear());
        }
        this.varRootRule = null;
        this.otherRules.forEach(rule => rule.clear());
        // deactivate imported stylesheets
        for (let ref of this.refs)
            ref[symContainer].deactivate();
    }
    /**
     * Inserts this stylesheet into DOM.
     *
     * @param insertBefore Optional HTML element before which the new '<style>' element should be
     * inserted. If not specified, the new element will be inserted as the last element under the
     * '<head>' element.
     */
    activate(insertBefore = null) {
        if (++this.refCount > 1)
            return;
        // only the top-level not-embedded style definitions create the `<style>` element
        if (!this.parent) {
            if (this.ec)
                this.elm = this.ec.elm;
            else {
                // themes are inserted before the special placeholder element, which is created
                // at the top of the '<head>' element
                if (this.sd instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition) {
                    if (!s_themePlaceholderElm) {
                        s_themePlaceholderElm = document.createElement("style");
                        s_themePlaceholderElm.id = generateUniqueName("themePlaceholderElement_");
                        document.head.insertBefore(s_themePlaceholderElm, document.head.firstElementChild);
                    }
                    insertBefore = s_themePlaceholderElm;
                }
                this.elm = document.createElement("style");
                this.elm.id = this.name;
                document.head.insertBefore(this.elm, insertBefore);
            }
        }
        else
            this.elm = this.tlc.elm;
        // if this is a theme class activation, check whether the instance is set as the current
        // one for its theme base class. If no, then deactivate the theme instance currently set
        // as active. In any case, set our new instance as the currently active one. We ignore
        // theme declaration classes - those that directly derive from ThemeDefinition
        if (this.sd instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition && Object.getPrototypeOf(this.sdc) !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition) {
            let themeClass = this.sd[symClass];
            if (themeClass) {
                let currInstance = getCurrentTheme(themeClass);
                if (currInstance && currInstance !== this.sd) {
                    let currContainer = currInstance[symContainer];
                    currContainer.deactivate();
                }
                setCurrentTheme(this.sd);
            }
        }
        this.insert(this.elm.sheet);
    }
    /** Removes this stylesheet from DOM. */
    deactivate() {
        // guard from extra deactivate calls
        if (this.refCount === 0) {
/////////////////////////
            console.error(`Extra call to deactivate() for style definition class '${this.name}'`);
//////////////////////
            return;
        }
        if (--this.refCount > 0)
            return;
        this.clear();
        // only the top-level not-embedded style defiitions create the `<style>` element
        if (!this.parent && !this.ec)
            this.elm.remove();
        this.elm = null;
        // if this is a theme class deactivation, check whether the instance is set as the current
        // one for its theme base class. If yes, remove it as the currently active one.
        if (this.sd instanceof _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition && Object.getPrototypeOf(this.sdc) !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition) {
            let themeClass = this.sd[symClass];
            if (themeClass) {
                let currInstance = getCurrentTheme(themeClass);
                if (currInstance === this.sd)
                    removeCurrentTheme(themeClass);
            }
        }
    }
    /** Writes all rules recursively to the given string. */
    serialize(ctx) {
        // insert @import and @namespace rules as they must be before other rules. If the parent is a grouping
        // rule, don't insert @import and @namespace rules at all
        if (!this.parent) {
            this.imports.forEach(rule => rule.serialize(ctx));
            this.namespaces.forEach(rule => rule.serialize(ctx));
        }
        // activate referenced style definitions
        for (let ref of this.refs)
            ctx.addSD(ref);
        // serialize our custom variables in a ":root" rule
        if (this.vars.length > 0)
            ctx.addRule(getRootCssForVars(this.vars));
        // serialize all other rules
        this.otherRules.forEach(rule => rule.serialize(ctx));
    }
    getVars() { return this.vars; }
}
const getRootCssForVars = (vars) => `:root {${vars.map(varObj => varObj.toCss()).filter(v => !!v).join(";")}}`;
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name generation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Sets the flag indicating whether to use optimized (short) rule names. If yes, the names
 * will be created by appending a unique number to the given prefix. If the prefix is not
 * specified, the standard prefix "n" will be used.
 * @param enable
 * @param prefix
 */
const configNames = (method, prefix) => {
    s_nameGeneratonMethod = method;
    s_uniqueStyleNamesPrefix = prefix ? prefix : "n";
};
/**
 * Flag indicating whether to use optimized names for style elements (classes,  animations, etc.)
 * By default this flag is true in the Release build of the library and false in the Debug build.
 */
let s_nameGeneratonMethod = 2 /* Optimized */;
/////////////
s_nameGeneratonMethod = 1 /* UniqueScoped */;
//////////
/**
 * Prefix to use when generating unique style names. If undefined, a standard prefix "n" will be used.
 */
let s_uniqueStyleNamesPrefix = "n";
/** Next number to use when generating unique identifiers. */
let s_nextUniqueID = 1;
/**
 * Generates name to use for the given rule from the given style sheet.
 */
const generateName = (sheetName, ruleName) => {
    switch (s_nameGeneratonMethod) {
        case 1 /* UniqueScoped */: return `${sheetName}_${ruleName}_${s_nextUniqueID++}`;
        case 2 /* Optimized */: return generateUniqueName();
        case 3 /* Scoped */: return `${sheetName}_${ruleName}`;
    }
};
/**
 * Generates a unique name, which can be used either for style element's ID or or class,
 * identifier or animation name. Names are generated using a simple incrementing number.
 */
const generateUniqueName = (prefix) => (prefix ? prefix : s_uniqueStyleNamesPrefix) + s_nextUniqueID++;
// Looks up a property with the given name in the prototype chain of the given style definition
// class. If found and if the property is a rule, then returns the name assigned for it.
const findNameForRuleInPrototypeChain = (definitionClass, ruleName) => {
    if (!definitionClass)
        return null;
    // loop over prototypes
    for (let baseClass = Object.getPrototypeOf(definitionClass); baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.StyleDefinition && baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition; baseClass = Object.getPrototypeOf(baseClass)) {
        // check if the base class already has an associated instance; if yes, check whether
        // it has a property with the given rule name. If yes, then use this rule's already
        // generated name (if exists).
        if (baseClass.hasOwnProperty(symInstance)) {
            let baseInst = baseClass[symInstance];
            if (baseInst && baseInst[ruleName] != null && "name" in baseInst[ruleName])
                return baseInst[ruleName].name;
        }
    }
    return null;
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Processing functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Processes the given stylesheet definition class or instance and assigns names to its rules.
 * If the parameter is a style definition class we check whether there is an instance already
 * created for it as a class will have only a single associated instane no matter how many times
 * this function is called.
 *
 * If the parameter is an object (an instance of the StyleDefinition class) then we check whether
 * it has already been processed. If yes, we just return it back; if no, we assign new unique names
 * to its rules.
 */
const processSD = (instOrClass, parent) => 
// instOrClass has type "object" if it is an instance and "function" if it is a class
typeof instOrClass === "object" ? processInstance(instOrClass) : processClass(instOrClass, parent);
/**
 * Processes the given style definition class by creating its instance and associating a
 * rule container object with it. The class will be associated with the instance using a
 * Symbol property. The parent parameter is a reference to the parent style defiition
 * object or null if the given class is itself a top-level class (that is, is not a class
 * that defines rules within nested grouping rules).
 */
const processClass = (sdc, parent) => {
    // check whether this definition class is already associated with an instance. Note that we
    // use hasOwnProperty() because otherwise, this could return instance for the base style
    // definition class.
    if (sdc.hasOwnProperty(symInstance))
        return sdc[symInstance];
    // recursively process all base classes so that rule names are generated. We don't activate styles
    // for these classes because derived classes will have all the rules from all the base classes
    // as their own and so these rules will be activated as part of the derived class.
    let baseClass = Object.getPrototypeOf(sdc);
    if (baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.StyleDefinition && baseClass !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition)
        processClass(baseClass, parent);
    try {
        // create the instance of the definition class
        s_processingStyleDefinitionClass = true;
        let sd = new sdc(parent);
        // get rule container from the instance and process the rules.
        sd[symContainer].process();
        return sd;
    }
    finally {
        s_processingStyleDefinitionClass = false;
    }
};
/**
 * Processes the given style definition instance and assigns names to its rules. If the
 * instance has already been processed, we do nothing; otherwise, we assign new unique names
 * to its rules.
 */
const processInstance = (sd) => {
    // if the instance is already processed, just return; in this case we ignore the
    // embeddingContainer parameter.
    let container = sd[symContainer];
    if (!container.processed)
        container.process();
    return sd;
};
/**
 * Processes the given style definition instance and assigns names to its rules. If the
 * instance has already been processed, we do nothing; otherwise, we assign new unique names
 * to its rules.
 */
const getVarsFromSD = (instOrClass) => processSD(instOrClass)[symContainer].getVars();
/**
 * Returns rule container object associated with the given style definition object.
 */
const getRCfromSD = (instance) => instance ? instance[symContainer] : null;
/**
 * Activates the given style definition and inserts all its rules into DOM. If the input object is
 * not a style definition but a style definition class, obtain style definition by calling the $use
 * function. Note that each style definition object maintains a reference counter of how many times
 * it was activated and deactivated. The rules are inserted to DOM only when this reference counter
 * goes from 0 to 1.
 */
const activateSD = (instance) => {
    let ruleContainer = getRCfromSD(instance);
    if (!ruleContainer)
        return;
    // if this container has an embedding container, activate the embedding container; otherwise,
    // activate the rule container itself.
    (ruleContainer.ec ?? ruleContainer).activate();
};
/**
 * Deactivates the given style definition by removing its rules from DOM. Note that each style
 * definition object maintains a reference counter of how many times it was activated and
 * deactivated. The rules are removed from DOM only when this reference counter goes from 1 to 0.
 */
const deactivateSD = (instance) => {
    let ruleContainer = getRCfromSD(instance);
    if (!ruleContainer)
        return;
    // if this container has an embedding container, deactivate the embedding container; otherwise,
    // deactivate the rule container itself.
    (ruleContainer.ec ?? ruleContainer).deactivate();
};
/**
 * Serializes the given style definition to the given string.
 */
const serializeSD = (instance, ctx) => {
    let ruleContainer = getRCfromSD(instance);
    if (ruleContainer)
        ruleContainer.serialize(ctx);
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Embedding
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/** Symbol used in style definition classes to point to an embedding container */
let symEmbeddingContainer = Symbol();
/**
 * The EmbeddingContainer class contains multiple style definition classes, which are activated and
 * deactivated together under a single `<style>` node. Style definition classes are added to the
 * embedding container by being decorated with the `@embedded` decorator.
 */
class EmbeddingContainer {
    constructor(id) {
        this.id = id;
        this.refCount = 0;
        this.sdcs = new Set();
    }
    /**
     * Adds the given style definition class to the list of embedded classes. If the container is
     * currently activated, the class will be activated too.
     */
    add(cls) {
        // add our class to the container
        this.sdcs.add(cls);
        // set the symbol on our class to point to the container
        cls[symEmbeddingContainer] = this;
        // if the embedding container is currently activated, we need to activate the added
        // style definition class using the currently default activator
        if (this.refCount > 0)
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_4__.getActivator)().activate(processClass(cls));
    }
    /**
     * Inserts all stylesheets in this container into DOM.
     */
    activate() {
        // only if this is the first activation call, create the style element and insert all
        // rules from all the style definition classes.
        if (++this.refCount === 1) {
            this.elm = document.createElement("style");
            this.elm.id = this.id;
            document.head.appendChild(this.elm);
            for (let cls of this.sdcs) {
                // definition class may be already associated with an instance; if not -
                // process it now.
                let instance = cls.hasOwnProperty(symInstance)
                    ? cls[symInstance]
                    : processClass(cls);
                let ruleContainer = instance[symContainer];
                ruleContainer.activate();
            }
        }
    }
    /**
     * Removes all stylesheets in this container into DOM.
     */
    deactivate() {
        // only if this is the last deactivation call, remove the style element and remove all
        // rules from all the style definition classes.
        if (--this.refCount === 0) {
            this.elm?.remove();
            this.elm = null;
            for (let cls of this.sdcs) {
                // definition class must be already associated with an instance
                if (!cls.hasOwnProperty(symInstance))
                    continue;
                let instance = cls[symInstance];
                let ruleContainer = instance[symContainer];
                ruleContainer.deactivate();
            }
        }
    }
}
/**
 * Map of category names to embedding container objects containing style definitions for the given
 * category.
 */
let s_embeddingContainers = new Map();
/**
 * Decorator function for style definition classes that will be embedded into an embedding
 * container for the given category. All style definitions for a given category will be activated
 * and deactivated together and their rules will be inserted into a single `<style>` element.
 */
const embeddedDecorator = (category, target) => {
    // check whether we already have container for this category; if not, add it
    let ec = s_embeddingContainers.get(category);
    if (!ec) {
        // generate unique ID for our container, which will be the ID of the `<style>` element
        let id = `${category}_${s_nextUniqueID++}`;
        ec = new EmbeddingContainer(id);
        s_embeddingContainers.set(category, ec);
    }
    // add our class to the container
    ec.add(target);
};
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Rule virtualization.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Decorator that should be applied to a rule if it is defined and used in the same style
 * definition class but then is overridden in a derived style definition class. The problem
 * this solves is this: when a rule is defined in a base class and then overridden in a derived
 * class, when an instance of the derived class is created, the rules that are created in the
 * base and derived classes see different values of the rule. Since our rules are defined as
 * part of the constructor, the base class constructor's code only sees the value assigned in that
 * code. If another rule in the base class uses this first rule, this value is remembered.
 *
 * The `@virtual` decorator creates a Proxy object for the rule with the handler that keeps the
 * most recent value set. Thus when a rule in the base class's constructor uses a virtualized
 * rule, the first rule will see the overridden value of the rule when accessed in the
 * post-constructor code.
 */
const virtualize = (target, name) => {
    // symbol to keep the proxy handler value
    let sym = Symbol(name);
    Object.defineProperty(target, name, {
        enumerable: true,
        get() { return ensureHandlerAndProxy(this, sym).x; },
        set(v) {
            // set the new value to the handler so that it will use it from now on. The primitive
            // values are boxed.
            let type = typeof v;
            ensureHandlerAndProxy(this, sym).t =
                type === "string" ? new String(v) :
                    type === "number" ? new Number(v) :
                        type === "boolean" ? new Boolean(v) :
                            type === "symbol" ? new Object(v) :
                                v;
        }
    });
};
/**
 * Creates handler and proxy in the given object using the given symbol if not created yet.
 * Returns the handler. Proxy is stored in the handler's property.
 */
const ensureHandlerAndProxy = (instance, sym) => {
    // check whether we already have the handler and create it if we don't. In this
    // case we also create a proxy for an empty object
    let handler = instance[sym];
    if (!handler) {
        instance[sym] = handler = new VirtHandler();
        handler.x = new Proxy({}, handler);
    }
    return handler;
};
/**
 * Handler for the proxy created by the `@virtual` decorator. It keeps the current value of a
 * rule so that the most recent value is used whenever the proxy is accessed.
 */
class VirtHandler {
    // interesting things happen in the get method
    get(t, p, r) {
        // if our value is null or undefined and the requested property is a well-known symbol
        // toPrimitive we return a function that returns either null or undefined. This will help
        // if our proxy either participate in an arithmetic expression or is combined with a
        // string.
        if (this.t == null && p === Symbol.toPrimitive)
            return () => this.t;
        // get the value of the request property; if the value is null or undefined, an exception
        // will be thrown - which is expected.
        let pv = Reflect.get(this.t, p, r);
        // if the requested property is a function, bind the original method to the target object
        return typeof pv === "function" ? pv.bind(this.t) : pv;
    }
    // the rest of the methods mostly delegate the calls to the latest target instead of the
    // original target. In some cases, we check whether the target is null or undefined so that
    // we don't throw exceptions where we can avoid it.
    getPrototypeOf(t) { return this.t == null ? null : Reflect.getPrototypeOf(this.t); }
    setPrototypeOf(t, v) { return Reflect.setPrototypeOf(this.t, v); }
    isExtensible(t) { return this.t == null ? false : Reflect.isExtensible(this.t); }
    preventExtensions(t) { return this.t == null ? false : Reflect.preventExtensions(this.t); }
    getOwnPropertyDescriptor(t, p) { return Reflect.getOwnPropertyDescriptor(this.t, p); }
    has(t, p) { return this.t == null ? false : Reflect.has(this.t, p); }
    set(t, p, v, r) { return Reflect.set(this.t, p, v, r); }
    deleteProperty(t, p) { return Reflect.deleteProperty(this.t, p); }
    defineProperty(t, p, attrs) { return Reflect.defineProperty(this.t, p, attrs); }
    ownKeys(t) { return Reflect.ownKeys(this.t); }
    apply(t, thisArg, args) { return this.t.apply(thisArg, args); }
    construct(t, args, newTarget) { return Reflect.construct(this.t, args, newTarget); }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Theming support.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Map of them definition classes to the instances that are currently active for these classes.
 */
let s_themeInstanceMap = new Map();
/**
 * Returns the theme base class for the given theme class.
 * @param themeClass ThemeDefinition-derived class
 * @returns Theme base class.
 */
const getThemeBaseClass = (themeClass) => {
    // make sure we are not passed the ThemeDefinition class itself
    if (themeClass === _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition)
        return undefined;
    // loop over prototypes until we find the class, which derives directly from ThemeDefinition.
    // This is the theme base class
    let themeBaseClass = themeClass;
    for (let cls = Object.getPrototypeOf(themeClass); cls !== _api_RuleAPI__WEBPACK_IMPORTED_MODULE_0__.ThemeDefinition; cls = Object.getPrototypeOf(cls))
        themeBaseClass = cls;
    return themeBaseClass;
};
/**
 * Returns the theme definition object, which is currently activated for the given theme.
 * @param themeClass Theme definition class
 * @returns Theme instance, which is currently activated for the given theme class or null
 * if no istance is currently activated.
 */
const getCurrentTheme = (themeClass) => {
    let themeBaseClass = getThemeBaseClass(themeClass);
    return themeBaseClass && s_themeInstanceMap.get(themeBaseClass);
};
/**
 * Sets the theme definition object as the instance that is currently activated for the
 * corresponding base theme class.
 * @param theme theme instance to set as current for the corresponding base theme class
 */
const setCurrentTheme = (theme) => {
    let themeBaseClass = getThemeBaseClass(theme.constructor);
    themeBaseClass && s_themeInstanceMap.set(themeBaseClass, theme);
};
/**
 * Removes a theme definition object set as the instance that is currently activated for the
 * corresponding base theme class.
 * @param themeClass Theme definition class
 */
const removeCurrentTheme = (themeClass) => {
    let themeBaseClass = getThemeBaseClass(themeClass);
    themeBaseClass && s_themeInstanceMap.delete(themeBaseClass);
};


/***/ }),

/***/ "./lib/rules/StyleRules.js":
/*!*********************************!*\
  !*** ./lib/rules/StyleRules.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleRule": () => (/* binding */ StyleRule),
/* harmony export */   "AbstractRule": () => (/* binding */ AbstractRule),
/* harmony export */   "ClassRule": () => (/* binding */ ClassRule),
/* harmony export */   "IDRule": () => (/* binding */ IDRule),
/* harmony export */   "SelectorRule": () => (/* binding */ SelectorRule)
/* harmony export */ });
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");
/* harmony import */ var _impl_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/Utils */ "./lib/impl/Utils.js");
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../impl/SchedulingImpl */ "./lib/impl/SchedulingImpl.js");
/* harmony import */ var _impl_CoreImpl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../impl/CoreImpl */ "./lib/impl/CoreImpl.js");





/**
 * The StyleRule class is used as a base class for rules that contain a style rule. This class
 * implements the parsing of the CombinedStyleset object.
 */
class StyleRule extends _Rule__WEBPACK_IMPORTED_MODULE_0__.Rule {
    // The styleset can be an CombinedStyleset for many rules; however, for some it is just
    // of the Styleset type.
    constructor(inputStyleset) {
        super();
        // Selector string cached after it is first obtained. Needed to not invoke getSelectorString
        // multiple times in the presence of dependent rules.
        this._sel = null;
        this.styleset = {};
        this.dependentRules = {};
        if (inputStyleset) {
            if (Array.isArray(inputStyleset))
                inputStyleset.forEach(v => this.parse(v));
            else
                this.parse(inputStyleset);
        }
    }
    /**
     * This function allows the object to particpate in "v2s" serialization. Whenever the
     * StyleRule-derived object is encountered by the `v2s` function, the rule's selector will be
     * used.
     */
    [_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.symV2S]() { return this.selectorText; }
    /**
     * Goes over properties in the given styleset and parses them into proper styleset, set of
     * important properties and dependent rules.
     */
    parse(inputStyleset) {
        for (let propName in inputStyleset) {
            let propVal = inputStyleset[propName];
            if (propName === "+") {
                let extendsPropVal = propVal;
                if (extendsPropVal) {
                    // the value is a single StyleRule or an array of StyleRules to copy properties from
                    let parentRules = extendsPropVal instanceof StyleRule ? [extendsPropVal] : extendsPropVal;
                    for (let parent of parentRules) {
                        mergeStylesets(this.styleset, parent.styleset);
                        this.copyDepRules(parent);
                    }
                }
            }
            else if (propName === "--") {
                if (propVal)
                    mergeCustomProps(this.styleset, propVal);
            }
            else if (propName.startsWith(":")) {
                // if the value is an array, then this is an array of tuples representing
                // parameterised pseudo entities where the first element is the parameter value
                // (string) and the second the CombinedStyleset. Otherwise, the value is just a
                // CombinedStyleset.
                if (Array.isArray(propVal)) {
                    let tuples = propVal;
                    if (tuples.length > 0) {
                        this.dependentRules[propName] = tuples.map(tuple => new DepRule(propName, tuple[0], tuple[1], this));
                    }
                }
                else
                    this.dependentRules[propName] = new DepRule("&" + propName, undefined, propVal, this);
            }
            else if (propName.includes("&")) {
                // value is an array of two-element tuples with selector and styleset
                let tuples = propVal;
                if (tuples.length > 0) {
                    this.dependentRules[propName] = tuples.map(tuple => {
                        let newSelector = propName === "&"
                            ? tuple[0]
                            : propName.startsWith("&")
                                ? [propName, tuple[0]]
                                : [tuple[0], propName];
                        return new DepRule(newSelector, undefined, tuple[1], this);
                    });
                }
            }
            else if (this.parseSP(propName, propVal)) {
                // this is a regular CSS property: copy the property value to our internal styleset
                mergePropValues(this.styleset, propName, propVal);
            }
        }
    }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.forEachDepRule((depRule) => depRule.process(container, null));
    }
    // Converts the rule to CSS string representing the rule.
    toCss() {
        return this.selectorText + (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__.styleset2s)(this.styleset);
    }
    // Inserts this rule into the given parent rule or stylesheet.
    insert(parent) {
        if (Object.keys(this.styleset).length > 0)
            this.cssRule = _Rule__WEBPACK_IMPORTED_MODULE_0__.Rule.toDOM(this.toCss(), parent);
        // insert dependent rules under the same parent
        this.forEachDepRule((depRule) => depRule.insert(parent));
    }
    // Clers the CSS rule object.
    clear() {
        super.clear();
        // clear dependent rules
        this.forEachDepRule((depRule) => depRule.clear());
    }
    // Serializes this rule to a string.
    serialize(ctx) {
        if (Object.keys(this.styleset).length > 0)
            ctx.addRule(this.toCss());
        // insert dependent rules under the same parent
        this.forEachDepRule((depRule) => depRule.serialize(ctx));
    }
    // Invoke the given function for each of the dependent rules.
    forEachDepRule(func) {
        for (let propName in this.dependentRules) {
            let propVal = this.dependentRules[propName];
            if (Array.isArray(propVal))
                for (let depRule of propVal)
                    func(depRule);
            else
                func(propVal);
        }
    }
    /** CSS rule selector string */
    get selectorText() {
        if (this._sel == null)
            this._sel = this.getSel();
        return this._sel;
    }
    // Copies dependent rules from another style rule object.
    copyDepRules(src) {
        let srsDepRules = src.dependentRules;
        let thisDepRules = this.dependentRules;
        for (let propName in srsDepRules) {
            let srcRuleOrArr = srsDepRules[propName];
            if (Array.isArray(srcRuleOrArr)) {
                if (srcRuleOrArr.length > 0) {
                    let thisArr = thisDepRules[propName];
                    if (!thisArr)
                        thisDepRules[propName] = thisArr = [];
                    for (let srcDepRule of srcRuleOrArr)
                        thisArr.push(srcDepRule.clone(this));
                }
            }
            else
                thisDepRules[propName] = srcRuleOrArr.clone(this);
        }
    }
    // Allows the derived classes to process style properties that the StyleRule doesn't know about.
    // If false is returned, the property with the given name will not be added to the styleset.
    parseSP(propName, propVal) { return true; }
    /**
     * Adds/replaces the value of the given CSS property in this rule.
     * @param name Name of the CSS property.
     * @param value New value of the CSS property.
     * @param important Flag indicating whether to set the "!important" flag on the property value.
     * @param schedulerType ID of a registered scheduler type that is used to write the property
     * value to the DOM. If undefined, the current default scheduler will be used.
     */
    setProp(name, value, important, schedulerType) {
        // first set/remove the value in our internal styleset object
        if (value == null)
            delete this.styleset[name];
        else
            this.styleset[name] = important ? { "!": value } : value;
        // second, if CSSRule alredy exists, set/remove the property value there
        if (this.cssRule) {
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_3__.scheduleStyleUpdate)(this.cssRule, (0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.camelToDash)(name), value == null ? null : (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__.sp2s)(name, value), important, schedulerType);
        }
    }
    /**
     * Adds/replaces the value of the given custom CSS property in this rule.
     * @param varObj IVarRule object defining a custom CSS property.
     * @param varValue New value of the custom CSS property.
     * @param important Flag indicating whether to set the "!important" flag on the property value.
     * @param schedulerType ID of a registered scheduler type that is used to write the property
     * value to the DOM. If undefined, the current default scheduler will be used.
     */
    setCustomProp(varObj, value, important, schedulerType) {
        if (!varObj)
            return;
        // first set/remove the value in our internal styleset object
        let currCustomProps = this.styleset["--"];
        if (currCustomProps || value != null) {
            if (value == null) {
                let index = currCustomProps.findIndex(item => item[0] === varObj);
                if (index >= 0)
                    currCustomProps.splice(index, 1);
            }
            else if (!currCustomProps)
                this.styleset["--"] = [[varObj, value]];
            else {
                let index = currCustomProps.findIndex(item => item[0] === varObj);
                if (index >= 0)
                    currCustomProps[index][1] = value;
                else
                    currCustomProps.push([varObj, value]);
            }
        }
        // second, if CSSRule alredy exists, set/remove the property value there
        if (this.cssRule) {
            (0,_impl_SchedulingImpl__WEBPACK_IMPORTED_MODULE_3__.scheduleStyleUpdate)(this.cssRule, varObj.cssVarName, value == null ? null : (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_2__.sp2s)(varObj.template, value), important, schedulerType);
        }
    }
}
/**
 * The DependentRule class describes a styleset that depends on the containing style rule. This
 * is used for pseudo classes, pseudo elements, combinators and other selectors that combine the
 * containing rule's selector with additional selector items.
 */
class DepRule extends StyleRule {
    // for regular selectors, pseudo classes and pseudo elements, the selector already contains
    // the ampersand and the selectorParam is undefined. For parameterized pseudo classes, pseudo
    // elements and combinators, the selectorParam is defined and the selector is just the entity
    // name.
    constructor(selector, param, styleset, parent) {
        super(styleset);
        this.selector = selector;
        this.parent = parent;
        this.param = param;
    }
    // Creates a copy of the rule but with new parent (containing rule).
    clone(containingRule) {
        let newRule = new DepRule(this.selector, this.param, undefined, containingRule);
        // this method is called on a newly created object so we don't have any properties in
        // our own styleset yet
        mergeStylesets(newRule.styleset, this.styleset);
        newRule.copyDepRules(this);
        return newRule;
    }
    // Returns the selector part of the style rule.
    getSel() {
        let parentSelector = this.parent.selectorText;
        if (this.param) {
            // the "param" value is only set for parameterized pseudo entities, so we convert it to
            // the "func" object form. We also know that the selector is a string - name of the entity.
            return `${parentSelector}${(0,_impl_Utils__WEBPACK_IMPORTED_MODULE_1__.fdo2s)({ fn: this.selector, p: this.param })}`;
        }
        else {
            // convert selector to string.
            let selector = (0,_impl_CoreImpl__WEBPACK_IMPORTED_MODULE_4__.selector2s)(this.selector);
            // if the selector string doesn't have any occurrences of the ampersand symbol, we
            // simply append the selector to the parent selector; otherwise, we replace all
            // occurrences of the ampersand symbol in the selector string with the selector
            // string of the parent rule.
            return selector.indexOf("&") < 0
                ? `${parentSelector}${selector}`
                : selector.replace(/&/g, parentSelector);
        }
    }
}
/**
 * The AbstractRule class describes a styleset that can only be used as a base for other style
 * rules.
 */
class AbstractRule extends StyleRule {
    // Overrides the StyleRule's implementation to do nothing. No CSSStyleRule is created for
    // abstract rules.
    insert(parent) { }
    // Overrides the StyleRule's implementation to do nothing.
    clear() { }
    // Overrides the StyleRule's implementation to do nothing.
    serialize(ctx) { }
    // Returns the selector part of the style rule.
    getSel() { return ""; }
}
/**
 * The NamedStyleRule class is a base for style rule classes that are also named entities - such
 * as class rule and ID rule.
 */
class NamedStyleRule extends StyleRule {
    constructor(styleset, nameOverride) {
        super(styleset);
        this.nameOverride = nameOverride;
    }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.name = container.getScopedName(ruleName, this.nameOverride);
        this.cssName = this.cssPrefix + this.name.replace(/ /g, this.cssPrefix);
    }
    // Returns the selector part of the style rule.
    getSel() {
        return this.cssName;
    }
    // Implementation of the toString method returns the name of the rule (without the CSS prefix).
    toString() {
        return this.name;
    }
}
/**
 * The ClassRule class describes a styleset that applies to elements identified by a CSS class.
 */
class ClassRule extends NamedStyleRule {
    // Allows the derived classes to process style properties that the StyleRule doesn't know about.
    // If returns false, the property with the given name will not be added to the styleset.
    parseSP(propName, propVal) {
        if (propName == "++") {
            let rules = propVal;
            if (rules)
                this.parents = Array.isArray(rules) ? rules : [rules];
            return false;
        }
        return super.parseSP(propName, propVal);
    }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        // by now our name and cssName properties have been set to reflect a single name. Now
        // look at the parent class rues defined using the "++" property and take names from the
        // referenced class rules and append them to the name.
        if (this.parents) {
            this.name += " " + this.parents.map(cls => typeof cls === "string" ? cls : cls.name).join(" ");
            this.cssName = "." + this.name.replace(/ /g, ".");
        }
    }
    /** Name of the class prefixed with "." */
    get cssClassName() { return this.cssName; }
    // Returns prefix that is put before the entity name to create a CSS name used in style rule
    // selectors.
    get cssPrefix() { return "."; }
}
/**
 * The IDRule class describes a styleset that applies to elements identified by an ID.
 */
class IDRule extends NamedStyleRule {
    /** Name of the element ID prefixed with "#" */
    get cssIDName() { return this.cssName; }
    // Returns prefix that is put before the entity name to create a CSS name used in style rule
    // selectors.
    get cssPrefix() { return "#"; }
}
/**
 * The SelectorRule type describes a styleset that applies to elements identified by a CSS selector.
 */
class SelectorRule extends StyleRule {
    constructor(selector, styleset) {
        super(styleset);
        this.selector = selector;
    }
    // Returns the selector part of the style rule.
    getSel() {
        return (0,_impl_CoreImpl__WEBPACK_IMPORTED_MODULE_4__.selector2s)(this.selector);
    }
}
/**
 * Merges properties from the source styleset to the target styleset. All regular properties are
 * replaced. The "--" property gets special treatment because it is an array.
 * @param target Target Styleset object - cannot be null or undefined;
 * @param source Source Styleset object - cannot be null or undefined.
 * @param source
 */
const mergeStylesets = (target, source) => {
    // copy all other properties from the source
    if (Object.keys(target).length === 0)
        Object.assign(target, source);
    else {
        for (let propName in source) {
            if (propName === "--")
                mergeCustomProps(target, source[propName]);
            else
                mergePropValues(target, propName, source[propName]);
        }
    }
};
/**
 * Merges "--" property from the source styleset to the target styleset.
 */
const mergeCustomProps = (target, sourceVars) => {
    let targetVars = target["--"];
    target["--"] = !targetVars ? sourceVars.slice() : targetVars.concat(sourceVars);
};
/**
 * Merges values of the given property from the source styleset to the target styleset. Note that
 * both source or target value can be either null or single value or an object with the `"[]"`
 * property that contains multiple values.
 * @param target Target Styleset object - cannot be null or undefined.
 * @param propName Name of the property.
 * @param sourceVal Value from the source styleset to merge with the target value - can be null or
 * undefined.
 */
const mergePropValues = (target, propName, sourceVal) => {
    if (sourceVal == null)
        delete target[propName];
    else {
        let targetVal = target[propName];
        if (targetVal == null) {
            // if property doesn't exist in the target or its value is null or undefined, just
            // take the source's value
            target[propName] = sourceVal;
        }
        else {
            let targetArray = targetVal["[]"];
            if (!targetArray)
                target[propName] = { "[]": targetArray = [targetVal] };
            let sourceArray = sourceVal["[]"];
            if (!sourceArray)
                targetArray.push(sourceVal);
            else
                targetArray.push(...sourceArray);
        }
    }
};


/***/ }),

/***/ "./lib/rules/VarRule.js":
/*!******************************!*\
  !*** ./lib/rules/VarRule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VarRule": () => (/* binding */ VarRule),
/* harmony export */   "PropertyRule": () => (/* binding */ PropertyRule),
/* harmony export */   "ConstRule": () => (/* binding */ ConstRule)
/* harmony export */ });
/* harmony import */ var _impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/StyleImpl */ "./lib/impl/StyleImpl.js");
/* harmony import */ var _Rule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rule */ "./lib/rules/Rule.js");


/**
 * The VarBaseRule class contains functionality common for VarRule class describing a custom CSS
 * property definition in the `:root` rule and for PropertyRule class describing the `@property`
 * at-rule.
 */
class VarBaseRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule {
    constructor(template, value, nameOverride) {
        super();
        this.template = template;
        this.value = value;
        this.nameOverride = nameOverride;
    }
    // This function is used when the object is specified as a value of a style property.
    // We return the var(--name) expression.
    toString() {
        return `var(${this.cssVarName})`;
    }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        this.name = container.getScopedName(ruleName, this.nameOverride);
        if (this.name.startsWith("--"))
            this.name = this.name.substr(2);
        this.cssVarName = "--" + this.name;
    }
    // Inserts this rule into the given parent rule or stylesheet. This method is called when the
    // style definition class, to which this rule belongs, is activated.
    insert(parent) { }
    // Serializes this rule to a string.
    serialize(ctx) { }
    /**
     * Gets the value of the property.
     */
    getValue() {
        return this.value;
    }
    /**
     * Sets new value of this custom CSS property.
     * @param value New value for the CSS property.
     * @param schedulerType ID of a registered scheduler type that is used to write the property
     * value to the DOM. If undefined, the current default scheduler will be used.
     */
    setValue(value, schedulerType) {
        this.value = value;
        if (this.c) {
            let important = false;
            if (value != null && typeof value === "object" && "!" in value) {
                important = true;
                value = value["!"];
            }
            this.c.setVarValue(this.cssVarName, value == null
                ? null
                : (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(this.template, value), important, schedulerType);
        }
    }
}
/**
 * The VarRule class describes a custom CSS property. VarRule is not a real CSS rule; however, in
 * many aspects it repeats the Rule's functionality. In particular it has the process function that
 * allows it to obtain an actual name, which will be used when defining and using this custom
 * property in CSS.
 */
class VarRule extends VarBaseRule {
    constructor(template, value, nameOverride) {
        super(template, value, nameOverride);
    }
    // Converts the rule to CSS string.
    toCss() {
        return this.value == null ? null : `${this.cssVarName}: ${(0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(this.template, this.value)}`;
    }
}
/**
 * The PropertyRule class describes the `@property` at-rule.
 */
class PropertyRule extends VarBaseRule {
    constructor(syntax, initValue, inherits = true, nameOverride) {
        if (Array.isArray(syntax)) {
            super("*", initValue, nameOverride);
            this.syntax = syntax[0];
        }
        else {
            super(syntax, initValue, nameOverride);
            this.syntax = syntax;
        }
        this.inherits = inherits;
    }
    // public constructor( syntax: K, initValue: ExtendedVarValue<K>, inherits: boolean, nameOverride?: string | IVarRule<K>)
    // {
    //     super( syntax, initValue, nameOverride);
    // 	this.inherits = inherits;
    // }
    // Inserts this rule into the given parent rule or stylesheet. This method is called when the
    // style definition class, to which this rule belongs, is activated.
    insert(parent) {
        this.cssRule = _Rule__WEBPACK_IMPORTED_MODULE_1__.Rule.toDOM(this.toCss(), parent);
    }
    // Serializes this rule to a string.
    serialize(ctx) {
        ctx.addRule(this.toCss());
    }
    // Converts the rule to CSS string.
    toCss() {
        return `@property ${this.cssVarName}{syntax:'${this.syntax}';inherits:${this.inherits};` +
            `initial-value:${(0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(this.template, this.value)};}`;
    }
}
/**
 * The IConstRule interface represents a "constant" that can be used anywhere the type defined by
 * the `template` parameter can be used. These are called constants, because they provide the
 * convenient and lightweight way of defining values that are unchanged during the application
 * lifetime. Although constants are defined very similarly to custom properties (see the
 * [[IVarRule]] function), they cannot participate in the cascade and cannot be redefined under
 * elements. Constant can, however, use any expression that satisfies the type defined by the
 * `template` parameter including other constants, custom properties and functions.
 * Objects implementing this interface are returned from the [[$const]] function.
 */
class ConstRule extends _Rule__WEBPACK_IMPORTED_MODULE_1__.RuleLike {
    constructor(template, value, cachedValue) {
        super();
        this.template = template;
        this.value = value;
        this._val = cachedValue;
    }
    // This function is used when the object is specified as a value of a style property.
    toString() { return this._val; }
    // Processes the given rule.
    process(container, ruleName) {
        super.process(container, ruleName);
        if (!this._val)
            this._val = (0,_impl_StyleImpl__WEBPACK_IMPORTED_MODULE_0__.sp2s)(this.template, this.value);
    }
    /**
     * Gets the value of the property.
     */
    getValue() {
        return this.value;
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attr": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.attr),
/* harmony export */   "counter": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.counter),
/* harmony export */   "counters": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.counters),
/* harmony export */   "cubicBezier": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.cubicBezier),
/* harmony export */   "cursor": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.cursor),
/* harmony export */   "raw": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.raw),
/* harmony export */   "sel": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.sel),
/* harmony export */   "selector": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.selector),
/* harmony export */   "steps": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.steps),
/* harmony export */   "url": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.url),
/* harmony export */   "usevar": () => (/* reexport safe */ _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__.usevar),
/* harmony export */   "Angle": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Angle),
/* harmony export */   "Frequency": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Frequency),
/* harmony export */   "Len": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Len),
/* harmony export */   "Num": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Num),
/* harmony export */   "Percent": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Percent),
/* harmony export */   "Q": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Q),
/* harmony export */   "Resolution": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Resolution),
/* harmony export */   "Time": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.Time),
/* harmony export */   "ch": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ch),
/* harmony export */   "cm": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.cm),
/* harmony export */   "deg": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.deg),
/* harmony export */   "dpcm": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.dpcm),
/* harmony export */   "dpi": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.dpi),
/* harmony export */   "dppx": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.dppx),
/* harmony export */   "em": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.em),
/* harmony export */   "ex": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ex),
/* harmony export */   "fitContent": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.fitContent),
/* harmony export */   "fr": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.fr),
/* harmony export */   "grad": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.grad),
/* harmony export */   "hz": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.hz),
/* harmony export */   "ic": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ic),
/* harmony export */   "inch": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.inch),
/* harmony export */   "khz": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.khz),
/* harmony export */   "lh": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.lh),
/* harmony export */   "mm": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.mm),
/* harmony export */   "ms": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ms),
/* harmony export */   "pc": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.pc),
/* harmony export */   "percent": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.percent),
/* harmony export */   "pt": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.pt),
/* harmony export */   "px": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.px),
/* harmony export */   "rad": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rad),
/* harmony export */   "ratio": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.ratio),
/* harmony export */   "rect": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rect),
/* harmony export */   "rem": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rem),
/* harmony export */   "rlh": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.rlh),
/* harmony export */   "s": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.s),
/* harmony export */   "turn": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.turn),
/* harmony export */   "vb": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vb),
/* harmony export */   "vh": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vh),
/* harmony export */   "vi": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vi),
/* harmony export */   "vmax": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vmax),
/* harmony export */   "vmin": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vmin),
/* harmony export */   "vw": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.vw),
/* harmony export */   "x": () => (/* reexport safe */ _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__.x),
/* harmony export */   "Colors": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.Colors),
/* harmony export */   "alpha": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.alpha),
/* harmony export */   "colorContrast": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.colorContrast),
/* harmony export */   "colorMix": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.colorMix),
/* harmony export */   "hsl": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.hsl),
/* harmony export */   "lab": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.lab),
/* harmony export */   "lch": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.lch),
/* harmony export */   "registerColor": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.registerColor),
/* harmony export */   "rgb": () => (/* reexport safe */ _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__.rgb),
/* harmony export */   "blur": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.blur),
/* harmony export */   "brightness": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.brightness),
/* harmony export */   "circle": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.circle),
/* harmony export */   "conicGradient": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.conicGradient),
/* harmony export */   "contrast": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.contrast),
/* harmony export */   "crossFade": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.crossFade),
/* harmony export */   "dropShadow": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.dropShadow),
/* harmony export */   "ellipse": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.ellipse),
/* harmony export */   "grayscale": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.grayscale),
/* harmony export */   "hueRotate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.hueRotate),
/* harmony export */   "imageSet": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.imageSet),
/* harmony export */   "inset": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.inset),
/* harmony export */   "invert": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.invert),
/* harmony export */   "linearGradient": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.linearGradient),
/* harmony export */   "matrix": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.matrix),
/* harmony export */   "matrix3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.matrix3d),
/* harmony export */   "minmax": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.minmax),
/* harmony export */   "opacity": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.opacity),
/* harmony export */   "paint": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.paint),
/* harmony export */   "path": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.path),
/* harmony export */   "perspective": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.perspective),
/* harmony export */   "polygon": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.polygon),
/* harmony export */   "radialGradient": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.radialGradient),
/* harmony export */   "ray": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.ray),
/* harmony export */   "registerPaintWorklet": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.registerPaintWorklet),
/* harmony export */   "repeat": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.repeat),
/* harmony export */   "rotate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotate),
/* harmony export */   "rotate3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotate3d),
/* harmony export */   "rotateX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotateX),
/* harmony export */   "rotateY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotateY),
/* harmony export */   "rotateZ": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.rotateZ),
/* harmony export */   "saturate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.saturate),
/* harmony export */   "scale": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scale),
/* harmony export */   "scale3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scale3d),
/* harmony export */   "scaleX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scaleX),
/* harmony export */   "scaleY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scaleY),
/* harmony export */   "scaleZ": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.scaleZ),
/* harmony export */   "sepia": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.sepia),
/* harmony export */   "skew": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.skew),
/* harmony export */   "skewX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.skewX),
/* harmony export */   "skewY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.skewY),
/* harmony export */   "span": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.span),
/* harmony export */   "translate": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translate),
/* harmony export */   "translate3d": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translate3d),
/* harmony export */   "translateX": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translateX),
/* harmony export */   "translateY": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translateY),
/* harmony export */   "translateZ": () => (/* reexport safe */ _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__.translateZ),
/* harmony export */   "StyleDefinition": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.StyleDefinition),
/* harmony export */   "ThemeDefinition": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.ThemeDefinition),
/* harmony export */   "activate": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.activate),
/* harmony export */   "chooseClass": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.chooseClass),
/* harmony export */   "classes": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.classes),
/* harmony export */   "configNameGeneration": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.configNameGeneration),
/* harmony export */   "deactivate": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.deactivate),
/* harmony export */   "embedded": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.embedded),
/* harmony export */   "getActiveTheme": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.getActiveTheme),
/* harmony export */   "virtual": () => (/* reexport safe */ _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__.virtual),
/* harmony export */   "cancelDOMUpdate": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.cancelDOMUpdate),
/* harmony export */   "forceDOMUpdate": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.forceDOMUpdate),
/* harmony export */   "getDefaultScheduler": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.getDefaultScheduler),
/* harmony export */   "registerScheduler": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.registerScheduler),
/* harmony export */   "setDefaultScheduler": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.setDefaultScheduler),
/* harmony export */   "unregisterScheduler": () => (/* reexport safe */ _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__.unregisterScheduler),
/* harmony export */   "createCssSerializer": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.createCssSerializer),
/* harmony export */   "diffStylesets": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.diffStylesets),
/* harmony export */   "getStylePropValue": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.getStylePropValue),
/* harmony export */   "media": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.media),
/* harmony export */   "mediaToString": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.mediaToString),
/* harmony export */   "registerStyleProperty": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.registerStyleProperty),
/* harmony export */   "serializeToCSS": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.serializeToCSS),
/* harmony export */   "setElementStringStyle": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.setElementStringStyle),
/* harmony export */   "setElementStyle": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.setElementStyle),
/* harmony export */   "stylesetToString": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.stylesetToString),
/* harmony export */   "stylesetToStringStyleset": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.stylesetToStringStyleset),
/* harmony export */   "supports": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.supports),
/* harmony export */   "supportsToString": () => (/* reexport safe */ _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__.supportsToString)
/* harmony export */ });
/* harmony import */ var _api_CoreTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api/CoreTypes */ "./lib/api/CoreTypes.js");
/* harmony import */ var _api_NumericTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api/NumericTypes */ "./lib/api/NumericTypes.js");
/* harmony import */ var _api_ColorTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api/ColorTypes */ "./lib/api/ColorTypes.js");
/* harmony import */ var _api_ShapeTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api/ShapeTypes */ "./lib/api/ShapeTypes.js");
/* harmony import */ var _api_FontTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./api/FontTypes */ "./lib/api/FontTypes.js");
/* harmony import */ var _api_MediaTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./api/MediaTypes */ "./lib/api/MediaTypes.js");
/* harmony import */ var _api_RuleTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./api/RuleTypes */ "./lib/api/RuleTypes.js");
/* harmony import */ var _api_SchedulingTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./api/SchedulingTypes */ "./lib/api/SchedulingTypes.js");
/* harmony import */ var _api_StyleTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./api/StyleTypes */ "./lib/api/StyleTypes.js");
/* harmony import */ var _api_Stylesets__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./api/Stylesets */ "./lib/api/Stylesets.js");
/* harmony import */ var _api_CoreAPI__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./api/CoreAPI */ "./lib/api/CoreAPI.js");
/* harmony import */ var _api_NumericAPI__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./api/NumericAPI */ "./lib/api/NumericAPI.js");
/* harmony import */ var _api_ColorAPI__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./api/ColorAPI */ "./lib/api/ColorAPI.js");
/* harmony import */ var _api_ShapeAPI__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./api/ShapeAPI */ "./lib/api/ShapeAPI.js");
/* harmony import */ var _api_RuleAPI__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./api/RuleAPI */ "./lib/api/RuleAPI.js");
/* harmony import */ var _api_SchedulingAPI__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./api/SchedulingAPI */ "./lib/api/SchedulingAPI.js");
/* harmony import */ var _api_StyleAPI__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./api/StyleAPI */ "./lib/api/StyleAPI.js");
// Type definitions for mimcss


















})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW1jc3Mvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvQ29sb3JBUEkudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2FwaS9Db3JlQVBJLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvQ29yZVR5cGVzLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvTnVtZXJpY0FQSS50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvYXBpL051bWVyaWNUeXBlcy50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvYXBpL1J1bGVBUEkudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2FwaS9TY2hlZHVsaW5nQVBJLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9hcGkvU2hhcGVBUEkudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2FwaS9TdHlsZUFQSS50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9Db3JlSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9NaXNjSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9OdW1lcmljSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9TY2hlZHVsaW5nSW1wbC50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvaW1wbC9TdHlsZUltcGwudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2ltcGwvVXRpbHMudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL0FuaW1hdGlvblJ1bGUudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL0NvdW50ZXJSdWxlcy50cyIsIndlYnBhY2s6Ly9taW1jc3MvLi9zcmMvcnVsZXMvR3JpZFJ1bGVzLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9ydWxlcy9Hcm91cFJ1bGVzLnRzIiwid2VicGFjazovL21pbWNzcy8uL3NyYy9ydWxlcy9NaXNjUnVsZXMudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1J1bGUudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1J1bGVDb250YWluZXIudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1N0eWxlUnVsZXMudHMiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL3J1bGVzL1ZhclJ1bGUudHMiLCJ3ZWJwYWNrOi8vbWltY3NzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL21pbWNzcy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbWltY3NzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbWltY3NzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbWltY3NzLy4vc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1A0RDtBQUk1RDs7Ozs7RUFLRTtBQUNLLE1BQU0sTUFBTSxHQUNuQjtJQUNJLEtBQUssRUFBbUIsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsSUFBSSxFQUFvQixRQUFRO0lBQ2hDLEtBQUssRUFBbUIsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsR0FBRyxFQUFxQixRQUFRO0lBQ2hDLE1BQU0sRUFBa0IsUUFBUTtJQUNoQyxPQUFPLEVBQWlCLFFBQVE7SUFDaEMsS0FBSyxFQUFtQixRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxLQUFLLEVBQW1CLFFBQVE7SUFDaEMsTUFBTSxFQUFrQixRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxJQUFJLEVBQW9CLFFBQVE7SUFDaEMsSUFBSSxFQUFvQixRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsU0FBUyxFQUFlLFFBQVE7SUFDaEMsWUFBWSxFQUFZLFFBQVE7SUFDaEMsVUFBVSxFQUFjLFFBQVE7SUFDaEMsS0FBSyxFQUFtQixRQUFRO0lBQ2hDLEtBQUssRUFBbUIsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsY0FBYyxFQUFVLFFBQVE7SUFDaEMsVUFBVSxFQUFjLFFBQVE7SUFDaEMsS0FBSyxFQUFtQixRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLFVBQVUsRUFBYyxRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLEtBQUssRUFBbUIsUUFBUTtJQUNoQyxjQUFjLEVBQVUsUUFBUTtJQUNoQyxRQUFRLEVBQWdCLFFBQVE7SUFDaEMsT0FBTyxFQUFpQixRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxRQUFRLEVBQWdCLFFBQVE7SUFDaEMsUUFBUSxFQUFnQixRQUFRO0lBQ2hDLGFBQWEsRUFBVyxRQUFRO0lBQ2hDLFFBQVEsRUFBZ0IsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxRQUFRLEVBQWdCLFFBQVE7SUFDaEMsU0FBUyxFQUFlLFFBQVE7SUFDaEMsV0FBVyxFQUFhLFFBQVE7SUFDaEMsY0FBYyxFQUFVLFFBQVE7SUFDaEMsVUFBVSxFQUFjLFFBQVE7SUFDaEMsVUFBVSxFQUFjLFFBQVE7SUFDaEMsT0FBTyxFQUFpQixRQUFRO0lBQ2hDLFVBQVUsRUFBYyxRQUFRO0lBQ2hDLFlBQVksRUFBWSxRQUFRO0lBQ2hDLGFBQWEsRUFBVyxRQUFRO0lBQ2hDLGFBQWEsRUFBVyxRQUFRO0lBQ2hDLGFBQWEsRUFBVyxRQUFRO0lBQ2hDLGFBQWEsRUFBVyxRQUFRO0lBQ2hDLFVBQVUsRUFBYyxRQUFRO0lBQ2hDLFFBQVEsRUFBZ0IsUUFBUTtJQUNoQyxXQUFXLEVBQWEsUUFBUTtJQUNoQyxPQUFPLEVBQWlCLFFBQVE7SUFDaEMsT0FBTyxFQUFpQixRQUFRO0lBQ2hDLFVBQVUsRUFBYyxRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLFdBQVcsRUFBYSxRQUFRO0lBQ2hDLFdBQVcsRUFBYSxRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLFVBQVUsRUFBYyxRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxXQUFXLEVBQWEsUUFBUTtJQUNoQyxJQUFJLEVBQW9CLFFBQVE7SUFDaEMsUUFBUSxFQUFnQixRQUFRO0lBQ2hDLE9BQU8sRUFBaUIsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsS0FBSyxFQUFtQixRQUFRO0lBQ2hDLEtBQUssRUFBbUIsUUFBUTtJQUNoQyxRQUFRLEVBQWdCLFFBQVE7SUFDaEMsYUFBYSxFQUFXLFFBQVE7SUFDaEMsU0FBUyxFQUFlLFFBQVE7SUFDaEMsWUFBWSxFQUFZLFFBQVE7SUFDaEMsU0FBUyxFQUFlLFFBQVE7SUFDaEMsVUFBVSxFQUFjLFFBQVE7SUFDaEMsU0FBUyxFQUFlLFFBQVE7SUFDaEMsb0JBQW9CLEVBQUksUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxVQUFVLEVBQWMsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxXQUFXLEVBQWEsUUFBUTtJQUNoQyxhQUFhLEVBQVcsUUFBUTtJQUNoQyxZQUFZLEVBQVksUUFBUTtJQUNoQyxjQUFjLEVBQVUsUUFBUTtJQUNoQyxjQUFjLEVBQVUsUUFBUTtJQUNoQyxjQUFjLEVBQVUsUUFBUTtJQUNoQyxXQUFXLEVBQWEsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxLQUFLLEVBQW1CLFFBQVE7SUFDaEMsT0FBTyxFQUFpQixRQUFRO0lBQ2hDLGdCQUFnQixFQUFRLFFBQVE7SUFDaEMsVUFBVSxFQUFjLFFBQVE7SUFDaEMsWUFBWSxFQUFZLFFBQVE7SUFDaEMsWUFBWSxFQUFZLFFBQVE7SUFDaEMsY0FBYyxFQUFVLFFBQVE7SUFDaEMsZUFBZSxFQUFTLFFBQVE7SUFDaEMsaUJBQWlCLEVBQU8sUUFBUTtJQUNoQyxlQUFlLEVBQVMsUUFBUTtJQUNoQyxlQUFlLEVBQVMsUUFBUTtJQUNoQyxZQUFZLEVBQVksUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxRQUFRLEVBQWdCLFFBQVE7SUFDaEMsV0FBVyxFQUFhLFFBQVE7SUFDaEMsT0FBTyxFQUFpQixRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLE1BQU0sRUFBa0IsUUFBUTtJQUNoQyxhQUFhLEVBQVcsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxhQUFhLEVBQVcsUUFBUTtJQUNoQyxhQUFhLEVBQVcsUUFBUTtJQUNoQyxVQUFVLEVBQWMsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxJQUFJLEVBQW9CLFFBQVE7SUFDaEMsSUFBSSxFQUFvQixRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxVQUFVLEVBQWMsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxXQUFXLEVBQWEsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsVUFBVSxFQUFjLFFBQVE7SUFDaEMsUUFBUSxFQUFnQixRQUFRO0lBQ2hDLFFBQVEsRUFBZ0IsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsT0FBTyxFQUFpQixRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLFNBQVMsRUFBZSxRQUFRO0lBQ2hDLElBQUksRUFBb0IsUUFBUTtJQUNoQyxXQUFXLEVBQWEsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxHQUFHLEVBQXFCLFFBQVE7SUFDaEMsT0FBTyxFQUFpQixRQUFRO0lBQ2hDLE1BQU0sRUFBa0IsUUFBUTtJQUNoQyxTQUFTLEVBQWUsUUFBUTtJQUNoQyxNQUFNLEVBQWtCLFFBQVE7SUFDaEMsS0FBSyxFQUFtQixRQUFRO0lBQ2hDLFVBQVUsRUFBYyxRQUFRO0lBQ2hDLFdBQVcsRUFBYSxRQUFRO0lBQ2hDLGFBQWEsRUFBVyxRQUFRO0NBQ25DLENBQUM7QUFJRjs7O0dBR0c7QUFDSCxNQUFNLFlBQVksR0FBNEIsRUFBRSxDQUFDO0FBSWpEOzs7Ozs7OztHQVFHO0FBQ0ksTUFBTSxhQUFhLEdBQUcsQ0FBRSxJQUF3QixFQUFFLEtBQWEsRUFBVyxFQUFFO0lBRS9FLElBQUksQ0FBQyxJQUFJLElBQUksS0FBSyxJQUFJLElBQUk7UUFDdEIsT0FBTyxLQUFLLENBQUM7SUFFakIseUZBQXlGO0lBQ3pGLHlDQUF5QztJQUN6QyxJQUFJLFdBQVcsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFckMsd0ZBQXdGO0lBQ3hGLG1DQUFtQztJQUNuQyxJQUFJLElBQUksSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLElBQUk7UUFDckMsT0FBTyxLQUFLLENBQUM7SUFFakIsdURBQXVEO0lBQ3RELE1BQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDOUIsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMzQixPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDO0FBSUQ7O0dBRUc7QUFDSCxJQUFLLGFBQWEsR0FBRyxDQUFDLEdBQVcsRUFBVSxFQUFFO0lBRXpDLDRFQUE0RTtJQUM1RSxJQUFJLFVBQVUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUVoQywwRUFBMEU7SUFDMUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQ3hCO1FBQ0ksSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixrQ0FBa0M7UUFDbEMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDL0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNUO0lBRUQsd0ZBQXdGO0lBQ3hGLG9EQUFvRDtJQUNwRCxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBRXBELElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDL0MsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBSUQ7Ozs7O0dBS0c7QUFDSCxnREFBYyxHQUFHLENBQUMsR0FBdUIsRUFBVSxFQUFFLENBQ2pELGdEQUFHLENBQUUsR0FBRyxFQUFFO0lBQ04sR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLEdBQUcsRUFBRSxhQUFhO0NBQ3JCLENBQUMsQ0FBQztBQUVQOzs7OztHQUtHO0FBQ0gsZ0RBQWUsR0FBRyxDQUFDLEdBQXdCLEVBQVUsRUFBRSxDQUFDLGdEQUFHLENBQUUsR0FBRyxFQUFFLEVBQUUsR0FBRyxnQkFBVyxFQUFFLENBQUM7QUFJckY7O0dBRUc7QUFDSCxnREFBd0IsR0FBRyxDQUFDLENBQW1CLEVBQVUsRUFBRSxDQUN2RCxnREFBRyxDQUFFLENBQUMsRUFBRTtJQUNKLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRTtRQUNMLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25CLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUN2RSxDQUFDO0NBQ0osQ0FBQztBQUlOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVCRztBQUNJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBK0IsRUFBRSxDQUErQixFQUNoRixDQUErQixFQUFFLENBQXdCLEVBQVksRUFBRTtJQUV2RSxPQUFPLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUNyQyxDQUFDO0FBRUQsZ0RBQU8sR0FBRztJQUNOLENBQUMsRUFBRSxDQUFFLENBQUMsR0FBRywyQkFBc0IsRUFBRSxDQUFDLEdBQUcsMkJBQXVCLEVBQUUsQ0FBQyxHQUFHLDJCQUF1QixFQUFFLENBQUMsR0FBRyxtQkFBZ0IsR0FBRyxDQUFDLENBQUU7SUFDckgsQ0FBQyxFQUFFLEdBQUc7Q0FDVCxDQUFDO0FBSUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEJHO0FBQ0ksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFxQixFQUFFLENBQXVCLEVBQUUsQ0FBdUIsRUFDdkYsQ0FBd0IsRUFBWSxFQUFFO0lBRXRDLE9BQU8sRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQ3JDLENBQUM7QUFFRCxnREFBTyxHQUFHO0lBQ04sQ0FBQyxFQUFFLENBQUUsQ0FBQyxHQUFHLGdCQUFZLEVBQUUsQ0FBQyxHQUFHLGtCQUFjLEVBQUUsQ0FBQyxHQUFHLGtCQUFjLEVBQUUsQ0FBQyxHQUFHLG1CQUFlLEdBQUcsQ0FBQyxDQUFFO0lBQ3hGLENBQUMsRUFBRSxHQUFHO0NBQ1QsQ0FBQztBQUlGOzs7Ozs7Ozs7Ozs7R0FZRztBQUNJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBdUIsRUFBRSxFQUFvQixFQUFFLEVBQW9CLEVBQ25GLENBQXdCLEVBQVksRUFBRTtJQUV0QyxPQUFPLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUN2QyxDQUFDO0FBRUQsZ0RBQU8sR0FBRztJQUNOLENBQUMsRUFBRSxDQUFFLENBQUMsR0FBRyx5QkFBb0IsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxtQkFBZSxHQUFHLENBQUMsQ0FBRTtJQUNwRSxDQUFDLEVBQUUsR0FBRztDQUNULENBQUM7QUFJRjs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQXVCLEVBQUUsQ0FBbUIsRUFBRSxDQUFxQixFQUNuRixDQUF3QixFQUFZLEVBQUU7SUFFdEMsT0FBTyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDckMsQ0FBQztBQUVELGdEQUFPLEdBQUc7SUFDTixDQUFDLEVBQUUsQ0FBRSxDQUFDLEdBQUcseUJBQW9CLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxnQkFBWSxFQUFFLENBQUMsR0FBRyxtQkFBZSxHQUFHLENBQUMsQ0FBRTtJQUMvRSxDQUFDLEVBQUUsR0FBRztDQUNULENBQUM7QUFJRjs7Ozs7Ozs7O0dBU0c7QUFDSSxNQUFNLGFBQWEsR0FBRyxDQUFDLENBQXFCLEVBQUUsR0FBRyxFQUF3QixFQUFzQixFQUFFLENBQ3BHLENBQUMsRUFBRSxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFFdEMsOERBQXFCLEdBQUc7SUFDcEIsQ0FBQyxFQUFFO1FBQ0MsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFxQixFQUFFLEVBQUUsQ0FBQyxnREFBRyxDQUFFLENBQUMsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFDNUQsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUF1QixFQUFFLEVBQUUsQ0FBQyxnREFBRyxDQUFFLENBQUMsa0JBQWEsR0FBRyxDQUFDLENBQUM7S0FDL0Q7SUFDRCxDQUFDLEVBQUUsR0FBRztDQUNULENBQUM7QUFJRjs7O0dBR0c7QUFDSCxNQUFNLFlBQVk7SUFRZCxZQUFhLENBQXFCLEVBQUUsQ0FBd0I7UUFONUQsT0FBRSxHQUFnQixXQUFXLENBQUM7UUFNa0MsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUFDLENBQUM7SUFFbkYsSUFBSSxDQUFFLENBQXFCLEVBQUUsQ0FBd0IsSUFBVyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2hHLEVBQUUsQ0FBRSxFQUF3QixJQUFVLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO0NBQ3JFO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdCRztBQUNJLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBcUIsRUFBRSxDQUF3QixFQUFvQixFQUFFLENBQUMsSUFBSSxZQUFZLENBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRXZILHlEQUFnQixHQUFHO0lBQ2YsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUF1QixFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxnREFBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDNUQsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxpREFBSSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFjLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsaURBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBYyxDQUFDLENBQUMsQ0FBQztDQUMvRCxDQUFDO0FBSUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEJHO0FBQ0ksTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUE4QixFQUFFLENBQVMsRUFBYyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFFeEcsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUE4QixFQUFFLENBQVMsRUFBVSxFQUFFO0lBRWxFLDhDQUE4QztJQUM5QyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ1AsT0FBTyxPQUFPLENBQUM7SUFFbkIseUZBQXlGO0lBQ3pGLHNFQUFzRTtJQUN0RSxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlDLElBQUksQ0FBQyxJQUFJLElBQUk7UUFDVCxPQUFPLE1BQU0sQ0FBQztJQUVsQix3RkFBd0Y7SUFDeEYsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNMLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUVYLHlGQUF5RjtJQUN6Rix1RkFBdUY7SUFDdkYsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFbEQscUJBQXFCO0lBQ3JCLE9BQU8sYUFBYSxDQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNsRCxDQUFDO0FBRUQsa0RBQVMsR0FBRyxDQUFDLENBQWEsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDemdCVjtBQUNvQztBQUszRSxtR0FBbUc7QUFDbkcsRUFBRTtBQUNGLHFCQUFxQjtBQUNyQixFQUFFO0FBQ0YsbUdBQW1HO0FBRW5HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0ksTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUEyQixFQUFFLEdBQUcsTUFBcUIsRUFBa0IsRUFBRSxDQUM5RixHQUFHLEVBQUUsQ0FBQyxrREFBSyxDQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztBQUloQzs7O0dBR0c7QUFDSCxNQUFNLHdCQUF3QixHQUE4QixDQUFDLEdBQUcsRUFBRyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFakc7O0dBRUc7QUFDSCxNQUFNLG1CQUFtQixHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztBQW9FNUQsZ0ZBQWdGO0FBQ2hGLE1BQU0sNEJBQTRCLEdBQTJCLEVBQUUsQ0FBQyxFQUFFLG1CQUFtQixFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUUxRzs7OztHQUlHO0FBQ0gsTUFBTSxhQUFhLEdBQ25CO0lBQ0ksaUJBQWlCO0lBQ2pCLE1BQU0sRUFBRSxlQUFlO0lBQ3ZCLEtBQUssRUFBRSxFQUFFLENBQUMsRUFBRSwyQkFBMkIsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNsRCxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDbEQsT0FBTyxFQUFFLEVBQUUsQ0FBQyxFQUFFLDJCQUEyQixFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0lBQ3JELE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSwyQkFBMkIsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRTtJQUNwRCxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDbkQsS0FBSyxFQUFFLEVBQUUsQ0FBQyxFQUFFLDJCQUEyQixFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0lBRW5ELHlCQUF5QjtJQUN6QixPQUFPLDZCQUE0QztJQUNuRCxVQUFVLDZCQUE0QztJQUN0RCxRQUFRLDZCQUE0QztJQUNwRCxLQUFLLDZCQUE0QztJQUNqRCxhQUFhLDZCQUE0QztJQUN6RCxXQUFXLDZCQUE0QztJQUN2RCxjQUFjLDZCQUE0QztJQUMxRCxRQUFRLDZCQUE0QztJQUNwRCxhQUFhLDZCQUE0QztJQUN6RCxXQUFXLDZCQUE0QztJQUN2RCxlQUFlLDZCQUE0QztJQUUzRCwrQkFBK0I7SUFDL0IsS0FBSyxrQ0FBaUQ7SUFDdEQsdUNBQXVDO0lBQ3ZDLE9BQU8sRUFBRSxFQUFFLENBQUMsRUFBRSxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUU7SUFDakUsYUFBYSxFQUFFLDRCQUE0QjtJQUMzQyxJQUFJLEVBQUUsNEJBQTRCO0lBQ2xDLE1BQU0sa0NBQWlEO0lBQ3ZELEtBQUssRUFBRSw0QkFBNEI7SUFDbkMsVUFBVSxFQUFFLGlCQUFpQjtJQUM3QixjQUFjLEVBQUUsaUJBQWlCO0lBQ2pDLFdBQVcsRUFBRSxpQkFBaUI7SUFDOUIsZUFBZSxFQUFFLGlCQUFpQjtJQUNsQyxPQUFPLEVBQUUsNEJBQTRCO0lBRXJDLGdDQUFnQztJQUNoQyxNQUFNLG9DQUFtRDtJQUN6RCxTQUFTLEVBQUUsRUFBRSxDQUFDLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRTtDQUMzRDtBQUlEOztHQUVHO0FBQ0gsTUFBTSxzQkFBc0I7SUE2Q3hCLFlBQWEsS0FBb0I7UUEzQ2pDLFVBQUssR0FBa0IsRUFBRSxDQUFDO1FBNkN0QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixDQUFDO0lBekNELEdBQUcsQ0FBRSxDQUFNLEVBQUUsUUFBcUIsRUFBRSxDQUFNO1FBRXRDLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUTtZQUM1QixPQUFPLFNBQVMsQ0FBQztRQUVyQiwwRUFBMEU7UUFDMUUsSUFBSSxRQUFRLEtBQUssSUFBSTtZQUNqQixPQUFPLEtBQUssQ0FBQzthQUNaLElBQUksUUFBUSxLQUFLLE9BQU87WUFDekIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBRXRCLElBQUksSUFBSSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsSUFBSTtZQUNMLE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBRSxJQUFJLEVBQUUsa0JBQWtCLENBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7YUFDbkUsSUFBSSxJQUFJLGdDQUErQztZQUN4RCxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLGtCQUFrQixDQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO2FBQ3BFLElBQUksSUFBSSxxQ0FBb0Q7WUFDN0QsT0FBTyw0QkFBNEIsQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLGtCQUFrQixDQUFFLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO2FBQ25GLElBQUksSUFBSSx1Q0FBc0Q7WUFDL0QsT0FBTyw0QkFBNEIsQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLGtCQUFrQixDQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO2FBQ3BGLElBQUksT0FBTyxJQUFJLEtBQUssVUFBVTtZQUMvQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBRXRDO1lBQ0ksUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNqRixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbEQ7SUFDTCxDQUFDO0lBRUQsT0FBTyxDQUFFLENBQU0sSUFBZ0MsT0FBTyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3BGLEdBQUcsQ0FBRSxDQUFNLEVBQUUsQ0FBUyxJQUFhLE9BQU8sc0JBQXNCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7O0FBakNwRiwrRkFBK0Y7QUFDeEYsMkJBQUksR0FBRyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztBQWdEbEMsNkJBQTZCO0FBQzdCLFNBQVMsZUFBZSxDQUFnQyxRQUFnQixFQUNwRSxRQUFnQixFQUFFLEVBQVEsRUFBRSxFQUFRLEVBQUUsRUFBUSxFQUFFLEVBQVE7SUFFeEQsT0FBTyxZQUFZLENBQUMsSUFBSSxDQUFFLElBQUksRUFDMUIsd0JBQXdCLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztRQUNqQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBQztRQUNuRSxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUMsQ0FDbEUsQ0FBQztBQUNOLENBQUM7QUFFRCxtRkFBbUY7QUFDbkYsU0FBUyw0QkFBNEIsQ0FBZ0MsTUFBYyxFQUFFLEtBQVU7SUFFM0YsT0FBTyxZQUFZLENBQUMsSUFBSSxDQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7QUFDOUQsQ0FBQztBQUVELHdGQUF3RjtBQUN4RixTQUFTLDJCQUEyQixDQUFnQyxNQUFjLEVBQzlFLFVBQWtCLEVBQUUsR0FBRyxRQUF1QjtJQUU5QyxPQUFPLDRCQUE0QixDQUFDLElBQUksQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDO0FBQ25GLENBQUM7QUFFRCwyRkFBMkY7QUFDM0YsdUJBQXVCO0FBQ3ZCLFNBQVMsbUJBQW1CLENBQWdDLElBQVksRUFBRSxVQUFrQixFQUFFLEdBQUcsUUFBdUI7SUFFcEgsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLDRCQUE0QixDQUFDLElBQUksQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxHQUFHLFFBQVEsQ0FBQztJQUN4RSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBRSxHQUFHLENBQUMsQ0FBQztJQUN0QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDdEIsQ0FBQztBQUVELCtFQUErRTtBQUMvRSxTQUFTLGlCQUFpQixDQUFnQyxRQUFnQixFQUFFLEVBQWlCLEVBQUUsRUFBVztJQUV0RyxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLGtCQUFrQixDQUFFLEdBQUcsRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFZLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDekgsQ0FBQztBQUVELDhGQUE4RjtBQUM5RixnR0FBZ0c7QUFDaEcsaUJBQWlCO0FBQ2pCLFNBQVMsNEJBQTRCLENBQWdDLFVBQWtCLEVBQ25GLFlBQXFCLEVBQUUsR0FBRyxRQUF1QjtJQUVqRCxJQUFJLFlBQVksSUFBSSxVQUFVO1FBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRWpDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUN4QztRQUNJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxVQUFVO1lBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRWpDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2hDO0lBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ3RCLENBQUM7QUFFRCxpREFBaUQ7QUFDakQsU0FBUyxZQUFZLENBQWdDLElBQWlCO0lBRWxFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztBQUN0QixDQUFDO0FBRUQscUZBQXFGO0FBQ3JGLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxNQUFrQixFQUFFLElBQVksRUFBRSxFQUFFLENBQUMsTUFBTSxHQUFHLHdEQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFJNUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNJLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBRyxLQUFvQixFQUFvQixFQUFFO0lBRTdELElBQUksT0FBTyxHQUFHLElBQUksc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEQsSUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUUsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXBDLDZGQUE2RjtJQUM3Rix3QkFBd0I7SUFDeEIsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdEIsT0FBTyxLQUF5QixDQUFDO0FBQ3JDLENBQUM7QUFFRCxnREFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsZ0RBQUcsQ0FBRSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFJbEUsbUdBQW1HO0FBQ25HLEVBQUU7QUFDRiw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLG1HQUFtRztBQUVuRzs7OztHQUlHO0FBQ0ssTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFtQixFQUFFLENBQTBCLEVBQWMsRUFBRSxDQUNyRixDQUFDLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUV6QixrREFBUyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUl0Qjs7OztFQUlFO0FBQ0ssTUFBTSxXQUFXLEdBQUcsQ0FBQyxFQUFvQixFQUFFLEVBQW9CLEVBQUUsRUFBb0IsRUFDM0YsRUFBb0IsRUFBb0IsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFFckYsNERBQW1CLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7QUFJOUMsbUdBQW1HO0FBQ25HLEVBQUU7QUFDRixvQkFBb0I7QUFDcEIsRUFBRTtBQUNGLG1HQUFtRztBQUVuRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0ksTUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUEyQixFQUFFLEdBQUcsTUFBYSxFQUFhLEVBQUUsQ0FDNUUsR0FBRyxFQUFFLENBQUMsa0RBQUssQ0FBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFJaEM7Ozs7R0FJRztBQUNJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBNkIsRUFBWSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUVuRixnREFBTyxHQUFHLENBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBQyxHQUFHLGlCQUFZLEVBQUMsQ0FBRSxDQUFDO0FBZXRDLGlCQUFpQjtBQUNWLFNBQVMsTUFBTSxDQUFFLEdBQStCLEVBQUUsQ0FBVSxFQUFFLENBQVU7SUFFM0UsT0FBTyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUN2QyxDQUFDO0FBRUQsbURBQVUsR0FBRyxDQUFDLENBQWMsRUFBRSxFQUFFLENBQUMsaURBQUksQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFJOUQ7Ozs7Ozs7Ozs7R0FVRztBQUNLLE1BQU0sSUFBSSxHQUFHLENBQUMsUUFBMEIsRUFBRSxVQUF3RCxFQUN6RyxRQUEyQixFQUFnQixFQUFFLENBQzFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsaURBQUksQ0FBRSxDQUFDLGlEQUFJLENBQUUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDO0FBSTNFOzs7OztHQUtHO0FBQ0ssTUFBTSxPQUFPLEdBQUcsQ0FBQyxVQUEyQyxFQUNuRSxLQUF5QyxFQUFnQixFQUFFLENBQ3hELEdBQUcsRUFBRSxDQUFDLGdEQUFHLENBQUUsU0FBUyxFQUFFLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFJL0M7Ozs7Ozs7O0dBUUc7QUFDSSxNQUFNLFFBQVEsR0FBRyxDQUFDLFVBQTJDLEVBQ25FLEdBQXFCLEVBQUUsS0FBeUMsRUFBZ0IsRUFBRSxDQUMvRSxHQUFHLEVBQUUsQ0FBQyxnREFBRyxDQUFFLFVBQVUsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEdBQUcsa0JBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBSW5FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJHO0FBQ0ksTUFBTSxNQUFNLEdBQUcsQ0FBNkIsTUFBbUIsRUFBRSxRQUE4QixFQUFhLEVBQUUsQ0FDakgsR0FBRyxFQUFFLENBQUMsZ0RBQUcsQ0FBRSxLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLHFEQUFJLENBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztBQ3pmN0UsbUdBQW1HO0FBQ25HLEVBQUU7QUFDRixlQUFlO0FBQ2YsRUFBRTtBQUNGLG1HQUFtRztBQWtXL0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hXc0Q7QUFDL0U7QUFLNUMsdUNBQXVDO0FBQ3ZDLE1BQU0sWUFBWSxHQUFHLENBQUUsQ0FBUyxFQUFFLElBQVksRUFBaUIsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFJakY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0ksTUFBTSxHQUFHLEdBQWdCLHlEQUFVLENBQUM7QUFJM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSSxNQUFNLE9BQU8sR0FBaUIsMERBQVcsQ0FBQztBQUVqRDs7OztHQUlHO0FBQ0ksTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFTLEVBQWlCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBSTNFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0ksTUFBTSxHQUFHLEdBQWdCLHlEQUFVLENBQUM7QUFFM0M7OztHQUdHO0FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBRXBFOzs7OztHQUtHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFdEU7OztHQUdHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLElBQUksR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFeEU7OztHQUdHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFFdEU7OztHQUdHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7OztHQUlHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7OztHQUlHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXRFOzs7R0FHRztBQUNJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUV0RTs7O0dBR0c7QUFDSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFeEU7OztHQUdHO0FBQ0ksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRXhFOzs7R0FHRztBQUNJLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBUyxFQUFnQixFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUUxRTs7O0dBR0c7QUFDSSxNQUFNLElBQUksR0FBRyxDQUFDLENBQVMsRUFBZ0IsRUFBRSxDQUFDLFlBQVksQ0FBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFFMUU7OztHQUdHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFTLEVBQWdCLEVBQUUsQ0FBQyxZQUFZLENBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBSXRFOzs7OztHQUtHO0FBQ0ksTUFBTSxLQUFLLEdBQWUsd0RBQVMsQ0FBQztBQUUzQzs7O0dBR0c7QUFDSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQVMsRUFBZSxFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUV2RTs7O0dBR0c7QUFDSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQVMsRUFBZSxFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUV2RTs7O0dBR0c7QUFDSSxNQUFNLElBQUksR0FBRyxDQUFDLENBQVMsRUFBZSxFQUFFLENBQUMsWUFBWSxDQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUV6RTs7O0dBR0c7QUFDSSxNQUFNLElBQUksR0FB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QUVGO0FBQ0c7QUFDRjtBQUNBO0FBQ0Q7QUFDTTtBQUNMIiwiZmlsZSI6Im1pbWNzcy5kZXYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJtaW1jc3NcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibWltY3NzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwi77u/aW1wb3J0IHtFeHRlbmRlZCwgT25lT3JNYW55fSBmcm9tIFwiLi9Db3JlVHlwZXNcIjtcclxuaW1wb3J0IHtDc3NBbmdsZSwgQ3NzUGVyY2VudH0gZnJvbSBcIi4vTnVtZXJpY1R5cGVzXCI7XHJcbmltcG9ydCB7Q29sb3JTcGFjZSwgQ3NzQ29sb3IsIENzc0NvbG9yU2VwYXJhdGlvbiwgSUFscGhhRnVuYywgSUNvbG9yQ29udHJhc3RGdW5jLCBJQ29sb3JNaXhCdWlsZGVyLCBJSHNsRnVuYywgSUxhYkZ1bmMsIElMY2hGdW5jLCBJTmFtZWRDb2xvcnMsIElSZ2JGdW5jfSBmcm9tIFwiLi9Db2xvclR5cGVzXCI7XHJcbmltcG9ydCB7YTJzLCBmZG8sIG12MnMsIHYycywgd2tmLCBXS0Z9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBPYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIHRoZSB3ZWxsLWtub3duIFdlYiBjb2xvciBuYW1lcyB3aGlsZSB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGVcclxuICogaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIFJHQiBzZXBhcmF0aW9ucyAod2l0aG91dCBhbiBhbHBoYSBtYXNrKS4gVGhlIHByb3BlcnRpZXMgb2ZcclxuICogdGhpcyBvYmplY3QgY2FuIGJlIHVzZWQgd2hlcmV2ZXIgdGhlIFtbQ3NzQ29sb3JdXSB0eXBlIGNhbiBiZSB1c2VkLiBTaW5jZSB0aGUgcHJvcGVydGllcyBhcmVcclxuICogb2YgdGhlIGBudW1iZXJgIHR5cGUsIHRoZXkgY2FuIGJlIHVzZWQgZm9yIG1hbmlwdWxhdGluZyB0aGUgY29sb3IgdmFsdWUuXHJcbiovXHJcbmV4cG9ydCBjb25zdCBDb2xvcnM6IElOYW1lZENvbG9ycyA9XHJcbntcclxuICAgIGJsYWNrOiAgICAgICAgICAgICAgICAgIDB4MDAwMDAwLFxyXG4gICAgc2lsdmVyOiAgICAgICAgICAgICAgICAgMHhjMGMwYzAsXHJcbiAgICBncmF5OiAgICAgICAgICAgICAgICAgICAweDgwODA4MCxcclxuICAgIHdoaXRlOiAgICAgICAgICAgICAgICAgIDB4ZmZmZmZmLFxyXG4gICAgbWFyb29uOiAgICAgICAgICAgICAgICAgMHg4MDAwMDAsXHJcbiAgICByZWQ6ICAgICAgICAgICAgICAgICAgICAweGZmMDAwMCxcclxuICAgIHB1cnBsZTogICAgICAgICAgICAgICAgIDB4ODAwMDgwLFxyXG4gICAgZnVjaHNpYTogICAgICAgICAgICAgICAgMHhmZjAwZmYsXHJcbiAgICBncmVlbjogICAgICAgICAgICAgICAgICAweDAwODAwMCxcclxuICAgIGxpbWU6ICAgICAgICAgICAgICAgICAgIDB4MDBmZjAwLFxyXG4gICAgb2xpdmU6ICAgICAgICAgICAgICAgICAgMHg4MDgwMDAsXHJcbiAgICB5ZWxsb3c6ICAgICAgICAgICAgICAgICAweGZmZmYwMCxcclxuICAgIG5hdnk6ICAgICAgICAgICAgICAgICAgIDB4MDAwMDgwLFxyXG4gICAgYmx1ZTogICAgICAgICAgICAgICAgICAgMHgwMDAwZmYsXHJcbiAgICB0ZWFsOiAgICAgICAgICAgICAgICAgICAweDAwODA4MCxcclxuICAgIGFxdWE6ICAgICAgICAgICAgICAgICAgIDB4MDBmZmZmLFxyXG4gICAgb3JhbmdlOiAgICAgICAgICAgICAgICAgMHhmZmE1MDAsXHJcbiAgICBhbGljZWJsdWU6ICAgICAgICAgICAgICAweGYwZjhmZixcclxuICAgIGFudGlxdWV3aGl0ZTogICAgICAgICAgIDB4ZmFlYmQ3LFxyXG4gICAgYXF1YW1hcmluZTogICAgICAgICAgICAgMHg3ZmZmZDQsXHJcbiAgICBhenVyZTogICAgICAgICAgICAgICAgICAweGYwZmZmZixcclxuICAgIGJlaWdlOiAgICAgICAgICAgICAgICAgIDB4ZjVmNWRjLFxyXG4gICAgYmlzcXVlOiAgICAgICAgICAgICAgICAgMHhmZmU0YzQsXHJcbiAgICBibGFuY2hlZGFsbW9uZDogICAgICAgICAweGZmZWJjZCxcclxuICAgIGJsdWV2aW9sZXQ6ICAgICAgICAgICAgIDB4OGEyYmUyLFxyXG4gICAgYnJvd246ICAgICAgICAgICAgICAgICAgMHhhNTJhMmEsXHJcbiAgICBidXJseXdvb2Q6ICAgICAgICAgICAgICAweGRlYjg4NyxcclxuICAgIGNhZGV0Ymx1ZTogICAgICAgICAgICAgIDB4NWY5ZWEwLFxyXG4gICAgY2hhcnRyZXVzZTogICAgICAgICAgICAgMHg3ZmZmMDAsXHJcbiAgICBjaG9jb2xhdGU6ICAgICAgICAgICAgICAweGQyNjkxZSxcclxuICAgIGNvcmFsOiAgICAgICAgICAgICAgICAgIDB4ZmY3ZjUwLFxyXG4gICAgY29ybmZsb3dlcmJsdWU6ICAgICAgICAgMHg2NDk1ZWQsXHJcbiAgICBjb3Juc2lsazogICAgICAgICAgICAgICAweGZmZjhkYyxcclxuICAgIGNyaW1zb246ICAgICAgICAgICAgICAgIDB4ZGMxNDNjLFxyXG4gICAgY3lhbjogICAgICAgICAgICAgICAgICAgMHgwMGZmZmYsXHJcbiAgICBkYXJrYmx1ZTogICAgICAgICAgICAgICAweDAwMDA4YixcclxuICAgIGRhcmtjeWFuOiAgICAgICAgICAgICAgIDB4MDA4YjhiLFxyXG4gICAgZGFya2dvbGRlbnJvZDogICAgICAgICAgMHhiODg2MGIsXHJcbiAgICBkYXJrZ3JheTogICAgICAgICAgICAgICAweGE5YTlhOSxcclxuICAgIGRhcmtncmVlbjogICAgICAgICAgICAgIDB4MDA2NDAwLFxyXG4gICAgZGFya2dyZXk6ICAgICAgICAgICAgICAgMHhhOWE5YTksXHJcbiAgICBkYXJra2hha2k6ICAgICAgICAgICAgICAweGJkYjc2YixcclxuICAgIGRhcmttYWdlbnRhOiAgICAgICAgICAgIDB4OGIwMDhiLFxyXG4gICAgZGFya29saXZlZ3JlZW46ICAgICAgICAgMHg1NTZiMmYsXHJcbiAgICBkYXJrb3JhbmdlOiAgICAgICAgICAgICAweGZmOGMwMCxcclxuICAgIGRhcmtvcmNoaWQ6ICAgICAgICAgICAgIDB4OTkzMmNjLFxyXG4gICAgZGFya3JlZDogICAgICAgICAgICAgICAgMHg4YjAwMDAsXHJcbiAgICBkYXJrc2FsbW9uOiAgICAgICAgICAgICAweGU5OTY3YSxcclxuICAgIGRhcmtzZWFncmVlbjogICAgICAgICAgIDB4OGZiYzhmLFxyXG4gICAgZGFya3NsYXRlYmx1ZTogICAgICAgICAgMHg0ODNkOGIsXHJcbiAgICBkYXJrc2xhdGVncmF5OiAgICAgICAgICAweDJmNGY0ZixcclxuICAgIGRhcmtzbGF0ZWdyZXk6ICAgICAgICAgIDB4MmY0ZjRmLFxyXG4gICAgZGFya3R1cnF1b2lzZTogICAgICAgICAgMHgwMGNlZDEsXHJcbiAgICBkYXJrdmlvbGV0OiAgICAgICAgICAgICAweDk0MDBkMyxcclxuICAgIGRlZXBwaW5rOiAgICAgICAgICAgICAgIDB4ZmYxNDkzLFxyXG4gICAgZGVlcHNreWJsdWU6ICAgICAgICAgICAgMHgwMGJmZmYsXHJcbiAgICBkaW1ncmF5OiAgICAgICAgICAgICAgICAweDY5Njk2OSxcclxuICAgIGRpbWdyZXk6ICAgICAgICAgICAgICAgIDB4Njk2OTY5LFxyXG4gICAgZG9kZ2VyYmx1ZTogICAgICAgICAgICAgMHgxZTkwZmYsXHJcbiAgICBmaXJlYnJpY2s6ICAgICAgICAgICAgICAweGIyMjIyMixcclxuICAgIGZsb3JhbHdoaXRlOiAgICAgICAgICAgIDB4ZmZmYWYwLFxyXG4gICAgZm9yZXN0Z3JlZW46ICAgICAgICAgICAgMHgyMjhiMjIsXHJcbiAgICBnYWluc2Jvcm86ICAgICAgICAgICAgICAweGRjZGNkYyxcclxuICAgIGdob3N0d2hpdGU6ICAgICAgICAgICAgIDB4ZjhmOGZmLFxyXG4gICAgZ29sZDogICAgICAgICAgICAgICAgICAgMHhmZmQ3MDAsXHJcbiAgICBnb2xkZW5yb2Q6ICAgICAgICAgICAgICAweGRhYTUyMCxcclxuICAgIGdyZWVueWVsbG93OiAgICAgICAgICAgIDB4YWRmZjJmLFxyXG4gICAgZ3JleTogICAgICAgICAgICAgICAgICAgMHg4MDgwODAsXHJcbiAgICBob25leWRldzogICAgICAgICAgICAgICAweGYwZmZmMCxcclxuICAgIGhvdHBpbms6ICAgICAgICAgICAgICAgIDB4ZmY2OWI0LFxyXG4gICAgaW5kaWFucmVkOiAgICAgICAgICAgICAgMHhjZDVjNWMsXHJcbiAgICBpbmRpZ286ICAgICAgICAgICAgICAgICAweDRiMDA4MixcclxuICAgIGl2b3J5OiAgICAgICAgICAgICAgICAgIDB4ZmZmZmYwLFxyXG4gICAga2hha2k6ICAgICAgICAgICAgICAgICAgMHhmMGU2OGMsXHJcbiAgICBsYXZlbmRlcjogICAgICAgICAgICAgICAweGU2ZTZmYSxcclxuICAgIGxhdmVuZGVyYmx1c2g6ICAgICAgICAgIDB4ZmZmMGY1LFxyXG4gICAgbGF3bmdyZWVuOiAgICAgICAgICAgICAgMHg3Y2ZjMDAsXHJcbiAgICBsZW1vbmNoaWZmb246ICAgICAgICAgICAweGZmZmFjZCxcclxuICAgIGxpZ2h0Ymx1ZTogICAgICAgICAgICAgIDB4YWRkOGU2LFxyXG4gICAgbGlnaHRjb3JhbDogICAgICAgICAgICAgMHhmMDgwODAsXHJcbiAgICBsaWdodGN5YW46ICAgICAgICAgICAgICAweGUwZmZmZixcclxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAgIDB4ZmFmYWQyLFxyXG4gICAgbGlnaHRncmF5OiAgICAgICAgICAgICAgMHhkM2QzZDMsXHJcbiAgICBsaWdodGdyZWVuOiAgICAgICAgICAgICAweDkwZWU5MCxcclxuICAgIGxpZ2h0Z3JleTogICAgICAgICAgICAgIDB4ZDNkM2QzLFxyXG4gICAgbGlnaHRwaW5rOiAgICAgICAgICAgICAgMHhmZmI2YzEsXHJcbiAgICBsaWdodHNhbG1vbjogICAgICAgICAgICAweGZmYTA3YSxcclxuICAgIGxpZ2h0c2VhZ3JlZW46ICAgICAgICAgIDB4MjBiMmFhLFxyXG4gICAgbGlnaHRza3libHVlOiAgICAgICAgICAgMHg4N2NlZmEsXHJcbiAgICBsaWdodHNsYXRlZ3JheTogICAgICAgICAweDc3ODg5OSxcclxuICAgIGxpZ2h0c2xhdGVncmV5OiAgICAgICAgIDB4Nzc4ODk5LFxyXG4gICAgbGlnaHRzdGVlbGJsdWU6ICAgICAgICAgMHhiMGM0ZGUsXHJcbiAgICBsaWdodHllbGxvdzogICAgICAgICAgICAweGZmZmZlMCxcclxuICAgIGxpbWVncmVlbjogICAgICAgICAgICAgIDB4MzJjZDMyLFxyXG4gICAgbGluZW46ICAgICAgICAgICAgICAgICAgMHhmYWYwZTYsXHJcbiAgICBtYWdlbnRhOiAgICAgICAgICAgICAgICAweGZmMDBmZixcclxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgICAgIDB4NjZjZGFhLFxyXG4gICAgbWVkaXVtYmx1ZTogICAgICAgICAgICAgMHgwMDAwY2QsXHJcbiAgICBtZWRpdW1vcmNoaWQ6ICAgICAgICAgICAweGJhNTVkMyxcclxuICAgIG1lZGl1bXB1cnBsZTogICAgICAgICAgIDB4OTM3MGRiLFxyXG4gICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgICAgMHgzY2IzNzEsXHJcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgICAgICAweDdiNjhlZSxcclxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAgICAgIDB4MDBmYTlhLFxyXG4gICAgbWVkaXVtdHVycXVvaXNlOiAgICAgICAgMHg0OGQxY2MsXHJcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICAgICAgICAweGM3MTU4NSxcclxuICAgIG1pZG5pZ2h0Ymx1ZTogICAgICAgICAgIDB4MTkxOTcwLFxyXG4gICAgbWludGNyZWFtOiAgICAgICAgICAgICAgMHhmNWZmZmEsXHJcbiAgICBtaXN0eXJvc2U6ICAgICAgICAgICAgICAweGZmZTRlMSxcclxuICAgIG1vY2Nhc2luOiAgICAgICAgICAgICAgIDB4ZmZlNGI1LFxyXG4gICAgbmF2YWpvd2hpdGU6ICAgICAgICAgICAgMHhmZmRlYWQsXHJcbiAgICBvbGRsYWNlOiAgICAgICAgICAgICAgICAweGZkZjVlNixcclxuICAgIG9saXZlZHJhYjogICAgICAgICAgICAgIDB4NmI4ZTIzLFxyXG4gICAgb3JhbmdlcmVkOiAgICAgICAgICAgICAgMHhmZjQ1MDAsXHJcbiAgICBvcmNoaWQ6ICAgICAgICAgICAgICAgICAweGRhNzBkNixcclxuICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgICAgIDB4ZWVlOGFhLFxyXG4gICAgcGFsZWdyZWVuOiAgICAgICAgICAgICAgMHg5OGZiOTgsXHJcbiAgICBwYWxldHVycXVvaXNlOiAgICAgICAgICAweGFmZWVlZSxcclxuICAgIHBhbGV2aW9sZXRyZWQ6ICAgICAgICAgIDB4ZGI3MDkzLFxyXG4gICAgcGFwYXlhd2hpcDogICAgICAgICAgICAgMHhmZmVmZDUsXHJcbiAgICBwZWFjaHB1ZmY6ICAgICAgICAgICAgICAweGZmZGFiOSxcclxuICAgIHBlcnU6ICAgICAgICAgICAgICAgICAgIDB4Y2Q4NTNmLFxyXG4gICAgcGluazogICAgICAgICAgICAgICAgICAgMHhmZmMwY2IsXHJcbiAgICBwbHVtOiAgICAgICAgICAgICAgICAgICAweGRkYTBkZCxcclxuICAgIHBvd2RlcmJsdWU6ICAgICAgICAgICAgIDB4YjBlMGU2LFxyXG4gICAgcm9zeWJyb3duOiAgICAgICAgICAgICAgMHhiYzhmOGYsXHJcbiAgICByb3lhbGJsdWU6ICAgICAgICAgICAgICAweDQxNjllMSxcclxuICAgIHNhZGRsZWJyb3duOiAgICAgICAgICAgIDB4OGI0NTEzLFxyXG4gICAgc2FsbW9uOiAgICAgICAgICAgICAgICAgMHhmYTgwNzIsXHJcbiAgICBzYW5keWJyb3duOiAgICAgICAgICAgICAweGY0YTQ2MCxcclxuICAgIHNlYWdyZWVuOiAgICAgICAgICAgICAgIDB4MmU4YjU3LFxyXG4gICAgc2Vhc2hlbGw6ICAgICAgICAgICAgICAgMHhmZmY1ZWUsXHJcbiAgICBzaWVubmE6ICAgICAgICAgICAgICAgICAweGEwNTIyZCxcclxuICAgIHNreWJsdWU6ICAgICAgICAgICAgICAgIDB4ODdjZWViLFxyXG4gICAgc2xhdGVibHVlOiAgICAgICAgICAgICAgMHg2YTVhY2QsXHJcbiAgICBzbGF0ZWdyYXk6ICAgICAgICAgICAgICAweDcwODA5MCxcclxuICAgIHNsYXRlZ3JleTogICAgICAgICAgICAgIDB4NzA4MDkwLFxyXG4gICAgc25vdzogICAgICAgICAgICAgICAgICAgMHhmZmZhZmEsXHJcbiAgICBzcHJpbmdncmVlbjogICAgICAgICAgICAweDAwZmY3ZixcclxuICAgIHN0ZWVsYmx1ZTogICAgICAgICAgICAgIDB4NDY4MmI0LFxyXG4gICAgdGFuOiAgICAgICAgICAgICAgICAgICAgMHhkMmI0OGMsXHJcbiAgICB0aGlzdGxlOiAgICAgICAgICAgICAgICAweGQ4YmZkOCxcclxuICAgIHRvbWF0bzogICAgICAgICAgICAgICAgIDB4ZmY2MzQ3LFxyXG4gICAgdHVycXVvaXNlOiAgICAgICAgICAgICAgMHg0MGUwZDAsXHJcbiAgICB2aW9sZXQ6ICAgICAgICAgICAgICAgICAweGVlODJlZSxcclxuICAgIHdoZWF0OiAgICAgICAgICAgICAgICAgIDB4ZjVkZWIzLFxyXG4gICAgd2hpdGVzbW9rZTogICAgICAgICAgICAgMHhmNWY1ZjUsXHJcbiAgICB5ZWxsb3dncmVlbjogICAgICAgICAgICAweDlhY2QzMixcclxuICAgIHJlYmVjY2FwdXJwbGU6ICAgICAgICAgIDB4NjYzMzk5LFxyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogT2JqZWN0IHdoZXJlIHdlIGtlZXAgdGhlIHJlZ2lzdGVyZWQgY3VzdG9tIGNvbG9ycy4gV2UgbmVlZCBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY29sb3JcclxuICogaXMgYSBzdGFuZGFyZCBvciBhIGN1c3RvbSBvbmUuXHJcbiAqL1xyXG5jb25zdCBjdXN0b21Db2xvcnM6IHsgW1A6IHN0cmluZ106IG51bWJlciB9ID0ge307XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBuZXcgY3VzdG9tIGNvbG9yIG9yIGNoYW5nZXMgdGhlIHZhbHVlIG9mIHRoZSBleGlzdGluZyBjdXN0b20gY29sb3IuIFRoZSBuYW1lIG9mIHRoZVxyXG4gKiBjdXN0b20gY29sb3Igc2hvdWxkIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkIHRvIHRoZSBbW0lOYW1lZENvbG9yc11dIGludGVyZmFjZSB1c2luZyB0aGUgbW9kdWxlXHJcbiAqIGF1Z21lbnRhdGlvbiB0ZWNobmlxdWUuIE5vdGUgdGhhdCB2YWx1ZXMgb2Ygc3RhbmRhcmQgV2ViIGNvbG9ycyBjYW5ub3QgYmUgY2hhbmdlZC5cclxuICpcclxuICogQHBhcmFtIG5hbWUgQ29sb3IgbmFtZS4gVGhpcyBuYW1lIGNhbm5vdCBiZSBhIG5hbWUgb2YgdGhlIHN0YW5kYXJkIFdlYiBjb2xvci5cclxuICogQHBhcmFtIHZhbHVlIENvbG9yIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZ2l2ZW4gbmFtZWQgY29sb3IuXHJcbiAqIEByZXR1cm5zIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWwuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJDb2xvciA9ICggbmFtZToga2V5b2YgSU5hbWVkQ29sb3JzLCB2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiA9PlxyXG57XHJcbiAgICBpZiAoIW5hbWUgfHwgdmFsdWUgPT0gbnVsbClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgLy8gdHJ5IHRvIHJldHJpZXZlIHRoaXMgbmFtZSBmcm9tIHRoZSBDdXN0b21Db2xvcnMgb2JqZWN0LiBOb24tdW5kZWZpbmVkIHZhbHVlIG1lYW5zIHRoYXRcclxuICAgIC8vIHdlIGFscmVhZHkgaGF2ZSB0aGlzIGNvbG9yIHJlZ2lzdGVyZWQuXHJcbiAgICBsZXQgY3VzdG9tVmFsdWUgPSBjdXN0b21Db2xvcnNbbmFtZV07XHJcblxyXG4gICAgLy8gaWYgdGhlIGNvbG9yIG5hbWUgYWxyZWFkeSBleGlzdHMgaW4gdGhlIENvbG9ycyBvYmplY3Qgd2Ugd2lsbCBvbmx5IGFsbG93IGNoYW5naW5nIGl0c1xyXG4gICAgLy8gdmFsdWUgaWYgdGhpcyBpcyBhIGN1c3RvbSBjb2xvci5cclxuICAgIGlmIChuYW1lIGluIENvbG9ycyAmJiBjdXN0b21WYWx1ZSAhPSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAvLyBhZGQgdGhlIHZhbHVlIHRvIHRoZSBDb2xvcnMgYW5kIEN1c3RvbUNvbG9ycyBvYmplY3RzXHJcbiAgICAoQ29sb3JzIGFzIGFueSlbbmFtZV0gPSB2YWx1ZTtcclxuICAgIGN1c3RvbUNvbG9yc1tuYW1lXSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGNvbG9yIHZhbHVlIGZyb20gdGhlIG51bWVyaWMgcmVwcmVzZW50YXRpb24gdG8gdGhlIENTUyBjb2xvciBzdHJpbmcuXHJcbiAqL1xyXG5sZXQgIGNvbG9yTnVtYmVyMnMgPSAodmFsOiBudW1iZXIpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBuZWdhdGl2ZSwgcmVtZW1iZXIgdGhhdCBmYWN0IGFuZCBnZXQgdGhlIHBvc2l0aXZlIG51bWJlclxyXG4gICAgbGV0IGlzTmVnYXRpdmUgPSB2YWwgPCAwO1xyXG4gICAgbGV0IG4gPSBpc05lZ2F0aXZlID8gLXZhbCA6IHZhbDtcclxuXHJcbiAgICAvLyBpZiB0aGUgbnVtYmVyIGhhcyBhIGZsb2F0aW5nIHBvaW50IHBhcnQsIHNlcGFyYXRlIGl0IGludG8gYWxwaGEgY2hhbm5lbFxyXG4gICAgbGV0IGEgPSAwO1xyXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKVxyXG4gICAge1xyXG4gICAgICAgIGxldCBrID0gTWF0aC5mbG9vcihuKTtcclxuICAgICAgICAvLyBhID0gTWF0aC5yb3VuZCggKG4gLSBrKSAqIDEwMCk7XHJcbiAgICAgICAgYSA9IE1hdGgucm91bmQoIChuIC0gaykgKiAyNTUpO1xyXG4gICAgICAgIG4gPSBrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBudW1iZXIgd2FzIG5lZ2F0aXZlIHdlIHJldmVydCB0aGUgY29sb3IgYnkgbmVnYXRpbmcgYWxsIHRoZSBiaXRzLiBJbiBhbnkgY2FzZSxcclxuICAgIC8vIHdlIGNsZWFyIGV2ZXJ5dGhpbmcgYmV5b25kIHRoZSBmaXJzdCB0aHJlZSBieXRlcy5cclxuICAgIG4gPSBpc05lZ2F0aXZlID8gfigweEZGMDAwMDAwIHwgbikgOiAweDAwRkZGRkZGICYgbjtcclxuXHJcbiAgICBsZXQgcyA9IFwiI1wiICsgbi50b1N0cmluZygxNikucGFkU3RhcnQoIDYsIFwiMFwiKTtcclxuICAgIHJldHVybiBhID8gcyArIGEudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KCAyLCBcIjBcIikgOiBzO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBjb2xvciBzdHlsZSB2YWx1ZSB0byB0aGUgQ1NTIHN0cmluZy4gV2UgY29udmVydCBudW1lcmljIHZhbHVlcyB0byB0aGUgI1JSR0dCQkFBXHJcbiAqIHJlcHJlc2VudGF0aW9uLiBJZiBhIHN0cmluZyB2YWx1ZSBpcyBhIGN1c3RvbSBjb2xvciBhZGRlZCB2aWEgSU5hbWVkQ29sb3JzIG1vZHVsZVxyXG4gKiBhdWdtZW50YXRpb24gd2UgZ2V0IGl0cyBudW1iZXIgZnJvbSB0aGUgYGN1c3RtQ29sb3JzYCBvYmplY3QgYW5kIGFsc28gY29udmVydCBpdCB0byB0aGVcclxuICogI1JSR0dCQkFBIHJlcHJlc2VudGF0aW9uLiBTdGFuZGFyZCBuYW1lZCBjb2xvcnMgYXMgd2VsbCBhcyBhcmUgcmV0dXJuZWQgYXMgaXMuXHJcbiAqL1xyXG53a2ZbV0tGLkNvbG9yXSA9ICh2YWw6IEV4dGVuZGVkPENzc0NvbG9yPik6IHN0cmluZyA9PlxyXG4gICAgdjJzKCB2YWwsIHtcclxuICAgICAgICBzdHI6IHYgPT4gdiBpbiBjdXN0b21Db2xvcnMgPyBjb2xvck51bWJlcjJzKCBjdXN0b21Db2xvcnNbdl0pIDogdixcclxuICAgICAgICBudW06IGNvbG9yTnVtYmVyMnNcclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGNvbG9yIHN0eWxlIHZhbHVlIHRvIHRoZSBDU1Mgc3RyaW5nLiBXZSBjb252ZXJ0IG51bWVyaWMgdmFsdWVzIHRvIHRoZSAjUlJHR0JCQUFcclxuICogcmVwcmVzZW50YXRpb24uIElmIGEgc3RyaW5nIHZhbHVlIGlzIGEgY3VzdG9tIGNvbG9yIGFkZGVkIHZpYSBJTmFtZWRDb2xvcnMgbW9kdWxlXHJcbiAqIGF1Z21lbnRhdGlvbiB3ZSBnZXQgaXRzIG51bWJlciBmcm9tIHRoZSBgY3VzdG1Db2xvcnNgIG9iamVjdCBhbmQgYWxzbyBjb252ZXJ0IGl0IHRvIHRoZVxyXG4gKiAjUlJHR0JCQUEgcmVwcmVzZW50YXRpb24uIFN0YW5kYXJkIG5hbWVkIGNvbG9ycyBhcyB3ZWxsIGFzIGFyZSByZXR1cm5lZCBhcyBpcy5cclxuICovXHJcbndrZltXS0YuQ29sb3JzXSA9ICh2YWw6IE9uZU9yTWFueTxDc3NDb2xvcj4pOiBzdHJpbmcgPT4gdjJzKCB2YWwsIHsgYW55OiBXS0YuQ29sb3IgfSlcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBjb2xvciBzZXBhcmF0aW9uIHZhbHVlIHRvIGEgQ1NTIHN0cmluZy5cclxuICovXHJcbndrZltXS0YuQ29sb3JTZXBhcmF0aW9uXSA9IChjOiBFeHRlbmRlZDxudW1iZXI+KTogc3RyaW5nID0+XHJcbiAgICB2MnMoIGMsIHtcclxuICAgICAgICBudW06IGMgPT4ge1xyXG4gICAgICAgICAgICBjID0gYyA8IDAgPyAtYyA6IGM7XHJcbiAgICAgICAgICAgIHJldHVybiAoYyA9PT0gMCB8fCBjID49IDEpID8gXCJcIiArIGMgOiAoTWF0aC5yb3VuZCggYyAqIDEwMCkgKyBcIiVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBjb2xvciBzcGVjaWZpZWQgYXMgcmVkLCBncmVlbiwgYmx1ZSBzZXBhcmF0aW9uIHZhbHVlcyBhbmQgYW4gb3B0aW9uYWwgYWxwaGFcclxuICogbWFzayB0byBhIENTUyBjb2xvciByZXByZXNlbnRhdGlvbi4gRWFjaCBjb2xvciBzZXBhcmF0aW9uIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIG51bWJlciB3aXRoXHJcbiAqIHRoZSBmb2xsb3dpbmcgbWVhbmluZzpcclxuICogICAtIEludGVnZXIgbnVtYmVyIC0yNTUgdG8gMjU1LiBOdW1iZXJzIGJleW9uZCB0aGlzIHJhbmdlIHdpbGwgYmUgY2xhbXBlZC4gTmVnYXRpdmUgbnVtYmVyc1xyXG4gKiAgICAgd2lsbCBiZSBpbnZlcnRlZC5cclxuICogICAtIEZsb2F0aW5nIG51bWJlciAtMS4wIHRvIDEuMCBub24taW5jbHVzaXZlLCB3aGljaCBpcyBtdWx0aXBsaWVkIGJ5IDEwMCB0cmVhdGVkIGFzIHBlcmNlbnRhZ2UuXHJcbiAqICAgICBGbG9hdGluZyBudW1iZXJzIGJleW9uZCB0aGlzIHJhbmdlIHdpbGwgYmUgcm91bmRlZCBhbmQgdHJlYXRlZCBhcyBpbnRlZ2VyIG51bWJlcnMuIE5lZ2F0aXZlXHJcbiAqICAgICBudW1iZXJzIHdpbGwgYmUgaW52ZXJ0ZWQuXHJcbiAqXHJcbiAqIFRoZSBhbHBoYSBtYXNrIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcclxuICogICAtIEZsb2F0aW5nIG51bWJlciAwIHRvIDEgaW5jbHVzaXZlLlxyXG4gKiAgIC0gSW50ZWdlciBvciBmbG9hdGluZyBudW1iZXIgMSB0byAxMDAsIHdoaWNoIGlzIGRpdmlkZWQgYnkgMTAwLiBGbG9hdGluZyBudW1iZXJzIHdpbGwgYmVcclxuICogICAgIHJvdW5kZWQuIE51bWJlcnMgYmV5b25kIHRoaXMgcmFuZ2Ugd2lsbCBiZSBjbGFtcGVkLlxyXG4gKiAgIC0gVGhlIHNpZ24gb2YgYWxwaGEgaXMgaWdub3JlZDsgdGhhdCBpcywgb25seSB0aGUgYWJzb2x1dGUgdmFsdWUgaXMgY29uc2lkZXJlZC5cclxuICpcclxuICogLSBNRE46IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZS9yZ2IoKVxyXG4gKlxyXG4gKiBAcGFyYW0gciBSZWQgc2VwYXJhdGlvbiB2YWx1ZS5cclxuICogQHBhcmFtIGcgR3JlZW4gc2VwYXJhdGlvbiB2YWx1ZS5cclxuICogQHBhcmFtIGIgQmx1ZSBzZXBhcmF0aW9uIHZhbHVlLlxyXG4gKiBAcGFyYW0gYSBPcHRpb25hbCBhbHBoYSBtYXNrIGFzIGEgcGVyY2VudGFnZSB2YWx1ZS5cclxuICogQHJldHVybiBUaGUgYElSZ2JGdW5jYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgcmdiKClgIENTUyBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJnYiA9IChyOiBFeHRlbmRlZDxDc3NDb2xvclNlcGFyYXRpb24+LCBnOiBFeHRlbmRlZDxDc3NDb2xvclNlcGFyYXRpb24+LFxyXG4gICAgYjogRXh0ZW5kZWQ8Q3NzQ29sb3JTZXBhcmF0aW9uPiwgYT86IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSVJnYkZ1bmMgPT5cclxue1xyXG4gICAgcmV0dXJuIHsgZm46IFwicmdiXCIsIHIsIGcsIGIsIGEgfTtcclxufVxyXG5cclxuZmRvLnJnYiA9IHtcclxuICAgIHA6IFsgW1wiclwiLCBXS0YuQ29sb3JTZXBhcmF0aW9uXSwgW1wiZ1wiLCAgV0tGLkNvbG9yU2VwYXJhdGlvbl0sIFtcImJcIiwgIFdLRi5Db2xvclNlcGFyYXRpb25dLCBbXCJhXCIsICBXS0YuUGVyY2VudCwgXCIvXCJdIF0sXHJcbiAgICBzOiBcIiBcIlxyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGNvbG9yIHNwZWNpZmllZCBhcyBodWUtc2F0dXJhdGlvbi1saWdodG5lc3MgY29tcG9uZW50cyBhbmQgYW4gb3B0aW9uYWwgYWxwaGFcclxuICogbWFzayB0byBhIENTUyBjb2xvciByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgd2hlbiBkZWZpbmluZyBDU1MgY29sb3JcclxuICogdmFsdWVzIGluIHN0eWxlc2V0IHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIFRoZSBIdWUgY29tcG9uZW50IGlzIHRyZWF0ZWQgYXMgdGhlIENTUyBgPGFuZ2xlPmAgdHlwZS4gTnVtYmVycyBhcmUgY29uc2lkZXJlZCBkZWdyZWVzLlxyXG4gKlxyXG4gKiBUaGUgU2F0dXJhdGlvbiBhbmQgTGlnaHRuZXNzIGNvbXBvbmVudHMgYXJlIHRyZWF0ZWQgYXMgcGVyY2VudGFnZXM6XHJcbiAqICAgLSBUaGUgc2lnbiBpcyBpZ25vcmVkOyB0aGF0IGlzLCBvbmx5IHRoZSBhYnNvbHV0ZSB2YWx1ZSBpcyBjb25zaWRlcmVkLlxyXG4gKiAgIC0gRmxvYXRpbmcgbnVtYmVyIDAgdG8gMSBpbmNsdXNpdmUgYXJlIG11bHRpcGxpZWQgYnkgMTAwIGFuZCB0cmVhdGVkIGFzIHBlcmNlbnRhZ2UuXHJcbiAqICAgLSBJbnRlZ2VyIG9yIGZsb2F0aW5nIG51bWJlciAxIHRvIDEwMCBhcmUgdHJlYXRlZCBhcyBwZXJjZW50YWdlLiBGbG9hdGluZyBudW1iZXJzIHdpbGwgYmVcclxuICogICAgIHJvdW5kZWQuIE51bWJlcnMgYmV5b25kIHRoaXMgcmFuZ2Ugd2lsbCBiZSBjbGFtcGVkIHRvIDEwMC5cclxuICpcclxuICogVGhlIGFscGhhIG1hc2sgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxyXG4gKiAgIC0gRmxvYXRpbmcgbnVtYmVyIDAgdG8gMSBpbmNsdXNpdmUuXHJcbiAqICAgLSBJbnRlZ2VyIG9yIGZsb2F0aW5nIG51bWJlciAxIHRvIDEwMCwgd2hpY2ggaXMgZGl2aWRlZCBieSAxMDAuIEZsb2F0aW5nIG51bWJlcnMgd2lsbCBiZVxyXG4gKiAgICAgcm91bmRlZC4gTnVtYmVycyBiZXlvbmQgdGhpcyByYW5nZSB3aWxsIGJlIGNsYW1wZWQuXHJcbiAqICAgLSBUaGUgc2lnbiBvZiBhbHBoYSBpcyBpZ25vcmVkOyB0aGF0IGlzLCBvbmx5IHRoZSBhYnNvbHV0ZSB2YWx1ZSBpcyBjb25zaWRlcmVkLlxyXG4gKlxyXG4gKiAtIE1ETjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlL2hzbCgpXHJcbiAqXHJcbiAqIEBwYXJhbSBoIEh1ZSBjb21wb25lbnQgYXMgYW4gYW5nbGUgdmFsdWUuXHJcbiAqIEBwYXJhbSBzIFNhdHVyYXRpb24gY29tcG9uZW50IGFzIGEgcGVyY2VudGFnZSB2YWx1ZS5cclxuICogQHBhcmFtIGwgTGlnaHRuZXNzIGNvbXBvbmVudCBhcyBhIHBlcmNlbnRhZ2UgdmFsdWUuXHJcbiAqIEBwYXJhbSBhIE9wdGlvbmFsIGFscGhhIG1hc2sgYXMgYSBwZXJjZW50YWdlIHZhbHVlLlxyXG4gKiBAcmV0dXJuIFRoZSBgSUhzbEZ1bmNgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludm9jYXRpb24gb2YgdGhlIGBoc2woKWAgQ1NTIGZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaHNsID0gKGg6IEV4dGVuZGVkPENzc0FuZ2xlPiwgczogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4sIGw6IEV4dGVuZGVkPENzc1BlcmNlbnQ+LFxyXG4gICAgYT86IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSUhzbEZ1bmMgPT5cclxue1xyXG4gICAgcmV0dXJuIHsgZm46IFwiaHNsXCIsIGgsIHMsIGwsIGEgfTtcclxufVxyXG5cclxuZmRvLmhzbCA9IHtcclxuICAgIHA6IFsgW1wiaFwiLCBXS0YuQW5nbGVdLCBbXCJzXCIsIFdLRi5QZXJjZW50XSwgW1wibFwiLCBXS0YuUGVyY2VudF0sIFtcImFcIiwgV0tGLlBlcmNlbnQsIFwiL1wiXSBdLFxyXG4gICAgczogXCIgXCJcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBjb2xvciBzcGVjaWZpZWQgYXMgTFxcKmFcXCpiXFwqIGNvbXBvbmVudHMgYW5kIGFuIG9wdGlvbmFsIGFscGhhXHJcbiAqIG1hc2sgdG8gYSBDU1MgY29sb3IgcmVwcmVzZW50YXRpb24uIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHdoZW4gZGVmaW5pbmcgQ1NTIGNvbG9yXHJcbiAqIHZhbHVlcyBpbiBzdHlsZXNldCBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiAtIE1ETjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlL2xhYigpXHJcbiAqXHJcbiAqIEBwYXJhbSBsIENJRSBMaWdodG5lc3MgY29tcG9uZW50XHJcbiAqIEBwYXJhbSBkYSBEaXN0YW5jZSBhbG9uZyB0aGUgYSBheGlzIGluIHRoZSBMYWIgY29sb3JzcGFjZVxyXG4gKiBAcGFyYW0gZGIgRGlzdGFuY2UgYWxvbmcgdGhlIGIgYXhpcyBpbiB0aGUgTGFiIGNvbG9yc3BhY2VcclxuICogQHBhcmFtIGEgT3B0aW9uYWwgYWxwaGEgbWFzayBhcyBhIHBlcmNlbnRhZ2UgdmFsdWUuXHJcbiAqIEByZXR1cm5zIFRoZSBgSUxhYkZ1bmNgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludm9jYXRpb24gb2YgdGhlIGBsYWIoKWAgQ1NTIGZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGFiID0gKGw6IEV4dGVuZGVkPENzc1BlcmNlbnQ+LCBkYTogRXh0ZW5kZWQ8bnVtYmVyPiwgZGI6IEV4dGVuZGVkPG51bWJlcj4sXHJcbiAgICBhPzogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4pOiBJTGFiRnVuYyA9PlxyXG57XHJcbiAgICByZXR1cm4geyBmbjogXCJsYWJcIiwgbCwgZGEsIGRiLCBhIH07XHJcbn1cclxuXHJcbmZkby5sYWIgPSB7XHJcbiAgICBwOiBbIFtcImxcIiwgV0tGLkFsd2F5c1BlcmNlbnRdLCBcImRhXCIsIFwiZGJcIiwgW1wiYVwiLCBXS0YuUGVyY2VudCwgXCIvXCJdIF0sXHJcbiAgICBzOiBcIiBcIlxyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGNvbG9yIHNwZWNpZmllZCBhcyBsaWdodG5lc3MtY2hyb21hLWh1ZSBjb21wb25lbnRzIGFuZCBhbiBvcHRpb25hbCBhbHBoYVxyXG4gKiBtYXNrIHRvIGEgQ1NTIGNvbG9yIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB3aGVuIGRlZmluaW5nIENTUyBjb2xvclxyXG4gKiB2YWx1ZXMgaW4gc3R5bGVzZXQgcHJvcGVydGllcy5cclxuICpcclxuICogLSBNRE46IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZS9sY2goKVxyXG4gKlxyXG4gKiBAcGFyYW0gbCBDSUUgTGlnaHRuZXNzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gYyBDaHJvbWEgY29tcG9uZW50XHJcbiAqIEBwYXJhbSBoIEh1ZSBjb21wb25lbnQgYXMgYW4gYW5nbGUgdmFsdWUuXHJcbiAqIEBwYXJhbSBhIE9wdGlvbmFsIGFscGhhIG1hc2sgYXMgYSBwZXJjZW50YWdlIHZhbHVlLlxyXG4gKiBAcmV0dXJucyBUaGUgYElMY2hGdW5jYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgbGNoKClgIENTUyBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxjaCA9IChsOiBFeHRlbmRlZDxDc3NQZXJjZW50PiwgYzogRXh0ZW5kZWQ8bnVtYmVyPiwgaDogRXh0ZW5kZWQ8Q3NzQW5nbGU+LFxyXG4gICAgYT86IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSUxjaEZ1bmMgPT5cclxue1xyXG4gICAgcmV0dXJuIHsgZm46IFwibGNoXCIsIGwsIGMsIGgsIGEgfTtcclxufVxyXG5cclxuZmRvLmxjaCA9IHtcclxuICAgIHA6IFsgW1wibFwiLCBXS0YuQWx3YXlzUGVyY2VudF0sIFwiY1wiLCBbXCJoXCIsIFdLRi5BbmdsZV0sIFtcImFcIiwgV0tGLlBlcmNlbnQsIFwiL1wiXSBdLFxyXG4gICAgczogXCIgXCJcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIGBjb2xvci1jb250cmFzdCgpYCBDU1MgcHJvcGVydHkuXHJcbiAqXHJcbiAqIC0gTUROOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWUvY29sb3ItY29udHJhc3QoKVxyXG4gKlxyXG4gKiBAcGFyYW0gYyBDb2xvciB0byB3aGljaCB0aGUgbGlzdCBvZiBjb2xvcnMgaW4gdGhlIGB2c2AgcHJvcGVydHkgd2lsbCBiZSBjb21wYXJlZFxyXG4gKiBAcGFyYW0gdnMgTGlzdCBvZiBjb2xvcnMgZnJvbSB3aGljaCB0byBzZWxlY3QgdGhlIG1vc3QgY29udHJhc3RpbmcgdG8gdGhlIGJhc2UgY29sb3IuXHJcbiAqIEByZXR1cm5zIFRoZSBgSUNvbG9yQ29udHJhc3RGdW5jYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgY29sb3ItY29udHJhc3QoKWBcclxuICogQ1NTIGZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29sb3JDb250cmFzdCA9IChjOiBFeHRlbmRlZDxDc3NDb2xvcj4sIC4uLnZzOiBFeHRlbmRlZDxDc3NDb2xvcj5bXSk6IElDb2xvckNvbnRyYXN0RnVuYyA9PlxyXG4gICAgKHsgZm46IFwiY29sb3ItY29udHJhc3RcIiwgYywgdnMgfSk7XHJcblxyXG5mZG9bXCJjb2xvci1jb250cmFzdFwiXSA9IHtcclxuICAgIHA6IFtcclxuICAgICAgICBbXCJjXCIsICh2OiBFeHRlbmRlZDxDc3NDb2xvcj4pID0+IHYycyggdiwgV0tGLkNvbG9yKSArIFwiIHZzXCJdLFxyXG4gICAgICAgIFtcInZzXCIsICh2OiBFeHRlbmRlZDxDc3NDb2xvcj5bXSkgPT4gYTJzKCB2LCBXS0YuQ29sb3IsIFwiLFwiKV1cclxuICAgIF0sXHJcbiAgICBzOiBcIiBcIlxyXG59O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBDU1MgYGNvbG9yLW1peCgpYCBmdW5jdGlvbi4gVGhpcyBpbnRlcmZhY2UgaXMgcmV0dXJuZWQgZnJvbSB0aGVcclxuICogW1tjb2xvck1peF1dIGZ1bmN0aW9uLiBEZXZlbG9wZXJzIGNhbiB1c2UgdGhpcyBzdHJ1Y3R1cmUgd2hlcmV2ZXIgW1tDc3NDb2xvcl1dIGlzIGFjY2VwdGVkLlxyXG4gKi9cclxuY2xhc3MgQ29sb3JNaXhGdW5jIGltcGxlbWVudHMgSUNvbG9yTWl4QnVpbGRlclxyXG57XHJcbiAgICBmbjogXCJjb2xvci1taXhcIiA9IFwiY29sb3ItbWl4XCI7XHJcblxyXG4gICAgY3M/OiBFeHRlbmRlZDxDb2xvclNwYWNlPjtcclxuICAgIGMxOiBbRXh0ZW5kZWQ8Q3NzQ29sb3I+LCBFeHRlbmRlZDxDc3NQZXJjZW50Pj9dO1xyXG4gICAgYzI6IFtFeHRlbmRlZDxDc3NDb2xvcj4sIEV4dGVuZGVkPENzc1BlcmNlbnQ+P107XHJcblxyXG4gICAgY29uc3RydWN0b3IoIGM6IEV4dGVuZGVkPENzc0NvbG9yPiwgcD86IEV4dGVuZGVkPENzc1BlcmNlbnQ+KSB7IHRoaXMuYzEgPSBbYywgcF07IH1cclxuXHJcbiAgICB3aXRoKCBjOiBFeHRlbmRlZDxDc3NDb2xvcj4sIHA/OiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IHRoaXMgIHsgdGhpcy5jMiA9IFtjLCBwXTsgcmV0dXJuIHRoaXM7IH1cclxuICAgIGluKCBjczogRXh0ZW5kZWQ8Q29sb3JTcGFjZT4pOiB0aGlzIHsgdGhpcy5jcyA9IGNzOyByZXR1cm4gdGhpczsgfVxyXG59XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyB0aGUgYGNvbG9yLW1peCgpYCBDU1MgcHJvcGVydHkuXHJcbiAqXHJcbiAqIC0gTUROOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWUvY29sb3Itbml4KClcclxuICpcclxuICogKipFeGFtcGxlcyoqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZuaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gY29sb3ItbWl4KCBcImJsdWVcIiwgXCJyZWRcIilcclxuICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7XHJcbiAqICAgICAgICAgY29sb3I6IGNzcy5jb2xvck1peChcImJsdWVcIikud2l0aChcInJlZFwiKTtcclxuICogICAgIH0pXHJcbiAqXHJcbiAqICAgICAvLyBjb2xvci1taXgoIGluIHNyZ2IsIFwiYmx1ZSAzMCVcIiwgXCJyZWRcIiA2MCUpXHJcbiAqICAgICBjbHMyID0gdGhpcy4kY2xhc3Moe1xyXG4gKiAgICAgICAgIGNvbG9yOiBjc3MuY29sb3JNaXgoXCJibHVlXCIsIDMwKS53aXRoKFwicmVkXCIsIDYwKS5pbihcInNyZ2JcIik7XHJcbiAqICAgICB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gY3MgQ29sb3Igc3BhY2UuIERlZmF1bHQgaXMgXCJsY2hcIi5cclxuICogQHJldHVybnMgVGhlIGBJQ29sb3JNaXhCdWlsZGVyYCBvYmplY3QgdGhhdCBhbGxvd3MgYWRkaW5nIGNvbG9ycyBhbmQgb3B0aW9uYWwgcGVyY2VudGFnZXMgdG8gbWl4XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29sb3JNaXggPSAoYzogRXh0ZW5kZWQ8Q3NzQ29sb3I+LCBwPzogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4pOiBJQ29sb3JNaXhCdWlsZGVyID0+IG5ldyBDb2xvck1peEZ1bmMoIGMsIHApO1xyXG5cclxuZmRvW1wiY29sb3ItbWl4XCJdID0gW1xyXG4gICAgW1wiY3NcIiwgKHY6IEV4dGVuZGVkPENvbG9yU3BhY2U+KSA9PiB2ID8gXCJpbiBcIiArIHYycyh2KSA6IFwiXCJdLFxyXG4gICAgW1wiYzFcIiwgdiA9PiBtdjJzKCBbW3ZbMF0sIFdLRi5Db2xvcl0sIFt2WzFdLCBXS0YuUGVyY2VudF1dKV0sXHJcbiAgICBbXCJjMlwiLCB2ID0+IG12MnMoIFtbdlswXSwgV0tGLkNvbG9yXSwgW3ZbMV0sIFdLRi5QZXJjZW50XV0pXSxcclxuXTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBjb2xvciBhbmQgdGhlIGFscGhhIG1hc2sgdG8gdGhlIENTUyBDb2xvciByZXByZXNlbnRhdGlvbi4gVGhpc1xyXG4gKiBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgd2hlbiBkZWZpbmluZyBDU1MgY29sb3IgdmFsdWVzIGluIHN0eWxlc2V0IHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIFRoZSBjb2xvciBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgbnVtZXJpYyB2YWx1ZSBvciBhcyBhIGNvbG9yIG5hbWUgZnJvbSB0aGUgW1tJTmFtZWRDb2xvcnNdXVxyXG4gKiBpbnRlcmZhY2UgLSBpbmNsdWRpbmcgY29sb3JzIGFkZGVkIHVzaW5nIHRoZSBtb2R1bGUgYXVnbWVudGF0aW9uIHRlY2huaXF1ZS5cclxuICpcclxuICogVGhlIGFscGhhIG1hc2sgaXMgc3BlY2lmaWVkIGFzIGEgbnVtYmVyOlxyXG4gKiAgIC0gVGhlIHNpZ24gaXMgaWdub3JlZDsgdGhhdCBpcywgb25seSB0aGUgYWJzb2x1dGUgdmFsdWUgaXMgY29uc2lkZXJlZC5cclxuICogICAtIE51bWJlciAwIHRvIDEgaW5jbHVzaXZlLCB3aGljaCBpcyB0cmVhdGVkIGFzIHBlcmNlbnRhZ2UuXHJcbiAqICAgLSBOdW1iZXIgMSB0byAxMDAgaW5jbHVzaXZlLCB3aGljaCBpcyB0cmVhdGVkIGFzIHBlcmNlbnRhZ2UuXHJcbiAqICAgLSBOdW1iZXJzIGdyZWF0ZXIgdGhhbiAxMDAgYXJlIGNsYW1wZWQgdG8gMTAwO1xyXG4gKlxyXG4gKiAqKkV4YW1wbGVzKipcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gYXBwbHlpbmcgYWxwaGEgdG8gYSBudW1lcmljIGNvbG9yXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3MoeyBjb2xvcjogY3NzLmFscGhhKCAweEFBMDBBQSwgMC41KSB9KVxyXG4gKlxyXG4gKiAgICAgLy8gYXBwbHlpbmcgYWxwaGEgdG8gYSBuYW1lZCBjb2xvclxyXG4gKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHsgY29sb3I6IGNzcy5hbHBoYSggXCJkYXJrb2xpdmVncmVlblwiLCAwLjUpIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqIEBwYXJhbSBjIENvbG9yIHZhbHVlIGFzIGVpdGhlciBhIG51bWJlciBvciBhIG5hbWVkIGNvbG9yXHJcbiAqIEBwYXJhbSBhIEFscGhhIGNoYW5uZWwgdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBhbHBoYSA9IChjOiBudW1iZXIgfCBrZXlvZiBJTmFtZWRDb2xvcnMsIGE6IG51bWJlcik6IElBbHBoYUZ1bmMgPT4gKHsgZm46IFwiYWxwaGFcIiwgYywgYSB9KTtcclxuXHJcbmNvbnN0IGFscGhhMnMgPSAoYzogbnVtYmVyIHwga2V5b2YgSU5hbWVkQ29sb3JzLCBhOiBudW1iZXIpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgLy8gaWYgdGhlIGFscGhhIGlzIDAsIHJldHVybiB0cmFuc3BhcmVudCBjb2xvclxyXG4gICAgaWYgKGEgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIFwiIzAwMDBcIjtcclxuXHJcbiAgICAvLyBjb252ZXJ0IGNvbG9yIHRvIG51bWVyaWMgdmFsdWUgKGlmIGl0J3Mgbm90IGEgbnVtYmVyIHlldCkuIElmIHRoZSBjb2xvciB3YXMgZ2l2ZW4gYXMgYVxyXG4gICAgLy8gc3RyaW5nIHRoYXQgd2UgY2Fubm90IGZpbmQgaW4gdGhlIENvbG9ycyBvYmplY3QsIHJldHVybiBwdXJlIHdoaXRlLlxyXG4gICAgbGV0IG4gPSB0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIiA/IENvbG9yc1tjXSA6IGM7XHJcbiAgICBpZiAobiA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBcIiNGRkZcIjtcclxuXHJcbiAgICAvLyBuZWdhdGl2ZSBhbmQgcG9zaXRpdmUgdmFsdWVzIG9mIGFscGhhIGFyZSB0cmVhdGVkIGlkZW50aWNhbGx5LCBzbyBjb252ZXJ0IHRvIHBvc2l0aXZlXHJcbiAgICBpZiAoYSA8IDApXHJcbiAgICAgICAgYSA9IC1hO1xyXG5cclxuICAgIC8vIGNvbnZlcnQgYWxwaGEgdG8gYSBudW1iZXIgd2l0aCBhYnNvbHV0ZSB2YWx1ZSBsZXNzIHRoYW4gMSAoaWYgaXQgaXMgbm90IHlldCkuIElmIGFscGhhXHJcbiAgICAvLyBpcyAxIG9yIDEwMCwgdGhlbiBzZXQgaXQgdG8gMCBiZWNhdXNlIDAgaW4gdGhlIGNvbG9yTnVtYmVyVG9TdHJpbmcgbWVhbnMgXCJubyBhbHBoYVwiLlxyXG4gICAgYSA9IGEgPT09IDEgfHwgYSA+PSAxMDAgPyAwIDogYSA+IDEgPyBhIC8gMTAwIDogYTtcclxuXHJcbiAgICAvLyBtYWtlIHRoZSBuZXcgYWxwaGFcclxuICAgIHJldHVybiBjb2xvck51bWJlcjJzKCBuID49IDAgPyBuICsgYSA6IG4gLSBhKTtcclxufVxyXG5cclxuZmRvLmFscGhhID0gKHY6IElBbHBoYUZ1bmMpID0+IGFscGhhMnMoIHYuYywgdi5hKVxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7XHJcbiAgICBDc3NTZWxlY3RvciwgSVNlbGVjdG9yUHJveHksIElSYXdQcm94eSwgRXh0ZW5kZWQsIElVcmxGdW5jLCBJQ3Vyc29yRnVuYywgSVN0cmluZ1Byb3h5LFxyXG4gICAgSVNlbGVjdG9yQnVpbGRlciwgTnRoRXhwcmVzc2lvbiwgQXR0ckNvbXBhcmlzb25PcGVyYXRpb24sIFRpbWluZ0Z1bmN0aW9uSnVtcFRlcm0sIElDdWJpY0JlemllckZ1bmMsIElTdGVwc0Z1bmNcclxufSBmcm9tIFwiLi9Db3JlVHlwZXNcIlxyXG5pbXBvcnQge0lDb3VudGVyUnVsZSwgSUlEUnVsZSwgSVZhclJ1bGV9IGZyb20gXCIuL1J1bGVUeXBlc1wiO1xyXG5pbXBvcnQge0F0dHJUeXBlS2V5d29yZCwgQXR0clVuaXRLZXl3b3JkLCBMaXN0U3R5bGVUeXBlX1N0eWxlVHlwZX0gZnJvbSBcIi4vU3R5bGVUeXBlc1wiO1xyXG5pbXBvcnQge0V4dGVuZGVkVmFyVmFsdWUsIFZhclRlbXBsYXRlTmFtZX0gZnJvbSBcIi4vU3R5bGVzZXRzXCI7XHJcbmltcG9ydCB7c3Ayc30gZnJvbSBcIi4uL2ltcGwvU3R5bGVJbXBsXCI7XHJcbmltcG9ydCB7YTJzLCBjYW1lbFRvRGFzaCwgZjJzLCBmZG8sIG12MnMsIHRhZzJzLCBXS0Z9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcblxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gU2VsZWN0b3IgZnVuY3Rpb25zXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3Rvci4gVGhpcyBmdW5jdGlvbiBpcyBhIHRhZyBmdW5jdGlvbiBhbmQgbXVzdCBiZVxyXG4gKiBpbnZva2VkIHdpdGggdGhlIHRlbXBsYXRlIHN0cmluZyB3aXRob3V0IHBhcmVudGhlc2VzLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHdoZXJldmVyIHRoZVxyXG4gKiBbW0Nzc1NlbGVjdG9yXV0gdHlwZXMgYXJlIGFsbG93ZWQuIFRoZSBwYXJhbWV0ZXJzIGVtYmVkZGVkIGludG8gdGhlIHN0cmluZ1xyXG4gKiBtdXN0IGNvbmZvcm0gdG8gdGhlIFtbQ3NzU2VsZWN0b3JdXSB0eXBlLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gY3NzOiB1bCA+IGxpIHsuLi59XHJcbiAqICAgICBzMSA9IHRoaXMuJHN0eWxlKCBjc3Muc2VsZWN0b3JgdWwgPiBsaWAsIHsuLi59KVxyXG4gKlxyXG4gKiAgICAgLy8gY3NzOiB1bC5jMTpob3ZlciB7Li4ufVxyXG4gKiAgICAgYzEgPSB0aGlzLiRjbGFzcyh7Li4ufSlcclxuICogICAgIHMyID0gdGhpcy4kc3R5bGUoIGNzcy5zZWxlY3RvcmB1bC4ke3RoaXMuYzF9OmhvdmVyYCwgey4uLn0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VsZWN0b3IgPSAocGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5wYXJhbXM6IENzc1NlbGVjdG9yW10pOiBJU2VsZWN0b3JQcm94eSA9PlxyXG4gICAgKCkgPT4gdGFnMnMoIHBhcnRzLCBwYXJhbXMpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQXJyYXkgb2YgYXR0cmlidXRlIGNvbXBhcmlzb24gb3BlcmF0aW9uIHN0cmluZ3MgLSBuZWVkZWQgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZyBpcyBhblxyXG4gKiBhdHRyaWJ1dGUgY29tcGFyaXNvbiBvcGVyYXRpb24uXHJcbiAqL1xyXG5jb25zdCBhdHRyQ29tcGFyaXNvbk9wZXJhdGlvbnM6IEF0dHJDb21wYXJpc29uT3BlcmF0aW9uW10gPSBbXCI9XCIsICBcIn49XCIsIFwifD1cIiwgXCJePVwiLCBcIiQ9XCIsIFwiKj1cIl07XHJcblxyXG4vKipcclxuICogQXJyYXkgb2YgY29tYmluYXRvciBzeW1ib2xzIC0gbmVlZGVkIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmcgaXMgYSBjb21iaW5hdG9yLlxyXG4gKi9cclxuY29uc3Qgc2VsZWN0b3JDb21iaW5hdG9ycyA9IFtcIixcIiwgXCIgXCIsIFwiPlwiLCBcIitcIiwgXCJ+XCIsIFwifHxcIl07XHJcblxyXG4vLyAvKipcclxuLy8gICogQXJyYXkgb2Ygbm9uLXBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzZXMgLSBuZWVkZWQgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZyBpcyBzdWNoIHBzZXVkbyBjbGFzcy5cclxuLy8gICovXHJcbi8vIGNvbnN0IHNpbXBsZVBzZXVkb0NsYXNzZXMgPSBbXHJcbi8vICAgICBcImJsYW5rXCIsIFwiZmlyc3RcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIixcclxuLy8gICAgIFwiYWN0aXZlXCIsIFwiYW55LWxpbmtcIiwgXCJhdXRvZmlsbFwiLCBcImJsYW5rXCIsIFwiY2hlY2tlZFwiLCBcImRlZmF1bHRcIiwgXCJkZWZpbmVkXCIsIFwiZGlzYWJsZWRcIixcclxuLy8gICAgIFwiZW1wdHlcIiwgXCJlbmFibGVkXCIsIFwiZmlyc3RDaGlsZFwiLCBcImZpcnN0T2ZUeXBlXCIsIFwiZnVsbHNjcmVlblwiLCBcImZvY3VzXCIsXHJcbi8vICAgICBcImZvY3VzVmlzaWJsZVwiLCBcImZvY3VzV2l0aGluXCIsIFwiaG9zdFwiLCBcImhvdmVyXCIsIFwiaW5kZXRlcm1pbmF0ZVwiLCBcImluUmFuZ2VcIiwgXCJpbnZhbGlkXCIsXHJcbi8vICAgICBcImxhc3RDaGlsZFwiLCBcImxhc3RPZlR5cGVcIiwgXCJsZWZ0XCIsIFwibGlua1wiLCBcIm9ubHlDaGlsZFwiLCBcIm9ubHlPZlR5cGVcIiwgXCJvcHRpb25hbFwiLFxyXG4vLyAgICAgXCJvdXRPZlJhbmdlXCIsIFwicGF1c2VkXCIsIFwicGxhY2Vob2xkZXJTaG93blwiLCBcInJlYWRPbmx5XCIsIFwicmVhZFdyaXRlXCIsIFwicmVxdWlyZWRcIixcclxuLy8gICAgIFwicmlnaHRcIiwgXCJyb290XCIsIFwic2NvcGVcIiwgXCJ0YXJnZXRcIiwgXCJ2YWxpZFwiLCBcInZpc2l0ZWRcIlxyXG4vLyBdO1xyXG5cclxuLy8gLyoqXHJcbi8vICAqIEFycmF5IG9mIG5vbi1wYXJhbWV0ZXJpemVkIHBzZXVkbyBlbGVtZW50cyAtIG5lZWRlZCB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nIGlzIHN1Y2ggcHNldWRvIGVsZW1lbnQuXHJcbi8vICAqL1xyXG4vLyBjb25zdCBzaW1wbGVQc2V1ZG9FbGVtZW50cyA9IFtcclxuLy8gICAgIFwiYWZ0ZXJcIiwgXCJiYWNrZHJvcFwiLCBcImJlZm9yZVwiLCBcImN1ZVwiLCBcImZpcnN0TGV0dGVyXCIsIFwiZmlyc3RMaW5lXCIsXHJcbi8vICAgICBcImdyYW1tYXJFcnJvclwiLCBcIm1hcmtlclwiLCBcInBsYWNlaG9sZGVyXCIsIFwic2VsZWN0aW9uXCIsIFwic3BlbGxpbmdFcnJvclwiXHJcbi8vIF07XHJcblxyXG4vLyAvKipcclxuLy8gICogQXJyYXkgb2YgcGFyYW1ldGVyaXplZCBwc2V1ZG8gY2xhc3NlcyAtIG5lZWRlZCB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nIGlzIHN1Y2ggcHNldWRvIGNsYXNzLlxyXG4vLyAgKi9cclxuLy8gY29uc3QgcGFyYW1ldGVyaXplZFBzZXVkb0NsYXNzZXMgPSBbXHJcbi8vICAgICBcImRpclwiLCBcImhhc1wiLCBcImhvc3RcIiwgXCJob3N0Q29udGV4dFwiLCBcImlzXCIsIFwibGFuZ1wiLCBcIm5vdFwiLCBcIm50aENoaWxkXCIsIFwibnRoT2ZUeXBlXCIsIFwibnRoTGFzdENoaWxkXCIsXHJcbi8vICAgICBcIm50aExhc3RPZlR5cGVcIiwgXCJ3aGVyZVwiXHJcbi8vIF07XHJcblxyXG4vLyAvKipcclxuLy8gICogQXJyYXkgb2YgcGFyYW1ldGVyaXplZCBwc2V1ZG8gZWxlbWVudHMgLSBuZWVkZWQgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZyBpcyBzdWNoIHBzZXVkbyBlbGVtZW50LlxyXG4vLyAgKi9cclxuLy8gY29uc3QgcGFyYW1ldGVyaXplZFBzZXVkb0VsZW1lbnRzID0gW1xyXG4vLyAgICAgXCJwYXJ0XCIsIFwic2xvdHRlZFwiXHJcbi8vIF07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlIG51bWVyaWMgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gaWRlbnRpZnkgd2hhdCB0byBkbyB3aGVuIGFuIGFwcHJvcHJpYXRlIHByb3BlcnR5IG9yXHJcbiAqIG1ldGhvZCBmcm9tIHRoZSBJU2VsZWN0b3JCdWlsZGVyIGludGVyZmFjZSBpcyBpbnZva2VkLlxyXG4gKi9cclxuY29uc3QgZW51bSBTZWxlY3RvclByb2Nlc3NpbmdUeXBlXHJcbntcclxuICAgIFNpbXBsZVBzZXVkb0VsZW1lbnQgPSAxLFxyXG4gICAgUGFyYW1ldGVyaXplZFBzZXVkb0NsYXNzLFxyXG4gICAgUGFyYW1ldGVyaXplZFBzZXVkb0VsZW1lbnQsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUeXBlIHRoYXQgZGV0ZXJtaW5lcyBob3cgYSBwcm9wZXJ0eSBvciBhIG1ldGhvZCBvZiB0aGUgSVNlbGVjdG9yQnVpbGRlciBpbnRlcmZhY2Ugc2hvdWxkIGJlXHJcbiAqIGNvbnZlcnRlZCB0byBDc3NTZWxlY3RvciB2YWx1ZXM6IFRoZSB0eXBlIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcclxuICogICAtIG51bWJlciAtIG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUgZW51bWVyYXRpb25cclxuICogICAtIEZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHdpbGwgYmUgYm91bmQgdG8gdGhlIFNlbGVjdG9yQnVpbGRlckhhbmRsZXIgaW5zdGFuY2UgYW5kIHRoZVxyXG4gKiAgICAgcHJvcGVydHkgbmFtZS5cclxuICogICAtIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZmllZHM6XHJcbiAqICAgICAtIGYgLSB0aGUgZnVuY3Rpb24gd2lsbCBiZSBib3VuZCB0byB0aGUgU2VsZWN0b3JCdWlsZGVySGFuZGxlciBpbnN0YW5jZSwgdGhlXHJcbiAqICAgICAgIHByb3BlcnR5IG5hbWUgYW5kIHdoYXRldmVyIGFyZ3VtZW50cyBhcmUgc3BlY2lmaWVkIGluIHRoZSBcImFcIiBmaWVsZC5cclxuICogICAgIC0gYSAtIGFycmF5IG9mIGFyZ3VtZW50cyB0byB3aGljaCB0aGUgZnVuY3Rpb24gc3BlY2lmaWVkIGJ5IHRoZSBcImZcIiBmaWVsZCB3aWwgYmUgYm91bmQgdG9cclxuICogICAgICAgaW4gYWRkaXRpb24gdG8gdGhlIFNlbGVjdG9yQnVpbGRlckhhbmRsZXIgaW5zdGFuY2UgYW5kIHRoZSBwcm9wZXJ0eSBuYW1lLlxyXG4gKiAgICAgLSBwIC0gb3B0aW9uYWwgcHJlZml4IHRvIGJlIGFkZGVkIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIGZvciBwc2V1ZG8gY2xhc3NlcyBhbmQgZWxlbWVudHMuXHJcbiAqICAgICAtIG4gLSBvcHRpb25hbCBuYW1lIG9mIHRoZSBlbnRpdHkgdG8gYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBuYW1lLlxyXG4gKi9cclxudHlwZSBTZWxlY3RvclByb2Nlc3NpbmdJbmZvID0gU2VsZWN0b3JQcm9jZXNzaW5nVHlwZSB8IEZ1bmN0aW9uIHxcclxuICAgIHsgZjogRnVuY3Rpb24sIGE6IGFueVtdLCBwPzogXCI6XCIgfCBcIjo6XCIsIG4/OiBzdHJpbmcgfTtcclxuXHJcbi8vIFNlbGVjdG9yUHJvY2Vzc2luZ0luZm8gb2JqZWN0IHRoYXQgdXNlZCBzZXZlcmFsIHRpbWVzLCBzbyBpdCBpcyBcImNhY2hlZFwiIGhlcmVcclxuY29uc3QgcHNldWRvQ2xhc3NXaXRoU2VsZWN0b3JzSW5mbzogU2VsZWN0b3JQcm9jZXNzaW5nSW5mbyA9IHsgZjogd3JhcEFuZEFkZFNlbGVjdG9ycywgYTogW1wiLFwiXSwgcDogXCI6XCIgfTtcclxuXHJcbi8qKlxyXG4gKiBPYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBob3cgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgSVNlbGVjdG9yQnVpbGRlciBpbnRlcmZhY2VcclxuICogc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBDc3NTZWxlY3RvciB2YWx1ZXMuIElmIGEgbmFtZSBvZiB0aGUgcHJvcGVydHkgaXMgbm90IGluIHRoaXMgb2JqZWN0LCBpdFxyXG4gKiBpcyB0cmVhdGVkIGFzIGEgbm9uLXBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzLlxyXG4gKi9cclxuY29uc3Qgc2VsZWN0b3JJbmZvczogeyBbUCBpbiBzdHJpbmddOiBTZWxlY3RvclByb2Nlc3NpbmdJbmZvIH0gPVxyXG57XHJcbiAgICAvLyBoZWxwZXIgbWV0aG9kc1xyXG4gICAgXCJhdHRyXCI6IGFkZEF0dHJTZWxlY3RvcixcclxuICAgIFwiYW5kXCI6IHsgZjogYWRkU2VsZWN0b3JzV2l0aENvbWJpbmF0b3JzLCBhOiBbXCJcIl0gfSxcclxuICAgIFwib3JcIjogeyBmOiBhZGRTZWxlY3RvcnNXaXRoQ29tYmluYXRvcnMsIGE6IFtcIixcIl0gfSxcclxuICAgIFwiY2hpbGRcIjogeyBmOiBhZGRTZWxlY3RvcnNXaXRoQ29tYmluYXRvcnMsIGE6IFtcIj5cIl0gfSxcclxuICAgIFwiZGVzY1wiOiB7IGY6IGFkZFNlbGVjdG9yc1dpdGhDb21iaW5hdG9ycywgYTogW1wiIFwiXSB9LFxyXG4gICAgXCJzaWJcIjogeyBmOiBhZGRTZWxlY3RvcnNXaXRoQ29tYmluYXRvcnMsIGE6IFtcIn5cIl0gfSxcclxuICAgIFwiYWRqXCI6IHsgZjogYWRkU2VsZWN0b3JzV2l0aENvbWJpbmF0b3JzLCBhOiBbXCIrXCJdIH0sXHJcblxyXG4gICAgLy8gc2ltcGxlIHBzZXVkbyBlbGVtZW50c1xyXG4gICAgXCJhZnRlclwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcbiAgICBcImJhY2tkcm9wXCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuU2ltcGxlUHNldWRvRWxlbWVudCxcclxuICAgIFwiYmVmb3JlXCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuU2ltcGxlUHNldWRvRWxlbWVudCxcclxuICAgIFwiY3VlXCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuU2ltcGxlUHNldWRvRWxlbWVudCxcclxuICAgIFwiZmlyc3RMZXR0ZXJcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJmaXJzdExpbmVcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJncmFtbWFyRXJyb3JcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJtYXJrZXJcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJwbGFjZWhvbGRlclwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcbiAgICBcInNlbGVjdGlvblwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQsXHJcbiAgICBcInNwZWxsaW5nRXJyb3JcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5TaW1wbGVQc2V1ZG9FbGVtZW50LFxyXG5cclxuICAgIC8vIHBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzZXNcclxuICAgIFwiZGlyXCI6IFNlbGVjdG9yUHJvY2Vzc2luZ1R5cGUuUGFyYW1ldGVyaXplZFBzZXVkb0NsYXNzLFxyXG4gICAgLy8gXCJoYXNcIjogcHNldWRvQ2xhc3NXaXRoU2VsZWN0b3JzSW5mbyxcclxuICAgIFwiaG9zdCRcIjogeyBmOiB3cmFwQW5kQWRkU2VsZWN0b3JzLCBhOiBbXCIsXCJdLCBwOiBcIjpcIiwgbjogXCI6aG9zdFwiIH0sXHJcbiAgICBcImhvc3RDb250ZXh0XCI6IHBzZXVkb0NsYXNzV2l0aFNlbGVjdG9yc0luZm8sXHJcbiAgICBcImlzXCI6IHBzZXVkb0NsYXNzV2l0aFNlbGVjdG9yc0luZm8sXHJcbiAgICBcImxhbmdcIjogU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5QYXJhbWV0ZXJpemVkUHNldWRvQ2xhc3MsXHJcbiAgICBcIm5vdFwiOiBwc2V1ZG9DbGFzc1dpdGhTZWxlY3RvcnNJbmZvLFxyXG4gICAgXCJudGhDaGlsZFwiOiBhZGROdGhQc2V1ZG9DbGFzcyxcclxuICAgIFwibnRoTGFzdENoaWxkXCI6IGFkZE50aFBzZXVkb0NsYXNzLFxyXG4gICAgXCJudGhPZlR5cGVcIjogYWRkTnRoUHNldWRvQ2xhc3MsXHJcbiAgICBcIm50aExhc3RPZlR5cGVcIjogYWRkTnRoUHNldWRvQ2xhc3MsXHJcbiAgICBcIndoZXJlXCI6IHBzZXVkb0NsYXNzV2l0aFNlbGVjdG9yc0luZm8sXHJcblxyXG4gICAgLy8gcGFyYW1ldGVyaXplZCBwc2V1ZG8gZWxlbWVudHNcclxuICAgIFwicGFydFwiOiBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlBhcmFtZXRlcml6ZWRQc2V1ZG9FbGVtZW50LFxyXG4gICAgXCJzbG90dGVkXCI6IHsgZjogd3JhcEFuZEFkZFNlbGVjdG9ycywgYTogW1wiLFwiXSwgcDogXCI6OlwiIH0sXHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFByb3h5IGhhbmRsZXIgdGhhdCBzZXJ2ZXMgYXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIElTZWxlY3RvckJ1aWxkZXIgaW50ZXJmYWNlLlxyXG4gKi9cclxuY2xhc3MgU2VsZWN0b3JCdWlsZGVySGFuZGxlciBpbXBsZW1lbnRzIFByb3h5SGFuZGxlcjxJU2VsZWN0b3JCdWlsZGVyPlxyXG57XHJcbiAgICBpdGVtczogQ3NzU2VsZWN0b3JbXSA9IFtdO1xyXG5cclxuICAgIC8vIGFycmF5IG9mIGtleXMgdGhhdCBhcmUgY29uc2lkZXJlZCBcIm93blwiOiB0aGVzZSBhcmUgdGhlIGtleXMgZnJvbSB0aGUgSVNlbGVjdG9yRnVuYyBpbnRlcmZhY2VcclxuICAgIHN0YXRpYyBrZXlzID0gW1wiZm5cIiwgXCJpdGVtc1wiXTtcclxuXHJcbiAgICBnZXQoIHQ6IGFueSwgcHJvcE5hbWU6IFByb3BlcnR5S2V5LCByOiBhbnkpOiBhbnlcclxuICAgIHtcclxuICAgICAgICBpZiAodHlwZW9mIHByb3BOYW1lICE9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIG1ha2VzIG91ciBvYmplY3QgdG8gaW1wbGVtZW50IHRoZSBJU2VsZWN0b3JGdW5jIGludGVyZmFjZVxyXG4gICAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJmblwiKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJzZWxcIjtcclxuICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCJpdGVtc1wiKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcztcclxuXHJcbiAgICAgICAgbGV0IGluZm8gPSBzZWxlY3RvckluZm9zW3Byb3BOYW1lXTtcclxuICAgICAgICBpZiAoIWluZm8pXHJcbiAgICAgICAgICAgIHJldHVybiBwdXNoU2VsZWN0b3IuY2FsbCggdGhpcywgcHNldWRvQ2FtZWxUb2REYXNoKCBcIjpcIiwgcHJvcE5hbWUpKTtcclxuICAgICAgICBlbHNlIGlmIChpbmZvID09PSBTZWxlY3RvclByb2Nlc3NpbmdUeXBlLlNpbXBsZVBzZXVkb0VsZW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBwdXNoU2VsZWN0b3IuY2FsbCggdGhpcywgcHNldWRvQ2FtZWxUb2REYXNoKCBcIjo6XCIsIHByb3BOYW1lKSk7XHJcbiAgICAgICAgZWxzZSBpZiAoaW5mbyA9PT0gU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5QYXJhbWV0ZXJpemVkUHNldWRvQ2xhc3MpXHJcbiAgICAgICAgICAgIHJldHVybiBhZGRQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5LmJpbmQoIHRoaXMsIHBzZXVkb0NhbWVsVG9kRGFzaCggXCI6XCIsIHByb3BOYW1lKSk7XHJcbiAgICAgICAgZWxzZSBpZiAoaW5mbyA9PT0gU2VsZWN0b3JQcm9jZXNzaW5nVHlwZS5QYXJhbWV0ZXJpemVkUHNldWRvRWxlbWVudClcclxuICAgICAgICAgICAgcmV0dXJuIGFkZFBhcmFtZXRlcml6ZWRQc2V1ZG9FbnRpdHkuYmluZCggdGhpcywgcHNldWRvQ2FtZWxUb2REYXNoKCBcIjo6XCIsIHByb3BOYW1lKSk7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGluZm8gPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgcmV0dXJuIGluZm8uYmluZCggdGhpcywgcHJvcE5hbWUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb3BOYW1lID0gaW5mby5uID8/IChpbmZvLnAgPyBwc2V1ZG9DYW1lbFRvZERhc2goIGluZm8ucCwgcHJvcE5hbWUpIDogcHJvcE5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5mby5mLmJpbmQoIHRoaXMsIHByb3BOYW1lLCAuLi5pbmZvLmEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvd25LZXlzKCB0OiBhbnkpOiBBcnJheUxpa2U8c3RyaW5nIHwgc3ltYm9sPiB7IHJldHVybiBTZWxlY3RvckJ1aWxkZXJIYW5kbGVyLmtleXM7IH1cclxuICAgIGhhcyggdDogYW55LCBwOiBzdHJpbmcpOiBib29sZWFuIHsgcmV0dXJuIFNlbGVjdG9yQnVpbGRlckhhbmRsZXIua2V5cy5pbmNsdWRlcyhwKTsgfVxyXG5cclxuXHJcblxyXG4gICAgLy8gcmVmZXJlbmNlIHRvIHRoZSBwcm94eSBvYmplY3QgdGhhdCB0aGlzIGhhbmRsZXIgc2VydmVzLiBXZSBuZWVkIGl0IHRvIHJldHVybiBmcm9tXHJcbiAgICAvLyBvdXIgZnVuY3Rpb25zIGluIG9yZGVyIHRvIG1ha2UgdGhlIGNhbGwgY2hhaW5pbmcgd29yay5cclxuICAgIHByb3h5OiBhbnk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoIGl0ZW1zOiBDc3NTZWxlY3RvcltdKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vLyBhZGRzIGFuIGF0dHJpYnV0ZSBzZWxlY3RvclxyXG5mdW5jdGlvbiBhZGRBdHRyU2VsZWN0b3IoIHRoaXM6IFNlbGVjdG9yQnVpbGRlckhhbmRsZXIsIHByb3BOYW1lOiBzdHJpbmcsXHJcbiAgICBhdHRyTmFtZTogc3RyaW5nLCBwMj86IGFueSwgcDM/OiBhbnksIHA0PzogYW55LCBwNT86IGFueSk6IGFueVxyXG57XHJcbiAgICByZXR1cm4gcHVzaFNlbGVjdG9yLmNhbGwoIHRoaXMsXHJcbiAgICAgICAgYXR0ckNvbXBhcmlzb25PcGVyYXRpb25zLmluY2x1ZGVzKHAyKVxyXG4gICAgICAgICAgICA/IHtmbjogXCJhdHRyLXNlbFwiLCBuYW1lOiBhdHRyTmFtZSwgdmFsOiBwMywgb3A6IHAyLCBjZjogcDQsIG5zOiBwNX1cclxuICAgICAgICAgICAgOiB7Zm46IFwiYXR0ci1zZWxcIiwgbmFtZTogYXR0ck5hbWUsIHZhbDogcDIsIGNmOiBwMywgbnM6IHA0fVxyXG4gICAgKTtcclxufVxyXG5cclxuLy8gUHVzaGVzIGEgc2VsZWN0b3IgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJpemVkIHBzZXVkbyBlbnRpdHkgdG8gdGhlIGxpc3Qgb2YgaXRlbXNcclxuZnVuY3Rpb24gYWRkUGFyYW1ldGVyaXplZFBzZXVkb0VudGl0eSggdGhpczogU2VsZWN0b3JCdWlsZGVySGFuZGxlciwgZW50aXR5OiBzdHJpbmcsIHBhcmFtOiBhbnkpOiBhbnlcclxue1xyXG4gICAgcmV0dXJuIHB1c2hTZWxlY3Rvci5jYWxsKCB0aGlzLCB7IGZuOiBlbnRpdHksIHA6IHBhcmFtIH0pO1xyXG59XHJcblxyXG4vLyBBZGRzIHRoZSBnaXZlbiBzZWxlY3RvcnMgaW50ZXJtaW5nbGVkIHdpdGggdGhlIGdpdmVuIGNvbWJpbmF0b3IgdG8gdGhlIGxpc3Qgb2YgaXRlbXMuXHJcbmZ1bmN0aW9uIGFkZFNlbGVjdG9yc1dpdGhDb21iaW5hdG9ycyggdGhpczogU2VsZWN0b3JCdWlsZGVySGFuZGxlciwgZW50aXR5OiBzdHJpbmcsXHJcbiAgICBjb21iaW5hdG9yOiBzdHJpbmcsIC4uLm5ld0l0ZW1zOiBDc3NTZWxlY3RvcltdKTogYW55XHJcbntcclxuICAgIHJldHVybiBwdXNoU2VsZWN0b3JzV2l0aENvbWJpbmF0b3JzLmNhbGwoIHRoaXMsIGNvbWJpbmF0b3IsIHRydWUsIC4uLm5ld0l0ZW1zKTtcclxufVxyXG5cclxuLy8gV3JhcHMgdGhlIGdpdmVuIHNlbGVjdG9ycyB3aXRoIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBnaXZlbiBwc2V1ZG8gZW50aXR5IGFuZCBwdXNoZXMgdGhlbVxyXG4vLyB0byB0aGUgbGlzdCBvZiBpdGVtc1xyXG5mdW5jdGlvbiB3cmFwQW5kQWRkU2VsZWN0b3JzKCB0aGlzOiBTZWxlY3RvckJ1aWxkZXJIYW5kbGVyLCBuYW1lOiBzdHJpbmcsIGNvbWJpbmF0b3I6IHN0cmluZywgLi4ubmV3SXRlbXM6IENzc1NlbGVjdG9yW10pOiBhbnlcclxue1xyXG4gICAgdGhpcy5pdGVtcy5wdXNoKCBuYW1lICsgXCIoXCIpO1xyXG4gICAgcHVzaFNlbGVjdG9yc1dpdGhDb21iaW5hdG9ycy5jYWxsKCB0aGlzLCBjb21iaW5hdG9yLCBmYWxzZSwgLi4ubmV3SXRlbXMpXHJcbiAgICB0aGlzLml0ZW1zLnB1c2goIFwiKVwiKTtcclxuICAgIHJldHVybiB0aGlzLnByb3h5O1xyXG59XHJcblxyXG4vLyBQdXNoZXMgdGhlIFwibnRoXCIgcHNldWRvIGNsYXNzIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMgdG8gdGhlIGxpc3Qgb2YgaXRlbXNcclxuZnVuY3Rpb24gYWRkTnRoUHNldWRvQ2xhc3MoIHRoaXM6IFNlbGVjdG9yQnVpbGRlckhhbmRsZXIsIHByb3BOYW1lOiBzdHJpbmcsIHAxOiBOdGhFeHByZXNzaW9uLCBwMj86IG51bWJlcik6IGFueVxyXG57XHJcbiAgICByZXR1cm4gcHVzaFNlbGVjdG9yLmNhbGwoIHRoaXMsIHsgZm46IHBzZXVkb0NhbWVsVG9kRGFzaCggXCI6XCIsIHByb3BOYW1lKSwgcDogcDIgIT0gbnVsbCA/IFtwMSBhcyBudW1iZXIsIHAyXSA6IHAxIH0pO1xyXG59XHJcblxyXG4vLyBQdXNoZXMgdGhlIGdpdmVuIHNlbGVjdG9ycyBpbnRlcm1pbmdsZWQgd2l0aCB0aGUgZ2l2ZW4gY29tYmluYXRvciB0byB0aGUgbGlzdCBvZiBpdGVtcy4gVGhlXHJcbi8vIFwiaW5zZXJ0QmVmb3JlXCIgcGFyYW1ldGVyIGluZGljYXRlcyB3aGV0aGVyIHRoZSBjb21iaW5hdG9yIHNob3VsZCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGZpcnN0XHJcbi8vIHNlbGVjdG9yIGl0ZW0uXHJcbmZ1bmN0aW9uIHB1c2hTZWxlY3RvcnNXaXRoQ29tYmluYXRvcnMoIHRoaXM6IFNlbGVjdG9yQnVpbGRlckhhbmRsZXIsIGNvbWJpbmF0b3I6IHN0cmluZyxcclxuICAgIGluc2VydEJlZm9yZTogYm9vbGVhbiwgLi4ubmV3SXRlbXM6IENzc1NlbGVjdG9yW10pOiBhbnlcclxue1xyXG4gICAgaWYgKGluc2VydEJlZm9yZSAmJiBjb21iaW5hdG9yKVxyXG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCggY29tYmluYXRvcik7XHJcblxyXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBuZXdJdGVtcy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBpZiAoaSA+IDAgJiYgY29tYmluYXRvcilcclxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKCBjb21iaW5hdG9yKTtcclxuXHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ld0l0ZW1zW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5wcm94eTtcclxufVxyXG5cclxuLy8gUHVzaGVzIHRoZSBnaXZlbiBhcmd1bWVudCB0byB0aGUgbGlzdCBvZiBpdGVtc1xyXG5mdW5jdGlvbiBwdXNoU2VsZWN0b3IoIHRoaXM6IFNlbGVjdG9yQnVpbGRlckhhbmRsZXIsIGl0ZW06IENzc1NlbGVjdG9yKTogYW55XHJcbntcclxuICAgIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcclxuICAgIHJldHVybiB0aGlzLnByb3h5O1xyXG59XHJcblxyXG4vLyBjb21iaW5lcyB0aGUgZ2l2ZW4gcHJlZml4IHdpdGggdGhlIHBzZXVkbyBlbnRpdHkgY2FtZWwgbmFtZSBjb252ZXJ0ZWQgdG8gZGFzaCBmb3JtXHJcbmNvbnN0IHBzZXVkb0NhbWVsVG9kRGFzaCA9IChwcmVmaXg6IFwiOlwiIHwgXCI6OlwiLCBuYW1lOiBzdHJpbmcpID0+IHByZWZpeCArIGNhbWVsVG9EYXNoKG5hbWUpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBzZWxlY3RvciBidWlsZGVyIG9iamVjdCB0aGF0IHByb3ZpZGVzIG1lYW5zIHRvIGJ1aWxkIGNvbXBsZXggc2VsZWN0b3JzIGZyb20gbXVsdGlwbGVcclxuICogc2VsZWN0b3IgaXRlbXMgb2YgYWxsIHBvc3NpYmxlIGtpbmRzIGluY2x1ZGluZyB0YWdzLCBjbGFzc2VzcywgSURzLCBhdHRyaWJ1dGVzLCBwc2V1ZG8gY2xhc3Nlc1xyXG4gKiBhbmQgcHNldWRvIGVsZW1lbnRzIGNvbWJpbmVkIHdpdGggQ1NTIGNvbWJpbmF0b3JzLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIFtbSVNlbGVjdG9yQnVpbGRlcl1dXHJcbiAqIGludGVyZmFjZSwgd2hpY2ggaGFzIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgZm9yIGFsbCBzZWxlY3RvciBpdGVtcy5cclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIGNscyA9IHRoaXMuJGNsYXNzKHsuLi59KVxyXG4gKiAgICAgbXlJRCA9IHRoaXMuJGlkKHsuLi59KVxyXG4gKlxyXG4gKiAgICAgLy8gcHJvZHVjZXMgQ1NTOiBsYWJlbC5jbHMxW2RhdGEtaXRlbT1cIm15SURcIl06aG92ZXIgey4uLn1cclxuICogICAgIHMxID0gdGhpcy4kc3R5bGUoIGNzcy5zZWwoXCJsYWJlbFwiKS5hbmQodGhpcy5jbHMxKSkuYXR0cihcImZvclwiLCB0aGlzLm15SUQpLmhvdmVyLCB7Li4ufSlcclxuICogfVxyXG4gKiBgYGBcclxuICogQHBhcmFtIGl0ZW1zIExpc3Qgb2Ygc2VsZWN0b3IgaXRlbXMgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcGxleCBzZWxlY3Rvci4gSWYgbXVsdGlwbGUgaXRlbXMgYXJlXHJcbiAqIHNwZWNpZmllZCwgdGhleSBhcmUgdHJlYXRlZCBhcyBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZCB3aXRoIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VsID0gKC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogSVNlbGVjdG9yQnVpbGRlciA9PlxyXG57XHJcbiAgICBsZXQgaGFuZGxlciA9IG5ldyBTZWxlY3RvckJ1aWxkZXJIYW5kbGVyKGl0ZW1zKTtcclxuICAgIGxldCBwcm94eSA9IG5ldyBQcm94eSgge30sIGhhbmRsZXIpO1xyXG5cclxuICAgIC8vIHRoZSBoYW5kbGVyIHNob3VsZCByZWZlcmVuY2UgdGhlIHByb3h5IGluIG9yZGVyIHRvIHJldHVybiBpdCBmcm9tIG1ldGhvZHMgKGFuZCBwcm9wZXJ0aWVzKVxyXG4gICAgLy8gdG8gYWxsb3cgY2hhaW4gY2FsbHMuXHJcbiAgICBoYW5kbGVyLnByb3h5ID0gcHJveHk7XHJcbiAgICByZXR1cm4gcHJveHkgYXMgSVNlbGVjdG9yQnVpbGRlcjtcclxufVxyXG5cclxuZmRvW1wic2VsXCJdID0gdiA9PiBhMnMoIHYuaXRlbXMsIHsgc2VwOiBcIlwiLCByZWN1cnNpdmU6IHRydWUgfSwgXCJcIik7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBBbmltYXRpb24gYW5kIHRyYW5zaXRpb24gdGltaW5nIGZ1bmN0aW9ucy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHJlcHJlc2VudGluZyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBDU1MgYHN0ZXBzKClgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNpdGlvbiBhbmQgQW5pbWF0aW9uXHJcbiAqL1xyXG4gZXhwb3J0IGNvbnN0IHN0ZXBzID0gKG46IEV4dGVuZGVkPG51bWJlcj4sIGo/OiBUaW1pbmdGdW5jdGlvbkp1bXBUZXJtKTogSVN0ZXBzRnVuYyA9PlxyXG4gKHsgZm46IFwic3RlcHNcIiwgbiwgaiB9KTtcclxuXHJcbmZkby5zdGVwcyA9IFtcIm5cIiwgXCJqXCJdXHJcblxyXG5cclxuXHJcbi8qKlxyXG4qIFJldHVybnMgYSBmdW5jdGlvbiByZXByZXNlbnRpbmcgYW4gaW52b2NhdGlvbiBvZiB0aGUgQ1NTIGBjdWJpYy1iZXppZXIoKWAgZnVuY3Rpb24uXHJcbipcclxuKiBAY2F0ZWdvcnkgVHJhbnNpdGlvbiBhbmQgQW5pbWF0aW9uXHJcbiovXHJcbmV4cG9ydCBjb25zdCBjdWJpY0JlemllciA9IChuMTogRXh0ZW5kZWQ8bnVtYmVyPiwgbjI6IEV4dGVuZGVkPG51bWJlcj4sIG4zOiBFeHRlbmRlZDxudW1iZXI+LFxyXG4gbjQ6IEV4dGVuZGVkPG51bWJlcj4pOiBJQ3ViaWNCZXppZXJGdW5jID0+ICh7IGZuOiBcImN1YmljLWJlemllclwiLCBuMSwgbjIsIG4zLCBuNCB9KTtcclxuXHJcbmZkb1tcImN1YmljLWJlemllclwiXSA9IFtcIm4xXCIsIFwibjJcIiwgXCJuM1wiLCBcIm40XCJdXHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUaGUgYHJhd2AgZnVuY3Rpb24gYWxsb3dzIHNwZWNpZnlpbmcgYXJiaXRyYXJ5IHRleHQgZm9yIHByb3BlcnRpZXMgd2hvc2UgdHlwZSBub3JtYWxseSBkb2Vzbid0XHJcbiAqIGFsbG93IHN0cmluZ3MuVGhpcyBmdW5jdGlvbiBpcyBhIHRhZyBmdW5jdGlvbiBhbmQgbXVzdCBiZSBpbnZva2VkIHdpdGggdGhlIHRlbXBsYXRlIHN0cmluZ1xyXG4gKiB3aXRob3V0IHBhcmVudGhlc2VzLiBUaGUgYHJhd2AgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yIGFueSBzdHlsZSBwcm9wZXJ0eS4gTm90ZSwgaG93ZXZlciwgdGhhdFxyXG4gKiBubyB2YWxpZGF0aW9uIGNoZWNrcyBhcmUgcGVyZm9ybWVkIG9uIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHN0cmluZy4gSWYgdGhlIHN0cmluZyBpc24ndCB2YWxpZFxyXG4gKiBmb3IgdGhlIHN0eWxlIHByb3BlcnR5LCB0aGUgcHJvcGVydHkgd2lsbCBub3QgYmVjb21lIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUgaW5zZXJ0ZWQgaW50byB0aGVcclxuICogRE9NLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgcG9seSA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICBjbGlwUGF0aDogY3NzLnJhd2Bwb2x5Z29uKDUwJSAyMCUsIDkwJSA4MCUsIDEwJSA4MCUpYFxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjb25zdCByYXcgPSAocGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5wYXJhbXM6IGFueVtdKTogSVJhd1Byb3h5ID0+XHJcbiAgICAoKSA9PiB0YWcycyggcGFydHMsIHBhcmFtcyk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBDU1MgYHVybCgpYCBmdW5jdGlvbi4gVGhlIHN0cmluZyBwYXJhbWV0ZXJcclxuICogd2lsbCBiZSB3cmFwcGVkIGluIGEgYHVybCgpYCBpbnZvY2F0aW9uLiBUaGUgZnVuY3Rpb24gY2FuIGFsc28gYWNjZXB0IHRoZSBJSURSdWxlIG9iamVjdCB0b1xyXG4gKiBjcmVhdGUgdXJsKCNlbGVtZW50KSBpbnZvY2F0aW9uLCB3aGljaCBpcyBvZnRlbiB1c2VkIHRvIGFkZHJlc3MgU1ZHIGVsZW1lbnRzIGJ5IHRoZWlyIElEcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCB1cmwgPSAocDogRXh0ZW5kZWQ8c3RyaW5nIHwgSUlEUnVsZT4pOiBJVXJsRnVuYyA9PiAoeyBmbjogXCJ1cmxcIiwgcCB9KTtcclxuXHJcbmZkby51cmwgPSBbIFtcInBcIiwge3N0cjogV0tGLlF1b3RlZH0gXV1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIENTUyBgdXJsKClgIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGN1cnNvciggcDogRXh0ZW5kZWQ8c3RyaW5nIHwgSUlEUnVsZT4pOiBJQ3Vyc29yRnVuYztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBDU1MgYHVybCgpYCBmdW5jdGlvbiBmb2xsb3dlZCBieSB0d28gbnVtYmVyc1xyXG4gKiBpbmRpY2F0aW5nIHRoZSBjdXJzb3IgaG90c3BvdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjdXJzb3IoIHA6IEV4dGVuZGVkPHN0cmluZyB8IElJRFJ1bGU+LCB4OiBudW1iZXIsIHk6IG51bWJlcik6IElDdXJzb3JGdW5jO1xyXG5cclxuLy8gSW1wbGVtZW50YXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGN1cnNvciggdXJsOiBFeHRlbmRlZDxzdHJpbmcgfCBJSURSdWxlPiwgeD86IG51bWJlciwgeT86IG51bWJlcik6IElDdXJzb3JGdW5jXHJcbntcclxuICAgIHJldHVybiB7IGZuOiBcImN1cnNvclwiLCB1cmwsIHgsIHkgfTtcclxufVxyXG5cclxuZmRvLmN1cnNvciA9ICh2OiBJQ3Vyc29yRnVuYykgPT4gbXYycyggW3VybCh2LnVybCksIHYueCwgdi55XSlcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBhdHRyKClgIENTUyBmdW5jdGlvbi4gSXQgcmV0dXJucyBbW0lTdHJpbmdQcm94eV1dIGFuZFxyXG4gKiB0aGVvcmV0aWNhbGx5IGNhbiBiZSB1c2VkIGluIGFueSBzdHlsZSBwcm9wZXJ0eSB3aGVyZXZlciB0aGUgQ1NTIGA8c3RyaW5nPmAgdHlwZSBpcyBhY2NlcHRlZDtcclxuICogaG93ZXZlciwgaXRzIHVzZSBieSBicm93c2VycyBpcyBjdXJyZW50bHkgbGltaXRlZCB0byB0aGUgYGNvbnRlbnRgIHByb3BlcnR5LiBBbHNvIG5vdCBhbGxcclxuICogYnJvd3NlcnMgY3VycmVudGx5IHN1cHBvcnQgdHlwZSwgdW5pdHMgb3IgZmFsbGJhY2sgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXR0ck5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZC5cclxuICogQHBhcmFtIHR5cGVPclVuaXQgT3B0aW9uYWwgdHlwZSBvciB1bml0IGtleXdvcmQgdGhhdCBkZXRlcm1pbmVzIHRoZSByZXR1cm5lZCBDU1MgdHlwZS5cclxuICogQHBhcmFtIGZhbGxiYWNrIE9wdGlvbmFsIHZhbHVlIHRoYXQgaXMgdXNlZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBmb3VuZCBvbiB0aGUgZWxlbWVudC5cclxuICogQHJldHVybnNcclxuICovXHJcbiBleHBvcnQgY29uc3QgYXR0ciA9IChhdHRyTmFtZTogRXh0ZW5kZWQ8c3RyaW5nPiwgdHlwZU9yVW5pdD86IEV4dGVuZGVkPEF0dHJUeXBlS2V5d29yZCB8IEF0dHJVbml0S2V5d29yZD4sXHJcblx0ZmFsbGJhY2s/OiBFeHRlbmRlZDxzdHJpbmc+KTogSVN0cmluZ1Byb3h5ID0+XHJcbiAgICAoKSA9PiBgYXR0cigke212MnMoIFttdjJzKCBbYXR0ck5hbWUsIHR5cGVPclVuaXRdKSwgZmFsbGJhY2tdLCBcIixcIil9KWA7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIENTUyBgY291bnRlcigpYCBmdW5jdGlvbiB3aXRoIGFuIG9wdGlvbmFsIGNvdW50ZXIgc3R5bGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjIENvdW50ZXIgbmFtZSBvciBjb3VudGVyIHJ1bGUgb2JqZWN0XHJcbiAqIEByZXR1cm5zIElDb3VudGVyRnVuYyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgY291bnRlcigpYCBDU1MgZnVuY3Rpb25cclxuICovXHJcbiBleHBvcnQgY29uc3QgY291bnRlciA9IChjb3VudGVyT2JqOiBFeHRlbmRlZDxJQ291bnRlclJ1bGUgfCBzdHJpbmc+LFxyXG5cdHN0eWxlPzogRXh0ZW5kZWQ8TGlzdFN0eWxlVHlwZV9TdHlsZVR5cGU+KTogSVN0cmluZ1Byb3h5ID0+XHJcbiAgICAoKSA9PiBmMnMoIFwiY291bnRlclwiLCBbY291bnRlck9iaiwgc3R5bGVdKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ1NTIGBjb3VudGVycygpYCBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBzZXBhcmF0b3IgYW5kXHJcbiAqIGFuIG9wdGlvbmFsIGNvdW50ZXIgc3R5bGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb3VudGVyT2JqIENvdW50ZXIgbmFtZSBvciBjb3VudGVyIHJ1bGUgb2JqZWN0XHJcbiAqIEBwYXJhbSBzZXAgU2VwYXJhdG9yIHN0cmluZyBiZXR3ZWVuIG11bHRpcGxlIGNvdW50ZXJzXHJcbiAqIEBwYXJhbSBzdHlsZSBDb3VudGVyIHN0eWxlXHJcbiAqIEByZXR1cm5zIElDb3VudGVyRnVuYyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgY291bnRlcigpYCBDU1MgZnVuY3Rpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBjb3VudGVycyA9IChjb3VudGVyT2JqOiBFeHRlbmRlZDxJQ291bnRlclJ1bGUgfCBzdHJpbmc+LFxyXG5cdHNlcDogRXh0ZW5kZWQ8c3RyaW5nPiwgc3R5bGU/OiBFeHRlbmRlZDxMaXN0U3R5bGVUeXBlX1N0eWxlVHlwZT4pOiBJU3RyaW5nUHJveHkgPT5cclxuICAgICgpID0+IGYycyggXCJjb3VudGVyc1wiLCBbY291bnRlck9iaiwgW3NlcCwgV0tGLlF1b3RlZF0sIHN0eWxlXSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBgdmFyKClgIENTUyBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIGN1c3RvbVxyXG4gKiBDU1MgcHJvcGVydHkgd2l0aCBvcHRpb25hbCBmYWxsYmFja3MuIFVzdWFsbHksIHdoZW4geW91IHdhbnQgdG8gcmVmZXIgdG8gYSBjdXN0b20gQ1NTIHByb3BlcnR5XHJcbiAqIGluIHN0eWxlIHJ1bGVzLCBpdCBpcyBlbm91Z2ggdG8ganVzdCByZWZlciB0byB0aGUgc3R5bGUgZGVmaW5pdGlvbiBwcm9wZXJ0eSBjcmVhdGVkIHVzaW5nIHRoZVxyXG4gKiBbWyR2YXJdXSBmdW5jdGlvbjsgaG93ZXZlciwgaWYgeW91IHdhbnQgdG8gcHJvdmlkZSBhIGZhbGxiYWNrIHZhbHVlLCB5b3UgbXVzdCB1c2UgdGhpcyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBTdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gY3JlYXRlIGN1c3RvbSBDU1MgcHJvcGVydHkgYnV0IHdpdGhvdXQgYW4gYXNzaWduZWQgdmFsdWU7IGl0IGNhbiBiZSBhc3NpZ25lZFxyXG4gKiAgICAgLy8gbGF0ZXIgcHJvZ3JhbW1hdGljYWxseVxyXG4gKiAgICAgYmdDb2xvciA9IHRoaXMuJHZhciggXCJjb2xvclwiKVxyXG4gKlxyXG4gKiAgICAgZGl2ID0gdGhpcy4kdGFnKCBcImRpdlwiLCB7XHJcbiAqICAgICAgICAgLy8gdXNlIHRoZSBjdXN0b20gQ1NTIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGZhbGxiYWNrIHZhbHVlXHJcbiAqICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjc3MudXNldmFyKCB0aGlzLmJnQ29sb3IsIFwiYmVpZ2VcIilcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gSyBLZXkgb2YgdGhlIFtbSVZhclRlbXBsYXRlU3R5bGVzZXRdXSBpbnRlcmZhY2UgdGhhdCBkZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRoZVxyXG4gKiBjdXN0b20gQ1NTIHByb3BlcnR5IGFuZCBvZiB0aGUgZmFsbGJhY2sgdmFsdWUuXHJcbiAqIEBwYXJhbSB2YXJPYmogQ3VzdG9tIENTUyBwcm9wZXJ0eSBvYmplY3QgY3JlYXRlZCB1c2luZyB0aGUgW1skdmFyXV0gZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCBpZiB0aGUgY3VzdG9tIENTUyBwcm9wZXJ0eSBpc250IHNldC5cclxuICogQHJldHVybnMgVGhlIGBJUmF3UHJveHlgIGNhbGxhYmxlIGludGVyZmFjZSwgd2hjaWggYWxsb3dzIHRoZSBgdXNldmFyYCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICogaW4gYW55IGNvbnRleHQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXNldmFyID0gPEsgZXh0ZW5kcyBWYXJUZW1wbGF0ZU5hbWU+KCB2YXJPYmo6IElWYXJSdWxlPEs+LCBmYWxsYmFjaz86IEV4dGVuZGVkVmFyVmFsdWU8Sz4pOiBJUmF3UHJveHkgPT5cclxuICAgICgpID0+IGYycyggXCJ2YXJcIiwgW3Zhck9iai5jc3NWYXJOYW1lLCBzcDJzKCB2YXJPYmoudGVtcGxhdGUsIGZhbGxiYWNrKV0pO1xyXG5cclxuXHJcblxyXG4iLCLvu78vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQmFzaWMgdHlwZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuaW1wb3J0IHtJSURSdWxlLCBJTmFtZXNwYWNlUnVsZX0gZnJvbSBcIi4vUnVsZVR5cGVzXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTdHlsZSB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYW55IENTUyBwcm9wZXJ0eS5cclxuICovXHJcbmV4cG9ydCB0eXBlIEdsb2JhbF9TdHlsZVR5cGUgPSBcImluaGVyaXRcIiB8IFwiaW5pdGlhbFwiIHwgXCJ1bnNldFwiIHwgXCJyZXZlcnRcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJR2VuZXJpY1Byb3h5IGludGVyZmFjZSByZXByZXNlbnRzIGEgY2FsbGFibGUgaW50ZXJmYWNlIGltcGxlbWVudGVkIGJ5IGZ1bmN0aW9ucyB0aGF0XHJcbiAqIGFjY2VwdCBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgb2YgYSBnZW5lcmljIHR5cGUgYW5kIHJldHVybiBhIHN0cmluZy4gVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCBhcyBhXHJcbiAqIGJhc2UgZm9yIHByb3h5IGludGVyZmFjZXMgZGVmaW5pbmcgdHlwZXMgYWNjZXB0YWJsZSBieSBjZXJ0YWluIHN0eWxlIHByb3BlcnRpZXMuIFRoZSB0eXBlXHJcbiAqIHBhcmFtZXRlciBoZWxwcyBkaWZmZXJlbnRpYXRlIHRoZXNlIGludGVyZmFjZXMgc28gdGhhdCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gb25lXHJcbiAqIHR5cGUgb2Ygc3R5bGUgcHJvcGVydGllcyAoZS5nLiBgdHJhbnNmb3JtYCkgY2Fubm90IGJlIGFzc2lnbmVkIHRvIGFuIGluY29tcGF0aWJsZSBzdHlsZSBwcm9wZXJ0eVxyXG4gKiAoZS5nLiBgZmlsdGVyYCkuXHJcbiAqXHJcbiAqIERldmVsb3BlcnMgZG9uJ3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlIGRpcmVjdGx5OyBpbnN0ZWFkLCB0aGUgaW50ZXJmYWNlcyBkZXJpdmVkIGZyb20gdGhpc1xyXG4gKiBpbnRlcmZhY2UgYXJlIGltcGxlbWVudGVkIGJ5IGRpZmZlcmVudCBNaW1jc3MgZnVuY3Rpb25zLiBGb3IgZXhhbXBsZSwgW1tJUmF3UHJveHldXSBpbnRlcmZhY2VcclxuICogaXMgaW1wbGVtZW50ZWQgYnkgdGhlIFtbcmF3XV0gZnVuY3Rpb24sIFtbSVN0cmluZ1Byb3h5XV0gaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHRoZVxyXG4gKiBbW2F0dHJdXSwgW1tjb3VudGVyXV0gYW5kIFtbY291bnRlcnNdXSBmdW5jdGlvbnMsIGFuZCBzbyBvbi5cclxuICpcclxuICogQHR5cGVQYXJhbSBUIFN0cmluZyBjb25zdGFudCB0aGF0IGlzIHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHByb3hpZXMgdXNlZCBmb3IgZGlmZmVyZW50XHJcbiAqIHB1cnBvc2VzLiBUaGUgcGFyYW1ldGVyIGBwYCBvZiB0aGlzIGNhbGxhYmxlIGludGVyZmFjZSBpcyBvZiB0eXBlIFQgYnV0IGl0IGlzIG5vdCB1c2VkXHJcbiAqIGluIGFueSB3YXkuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElHZW5lcmljUHJveHk8VCBleHRlbmRzIHN0cmluZyA9IGFueT5cclxue1xyXG4gICAgKHA/OiBUKTogc3RyaW5nO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgSUNzc0Z1bmNPYmplY3QgaW50ZXJmYWNlIGlzIGEgYmFzZSBmb3IgYWxsIGludGVyZmFjZXMgcmVwcmVzZW50aW5nIG9iamVjdHMgdGhhdCBkZXNjcmliZVxyXG4gKiBjYWxscyB0byBhIENTUyBmdW5jdGlvbi4gRXZlcnkgc3VjaCBpbnRlcmZhY2UgZ2l2ZXMgYSB1bmlxdWUgdmFsdWUgKG9yIGEgdW5pcXVlIHNldCBvZiB2YWx1ZXMpXHJcbiAqIHRvIHRoZSBgZm5gIG1lbWJlci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNzc0Z1bmNPYmplY3Rcclxue1xyXG4gICAgZm46IHN0cmluZztcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBJUmF3UHJveHlgIGludGVyZmFjZSByZXByZXNlbnRzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nLCB3aGljaCBpcyByZWFkeSB0byBiZVxyXG4gKiB1c2VkIGluIENTUyBydWxlcy4gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHR5cGUgZGVmaW5pdGlvbiBmb3IgYWxsIENTUyBwcm9wZXJ0aWVzIC0gZXZlbiBmb3JcclxuICogdGhvc2UgdGhhdCBkb24ndCBoYXZlIGBzdHJpbmdgIGFzIHBhcnQgb2YgdGhlaXIgdHlwZS5cclxuICpcclxuICogQWxsIENTUyBwcm9wZXJ0aWVzIHNob3VsZCBhY2NlcHQgc3RyaW5nIGFzIHRoZSB0eXBlIG9mIHRoZWlyIHZhbHVlIGV2ZW4gaWYgbm9ybWFsbHlcclxuICogdGhleSBhY2NlcHQgb3RoZXIgdHlwZXMgKGUuZyBhIHNldCBvZiBzdHJpbmcgbGl0ZXJhbHMgYXMgYFwicmVkXCIgfCBcImdyZWVuXCIgfCAuLi5gIGZvciB0aGVcclxuICogY29sb3IpIHByb3BlcnR5LiBUaGlzIGlzIGJlY2F1c2UgaW4gYWRkaXRpb24gdG8gdGhlaXIgbm9ybWFsIHZhbHVlcyBhbnkgcHJvcGVydHlcclxuICogY2FuIHVzZSBjdXN0b20gQ1NTIHByb3BlcnR5IGluIHRoZSBmb3JtIGB2YXIoLS1wcm9wbmFtZSlgLiBIb3dldmVyLCBpZiB3ZSBhZGQgc3RyaW5nIHR5cGVcclxuICogdG8gdGhlIHNldCBvZiBzdHJpbmcgbGl0ZXJhbHMgKGUuZy4gYFwicmVkXCIgfCBcImdyZWVuXCIgfCBzdHJpbmdgKSwgdGhpcyB0aHJvd3Mgb2ZmIHRoZVxyXG4gKiBJbnRlbGxpc2Vuc2UgYW5kIGl0IGRvZXNuJ3QgcHJvbXB0IGRldmVsb3BlcnMgZm9yIHRoZSBwb3NzaWJsZSB2YWx1ZXMuIFRoZSBgSVJhd1Byb3h5YFxyXG4gKiBpbnRlcmZhY2UgaXMgdXNlZCBpbnN0ZWFkIG9mIHN0cmluZyBhbmQgdGhpcyBzb2x2ZXMgdGhlIEludGVsbGlzZW5zZSBpc3N1ZS5cclxuICpcclxuICogSW4gYWRkaXRpb24sIHNvbWV0aW1lcyBpdCBjYW4gYmUgZWFzaWVyIGZvciB0aGUgZGV2ZWxvcGVycyB0byBzcGVjaWZ5IGFuIGFscmVhZHkgcHJlLWZvcm1hdHRlZFxyXG4gKiBDU1Mgc3RyaW5nIGFzIHByb3BlcnR5IHZhbHVlIC0gbWF5YmUgYmVjYXVzZSBpdCBpcyBvYnRhaW5lZCBmcm9tIHNvbWUgZXh0ZXJuYWwgc291cmNlLiBUaGVcclxuICogYElSYXdQcm94eWAgY2FsbGFiY2xlIGludGVyZmFjZSBpcyByZXR1cm5lZCBmcm9tIHRoZSBbW3Jhd11dIGZ1bmN0aW9uLCB3aGljaCBhbGxvd3MgYnktcGFzc2luZ1xyXG4gKiB0aGUgcHJvcGVydHkgdHlwaW5nIHJ1bGVzIGFuZCBzcGVjaWZ5aW5nIGEgc3RyaW5nIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBEZXZlbG9wZXJzIGNhbiBjcmVhdGUgdGhlaXIgb3duIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGlzIGNhbGxhYmxlIGludGVyZmFjZSBhbmQgdGhlbiBpbnZva2VcclxuICogdGhlc2UgZnVuY3Rpb25zIHRvIGFzc2lnbiB2YWx1ZXMgdG8gc3R5bGUgcHJvcGVydGllcy4gSnVzdCBtYWtlIHN1cmUgdGhhdCB0aGUgcmV0dXJuZWQgc3RyaW5nXHJcbiAqIGlzIHRoZSBjb3JyZWN0IENTUyBzdHJpbmcuIE1pbWNzcyB3aWxsIHVzZSB0aGUgc3RyaW5nIHJldHVybmVkIGZyb20gY3VzdG9tIGZ1bmN0aW9ucyB3aXRob3V0XHJcbiAqIGNoZWNraW5nIGl0cyBjb3JyZWN0bmVzcy4gSWYgdGhlIHN0cmluZyBpcyBpbnZhbGlkIGZvciB0aGUgcHJvcGVydHkgaXQgaXMgYXNzaWduZWQgdG8sIHRoZVxyXG4gKiByZXN1bHRpbmcgQ1NTIHJ1bGUgd2lsbCBub3QgaGF2ZSB0aGF0IHByb3BlcnR5LlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIHVzaW5nIGByYXdgIGZ1bmN0aW9uXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3MoeyBib3JkZXI6IGNzcy5yYXdgMXB4IHNvbGlkIGJyb3duYCB9KVxyXG4gKlxyXG4gKiAgICAgLy8gdXNpbmcgY3VzdG9tIGZ1bmN0aW9uXHJcbiAqICAgICBjbHMyID0gdGhpcy4kY2xhc3MoeyBjbGlwLXBhdGg6IHJhbmRvbUNpcmNsZSgpfSlcclxuICogfVxyXG4gKlxyXG4gKiAvLyBjcmVhdGUgQ1NTIGNpcmNsZSBmdW5jdGlvbiB3aXRoIHJhbmRvbSByYWRpdXMgYmV0d2VlbiAzMCBhbmQgNTAgcGl4ZWxzXHJcbiAqIGZ1bmN0aW9uIHJhbmRvbUNpcmNsZSgpOiBjc3MuSVJhd1Byb3h5XHJcbiAqIHtcclxuICogICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmdcclxuICogICAgIHJldHVybiAoKSA9PiBgY2lyY2xlKCR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjEpICsgMzB9KWA7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElSYXdQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJyYXdcIj4ge31cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjYWxsYWJsZSBpbnRlcmZhY2UgdGhhdCBpcyByZXR1cm5lZCBieSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiBzdHJpbmdcclxuICogY29udGV4dCwgc3VjaCBhcyBbW2F0dHJdXSBhbmQgW1tjb3VudGVyXV0uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTdHJpbmdQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJzdHJpbmdcIj4ge31cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGA8c3RyaW5nPmAgQ1NTIHR5cGUsIHdoaWNoIGlzIGVpdGhlciBhIHF1YXRlZCBzdHJpbmcgb3IgZnVuY3Rpb25zIHRoYXQgY2FuIGJlXHJcbiAqIHVzZWQgaW4gc3RyaW5nIGNvbnRleHQsIHN1Y2ggYXMgYGF0dHIoKWAgYW5kIGBjb3VudGVyKClgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDc3NTdHJpbmcgPSBzdHJpbmcgfCBJU3RyaW5nUHJveHk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYElDdXN0b21WYXJgIGludGVyZmFjZSByZXByZXNlbnRzIGEgY3VzdG9tIHByb3BlcnR5IHdpdGggdmFsdWVzIG9mIHRoZSBnaXZlbiB0eXBlLiBFdmVyeVxyXG4gKiBzdHlsZSBwcm9wZXJ0eSBjYW4gYWNjZXB0IGEgY3VzdG9tIENTUyBwcm9wZXJ0eSB2YWx1ZSBpbiB0aGUgZm9ybSBvZiB0aGUgYHZhcigpYCBDU1NcclxuICogZnVuY3Rpb24uIE1pbWNzcyBhbHNvIGFsbG93cyBkZWZpbmluZyBcImNvbnN0YW50c1wiLCB3aGljaCBhcmUgYSBtb3JlIGxpZ2h0d2VpZ2h0IHdheSB0byBwcm92aWRlXHJcbiAqIHZhbHVlcyB0aGF0IGFyZSB1c2VkIGluIG90aGVyIHJ1bGVzIGFuZCBwcm9wZXJ0aWVzLiBTZWUgdGhlIFtbSUNvbnN0YW50XV0gaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBUaGUgYElDdXN0b21WYXJgIGludGVyZmFjZSBpcyBleHRlbmRlZCBieSB0aGUgW1tJVmFyUnVsZV1dIGludGVyZmFjZSB0aGF0IGlzIHJldHVybmVkXHJcbiAqIGZyb20gdGhlIFtbJHZhcl1dIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFQgQmFzaWMgdHlwZSBvZiB0aGUgdmFsdWUgb2YgdGhlIGN1c3RvbSBDU1MgdmFyaWFibGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElDdXN0b21WYXI8VCA9IGFueT5cclxue1xyXG4gICAgLyoqXHJcblx0ICogU2V0cyBuZXcgdmFsdWUgb2YgdGhpcyBjdXN0b20gQ1NTIHByb3BlcnR5IGF0IHRoZSBnbG9iYWwgbGV2ZWw7IHRoYXQgaXMsIHVuZGVyIGA6cm9vdGAuIFRvXHJcbiAgICAgKiBzZXQgYSB2YWx1ZSBvZiB0aGUgQ1NTIGN1c3RvbSBwcm9wZXJ0eSB1bmRlciBhIGNlcnRhaW4gQ1NTIHJ1bGUsIHVzZSB0aGVcclxuICAgICAqIFtbSVN0eWxlUnVsZS5zZXRDdXN0b21Qcm9wXV0gbWV0aG9kLlxyXG5cdCAqIEBwYXJhbSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRoZSBDU1MgcHJvcGVydHkuXHJcblx0ICogQHBhcmFtIHNjaGVkdWxlclR5cGUgSUQgb2YgYSByZWdpc3RlcmVkIHNjaGVkdWxlciB0eXBlIHRoYXQgaXMgdXNlZCB0byB3cml0ZSB0aGUgcHJvcGVydHlcclxuXHQgKiB2YWx1ZSB0byB0aGUgRE9NLiBJZiB1bmRlZmluZWQsIHRoZSBjdXJyZW50IGRlZmF1bHQgc2NoZWR1bGVyIHdpbGwgYmUgdXNlZC5cclxuXHQgKi9cclxuXHRzZXRWYWx1ZSggdmFsdWU6IEV4dGVuZGVkUHJvcDxUPiwgc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQ7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgSUNvbnN0YW50YCBpbnRlcmZhY2UgcmVwcmVzZW50cyBhIGNvbnN0YW50IHdpdGggdmFsdWVzIG9mIHRoZSBnaXZlbiB0eXBlLiBNaW1jc3MgYWxsb3dzXHJcbiAqIGRlZmluaW5nIFwiY29uc3RhbnRzXCIsIHdoaWNoIGFyZSBhIGxpZ2h0d2VpZ2h0IHdheSAoY29tcGFyZWQgdG8gY3VzdG9tIENTUyBwcm9wZXJ0aWVzKSB0byBwcm92aWRlXHJcbiAqIHZhbHVlcyB0aGF0IGFyZSB1c2VkIGluIG90aGVyIHJ1bGVzIGFuZCBwcm9wZXJ0aWVzLiBFdmVyeSBzdHlsZSBwcm9wZXJ0eSBjYW4gYWNjZXB0IGEgY29uc3RhbnRcclxuICogdmFsdWUuXHJcbiAqXHJcbiAqIFRoZSBgSUNvbnN0YW50YCBpbnRlcmZhY2UgaXMgZXh0ZW5kZWQgYnkgdGhlIFtbSUNvbnN0UnVsZV1dIGludGVyZmFjZSB0aGF0IGlzIHJldHVybmVkIGZyb20gdGhlXHJcbiAqIFtbJGNvbnN0XV0gZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVCBCYXNpYyB0eXBlIG9mIHRoZSB2YWx1ZSBvZiB0aGUgY29uc3RhbnQuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElDb25zdGFudDxUID0gYW55PlxyXG57XHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbnN0YW50LlxyXG5cdCAqL1xyXG5cdGdldFZhbHVlKCk6IEV4dGVuZGVkUHJvcDxUPjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSB0aGF0IGV4dGVuZHMgdGhlIGdpdmVuIHR5cGUgd2l0aCB0aGUgZm9sbG93aW5nIHR5cGVzOlxyXG4gKiAtIFtbSUN1c3RvbVZhcl1dIGludGVyZmFjZSB0aGF0IGFsbG93cyB1c2luZyBhIENTUyBjdXN0b20gcHJvcGVydHkgcnVsZSB2YWx1ZS5cclxuICogLSBbW0lDb25zdGFudF1dIGludGVyZmFjZSB0aGF0IGFsbG93cyB1c2luZyBhIGNvbnN0YW50IHJ1bGUgdmFsdWUuXHJcbiAqIC0gW1tJUmF3UHJveHldXSBpbnRlcmZhY2UgdGhhdCBhbGxvd3Mgc3BlY2lmeWluZyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHJhdyBzdHJpbmcgdmFsdWUuXHJcbiAqXHJcbiAqIERldmVsb3BlcnMgZG9uJ3QgdXN1YWxseSB1c2UgdGhpcyB0eXBlIGRpcmVjdGx5IC0gaXQgaXMgdXNlZCBieSBNaW1jc3MgdG8gZGVmaW5lIHN0eWxlIHByb3BlcnR5XHJcbiAqIHR5cGVzIGFzIHdlbGwgYXMgZnVuY3Rpb24gcGFyYW1ldGVyIHR5cGVzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRXh0ZW5kZWQ8VD4gPSBUIHwgSUN1c3RvbVZhcjxUPiB8IElDb25zdGFudDxUPiB8IElSYXdQcm94eSB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIHRoYXQgZW5jYXBzdWxhdGVzIHRoZSB0eXBlIG9mIHByb3BlcnR5IGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIFwiIVwiIHByb3BlcnR5LiBUaGlzXHJcbiAqIHR5cGUgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBwcm9wZXJ0eSB2YWx1ZSBtdXN0IGJlIGZsYWdnZWQgYXMgXCIhaW1wb3J0YW50XCIuXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBTdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gcHJvZHVjZXMgQ1NTOiAuY2xzMSB7IGNvbG9yOiByZWQ7IGJhY2tncm91bmQtY29sb3I6IGJlaWdlICFpbXBvcnRhbnQ7IH1cclxuICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7XHJcbiAqICAgICAgICAgY29sb3I6IFwicmVkXCIsXHJcbiAqICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7IFwiIVwiOiBcImJlaWdlXCIgfVxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB0eXBlIEltcG9ydGFudFByb3A8VD4gPSB7IFwiIVwiOiBFeHRlbmRlZDxUPiB8IEdsb2JhbF9TdHlsZVR5cGUgfTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgdGhhdCBhbGxvd3Mgc3BlY2lmeWluZyBtdWx0aXBsZSB2YWx1ZXMgb2YgYSBnaXZlbiB0eXBlIHVzaW5nIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIFwiW11cIlxyXG4gKiBwcm9wZXJ0eS4gVGhpcyB0eXBlIGlzIHVzZWQgdG8gaW5jbHVkZSBtdWx0aXBsZSBvY2N1cnJlbmNpZXMgb2YgdGhlIHNhbWUgc3R5bGUgcHJvcGVydHkgaW4gYVxyXG4gKiBzdHlsZXNldC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0YXJnZXRpbmcgYWR2YW5jZWQgZmVhdHVyZXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzIGFuZFxyXG4gKiBwcm92aWRpbmcgYSBmYWxsYmFjaywgd2hpY2ggaXMgc3VwcG9ydGVkIGV2ZXJ5d2hlcmUuXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBTdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IHtcIltdXCI6IFtcclxuICogICAgICAgICAgICAgLy8gZmlyc3QsIHNwZWNpZnkgYSBzdGF0aWMgaW1hZ2UgKHN1cHBvcnRlZCBldmVyeXdoZXJlKVxyXG4gKiAgICAgICAgICAgICB1cmwoXCJpbWFnZS5wbmdcIiksXHJcbiAqICAgICAgICAgICAgIC8vIHNlY29uZCwgdXNlIHBhaW50IHdvcmtsZXQgKG5vdCBzdXBwb3J0ZWQgZXZlcnl3aGVyZSB5ZXQpXHJcbiAqICAgICAgICAgICAgIHBhaW50KFwibXlQYWludFdvcmtsZXRcIiksXHJcbiAqICAgICAgICAgXX1cclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBwcm9kdWNlIHRoZSBmb2xsb3dpbmcgQ1NTOlxyXG4gKlxyXG4gKiBgYGBjc3NcclxuICogLmNsczEge1xyXG4gKiAgICAgYmFja2dyb3VuZEltYWdlOiB1cmwoXCJpbWFnZS5wbmdcIik7XHJcbiAqICAgICBiYWNrZ3JvdW5kSW1hZ2U6IHBhaW50KFwibXlQYWludFdvcmtsZXRcIik7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBNdWx0aVByb3A8VD4gPSB7IFwiW11cIjogKEV4dGVuZGVkPFQ+IHwgSW1wb3J0YW50UHJvcDxUPiB8IEdsb2JhbF9TdHlsZVR5cGUpW10gfTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBFeHRlbmRlZFByb3AgZXh0ZW5kcyB0aGUgZ2l2ZW4gZ2VuZXJpYyB0eXBlIHdpdGggdGhlIGZvbGxvd2luZyBlbGVtZW50czpcclxuICogLSBbW0lDdXN0b21WYXJdXSBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdXNpbmcgYSBDU1MgY3VzdG9tIHByb3BlcnR5IHJ1bGUgdmFsdWUuXHJcbiAqIC0gW1tJQ29uc3RhbnRdXSBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdXNpbmcgYSBjb25zdGFudCBydWxlIHZhbHVlLlxyXG4gKiAtIFtbSVJhd1Byb3h5XV0gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHNwZWNpZnlpbmcgcmF3IHN0cmluZyB2YWx1ZS5cclxuICogLSBPYmplY3Qgd2l0aCBhIHNpbmdsZSBwcm9wZXJ0eSBcIiFcIiwgd2hpY2ggaXMgdXNlZCB0byBtYXJrIGEgcHJvcGVydHkgYXMgXCIhaW1wb3J0YW50XCIuXHJcbiAqIC0gW1tHbG9iYWxfU3R5bGVUeXBlXV0sIHdoaWNoIGFsbG93cyBhbnkgcHJvcGVydHkgdG8gYmUgYXNzaWduZWQgdGhlIGdsb2JhbCB2YWx1ZXMgc3VjaCBhc1xyXG4gKiAgIFwiaW5pdGlhbFwiLCBcImluaGVyaXRcIiwgXCJ1bnNldFwiIGFuZCBcInJldmVydFwiLlxyXG4gKlxyXG4gKiAgRGV2ZWxvcGVycyBkb24ndCB1c3VhbGx5IHVzZSB0aGlzIHR5cGUgZGlyZWN0bHkgLSBpdCBpcyB1c2VkIGJ5IE1pbWNzcyB0byBkZWZpbmUgdHlwZXNcclxuICogb2YgcHJvcGVydGllcyBpbiB0aGUgW1tTdHlsZXNldF1dIGludGVyZmFjZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIEV4dGVuZGVkUHJvcDxUPiA9IEV4dGVuZGVkPFQ+IHwgSW1wb3J0YW50UHJvcDxUPiB8IE11bHRpUHJvcDxUPiB8IEdsb2JhbF9TdHlsZVR5cGU7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBVdGlsaXR5IHR5cGVzLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUeXBlIGZvciBwYWlyLWxpa2UgcHJvcGVydGllcyB0aGF0IGNhbiBoYXZlIDEgb3IgMiB2YWx1ZXMgb2YgdGhlIGdpdmVuIHR5cGUuIFRoaXMgdHlwZSBpcyB1c2VkXHJcbiAqIGZvciBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIHNwZWNpZnkgdmFsdWVzIGZvciB0d28gZGltZW5zaW9ucyAoeCBhbmQgeSksIGJ1dCBhbHNvIGFsbG93IGZvciBhXHJcbiAqIHNpbmdsZSB2YWx1ZSwgaW4gd2hpY2ggY2FzZSBpdCBhcHBsaWVzIHRvIGJvdGggZGltZW5zaW9ucy4gRm9yIGV4YW1wbGUsIGl0IGlzIHVzZWQgYnkgc3R5bGVcclxuICogcHJvcGVydGllcyBzdWNoIGFzIGBvdmVyZmxvd2AsIGBib3JkZXItcmFkaXVzYCwgYGJhY2tncm91bmQtcmVwZWF0YCBhbmQgb3RoZXJzLlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFQgVHlwZSBvZiB0aGUgdmFsdWVzXHJcbiAqXHJcbiAqICoqRXhhbXBsZXM6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gc2luZ2xlIHZhbHVlXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3MoeyBvdmVyZmxvdzogXCJhdXRvXCIgfSlcclxuXHJcbiAqICAgICAvLyB0d28gdmFsdWVzXHJcbiAqICAgICBjbHMyID0gdGhpcy4kY2xhc3MoeyBvdmVyZmxvdzogW1wic2Nyb2xsXCIsIFwiaGlkZGVuXCJdIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBPbmVPclBhaXI8VD4gPSBUIHwgW0V4dGVuZGVkPFQ+LCBFeHRlbmRlZDxUPj9dO1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgZm9yIGJveC1saWtlIHByb3BlcnRpZXMgdGhhdCBjYW4gaGF2ZSAxIHRvIDQgdmFsdWVzIG9mIHRoZSBnaXZlbiB0eXBlLiBUaGlzIHR5cGUgaXMgdXNlZFxyXG4gKiBmb3Igc3R5bGUgcHJvcGVydGllcyB0aGF0IHNwZWNpZnkgdmFsdWVzIGZvciB0aGUgZm91ciBzaWRlcyBvZiBhbiBlbGVtZW50IGJveCBhbmQgaGF2ZSBydWxlcyBob3dcclxuICogc3BlY2lmeWluZyAxLCAyIG9yIDMgdmFsdWVzIGRldGVybWluZSB0aGUgdmFsdWVzIGFwcGxpZWQgdG8gYWxsIGZvdXIgc2lkZXMuIEZvciBleGFtcGxlLCBpdCBpc1xyXG4gKiB1c2VkIGJ5IHN0eWxlIHByb3BlcnRpZXMgc3VjaCBhcyBgbWFyZ2luYCwgYHBhZGRpbmdgLCBgYm9yZGVyLWNvbG9yYCBhbmQgb3RoZXJzLlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFQgVHlwZSBvZiB0aGUgdmFsdWVzXHJcbiAqXHJcbiAqICoqRXhhbXBsZXM6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gc2luZ2xlIHZhbHVlXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3MoeyBtYXJnaW46IDQgfSlcclxuICpcclxuICogICAgIC8vIHR3byB2YWx1ZXNcclxuICogICAgIGNsczIgPSB0aGlzLiRjbGFzcyh7IG1hcmdpbjogWzAsIDhdIH0pXHJcbiAqXHJcbiAqICAgICAvLyB0aHJlZSB2YWx1ZXNcclxuICogICAgIGNsczMgPSB0aGlzLiRjbGFzcyh7IG1hcmdpbjogWzYsIDYsIDhdIH0pXHJcbiAqXHJcbiAqICAgICAvLyBmb3VyIHZhbHVlc1xyXG4gKiAgICAgY2xzNCA9IHRoaXMuJGNsYXNzKHsgbWFyZ2luOiBbNCwgNiwgOCwgMTJdIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBPbmVPckJveDxUPiA9IFQgfCBbRXh0ZW5kZWQ8VD4sIEV4dGVuZGVkPFQ+PywgRXh0ZW5kZWQ8VD4/LCBFeHRlbmRlZDxUPj9dO1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgZm9yIHByb3BlcnRpZXMgdGhhdCBjYW4gaGF2ZSAxIG9yIG1vcmUgdmFsdWVzIG9mIHRoZSBnaXZlbiB0eXBlLiBJdCBpcyB1c2VkIGJ5IG1hbnkgc3R5bGVcclxuICogcHJvcGVydGllcyBzdWNoIGFzIGBhbmltYXRpb25gIGFuZCBhbGwgaXRzIGxvbmdoYW5kcywgYGJhY2tncm91bmRgIGFuZCBhbGwgaXRzIGxvbmdoYW5kcyxcclxuICogYHRyYW5zaXRpb25gIGFuZCBhbGwgaXRzIGxvbmdoYW5kcywgYGJveC1zaGFkb3dgLCBgdHJhbnNmb3JtYCwgYGZpbHRlcmAgYW5kIG90aGVycy5cclxuICpcclxuICogQHR5cGVwYXJhbSBUIFR5cGUgb2YgdGhlIHZhbHVlc1xyXG4gKlxyXG4gKiAqKkV4YW1wbGVzOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIHNpbmdsZSB2YWx1ZVxyXG4gKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHsgdHJhbnNmb3JtOiBzY2FsZSgwLjUpIH0pXHJcbiAqXHJcbiAqICAgICAvLyBzZXZlcmFsIHZhbHVlc1xyXG4gKiAgICAgY2xzMiA9IHRoaXMuJGNsYXNzKHsgdHJhbnNmb3JtOiBbc2NhbGUoMC41LCByb3RhdGUoOTApLCB0cmFuc2xhdGVYKDIwMCkpXSB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgT25lT3JNYW55PFQ+ID0gVCB8IEV4dGVuZGVkPFQ+W107XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBTZWxlY3RvcnNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogVHlwZSB0aGF0IGNvbWJpbmVzIG5hbWVzIG9mIGFsbCBIVE1MIGFuZCBTVkcgdGFnc1xyXG4gKi9cclxuIGV4cG9ydCB0eXBlIEVsZW1lbnRUYWdOYW1lID0gKGtleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcCkgfCAoa2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXApIHwgXCIqXCI7XHJcblxyXG5cclxuXHJcbiAvKipcclxuICogVGhlIGBJUnVsZVdpdGhTZWxlY3RvcmAgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gZW50aXR5IHRoYXQgaGFzIGEgc2VsZWN0b3Igc3RyaW5nLiBUaGVzZSBpbmNsdWRlXHJcbiAqIGFsbCBzdHlsZSBydWxlcyAoW1tJU3R5bGVSdWxlXV0gaW50ZXJmYWNlKSBhbmQgY2xhc3MgbmFtZSBydWxlIChbW0lDbGFzc05hbWVSdWxlXV0gaW50ZXJmYWNlKS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVJ1bGVXaXRoU2VsZWN0b3Jcclxue1xyXG4gICAgLyoqIENTUyBydWxlIHNlbGVjdG9yIHN0cmluZyAqL1xyXG4gICAgcmVhZG9ubHkgc2VsZWN0b3JUZXh0OiBzdHJpbmc7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgSVNlbGVjdG9yUHJveHlgIGZ1bmN0aW9uIHJldHVybnMgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nLiBUaGlzIHR5cGUgaXMgcmV0dXJuZWQgZnJvbSB0aGVcclxuICogW1tzZWxlY3Rvcl1dIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJU2VsZWN0b3JQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJzZWxlY3RvclwiPiB7fTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIENTUyBzZWxlY3RvciBjb21iaW5hdG9ycyB1c2VkIHdoZW4gY3JlYXRpbmcgY29tcGxleCBDU1Mgc2VsZWN0b3JzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU2VsZWN0b3JDb21iaW5hdG9yID0gXCIsXCIgfCBcIiBcIiB8IFwiPlwiIHwgXCIrXCIgfCBcIn5cIiB8IFwifHxcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgW1tDb21iaW5lZFN0eWxlc2V0XV0gd2hpY2ggYXJlIHVzZWQgdG8gZGVmaW5lIGRlcGVuZGVudCBydWxlcy5cclxuICogUHJvcGVydHkgdmFsdWVzIGFyZSBkZWZpbmVkIGFzIGFycmF5cyBvZiB0d28tZWxlbWVudCB0dXBsZXMgZWFjaCBkZWZpbmluZyBhIHNlbGVjdG9yIGFuZCBhXHJcbiAqIHN0eWxlc2V0IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBzZWxlY3Rvci4gU2VsZWN0b3JzIGNhbiB1c2UgdGhlIGFtcGVyc2FuZCBzeW1ib2wgdG8gcmVmZXIgdG8gdGhlXHJcbiAqIHBhcmVudCBzdHlsZSBzZWxlY3Rvci4gSWYgdGhlIGFtcGVyc2FuZCBzeW1ib2wgaXMgbm90IHVzZWQsIHRoZSBzZWxlY3RvciB3aWxsIGJlIHNpbXBseSBhcHBlbmRlZFxyXG4gKiB0byB0aGUgcGFyZW50IHNlbGVjdG9yLlxyXG4gKlxyXG4gKiBUaGUgYW1wZXJzYW5kIHN5bWJvbCBjYW4gYmUgZWl0aGVyIHByZWNlZWRlZCBvciBmb2xvd2VkIGJ5IGEgY29tYmluYXRvciBjaGFyYWN0ZXIsIHdoaWNoIGFsbG93c1xyXG4gKiBlYXN5LXRvLXVzZSBjb21iaW5hdGlvbiBvZiBhIHBhcmVudCBzZWxlY3RvciB3aXRoIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgdXNpbmcgdGhlIGdpdmVuXHJcbiAqIGNvbWJpbmF0b3IuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBjbGFzcyB0aGF0IGRvZXNuJ3QgZGVmaW5lIGl0cyBvd24gc3R5bGVzIGFuZCBpcyBvbmx5IHVzZWQgaW4gY29tYmluYXRpb25zXHJcbiAqICAgICBjbGFzczEgPSB0aGlzLiRjbGFzcygpXHJcbiAqXHJcbiAqICAgICAvLyBcInBhcmVudCBjbGFzc1wiXHJcbiAqICAgICBjbGFzczIgPSB0aGlzLiRjbGFzcyh7XHJcbiAqXHJcbiAqICAgICAgICAgLy8gY3NzOiAuY2xhc3MyIHsgYmFja2dyb3VuZENvbG9yOiB3aGl0ZTsgfVxyXG4gKiAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiLFxyXG4gKlxyXG4gKiAgICAgICAgIC8vIGNzczogbGkgLmNsYXNzMjpob3ZlciB7IGJhY2tncm91bmRDb2xvcjogeWVsbG93OyB9XHJcbiAqICAgICAgICAgXCImXCI6ICBbIFtcImxpICY6aG92ZXJcIiwgeyBiYWNrZ3JvdW5kQ29sb3I6IFwieWVsbG93XCIgfV0gXSxcclxuICpcclxuICogICAgICAgICAvLyBjc3M6IC5jbGFzczIuY2xhc3MxIHsgYmFja2dyb3VuZENvbG9yOiBjeWFuOyB9XHJcbiAqICAgICAgICAgXCImXCI6ICBbIFt0aGlzLmNsYXNzMSwgeyBiYWNrZ3JvdW5kQ29sb3I6IFwiY3lhblwiIH1dIF0sXHJcbiAqXHJcbiAqICAgICAgICAgLy8gY3NzOiAuY2xhc3MyID4gLmNsYXNzMSB7IGJhY2tncm91bmRDb2xvcjogZ3JlZW47IH1cclxuICogICAgICAgICBcIiY+XCI6IFsgW3RoaXMuY2xhc3MxLCB7IGJhY2tncm91bmRDb2xvcjogXCJncmVlblwiIH1dIF0sXHJcbiAqXHJcbiAqICAgICAgICAgLy8gY3NzOiAuY2xhc3MxICsgLmNsYXNzMiB7IGJhY2tncm91bmRDb2xvcjogb3JhbmdlOyB9XHJcbiAqICAgICAgICAgXCIrJlwiOiBbIFt0aGlzLmNsYXNzMSwgeyBiYWNrZ3JvdW5kQ29sb3I6IFwib3JhbmdlXCIgfV0gXSxcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBEZXBlbmRlbnRSdWxlQ29tYmluYXRvciA9IFwiJlwiIHwgXCImLFwiIHwgXCImIFwiIHwgXCImPlwiIHwgXCImK1wiIHwgXCImflwiIHwgXCIsJlwiIHwgXCIgJlwiIHwgXCI+JlwiIHwgXCIrJlwiIHwgXCJ+JlwiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBwcmludC1yZWxhdGVkIHBzZXVkbyBjbGFzc2VzIC0gdGhvc2UgdGhhdCBjYW4gYmUgc3BlY2lmaWVkIHdpdGggdGhlIGBAcGFnZWAgQ1NTIHJ1bGVcclxuICpcclxuICogKipFeGFtcGxlOioqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIHBhZ2UgPSB0aGlzLiRwYWdlKCBcIjpmaXJzdFwiLCB7IG1hcmdpbjogXCJhdXRvXCIgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB0eXBlIFBhZ2VQc2V1ZG9DbGFzcyA9IFwiOmJsYW5rXCIgfCBcIjpmaXJzdFwiIHwgXCI6bGVmdFwiIHwgXCI6cmlnaHRcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgcHNldWRvIGNsYXNzZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBwcm9wZXJ0aWVzIGluIHRoZSBbW0NvbWJpbmVkU3R5bGVzZXRdXSBvYmplY3QgdG9cclxuICogZGVmaW5lIGRlcGVuZGVudCBydWxlcy4gTm90ZSB0aGF0IHRoaXMgdHlwZSBvbmx5IGNvbnRhaW5zIHBzZXVkbyBjbGFzc2VzIHRoYXQgZG9uJ3QgcmVxdWlyZVxyXG4gKiBwYXJhbWV0ZXJzLiBGb3IgcGFyYW1ldGVyaXplZCBwc2V1ZG8gY2xhc3Nlcywgc2VlIHRoZSBbW0lQYXJhbWV0ZXJpemVkUHNldWRvQ2xhc3NdXSBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICBjbGFzczEgPSB0aGlzLiRjbGFzcyh7XHJcbiAqICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImJsdWVcIixcclxuICogICAgICAgICBcIjpob3ZlclwiOiB7IG9wYWNpdHk6IDAuNyB9LFxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCB0eXBlIFBzZXVkb0NsYXNzID0gUGFnZVBzZXVkb0NsYXNzIHxcclxuXHRcIjphY3RpdmVcIiB8IFwiOmFueS1saW5rXCIgfCBcIjphdXRvZmlsbFwiIHwgXCI6YmxhbmtcIiB8IFwiOmNoZWNrZWRcIiB8IFwiOmRlZmF1bHRcIiB8IFwiOmRlZmluZWRcIiB8IFwiOmRpc2FibGVkXCIgfFxyXG5cdFwiOmVtcHR5XCIgfCBcIjplbmFibGVkXCIgfCBcIjpmaXJzdC1jaGlsZFwiIHwgXCI6Zmlyc3Qtb2YtdHlwZVwiIHwgXCI6ZnVsbHNjcmVlblwiIHwgXCI6Zm9jdXNcIiB8XHJcblx0XCI6Zm9jdXMtdmlzaWJsZVwiIHwgXCI6Zm9jdXMtd2l0aGluXCIgfCBcIjpob3N0XCIgfCBcIjpob3ZlclwiIHwgXCI6aW5kZXRlcm1pbmF0ZVwiIHwgXCI6aW4tcmFuZ2VcIiB8IFwiOmludmFsaWRcIiB8XHJcblx0XCI6bGFzdC1jaGlsZFwiIHwgXCI6bGFzdC1vZi10eXBlXCIgfCBcIjpsZWZ0XCIgfCBcIjpsaW5rXCIgfCBcIjpvbmx5LWNoaWxkXCIgfCBcIjpvbmx5LW9mLXR5cGVcIiB8IFwiOm9wdGlvbmFsXCIgfFxyXG5cdFwiOm91dC1vZi1yYW5nZVwiIHwgXCI6cGF1c2VkXCIgfCBcIjpwbGFjZWhvbGRlci1zaG93blwiIHwgXCI6cmVhZC1vbmx5XCIgfCBcIjpyZWFkLXdyaXRlXCIgfCBcIjpyZXF1aXJlZFwiIHxcclxuICAgIFwiOnJpZ2h0XCIgfCBcIjpyb290XCIgfCBcIjpzY29wZVwiIHwgXCI6dGFyZ2V0XCIgfCBcIjp2YWxpZFwiIHwgXCI6dmlzaXRlZFwiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBwc2V1ZG8gZWxlbWVudHMgdGhhdCBjYW4gYmUgdXNlZCBhcyBwcm9wZXJ0aWVzIGluIHRoZSBbW0NvbWJpbmVkU3R5bGVzZXRdXSBvYmplY3QgdG9cclxuICogZGVmaW5lIGRlcGVuZGVudCBydWxlcy4gTm90ZSB0aGF0IHRoaXMgdHlwZSBvbmx5IGNvbnRhaW5zIHBzZXVkbyBlbGVtZW50cyB0aGF0IGRvbid0IHJlcXVpcmVcclxuICogcGFyYW1ldGVycy4gRm9yIHBhcmFtZXRlcml6ZWQgcHNldWRvIGVsZW1lbnRzLCBzZWUgdGhlIFtbSVBhcmFtZXRlcml6ZWRQc2V1ZG9FbGVtZW50XV0gaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgZXhjaXRpbmcgPSB0aGlzLiRjbGFzcyh7XHJcbiAqICAgICAgICAgXCI6OmFmdGVyXCI6IHtcclxuICogICAgICAgICAgICAgY29udGVudDogXCIgPC0gRVhDSVRJTkchXCJcclxuICogICAgICAgICAgICAgY29sb3I6IFwiZ3JlZW5cIlxyXG4gKiAgICAgICAgIH0sXHJcbiAqICAgICB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUHNldWRvRWxlbWVudCA9IFwiOjphZnRlclwiIHwgXCI6OmJhY2tkcm9wXCIgfCBcIjo6YmVmb3JlXCIgfCBcIjo6Y3VlXCIgfCBcIjo6Zmlyc3QtbGV0dGVyXCIgfFxyXG5cdFwiOjpmaXJzdC1saW5lXCIgfCBcIjo6Z3JhbW1hci1lcnJvclwiIHwgXCI6Om1hcmtlclwiIHwgXCI6OnBsYWNlaG9sZGVyXCIgfCBcIjo6c2VsZWN0aW9uXCIgfCBcIjo6c3BlbGxpbmctZXJyb3JcIjtcclxuXHJcblxyXG5cclxuLyoqIENvbWJpbmVzIG5hbWVzIG9mIG5vbi1wYXJhbWV0ZXJpemVkIHBzZXVkbyBjbGFzc2VzIGFuZCBwc2V1ZG8gZWxlbWVudHMgKi9cclxuZXhwb3J0IHR5cGUgUHNldWRvRW50aXR5ID0gUHNldWRvQ2xhc3MgfCBQc2V1ZG9FbGVtZW50O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSBmb3IgZXhwcmVzc2lvbiBBbitCLCB3aGljaCBpcyB1c2VkIGZvciBwYXJhbWV0ZXJpemVkIHBzZXVkbyBjbGFzc2VzIGxpa2UgYDpudGgtY2hpbGRgLiBJdFxyXG4gKiBjYW4gYmUgYSBzdHJpbmcsIGEgc2luZ2xlIG51bWJlciBvciBhIHR1cGxlIHdpdGggb25lIG9yIHR3byBudW1iZXJzLiBJZiBpdCBpcyBhIHNpbmdsZSBudW1iZXIsXHJcbiAqIHRoZSAnbicgaW4gQW4rQiB3aWxsIG5vdCBiZSB1c2VkIC0gYXMgaW4gYG50aC1jaGlsZCgyKWAuIElmIGl0IGlzIGEgdHVwbGUsIHRoZSAnbicgd2lsbCBiZSB1c2VkXHJcbiAqIGV2ZW4gaWYgdGhlIHR1cGxlJ3Mgc2Vjb25kIGVsZW1lbnQgaXMgbm90IHByb3ZpZGVkLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgcCA9IHRoaXMuJHRhZyggXCJwXCIsIHtcclxuICogICAgICAgICBcIjpudGgtb2YtdHlwZVwiOiBbXHJcbiAqXHJcbiAqICAgICAgICAgICAgIC8vIGNzczogcDpudGgtb2YtdHlwZSgxKVxyXG4gKiAgICAgICAgICAgICBbMSwgeyBjb2xvcjogXCJyZWRcIiB9XSxcclxuICpcclxuICogICAgICAgICAgICAgLy8gY3NzOiBwOm50aC1vZi10eXBlKDNuKVxyXG4gKiAgICAgICAgICAgICBbWzNdLCB7IGNvbG9yOiBcImdyZWVuXCIgfV0sXHJcbiAqXHJcbiAqICAgICAgICAgICAgIC8vIGNzczogcDpudGgtb2YtdHlwZSgybisxKVxyXG4gKiAgICAgICAgICAgICBbWzIsMV0sIHsgY29sb3I6IFwiYmx1ZVwiIH1dLFxyXG4gKlxyXG4gKiAgICAgICAgICAgICAvLyBjc3M6IHA6bnRoLW9mLXR5cGUob2RkKVxyXG4gKiAgICAgICAgICAgICBbXCJvZGRcIiwgeyBjb2xvcjogXCJ5ZWxsb3dcIiB9XSxcclxuICpcclxuICogICAgICAgICAgICAgLy8gY3NzOiBwOm50aC1vZi10eXBlKDJuLTEpXHJcbiAqICAgICAgICAgICAgIFtbMiwtMV0sIHsgY29sb3I6IFwib3JhbmdlXCIgfV0sXHJcbiAqICAgICAgICAgXSxcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBOdGhFeHByZXNzaW9uID0gXCJvZGRcIiB8IFwiZXZlblwiIHwgbnVtYmVyIHwgW251bWJlciwgbnVtYmVyP10gfCBzdHJpbmcgfCBJUmF3UHJveHk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIHRoZSB0eXBlIGZvciB0aGUgdGV4dCBkaXJlY3Rpb24gdXNlZCBmb3IgdGhlIGBcIjpkaXJcImAgcHNldWRvIGNsYXNzXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBEaXJlY3Rpb24gPSBcInJ0bFwiIHwgXCJsdHJcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgSVBhcmFtZXRlcml6ZWRQc2V1ZG9DbGFzc2AgaW50ZXJmYWNlIG1hcHMgbmFtZXMgb2YgcHNldWRvIGNsYXNzZXMgdGhhdCByZXF1aXJlIHBhcmFtZXRlcnNcclxuICogdG8gdGhlIHR5cGVzIHRoYXQgYXJlIHVzZWQgdG8gc3BlY2lmeSB0aGVzZSBwYXJhbWV0ZXJzLiBXaGVuIGEgcGFyYW1ldGVyaXplZCBwc2V1ZG8gY2xhc3MgaXNcclxuICogdXNlZCBhcyBhIHByb3BlcnR5IGluIHRoZSBbW0NvbWJpbmVkU3R5bGVzZXRdXSBvYmplY3QsIHRoZSB2YWx1ZSBzaG91bGQgYmUgb2YgdGhlIHR5cGUgZnJvbVxyXG4gKiB0aGlzIGludGVyZmFjZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBhcmFtZXRlcml6ZWRQc2V1ZG9DbGFzc1xyXG57XHJcblx0XCI6ZGlyXCI6IERpcmVjdGlvbjtcclxuXHRcIjpoYXNcIjogQ3NzU2VsZWN0b3IgfCBbU2VsZWN0b3JDb21iaW5hdG9yLCBDc3NTZWxlY3Rvcl07XHJcblx0XCI6aG9zdFwiOiBzdHJpbmc7XHJcblx0XCI6aG9zdC1jb250ZXh0XCI6IHN0cmluZztcclxuXHRcIjppc1wiOiBDc3NTZWxlY3RvcjtcclxuXHRcIjpsYW5nXCI6IHN0cmluZztcclxuXHRcIjpub3RcIjogQ3NzU2VsZWN0b3I7XHJcblx0XCI6bnRoLWNoaWxkXCI6IE50aEV4cHJlc3Npb247XHJcblx0XCI6bnRoLW9mLXR5cGVcIjogTnRoRXhwcmVzc2lvbjtcclxuXHRcIjpudGgtbGFzdC1jaGlsZFwiOiBOdGhFeHByZXNzaW9uO1xyXG5cdFwiOm50aC1sYXN0LW9mLXR5cGVcIjogTnRoRXhwcmVzc2lvbjtcclxuXHRcIjp3aGVyZVwiOiBDc3NTZWxlY3RvcjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBJUGFyYW1ldGVyaXplZFBzZXVkb0VsZW1lbnRgIGludGVyZmFjZSBtYXBzIG5hbWVzIG9mIHBzZXVkbyBlbGVtZW50cyB0aGF0IHJlcXVpcmUgcGFyYW1ldGVyc1xyXG4gKiB0byB0aGUgdHlwZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZXNlIHBhcmFtZXRlcnMuIFdoZW4gYSBwYXJhbWV0ZXJpemVkIHBzZXVkbyBlbGVtZW50XHJcbiAqIGlzIHVzZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGUgW1tDb21iaW5lZFN0eWxlc2V0XV0gb2JqZWN0LCB0aGUgdmFsdWUgc2hvdWxkIGJlIG9mIHRoZSB0eXBlIGZyb21cclxuICogdGhpcyBpbnRlcmZhY2UuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElQYXJhbWV0ZXJpemVkUHNldWRvRWxlbWVudFxyXG57XHJcblx0XCI6OnBhcnRcIjogc3RyaW5nO1xyXG5cdFwiOjpzbG90dGVkXCI6IENzc1NlbGVjdG9yO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5YCBpbnRlcmZhY2UgY29tYmluZXMgW1tJUGFyYW1ldGVyaXplZFBzZXVkb0NsYXNzXV0gYW5kXHJcbiAqIFtbSVBhcmFtZXRlcml6ZWRQc2V1ZG9FbGVtZW50XV0gaW50ZXJmYWNlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBhcmFtZXRlcml6ZWRQc2V1ZG9FbnRpdHkgZXh0ZW5kcyBJUGFyYW1ldGVyaXplZFBzZXVkb0NsYXNzLCBJUGFyYW1ldGVyaXplZFBzZXVkb0VsZW1lbnQge31cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiBhIHBhcmFtZXRlcml6ZWQgcHNldWRvIGVudGl0eSB3aXRoIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGFyYW1ldGVyaXplZFBzZXVkb0VudGl0eUZ1bmM8VCBleHRlbmRzIGtleW9mIElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5PiBleHRlbmRzIElDc3NGdW5jT2JqZWN0XHJcbntcclxuICAgIC8qKiBQc2V1ZG8gZW50aXR5IG5hbWUgKi9cclxuICAgIGZuOiBUO1xyXG5cclxuICAgIC8qKiBQYXJhbWV0ZXIgb2YgdGhlIHBzZXVkbyBlbnRpdHkgKi9cclxuICAgIHA6IElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5W1RdO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBmb3Igb3BlcmF0aW9ucyBkZWZpbmluZyB0aGUgYmVoYXZpb3Igb2YgYXR0cmlidXRlIHNlbGVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQXR0ckNvbXBhcmlzb25PcGVyYXRpb24gPSBcIj1cIiB8IFwifj1cIiB8IFwifD1cIiB8IFwiXj1cIiB8IFwiJD1cIiB8IFwiKj1cIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gYXR0cmlidXRlIHNlbGVjdG9yIGRlZmluaW5nIGl0cyBuYW1lLCB2YWx1ZSBhbmQgY29tcGFyaXNvbiBvcGVyYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElBdHRyU2VsZWN0b3JGdW5jIGV4dGVuZHMgSUNzc0Z1bmNPYmplY3Rcclxue1xyXG4gICAgZm46IFwiYXR0ci1zZWxcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZSB0byB3aGljaCB0aGUgYXR0cmlidXRlIHZhbHVlIGlzIGNvbXBhcmVkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgc2VsZWN0b3Igb25seSBsb29rc1xyXG4gICAgICogZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICB2YWw/OiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyO1xyXG5cclxuICAgIC8qKiBOYW1lc3BhY2Ugb2YgdGhlIGF0dHJpYnV0ZSAqL1xyXG4gICAgbnM/OiBzdHJpbmcgfCBJTmFtZXNwYWNlUnVsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdGlvbiB0aGF0IGRlZmluZXMgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBjb21wYXJpc29uIGJlaGF2aW9yLiBUaGUgZGVmYXVsdCB2YWx1ZSBpc1xyXG4gICAgICogW1tBdHRyU2VsZWN0b3JPcGVyYXRpb24uRXF1YWxdXS5cclxuICAgICAqL1xyXG4gICAgb3A/OiBBdHRyQ29tcGFyaXNvbk9wZXJhdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhc2UgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSB2YWx1ZSBjb21wYXJpc29uIGlzIGNhc2Utc2Vuc2l0aXZlLiBUaGVcclxuICAgICAqIHVuZGVmaW5lZCB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgY2FzZS1zZW5zaXRpdmUgY29tcGFyaXNvbnMuXHJcbiAgICAgKi9cclxuICAgIGNmPzogXCJpXCIgfCBcInNcIjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNvbXBvdW5kIHNlbGVjdG9yIGFzIGFuIGFycmF5IG9mIHNlbGVjdG9ycy4gVGhpcyBpbnRlcmZhY2UgaXMgZXh0ZW5kZWQgYnkgdGhlXHJcbiAqIFtbSVNlbGVjdG9yQnVpbGRlcl1dIGludGVyZmFjZSwgd2hpY2ggYWxsb3dzIGJ1aWxkaW5nIGEgY29tcG91bmQgc2VsZWN0b3IgdXNpbmcgY2hhaW4gY2FsbHMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTZWxlY3RvckZ1bmMgZXh0ZW5kcyBJQ3NzRnVuY09iamVjdFxyXG57XHJcbiAgICBmbjogXCJzZWxcIjtcclxuXHJcbiAgICAvKiogQXJyYXkgb2Ygc2VsZWN0b3IgaXRlbXMgdGhhdCBhcmUgY29tYmluZWQgdG9nZXRoZXIgdG8gcHJvZHVjZSBhIGNvbXBvdW5kIHNlbGVjdG9yICovXHJcbiAgICBpdGVtczogQ3NzU2VsZWN0b3JbXTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgbWVhbnMgdG8gYnVpbGQgY29tcGxleCBzZWxlY3RvcnMgZnJvbSBtdWx0aXBsZSBzZWxlY3RvciBpdGVtcyBvZiBhbGwgcG9zc2libGUga2luZHNcclxuICogaW5jbHVkaW5nIHRhZ3MsIGNsYXNzZXNzLCBJRHMsIGF0dHJpYnV0ZXMsIHBzZXVkbyBjbGFzc2VzIGFuZCBwc2V1ZG8gZWxlbWVudHMgY29tYmluZWQgd2l0aFxyXG4gKiBDU1MgY29tYmluYXRvcnMuIFRoaXMgaW50ZXJmYWNlIGlzIHJldHVybmVkIGZyb20gdGhlIFtbc2VsXV0gZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTZWxlY3RvckJ1aWxkZXIgZXh0ZW5kcyBJU2VsZWN0b3JGdW5jXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBzZWxlY3RvciBpdGVtcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yIGFuZCBlYWNoIG90aGVyLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB3aXRob3V0IGFueSBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgZG9lc24ndCBoYXZlIGFueSBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBzZWN0aW9uLmMxLmMyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwic2VjdGlvblwiKS5hbmQoIHRoaXMuYzEsIHRoaXMuYzIpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIExpc3Qgb2Ygc2VsZWN0b3JzIHRvIGJlIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIGFuZCggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBzZWxlY3RvciBpdGVtcyB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgYXMgYSBsaXN0IG9mIHNlbGVjdG9ycy4gQWxsIGl0ZW1zXHJcbiAgICAgKiBhcmUgIGNvbmNhdGVuYXRlZCBhbmQgYXR0YWNoZWQgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIHVzaW5nIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuIENhbGxpbmdcclxuICAgICAqIHRoaXMgbWV0aG9kIHdpdGhvdXQgYW55IGFyZ3VtZW50cyBpbnNlcnRzIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBzZWN0aW9uLCAuYzEsIC5jMiB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikub3IoIHRoaXMuYzEsIHRoaXMuYzIpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIExpc3Qgb2Ygc2VsZWN0b3JzIHRvIGJlIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIG9yKCAuLi5pdGVtczogQ3NzU2VsZWN0b3JbXSk6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIHNlbGVjdG9yIGl0ZW1zIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciBhcyBjb25zZWN1dGl2ZSBpbW1lZGlhdGUgY2hpbGRyZW4uXHJcbiAgICAgKiBBbGwgaXRlbXMgYXJlIGNvbmNhdGVuYXRlZCBhbmQgYXR0YWNoZWQgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIHVzaW5nIHRoZSBgXCI+XCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGhvdXQgYW55IGFyZ3VtZW50cyBpbnNlcnRzIHRoZSBgXCI+XCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBzZWN0aW9uID4gLmMxID4gLmMyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwic2VjdGlvblwiKS5jaGlsZCggdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgTGlzdCBvZiBzZWxlY3RvcnMgdG8gYmUgYWRkZWRcclxuICAgICAqL1xyXG4gICAgY2hpbGQoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgc2VsZWN0b3IgaXRlbXMgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIGFzIGNvbnNlY3V0aXZlIGRlc2NlbmRhbnRzLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB1c2luZyB0aGUgYFwiIFwiYCBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgaW5zZXJ0cyB0aGUgYFwiIFwiYCBjb21iaW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGMxID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqICAgICBjMiA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogc2VjdGlvbiAuYzEgLmMyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwic2VjdGlvblwiKS5kZXNjKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBkZXNjKCAuLi5pdGVtczogQ3NzU2VsZWN0b3JbXSk6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIHNlbGVjdG9yIGl0ZW1zIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciBhcyBjb25zZWN1dGl2ZSBnZW5lcmFsIHNpYmxpbmdzLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB1c2luZyB0aGUgYFwiflwiYCBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgaW5zZXJ0cyB0aGUgYFwiflwiYCBjb21iaW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGMxID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqICAgICBjMiA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogc2VjdGlvbiB+IC5jMSB+IC5jMiB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuc2liKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBzaWIoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgc2VsZWN0b3IgaXRlbXMgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdG9yIGFzIGNvbnNlY3V0aXZlIGFkamFjZW50IHNpYmxpbmdzLlxyXG4gICAgICogQWxsIGl0ZW1zIGFyZSBjb25jYXRlbmF0ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBleGlzdGluZyBzZWxlY3RvciB1c2luZyB0aGUgYFwiK1wiYCBjb21iaW5hdG9yLlxyXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IGFueSBhcmd1bWVudHMgaW5zZXJ0cyB0aGUgYFwiK1wiYCBjb21iaW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGMxID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqICAgICBjMiA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogc2VjdGlvbiArIC5jMSArIC5jMiB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuYWRqKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBhZGooIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gYXR0cmlidXRlIHNlbGVjdG9yIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IuIFRoaXMgdmFyaWFudCBkb2Vzbid0XHJcbiAgICAgKiBhY2NlcHQgY29tcGFyaXNvbiBvcGVyYXRpb24gYW5kLCB0aGVyZWZvcmUsIHBlcmZvcm1zIHJlZ3VsYXIgZXF1YWxpdHkgY29tcGFyaXNvbi4gSXQgYWxzb1xyXG4gICAgICogYWxsb3dzIG9taXR0aW5nIHRoZSB2YWx1ZSwgaW4gd2hpY2ggY2FzZSwgb25seSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGF0dHJpYnV0ZSBpcyBjaGVja2VkLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogZGl2Olt0aXRsZV0gey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJkaXZcIikuYXR0ciggXCJ0aXRsZVwiKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogYTpbaHJlZj1cImh0dHBzOi8vd3d3LmV4YW1wbGUuY29tXCJdIHsuLi59XHJcbiAgICAgKiAgICAgczIgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwiYVwiKS5hdHRyKCBcImhyZWZcIiwgXCJodHRwczovL3d3dy5leGFtcGxlLmNvbVwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIHZhbCBBdHRyaWJ1dGUgdmFsdWUgLSBpZiBvbWl0dGVkLCBvbmx5IGF0dHJpYnV0ZSBwcmVzZW5jZSBpcyBjaGVja2VkLlxyXG4gICAgICogQHBhcmFtIGNmIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgY29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlLiBVbmRlZmluZWRcclxuICAgICAqIHZhbHVlIG1lYW5zIHRoZSBjb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLlxyXG4gICAgICogQHBhcmFtIG5zIEF0dHJpYnV0ZSdzIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgYXR0ciggbmFtZTogc3RyaW5nLCB2YWw/OiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyLCBjZj86IFwiaVwiIHwgXCJzXCIsIG5zPzogc3RyaW5nIHwgSU5hbWVzcGFjZVJ1bGUpOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogYTpbaHJlZl49XCJodHRwczovL1wiXSB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcImFcIikuYXR0ciggXCJocmVmXCIsIFwiXj1cIiwgXCJodHRwczovL1wiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG9wIEF0dHJidXRlIGNvbXBhcmlzb24gb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHZhbCBBdHRyaWJ1dGUgdmFsdWUgLSBpZiBvbWl0dGVkLCBvbmx5IGF0dHJpYnV0ZSBwcmVzZW5jZSBpcyBjaGVja2VkLlxyXG4gICAgICogQHBhcmFtIGNmIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgY29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlLiBVbmRlZmluZWRcclxuICAgICAqIHZhbHVlIG1lYW5zIHRoZSBjb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLlxyXG4gICAgICogQHBhcmFtIG5zIEF0dHJpYnV0ZSdzIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgYXR0ciggbmFtZTogc3RyaW5nLCBvcDogQXR0ckNvbXBhcmlzb25PcGVyYXRpb24sIHZhbDogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcixcclxuICAgICAgICBjZj86IFwiaVwiIHwgXCJzXCIsIG5zPzogc3RyaW5nIHwgSU5hbWVzcGFjZVJ1bGUpOiB0aGlzO1xyXG5cclxuXHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjphY3RpdmVcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGFjdGl2ZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmFueS1saW5rXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBhbnlMaW5rOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6YXV0b2ZpbGxcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGF1dG9maWxsOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6YmxhbmtcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGJsYW5rOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6Y2hlY2tlZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgY2hlY2tlZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmRlZmF1bHRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGRlZmF1bHQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpkZWZpbmVkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBkZWZpbmVkOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmRpcigpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBkaXJlY3Rpb24gdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZVxyXG4gICAgICogZXhpc3Rpbmcgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGRpciggZGlyZWN0aW9uOiBEaXJlY3Rpb24pOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZGlzYWJsZWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGRpc2FibGVkOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZW1wdHlcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGVtcHR5OiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZW5hYmxlZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZW5hYmxlZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmZpcnN0LWNoaWxkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBmaXJzdENoaWxkOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6Zmlyc3Qtb2YtdHlwZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZmlyc3RPZlR5cGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpmaXJzdFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZmlyc3Q6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpmb2N1cy12aXNpYmxlXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBmb2N1c1Zpc2libGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpmb2N1cy13aXRoaW5cImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGZvY3VzV2l0aGluOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6Zm9jdXNcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGZvY3VzOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6ZnVsbHNjcmVlblwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgZnVsbHNjcmVlbjogdGhpcztcclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8gVGhlIFwiaGFzXCIgbWV0aG9kIGlzIGNvbW1lbnRlZCBvdXQgYmVjYXVzZSBpdCBpcyBub3QgY2xlYXIgeWV0IGhvdyB0b1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vIGltcGxlbWVudCBpdCBpbiBhbiBlbGVnYW50IHdheSwgYW5kIGJlY2F1c2UgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBpdC5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gICogQWRkcyB0aGUgYFwiOmhhcygpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZiBtdWx0aXBsZVxyXG4gICAgLy8gICogaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZCB1c2luZ1xyXG4gICAgLy8gICogdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiAqKkV4YW1wbGU6KipcclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAvLyAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgIC8vICAqIHtcclxuICAgIC8vICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAvLyAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgLy8gICpcclxuICAgIC8vICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHNlY3Rpb246aGFzKC5jMSwgLmMyKSB7Li4ufVxyXG4gICAgLy8gICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuaGFzKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAvLyAgKiB9XHJcbiAgICAvLyAgKiBgYGBcclxuICAgIC8vICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgLy8gICovXHJcbiAgICAvLyBoYXMoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuICAgIC8vIC8qKlxyXG4gICAgLy8gICogQWRkcyB0aGUgYFwiOmhhcygpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHBhcnRpYWwgc2VsZWN0b3IgdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gY29tYmluYXRvci5cclxuICAgIC8vICAqIElmIG11bHRpcGxlIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIGNvbmNhdGVuYXRlZCB1c2luZyB0aGUgZ2l2ZW4gY29tYmluYXRvci4gQVxyXG4gICAgLy8gICogc3BlY2lhbCB2YWx1ZSBgXCJcImAgKGVtcHR5IHN0cmluZykgb2YgdGhlIGBjb21iaW5hdG9yYCBwYXJhbWV0ZXIgYWxsb3dzIHRvIGNvbmNhdGVuYXRlIHRoZVxyXG4gICAgLy8gICogaXRlbXMgd2l0aG91dCBhbnkgY29tYmluYXRvci5cclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiAqKkV4YW1wbGU6KipcclxuICAgIC8vICAqXHJcbiAgICAvLyAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAvLyAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgIC8vICAqIHtcclxuICAgIC8vICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAvLyAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgLy8gICpcclxuICAgIC8vICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHNlY3Rpb246aGFzKD4gLmMxID4gLmMyKSB7Li4ufVxyXG4gICAgLy8gICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInNlY3Rpb25cIikuaGFzKCBcIj5cIiwgdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgLy8gICpcclxuICAgIC8vICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHNlY3Rpb246aGFzKC5jMS5jMikgey4uLn1cclxuICAgIC8vICAqICAgICBzMiA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJzZWN0aW9uXCIpLmhhcyggXCJcIiwgdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgLy8gICogfVxyXG4gICAgLy8gICogYGBgXHJcbiAgICAvLyAgKiBAcGFyYW0gY29tYmluYXRvciBDb21iaW5hdG9yIHRvIHVzZSB0byBjb25jYXRlbmF0ZSB0aGUgaXRlbXMgYW5kIHRvIGF0dGFjaCB0aGVtIHRvIHRoZVxyXG4gICAgLy8gICogZXhpc3Rpbmcgc2VsZWN0b3IuXHJcbiAgICAvLyAgKiBAcGFyYW0gaXRlbXMgTGlzdCBvZiBzZWxlY3RvcnMgdG8gYmUgYWRkZWRcclxuICAgIC8vICAqL1xyXG4gICAgLy8gaGFzKCBjb21iaW5hdG9yOiBTZWxlY3RvckNvbWJpbmF0b3IgfCBcIlwiLCAuLi5pdGVtczogQ3NzU2VsZWN0b3JbXSk6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpob3N0XCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBob3N0OiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmhvc3QoKVwiYCBwYXJhbWV0ZXJpemVkIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLlxyXG4gICAgICogVGhlIG1ldGhvZCBoYXMgdGhlIGRvbGxhci1zaWduIGluIGl0cyBuYW1lIHRvIGRpZmZlcmVudGlhdGUgaXQgZnJvbSB0aGUgcHJvcGVydHkgW1tob3N0XV0uXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiA6aG9zdCguYzEsIC5jMikgey4uLn1cclxuICAgICAqICAgICBzID0gY3NzLiRzdHlsZSggY3NzLnNlbCgpLmhvc3QkKCB0aGlzLmMxLCB0aGlzLmMyKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBob3N0JCggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmhvc3QtY29udGV4dCgpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZlxyXG4gICAgICogbXVsdGlwbGUgaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZFxyXG4gICAgICogdXNpbmcgdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IDpob3N0LWNvbnRleHQoLmMxLCAuYzIpIHsuLi59XHJcbiAgICAgKiAgICAgcyA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoKS5ob3N0Q29udGV4dCggdGhpcy5jMSwgdGhpcy5jMiksIHsuLi59KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgTGlzdCBvZiBzZWxlY3RvcnMgdG8gYmUgYWRkZWRcclxuICAgICAqL1xyXG4gICAgaG9zdENvbnRleHQoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmhvdmVyXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBob3ZlcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmluLXJhbmdlXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBpblJhbmdlOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6aW5kZXRlcm1pbmF0ZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgaW5kZXRlcm1pbmF0ZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmludmFsaWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGludmFsaWQ6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBgXCI6aXMoKVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3Rvci4gSWYgbXVsdGlwbGVcclxuICAgICAqIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIGludGVycHJldGVkIGFzIGEgbGlzdDsgdGhhdCBpcywgdGhleSBhcmUgY29tYmluZWQgdXNpbmdcclxuICAgICAqIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiA6aXMoLmMxLCAuYzIpID4gcDpob3ZlciB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbCgpLmlzKCB0aGlzLmMxLCB0aGlzLmMyKS5jaGlsZFwicDpob3ZlclwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBpcyggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOmxhbmcoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBsYW5nKCBsYW5nQ29kZTogc3RyaW5nKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmxhc3QtY2hpbGRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGxhc3RDaGlsZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmxhc3Qtb2YtdHlwZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgbGFzdE9mVHlwZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOmxlZnRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGxlZnQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpsaW5rXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBsaW5rOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm5vdCgpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZiBtdWx0aXBsZVxyXG4gICAgICogaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZCB1c2luZ1xyXG4gICAgICogdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBmYW5jeSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogdGguZmFuY3k6bm90KDpudGgtb2YtdHlwZSgxKSkgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJ0aFwiKS5hbmQodGhpcy5mYW5jeSkubm90KCBcIjpudGgtb2YtdHlwZSgxKVwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICBub3QoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjpudGgtY2hpbGQoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWNoaWxkKFwib2RkXCIpIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhDaGlsZChcIm9kZFwiKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtY2hpbGQoMykgey4uLn1cclxuICAgICAqICAgICBzMiA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aENoaWxkKDMpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1jaGlsZCgzbikgey4uLn1cclxuICAgICAqICAgICBzMyA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aENoaWxkKFszXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWNoaWxkKDNuKzEpIHsuLi59XHJcbiAgICAgKiAgICAgczQgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhDaGlsZChbMywxXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWNoaWxkKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczUgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhDaGlsZChbMywtMV0pLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIG50aEV4cHIgU3RyaW5nLCBudW1iZXIgb3IgdHVwbGUgcHJvdmlkaW5nIHRoZSB2YWx1ZSBmb3IgdGhlIGBcIm50aFwiYCBleHByZXNzaW9uXHJcbiAgICAgKi9cclxuICAgIG50aENoaWxkKCBudGhFeHByOiBOdGhFeHByZXNzaW9uKTogdGhpcztcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm50aC1jaGlsZCgpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtY2hpbGQoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aENoaWxkKDMsIDEpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1jaGlsZCgzbi0xKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoQ2hpbGQoMywgLTEpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGEgTnVtYmVyIGJlZm9yZSB0aGUgYFwiblwiYCBpbiB0aGUgYFwiQW4rQlwiYCBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gYiBOdW1iZXIgYWZ0ZXIgdGhlIGBcIitcImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvbi4gVXNlIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICAgKiB0byBjcmVhdGUgYSBgXCJBbi1CXCJgIGV4cHJlc3Npb24uXHJcbiAgICAgKi9cclxuICAgIG50aENoaWxkKCBhOiBudW1iZXIsIGI6IG51bWJlcik6IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBgXCI6bnRoLWxhc3QtY2hpbGQoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3QtY2hpbGQoXCJvZGRcIikgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RDaGlsZChcIm9kZFwiKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1jaGlsZCgzKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdENoaWxkKDMpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LWNoaWxkKDNuKSB7Li4ufVxyXG4gICAgICogICAgIHMzID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdENoaWxkKFszXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3QtY2hpbGQoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzNCA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RDaGlsZChbMywxXSksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3QtY2hpbGQoM24tMSkgey4uLn1cclxuICAgICAqICAgICBzNSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RDaGlsZChbMywtMV0pLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIG50aEV4cHIgU3RyaW5nLCBudW1iZXIgb3IgdHVwbGUgcHJvdmlkaW5nIHRoZSB2YWx1ZSBmb3IgdGhlIGBcIm50aFwiYCBleHByZXNzaW9uXHJcbiAgICAgKi9cclxuICAgIG50aExhc3RDaGlsZCggbnRoRXhwcjogTnRoRXhwcmVzc2lvbik6IHRoaXM7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjpudGgtbGFzdC1jaGlsZCgpXCJgIHBzZXVkbyBjbGFzcyB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1jaGlsZCgzbisxKSB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdENoaWxkKDMsIDEpLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LWNoaWxkKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczIgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhMYXN0Q2hpbGQoMywgLTEpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGEgTnVtYmVyIGJlZm9yZSB0aGUgYFwiblwiYCBpbiB0aGUgYFwiQW4rQlwiYCBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gYiBOdW1iZXIgYWZ0ZXIgdGhlIGBcIitcImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvbi4gVXNlIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICAgKiB0byBjcmVhdGUgYSBgXCJBbi1CXCJgIGV4cHJlc3Npb24uXHJcbiAgICAgKi9cclxuICAgIG50aExhc3RDaGlsZCggYTogbnVtYmVyLCBiOiBudW1iZXIpOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm50aC1vZi10eXBlKClcImAgcHNldWRvIGNsYXNzIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1vZi10eXBlKFwib2RkXCIpIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhPZlR5cGUoXCJvZGRcIiksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLW9mLXR5cGUoMykgey4uLn1cclxuICAgICAqICAgICBzMiA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aE9mVHlwZSgzKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtb2YtdHlwZSgzbikgey4uLn1cclxuICAgICAqICAgICBzMyA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aE9mVHlwZShbM10pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1vZi10eXBlKDNuKzEpIHsuLi59XHJcbiAgICAgKiAgICAgczQgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhPZlR5cGUoWzMsMV0pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1vZi10eXBlKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczUgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhPZlR5cGUoWzMsLTFdKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBudGhFeHByIFN0cmluZywgbnVtYmVyIG9yIHR1cGxlIHByb3ZpZGluZyB0aGUgdmFsdWUgZm9yIHRoZSBgXCJudGhcImAgZXhwcmVzc2lvblxyXG4gICAgICovXHJcbiAgICBudGhPZlR5cGUoIG50aEV4cHI6IE50aEV4cHJlc3Npb24pOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBgXCI6bnRoLW9mLXR5cGUoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLW9mLXR5cGUoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aE9mVHlwZSgzLCAxKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtb2YtdHlwZSgzbi0xKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoT2ZUeXBlKDMsIC0xKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBhIE51bWJlciBiZWZvcmUgdGhlIGBcIm5cImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIGIgTnVtYmVyIGFmdGVyIHRoZSBgXCIrXCJgIGluIHRoZSBgXCJBbitCXCJgIGV4cHJlc3Npb24uIFVzZSBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICogdG8gY3JlYXRlIGEgYFwiQW4tQlwiYCBleHByZXNzaW9uLlxyXG4gICAgICovXHJcbiAgICBudGhPZlR5cGUoIGE6IG51bWJlciwgYjogbnVtYmVyKTogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjpudGgtbGFzdC1vZi10eXBlKClcImAgcHNldWRvIGNsYXNzIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LW9mLXR5cGUoXCJvZGRcIikgey4uLn1cclxuICAgICAqICAgICBzMSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RPZlR5cGUoXCJvZGRcIiksIHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3Qtb2YtdHlwZSgzKSB7Li4ufVxyXG4gICAgICogICAgIHMyID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdE9mVHlwZSgzKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1vZi10eXBlKDNuKSB7Li4ufVxyXG4gICAgICogICAgIHMzID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdE9mVHlwZShbM10pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LW9mLXR5cGUoM24rMSkgey4uLn1cclxuICAgICAqICAgICBzNCA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RPZlR5cGUoWzMsMV0pLCB7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiBwOm50aC1sYXN0LW9mLXR5cGUoM24tMSkgey4uLn1cclxuICAgICAqICAgICBzNSA9IGNzcy4kc3R5bGUoIGNzcy5zZWwoXCJwXCIpLm50aExhc3RPZlR5cGUoWzMsLTFdKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBudGhFeHByIFN0cmluZywgbnVtYmVyIG9yIHR1cGxlIHByb3ZpZGluZyB0aGUgdmFsdWUgZm9yIHRoZSBgXCJudGhcImAgZXhwcmVzc2lvblxyXG4gICAgICovXHJcbiAgICBudGhMYXN0T2ZUeXBlKCBudGhFeHByOiBOdGhFeHByZXNzaW9uKTogdGhpcztcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOm50aC1sYXN0LW9mLXR5cGUoKVwiYCBwc2V1ZG8gY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IHA6bnRoLWxhc3Qtb2YtdHlwZSgzbisxKSB7Li4ufVxyXG4gICAgICogICAgIHMxID0gY3NzLiRzdHlsZSggY3NzLnNlbChcInBcIikubnRoTGFzdE9mVHlwZSgzLCAxKSwgey4uLn0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHByb2R1Y2VzIGNzczogcDpudGgtbGFzdC1vZi10eXBlKDNuLTEpIHsuLi59XHJcbiAgICAgKiAgICAgczIgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKFwicFwiKS5udGhMYXN0T2ZUeXBlKDMsIC0xKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBhIE51bWJlciBiZWZvcmUgdGhlIGBcIm5cImAgaW4gdGhlIGBcIkFuK0JcImAgZXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIGIgTnVtYmVyIGFmdGVyIHRoZSBgXCIrXCJgIGluIHRoZSBgXCJBbitCXCJgIGV4cHJlc3Npb24uIFVzZSBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICogdG8gY3JlYXRlIGEgYFwiQW4tQlwiYCBleHByZXNzaW9uLlxyXG4gICAgICovXHJcbiAgICBudGhMYXN0T2ZUeXBlKCBhOiBudW1iZXIsIGI6IG51bWJlcik6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvbmx5LWNoaWxkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBvbmx5Q2hpbGQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvbmx5LW9mLXR5cGVcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IG9ubHlPZlR5cGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvcHRpb25hbFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgb3B0aW9uYWw6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpvdXQtb2YtcmFuZ2VcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IG91dE9mUmFuZ2U6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpwYXVzZWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHBhdXNlZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnBpY3R1cmUtaW4tcGljdHVyZVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcGljdHVyZUluUGljdHVyZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnBsYWNlaG9sZGVyLXNob3duXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBwbGFjZWhvbGRlclNob3duOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6cGxheWluZ1wiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcGxheWluZzogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnJlYWQtb25seVwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcmVhZE9ubHk6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyZWFkLXdyaXRlXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSByZWFkV3JpdGU6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyZXF1aXJlZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcmVxdWlyZWQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyaWdodFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgcmlnaHQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjpyb290XCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSByb290OiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6c2NvcGVcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHNjb3BlOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6dGFyZ2V0XCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSB0YXJnZXQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjp2YWxpZFwiYCBwc2V1ZG8gY2xhc3MgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgdmFsaWQ6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjp2aXNpdGVkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSB2aXNpdGVkOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6dXNlci1pbnZhbGlkXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSB1c2VySW52YWxpZDogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOnVzZXItdmFsaWRcImAgcHNldWRvIGNsYXNzIHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHVzZXJWYWxpZDogdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGBcIjp3aGVyZSgpXCJgIHBzZXVkbyBjbGFzcyB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yLiBJZiBtdWx0aXBsZVxyXG4gICAgICogaXRlbXMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgaW50ZXJwcmV0ZWQgYXMgYSBsaXN0OyB0aGF0IGlzLCB0aGV5IGFyZSBjb21iaW5lZCB1c2luZ1xyXG4gICAgICogdGhlIGBcIixcImAgY29tYmluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBjMSA9IGNzcy4kY2xhc3Moey4uLn0pXHJcbiAgICAgKiAgICAgYzIgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBwcm9kdWNlcyBjc3M6IDp3aGVyZSguYzEsIC5jMikgPiBwOmhvdmVyIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKCkud2hlcmUoIHRoaXMuYzEsIHRoaXMuYzIpLmNoaWxkKFwicDpob3ZlclwiKSwgey4uLn0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBpdGVtcyBMaXN0IG9mIHNlbGVjdG9ycyB0byBiZSBhZGRlZFxyXG4gICAgICovXHJcbiAgICB3aGVyZSggLi4uaXRlbXM6IENzc1NlbGVjdG9yW10pOiB0aGlzO1xyXG5cclxuXHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjo6YWZ0ZXJcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgYWZ0ZXI6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjo6YmFja2Ryb3BcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgYmFja2Ryb3A6IHRoaXM7XHJcblxyXG4gICAgLyoqIEFkZHMgdGhlIGBcIjo6YmVmb3JlXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGJlZm9yZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpjdWUtcmVnaW9uXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGN1ZVJlZ2lvbjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpjdWVcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgY3VlOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6OmZpcnN0LWxldHRlclwiYCBwc2V1ZG8gZWxlbWVudCB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBmaXJzdExldHRlcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpmaXJzdC1saW5lXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGZpcnN0TGluZTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpncmFtbWFyLWVycm9yXCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IGdyYW1tYXJFcnJvcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjptYXJrZXJcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgbWFya2VyOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOjpwYXJ0KClcImAgcHNldWRvIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVyLlxyXG4gICAgICovXHJcbiAgICBwYXJ0KCBwYXJ0TmFtZTogc3RyaW5nKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpwbGFjZWhvbGRlclwiYCBwc2V1ZG8gZWxlbWVudCB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBwbGFjZWhvbGRlcjogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpzZWxlY3Rpb25cImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3RvciAqL1xyXG4gICAgcmVhZG9ubHkgc2VsZWN0aW9uOiB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgYFwiOjpzbG90dGVkKClcImAgcHNldWRvIGVsZW1lbnQgdG8gaW1tZWRpYXRlbHkgZm9sbG93IHRoZSBleGlzdGluZyBzZWxlY3Rvci4gSWZcclxuICAgICAqIG11bHRpcGxlIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIGludGVycHJldGVkIGFzIGEgbGlzdDsgdGhhdCBpcywgdGhleSBhcmUgY29tYmluZWRcclxuICAgICAqIHVzaW5nIHRoZSBgXCIsXCJgIGNvbWJpbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgYzEgPSBjc3MuJGNsYXNzKHsuLi59KVxyXG4gICAgICogICAgIGMyID0gY3NzLiRjbGFzcyh7Li4ufSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcHJvZHVjZXMgY3NzOiA6OnNsb3R0ZWQoLmMxLCAuYzIpIHsuLi59XHJcbiAgICAgKiAgICAgczEgPSBjc3MuJHN0eWxlKCBjc3Muc2VsKCkuc2xvdHRlZCggdGhpcy5jMSwgdGhpcy5jMikpLCB7Li4ufSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIExpc3Qgb2Ygc2VsZWN0b3JzIHRvIGJlIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIHNsb3R0ZWQoIC4uLml0ZW1zOiBDc3NTZWxlY3RvcltdKTogdGhpcztcclxuXHJcbiAgICAvKiogQWRkcyB0aGUgYFwiOjpzcGVsbGluZy1lcnJvclwiYCBwc2V1ZG8gZWxlbWVudCB0byBpbW1lZGlhdGVseSBmb2xsb3cgdGhlIGV4aXN0aW5nIHNlbGVjdG9yICovXHJcbiAgICByZWFkb25seSBzcGVsbGluZ0Vycm9yOiB0aGlzO1xyXG5cclxuICAgIC8qKiBBZGRzIHRoZSBgXCI6OnRhcmdldC10ZXh0XCJgIHBzZXVkbyBlbGVtZW50IHRvIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGUgZXhpc3Rpbmcgc2VsZWN0b3IgKi9cclxuICAgIHJlYWRvbmx5IHRhcmdldFRleHQ6IHRoaXM7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgZm9yIGEgQ1NTIHNlbGVjdG9yLiBUaGlzIHR5cGUgaXMgdXNlZCB0byBwcm9kdWNlIGFyYml0cmFyeSBjb21wbGV4IHNlbGVjdG9ycyB1c2VkIGJ5IHRoZVxyXG4gKiBbWyRzdHlsZV1dIGZ1bmN0aW9uLiBJZiBhcnJheSBpcyBzcGVjaWZpZWQsIGFsbCBpdGVtcyBhcmUgY29udmVydGVkIHRvIHN0cmluZ3MgYW5kIGNvbmNhdGVuYXRlZC5cclxuICovXHJcbmV4cG9ydCB0eXBlIENzc1NlbGVjdG9yID0gRWxlbWVudFRhZ05hbWUgfCBQc2V1ZG9FbnRpdHkgfCBJUnVsZVdpdGhTZWxlY3RvciB8IElTZWxlY3RvclByb3h5IHxcclxuICAgIElTZWxlY3RvckZ1bmMgfCBJQXR0clNlbGVjdG9yRnVuYyB8IElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5RnVuYzxhbnk+IHxcclxuICAgIFNlbGVjdG9yQ29tYmluYXRvciB8IElSYXdQcm94eSB8IHN0cmluZyB8IENzc1NlbGVjdG9yW107XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBNaXNjZWxsYW5lb3VzIENTUyB0eXBlcy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogVHlwZSBmb3Igc2ltcGxlIGFuaW1hdGlvbiB0aW1pbmcgZnVuY3Rpb25zIC0gdGhvc2UgdGhhdCBkb24ndCBoYXZlIHBhcmFtZXRlcnNcclxuICpcclxuICovXHJcbmV4cG9ydCB0eXBlIFRpbWluZ0Z1bmN0aW9uS2V5d29yZHMgPSBcImxpbmVhclwiIHwgXCJlYXNlXCIgfCBcImVhc2UtaW5cIiB8IFwiZWFzZS1vdXRcIiB8IFwiZWFzZS1pbi1vdXRcIiB8IFwic3RlcC1zdGFydFwiIHwgXCJzdGVwLWVuZFwiO1xyXG5cclxuXHJcblxyXG4vKiogVHlwZSBmb3Igc3RlcCBhbmltYXRpb24gdGltaW5nIGZ1bmN0aW9uIGp1bXAtdGVybSAqL1xyXG5leHBvcnQgdHlwZSBUaW1pbmdGdW5jdGlvbkp1bXBUZXJtID0gXCJqdW1wLXN0YXJ0XCIgfCBcImp1bXAtZW5kXCIgfCBcImp1bXAtbm9uZVwiIHwgXCJqdW1wLWJvdGhcIiB8IFwic3RhcnRcIiB8IFwiZW5kXCI7XHJcblxyXG4vKipcclxuICogVGhlIElTdGVwc0Z1bmMgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiB0aGUgQ1NTIGBzdGVwcygpYCBmdW5jdGlvbi4gSXQgaXMgcmV0dXJuZWRcclxuICogZnJvbSB0aGUgW1tzdGVwc11dIGZ1bmN0aW9uLlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNpdGlvbiBhbmQgQW5pbWF0aW9uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTdGVwc0Z1bmMgZXh0ZW5kcyBJQ3NzRnVuY09iamVjdFxyXG57XHJcbiAgICBmbjogXCJzdGVwc1wiO1xyXG5cclxuICAgIC8qKiBOdW1iZXIgb2Ygc3RvcHMgKi9cclxuICAgIG46IEV4dGVuZGVkPG51bWJlcj47XHJcblxyXG4gICAgLyoqIEp1bXAgdGVybSAqL1xyXG4gICAgaj86IFRpbWluZ0Z1bmN0aW9uSnVtcFRlcm07XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJQ3ViaWNCZXppZXJGdW5jIGludGVyZmFjZSByZXByZXNlbnRzIGFuIGludm9jYXRpb24gb2YgdGhlIENTUyBgY3ViaWMtYmV6aWVyKClgIGZ1bmN0aW9uLlxyXG4gKiBJdCBpcyByZXR1cm5lZCBmcm9tIHRoZSBbW2N1YmljQmV6aWVyXV0gZnVuY3Rpb24uXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2l0aW9uIGFuZCBBbmltYXRpb25cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUN1YmljQmV6aWVyRnVuYyBleHRlbmRzIElDc3NGdW5jT2JqZWN0XHJcbntcclxuICAgIGZuOiBcImN1YmljLWJlemllclwiO1xyXG5cclxuICAgIG4xOiBFeHRlbmRlZDxudW1iZXI+O1xyXG4gICAgbjI6IEV4dGVuZGVkPG51bWJlcj47XHJcbiAgICBuMzogRXh0ZW5kZWQ8bnVtYmVyPixcclxuICAgIG40OiBFeHRlbmRlZDxudW1iZXI+O1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIGZvciBzaW5nbGUgYW5pbWF0aW9uIHRpbWluZyBmdW5jdGlvblxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgVGltaW5nRnVuY3Rpb24gPSBUaW1pbmdGdW5jdGlvbktleXdvcmRzIHwgSVN0ZXBzRnVuYyB8IElDdWJpY0JlemllckZ1bmM7XHJcblxyXG5cclxuXHJcbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gTWlzY2VsbGFuZW91cyBDU1MgZnVuY3Rpb25zLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUaGUgSVVybEZ1bmMgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiB0aGUgQ1NTIGB1cmwoKWAgZnVuY3Rpb24uIEl0IGlzIHJldHVybmVkIGZyb21cclxuICogdGhlIFtbdXJsXV0gZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElVcmxGdW5jIGV4dGVuZHMgSUNzc0Z1bmNPYmplY3Rcclxue1xyXG4gICAgZm46IFwidXJsXCI7XHJcblxyXG4gICAgLyoqIFVSTCBvciByZWZlcmVuY2UgdG8gdGhlIElEIHJ1bGUgaWRlbnRpZnlpbmcgYW4gU1ZHIGVsZW1lbnQgKi9cclxuICAgIHA6IEV4dGVuZGVkPHN0cmluZyB8IElJRFJ1bGU+O1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgSUN1cnNvckZ1bmMgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gaW52b2NhdGlvbiBvZiB0aGUgQ1NTIGB1cmwoKWAgZnVuY3Rpb24gd2l0aCB0d28gb3B0aW9uYWxcclxuICogbnVtYmVycyBpbmRpY2F0aW5nIHRoZSBjdXJzb3IncyBob3RzcG90LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQ3Vyc29yRnVuYyBleHRlbmRzIElDc3NGdW5jT2JqZWN0XHJcbntcclxuICAgIGZuOiBcImN1cnNvclwiO1xyXG5cclxuICAgIC8qKiBDdXJzb3IgVVJMIG9yIHJlZmVyZW5jZSB0byB0aGUgSUQgcnVsZSBpZGVudGlmeWluZyBhbiBTVkcgZWxlbWVudCAqL1xyXG4gICAgdXJsOiBFeHRlbmRlZDxzdHJpbmcgfCBJSURSdWxlPjtcclxuXHJcbiAgICAvKiogWC1jb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdCAqL1xyXG4gICAgeD86IG51bWJlcjtcclxuXHJcbiAgICAvKiogWS1jb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgaG90c3BvdCAqL1xyXG4gICAgeT86IG51bWJlcjtcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gSW1hZ2UgYW5kIGdyYWRpZW50IENTUyBmdW5jdGlvbnMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgcmVwcmVzZW50aW5nIGV4dGVudCBmb3IgdGhlIFtbcmFkaWFsR3JhZGllbnRdXSBvciBbW3JheV1dIGZ1bmN0aW9ucy5cclxuICovXHJcbmV4cG9ydCB0eXBlIEV4dGVudEtleXdvcmQgPSBcImNsb3Nlc3QtY29ybmVyXCIgfCBcImNsb3Nlc3Qtc2lkZVwiIHwgXCJmYXJ0aGVzdC1jb3JuZXJcIiB8IFwiZmFydGhlc3Qtc2lkZVwiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBvYmplY3QgdGhhdCBwcm9kdWNlcyBvbmUgb2YgQ1NTIGdyYWRpZW50IGZ1bmN0aW9uLiBJdCBjYW4gYmUgZGlyZWN0bHkgYXNzaWduZWQgdG9cclxuICogYSBzdWl0YWJsZSBzdHlsZSBwcm9wZXJ0eSAoZS5nLiBiYWNrZ3JvdW5kLWltYWdlKS4gT2JqZWN0cyBpbXBsZW1lbnRpbmcgdGhpcyBpbnRlcmZhY2UgY2FuIGJlXHJcbiAqIHVzZWQgd2hlcmVldmVyIGdyYWRpZW50cyBhcmUgdXNlZC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNzc0ltYWdlRnVuYyBleHRlbmRzIElDc3NGdW5jT2JqZWN0XHJcbntcclxuICAgIGZuOiBcImxpbmVhci1ncmFkaWVudFwiIHwgXCJyYWRpYWwtZ3JhZGllbnRcIiB8IFwiY29uaWMtZ3JhZGllbnRcIiB8XHJcbiAgICAgICAgXCJjcm9zcy1mYWRlXCIgfCBcImltYWdlLXNldFwiIHwgXCJwYWludFwiO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQ3NzSW1hZ2UgdHlwZSByZXByZXNlbnRzIGEgdHlwZSB1c2VkIGZvciBDU1MgcHJvcGVydGllcyB0aGF0IGFjY2VwdCB0aGUgYDxpbWFnZT5gIHR5cGUuXHJcbiAqIEltYWdlIGNhbiBiZSBzcGVjaWZpZWQgZWl0aGVyIHVzaW5nIHRoZSBbW3VybF1dIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgW1tJVXJsRnVuY11dXHJcbiAqIGludGVyZmFjZSBvciBhbnkgb2YgdGhlIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgW1tJSW1hZ2VQcm94eV1dIG9yIFtbSUNzc0ltYWdlRnVuY11dXHJcbiAqIGludGVyZmFjZSBzdWNoIGFzIFtbbGluZWFyR3JhZGllbnRdXSBhbmQgW1tjcm9zc0ZhZGVdXS5cclxuICovXHJcbmV4cG9ydCB0eXBlIENzc0ltYWdlID0gSVVybEZ1bmMgfCBJQ3NzSW1hZ2VGdW5jO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gV2ViIE5hbWVzcGFjZXMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBXZWJOYW1lc3BhY2VzIGVudW1lcmF0aW9uIHByb3ZpZGVzIGlkZW50aWZpZXJzIGZvciB0aGUga25vd24gV2ViLXJlbGF0ZWQgbmFtZXNwYWNlcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlbnVtIFdlYk5hbWVzcGFjZXNcclxue1xyXG4gICAgSFRNTCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxyXG4gICAgU1ZHID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxyXG4gICAgWExpbmsgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcclxuICAgIFhNTCA9IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXHJcbiAgICBYTUxOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIixcclxuICAgIE1hdGhNTCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxyXG59XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7RXh0ZW5kZWQsIElHZW5lcmljUHJveHl9IGZyb20gXCIuL0NvcmVUeXBlc1wiXHJcbmltcG9ydCB7XHJcbiAgICBJTGVuZ3RoUHJveHksIElQZXJjZW50UHJveHksIElBbmdsZVByb3h5LCBJVGltZVByb3h5LCBJUmVzb2x1dGlvblByb3h5LCBJRnJlcXVlbmN5UHJveHksXHJcbiAgICBDc3NMZW5ndGgsIElGaXRDb250ZW50UHJveHksIENzc051bWJlciwgSUFzcGVjdFJhdGlvUHJveHksIElOdW1iZXJNYXRoLCBJUGVyY2VudE1hdGgsXHJcbiAgICBJTGVuZ3RoTWF0aCwgSUFuZ2xlTWF0aCwgSVRpbWVNYXRoLCBJUmVzb2x1dGlvbk1hdGgsIElGcmVxdWVuY3lNYXRoLCBJUmVjdFByb3h5LFxyXG59IGZyb20gXCIuL051bWVyaWNUeXBlc1wiXHJcbmltcG9ydCB7TnVtYmVyTWF0aCwgUGVyY2VudE1hdGgsIExlbmd0aE1hdGgsIEFuZ2xlTWF0aCwgVGltZU1hdGgsIFJlc29sdXRpb25NYXRoLCBGcmVxdWVuY3lNYXRofSBmcm9tIFwiLi4vaW1wbC9OdW1lcmljSW1wbFwiXHJcbmltcG9ydCB7ZjJzLCBXS0YsIGEyc30gZnJvbSBcIi4uL2ltcGwvVXRpbHNcIjtcclxuXHJcblxyXG5cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiBmb3IgdW5pdHMgY29udmVyc2lvblxyXG5jb25zdCB0b1VuaXRzUHJveHkgPSAoIG46IG51bWJlciwgdW5pdDogc3RyaW5nKTogSUdlbmVyaWNQcm94eSA9PiAoKSA9PiBuICsgdW5pdDtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgTnVtYCBvYmplY3QgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlIGA8bnVtYmVyPmBcclxuICogQ1NTIHR5cGUuIEl0IGltcGxlbWVudHMgdGhlIFtbSU51bWVyaWNNYXRoXV0gaW50ZXJmYWNlIGFuZCB0aHVzIGFsbG93cyB1c2luZyB0aGUgbWV0aG9kcyBzdWNoXHJcbiAqIGFzIFtbbWluXV0sIFtbbWF4XV0sIFtbY2FsY11dIGFuZCBbW2NsYW1wXV0gd2l0aCBwYXJhbWV0ZXJzIG9mIHRoZSBbW0Nzc051bWJlcl1dIHR5cGUuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBkZWZpbmUgY3VzdG9tIENTUyBwcm9wZXJ0eSAtIG5vdGUgdGhhdCBpdHMgdmFsdWUgY2FuIGJlIGNoYW5nZWRcclxuICogICAgIC8vIHByb2dyYW1tYXRpY2FsbHlcclxuICogICAgIGNvbHVtblF0eSA9IHRoaXMuJHZhciggXCJDc3NOdW1iZXJcIiwgMylcclxuICpcclxuICogICAgIC8vIG1heCggNSwgdmFyKC0tY29sdW1uUXR5KSlcclxuICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7XHJcbiAqICAgICAgICAgY29sdW1uczogY3NzLk51bS5tYXgoIDUsIHRoaXMuY29sdW1uUXR5KVxyXG4gKiAgICAgfSlcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjb25zdCBOdW06IElOdW1iZXJNYXRoID0gTnVtYmVyTWF0aDtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgUGVyY2VudGAgb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZS4gSXQgaW1wbGVtZW50cyB0aGUgW1tJTnVtZXJpY01hdGhdXSBpbnRlcmZhY2UgYW5kIHRodXMgYWxsb3dzIHVzaW5nXHJcbiAqIHRoZSBtZXRob2RzIHN1Y2ggYXMgW1ttaW5dXSwgW1ttYXhdXSwgW1tjYWxjXV0gYW5kIFtbY2xhbXBdXSB3aXRoIHBhcmFtZXRlcnMgb2YgdGhlXHJcbiAqIFtbQ3NzUGVyY2VudF1dIHR5cGUuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICBpbml0aWFsWm9vbSA9IGNzcy52YXIoIFwiQ3NzUGVyY2VudFwiLCAxLjUpXHJcbiAqXHJcbiAqICAgICAvLyBtaW4oIDAuNSwgdmFyKC0taW5pdGlhbFpvb20pKVxyXG4gKiAgICAgY2xzMSA9IHRoaXMuJGNsYXNzKHtcclxuICogICAgICAgICB6b29tOiBjc3MuUGVyY2VudC5taW4oIDAuNSwgdGhpcy5pbml0aWFsWm9vbSlcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUGVyY2VudDogSVBlcmNlbnRNYXRoID0gUGVyY2VudE1hdGg7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBwZXJjZW50IHZhbHVlIGJ5IGFwcGVuZmluZyB0aGUgYFwiJVwiYCBzaWduIHRvIHRoZSBnaXZlbiBudW1iZXIuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlXHJcbiAqIHVzZWQgd2hlbmV2ZXIgYSBgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZSBpcyB1c2VkIGZvciBhIHN0eWxlIHByb3BlcnR5IG9yIHZhbHVlLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBwZXJjZW50ID0gKG46IG51bWJlcik6IElQZXJjZW50UHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcIiVcIik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYExlbmAgb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT5gIENTUyB0eXBlLiBJdCBpbXBsZW1lbnRzIHRoZSBbW0lOdW1lcmljTWF0aF1dIGludGVyZmFjZSBhbmQgdGh1c1xyXG4gKiBhbGxvd3MgdXNpbmcgdGhlIG1ldGhvZHMgc3VjaCBhcyBbW21pbl1dLCBbW21heF1dLCBbW2NhbGNdXSBhbmQgW1tjbGFtcF1dIHdpdGggcGFyYW1ldGVyc1xyXG4gKiBvZiB0aGUgW1tDc3NMZW5ndGhdXSB0eXBlLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgZGVmYXVsdFBhZGRpbmcgPSBjc3MudmFyKCBcIkNzc0xlbmd0aFwiLCA4KVxyXG4gKlxyXG4gKiAgICAgLy8gY2FsYyggMjAwcHggLSAoMiAqIHZhcigtLWRlZmF1bHRQYWRkaW5nKSkpXHJcbiAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gKiAgICAgICAgIHdpZHRoOiBjc3MuTGVuLmNhbGNgIDIwMHB4IC0gKDIgKiAke3RoaXMuZGVmYXVsdFBhZGRpbmd9KWBcclxuICogICAgIH0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTGVuOiBJTGVuZ3RoTWF0aCA9IExlbmd0aE1hdGg7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gcXVhcnRlcnMgb2YgYW4gaW5jaC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUSA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcIlFcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gY2ggdW5pdHMsIHdoaWNoIGlzIGVxdWFsIHRvIHRoZSB1c2VkIGFkdmFuY2UgbWVhc3VyZSBvZiB0aGUgYOKAnDDigJ1gIChaRVJPLFxyXG4gKiBVKzAwMzApIGdseXBoIGZvdW5kIGluIHRoZSBmb250IHVzZWQgdG8gcmVuZGVyIGl0LiAoVGhlIGFkdmFuY2UgbWVhc3VyZSBvZiBhIGdseXBoIGlzIGl0c1xyXG4gKiBhZHZhbmNlIHdpZHRoIG9yIGhlaWdodCwgd2hpY2hldmVyIGlzIGluIHRoZSBpbmxpbmUgYXhpcyBvZiB0aGUgZWxlbWVudC4pXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNoID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiY2hcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gY2FudGltZXRlcnMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNtID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiY21cIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gY2FsY3VsYXRlZCBmb250LXNpemVzIG9mIHRoZSBlbGVtZW50LlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBlbSA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImVtXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIGhlaWdodHMgb2YgbG93ZXJjYXNlIGxldHRlciAneCcgaW4gdGhlIGZvbnQuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGV4ID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiZXhcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gaWMgdW5pdHMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGljID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiaWNcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gaW5jaGVzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBpbmNoID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiaW5cIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gbGluZS1oZWlnaHRzIG9mIHRoZSBlbGVtZW50LlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBsaCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImxoXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIG1pbGxpbWV0ZXJzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBtbSA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcIm1tXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIHBpY2FzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBwYyA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInBjXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIHBvaW50cy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcHQgPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJwdFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiBwaXhlbHMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHB4ID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwicHhcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gMSUgb2YgdGhlIHNpemUgb2YgdGhlIGluaXRpYWwgY29udGFpbmluZyBibG9jaywgaW4gdGhlIGRpcmVjdGlvblxyXG4gKiBvZiB0aGUgcm9vdCBlbGVtZW504oCZcyBibG9jayBheGlzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCB2YiA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInZiXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIDElIG9mIHRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0J3MgaW5pdGlhbCBjb250YWluaW5nIGJsb2NrLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCB2aCA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInZoXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIDElIG9mIHRoZSBzaXplIG9mIHRoZSBpbml0aWFsIGNvbnRhaW5pbmcgYmxvY2ssIGluIHRoZSBkaXJlY3Rpb25cclxuICogb2YgdGhlIHJvb3QgZWxlbWVudOKAmXMgaW5saW5lIGF4aXMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwidmlcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBsZW5ndGggdmFsdWUgaW4gMSUgb2YgdGhlIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCdzIGluaXRpYWwgY29udGFpbmluZyBibG9jay5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdncgPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJ2d1wiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiBmb250LXNpemVzIG9mIHRoZSByb290IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbSA9IChuOiBudW1iZXIpOiBJTGVuZ3RoUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInJlbVwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiBsaW5lLWhlaWdodHMgb2YgdGhlIHJvb3QgZWxlbWVudCAoPGh0bWw+KS5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmxoID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwicmxoXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgbGVuZ3RoIHZhbHVlIGluIHRoZSB1bml0cyB3aGljaCBhcmUgYSBzbWFsbGVyIHZhbHVlIGJldHdlZW4gdncgYW5kIHZoLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCB2bWluID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwidm1pblwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBpbiB0aGUgdW5pdHMgd2hpY2ggYXJlIGEgbGFyZ2VyIHZhbHVlIGJldHdlZW4gdncgYW5kIHZoLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCB2bWF4ID0gKG46IG51bWJlcik6IElMZW5ndGhQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwidm1heFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGxlbmd0aCB2YWx1ZSBmb3IgZmxleC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZnIgPSAobjogbnVtYmVyKTogSUxlbmd0aFByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJmclwiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgQW5nbGVgIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxhbmdsZT4gfCA8cGVyY2VudGFnZT5gIENTUyB0eXBlLiBJdCBpbXBsZW1lbnRzIHRoZSBbW0lOdW1lcmljTWF0aF1dIGludGVyZmFjZSBhbmQgdGh1c1xyXG4gKiBhbGxvd3MgdXNpbmcgdGhlIG1ldGhvZHMgc3VjaCBhcyBbW21pbl1dLCBbW21heF1dLCBbW2NhbGNdXSBhbmQgW1tjbGFtcF1dIHdpdGggcGFyYW1ldGVyc1xyXG4gKiBvZiB0aGUgW1tDc3NBbmdsZV1dIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQW5nbGU6IElBbmdsZU1hdGggPSBBbmdsZU1hdGg7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbmdsZSB2YWx1ZSBpbiBkZWdyZWVzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWcgPSAobjogbnVtYmVyKTogSUFuZ2xlUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImRlZ1wiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZ2xlIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJhZCA9IChuOiBudW1iZXIpOiBJQW5nbGVQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwicmFkXCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5nbGUgdmFsdWUgaW4gZ3JhZGlhbnMuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdyYWQgPSAobjogbnVtYmVyKTogSUFuZ2xlUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcImdyYWRcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbmdsZSB2YWx1ZSBpbiB0dXJucy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHVybiA9IChuOiBudW1iZXIpOiBJQW5nbGVQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwidHVyblwiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgVGltZWAgb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZSBgPHRpbWU+YFxyXG4gKiBDU1MgdHlwZS4gSXQgaW1wbGVtZW50cyB0aGUgW1tJTnVtZXJpY01hdGhdXSBpbnRlcmZhY2UgYW5kIHRodXMgYWxsb3dzIHVzaW5nIHRoZSBtZXRob2RzIHN1Y2hcclxuICogYXMgW1ttaW5dXSwgW1ttYXhdXSwgW1tjYWxjXV0gYW5kIFtbY2xhbXBdXSB3aXRoIHBhcmFtZXRlcnMgb2YgdGhlIFtbQ3NzVGltZV1dIHR5cGUuXHJcbiAqL1xyXG4gZXhwb3J0IGNvbnN0IFRpbWU6IElUaW1lTWF0aCA9IFRpbWVNYXRoO1xyXG5cclxuIC8qKlxyXG4gKiBDcmVhdGVzIHRpbWUgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBtcyA9IChuOiBudW1iZXIpOiBJVGltZVByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJtc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRpbWUgdmFsdWUgaW4gc2Vjb25kcy5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcyA9IChuOiBudW1iZXIpOiBJVGltZVByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJzXCIpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGBSZXNvbHV0aW9uYCBvYmplY3QgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIGA8cmVzb2x1dGlvbj5gIENTUyB0eXBlLiBJdCBpbXBsZW1lbnRzIHRoZSBbW0lOdW1lcmljTWF0aF1dIGludGVyZmFjZSBhbmQgdGh1cyBhbGxvd3MgdXNpbmdcclxuICogdGhlIG1ldGhvZHMgc3VjaCBhcyBbW21pbl1dLCBbW21heF1dLCBbW2NhbGNdXSBhbmQgW1tjbGFtcF1dIHdpdGggcGFyYW1ldGVycyBvZiB0aGVcclxuICogW1tDc3NSZXNvbHV0aW9uXV0gdHlwZS5cclxuICovXHJcbiBleHBvcnQgY29uc3QgUmVzb2x1dGlvbjogSVJlc29sdXRpb25NYXRoID0gUmVzb2x1dGlvbk1hdGg7XHJcblxyXG4gLyoqXHJcbiAqIENyZWF0ZXMgcmVzb2x1dGlvbiB2YWx1ZSBpbiBEUEkuXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRwaSA9IChuOiBudW1iZXIpOiBJUmVzb2x1dGlvblByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJkcGlcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyByZXNvbHV0aW9uIHZhbHVlIGluIERQQ00uXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRwY20gPSAobjogbnVtYmVyKTogSVJlc29sdXRpb25Qcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiZHBjbVwiKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlc29sdXRpb24gdmFsdWUgaW4gRFBQWC5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZHBweCA9IChuOiBudW1iZXIpOiBJUmVzb2x1dGlvblByb3h5ID0+IHRvVW5pdHNQcm94eSggbiwgXCJkcHB4XCIpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVzb2x1dGlvbiB2YWx1ZSBpbiBYLlxyXG4gKiBAY2F0ZWdvcnkgVW5pdHNcclxuICovXHJcbmV4cG9ydCBjb25zdCB4ID0gKG46IG51bWJlcik6IElSZXNvbHV0aW9uUHJveHkgPT4gdG9Vbml0c1Byb3h5KCBuLCBcInhcIik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYEZyZXF1ZW5jeWAgb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZSBgPGZyZXF1ZW5jeT5gXHJcbiAqIENTUyB0eXBlLiBJdCBpbXBsZW1lbnRzIHRoZSBbW0lOdW1lcmljTWF0aF1dIGludGVyZmFjZSBhbmQgdGh1cyBhbGxvd3MgdXNpbmcgdGhlIG1ldGhvZHMgc3VjaFxyXG4gKiBhcyBbW21pbl1dLCBbW21heF1dLCBbW2NhbGNdXSBhbmQgW1tjbGFtcF1dIHdpdGggcGFyYW1ldGVycyBvZiB0aGUgW1tDc3NGcmVxdWVuY3ldXSB0eXBlLlxyXG4gKi9cclxuIGV4cG9ydCBjb25zdCBGcmVxdWVuY3k6IElGcmVxdWVuY3lNYXRoID0gRnJlcXVlbmN5TWF0aDtcclxuXHJcbiAvKipcclxuICogQ3JlYXRlcyBmcmVxdWVuY3kgdmFsdWUgaW4gSGVydHouXHJcbiAqIEBjYXRlZ29yeSBVbml0c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGh6ID0gKG46IG51bWJlcik6IElGcmVxdWVuY3lQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwiaHpcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBmcmVxdWVuY3kgdmFsdWUgaW4gS2lsby1IZXJ0ei5cclxuICogQGNhdGVnb3J5IFVuaXRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qga2h6ID0gKG46IG51bWJlcik6IElGcmVxdWVuY3lQcm94eSA9PiB0b1VuaXRzUHJveHkoIG4sIFwia2h6XCIpO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gVXRpbGl0eSBmdW5jdGlvbnNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lGaXRDb250ZW50UHJveHldXSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBmaXQtY29udGVudCgpYCBDU1MgZnVuY3Rpb25cclxuICogKFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9maXQtY29udGVudCgpKSkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZml0Q29udGVudCA9IChzaXplOiBFeHRlbmRlZDxDc3NMZW5ndGg+KTogSUZpdENvbnRlbnRQcm94eSA9PlxyXG4gICAgKCkgPT4gZjJzKCBcImZpdC1jb250ZW50XCIsIFtbc2l6ZSwgV0tGLkxlbmd0aF1dKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJQXNwZWN0UmF0aW9Qcm94eV1dIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYDxyYXRpbz5gIENTUyB0eXBlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJhdGlvID0gKHc6IENzc051bWJlciwgaD86IENzc051bWJlcik6IElBc3BlY3RSYXRpb1Byb3h5ID0+ICgpID0+IFt3LGhdLmpvaW4oXCIvXCIpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lSZWN0UHJveHldXSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGByZWN0KClgIENTUyBmdW5jdGlvbiB1c2VkIGZvciB0aGUgYGNsaXBgXHJcbiAqIHN0eWxlIHByb3BlcnR5LlxyXG4gKiBAZGVwcmVjYXRlZCBUaGUgQ1NTIGBjbGlwYCBwcm9wZXJ0eSBhbmQgYHJlY3QoKWAgZnVuY3Rpb24gYXJlIGRlcHJlY2F0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVjdCA9ICh0b3A6IENzc0xlbmd0aCwgcmlnaHQ6IENzc0xlbmd0aCwgYm90dG9tOiBDc3NMZW5ndGgsIGxlZnQ6IENzc0xlbmd0aCk6IElSZWN0UHJveHkgPT5cclxuICAgICgpID0+IGByZWN0KCR7YTJzKCBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XSwgV0tGLkxlbmd0aCwgXCIsXCIpfSlgO1xyXG5cclxuXHJcblxyXG4iLCLvu79pbXBvcnQge0V4dGVuZGVkLCBJR2VuZXJpY1Byb3h5LCBPbmVPckJveCwgT25lT3JQYWlyfSBmcm9tIFwiLi9Db3JlVHlwZXNcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgSU51bWJlckJhc2VNYXRoYCBpbnRlcmZhY2UgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpY2FsIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogbnVtZXJpYyBDU1MgdHlwZXMuIFRoaXMgaW50ZXJmYWNlIGlzIGV4dGVuZGVkIGJ5IGRpbWVuc2lvbi1zcGVjaWZpYyBpbnRlcmZhY2VzIHN1Y2ggYXNcclxuICogW1tJTnVtYmVyTWF0aF1dLCBbW0lMZW5ndGhNYXRoXV0sIFtbSUFuZ2xlTWF0aF1dLCBldGMuXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVCBUeXBlIG9mIHZhbHVlcyBwYXJ0aWNpcGF0aW5nIGluIHRoZSBtYXRoZW1hdGljYWwgZnVuY3Rpb25zLiBGb3IgZXhhbXBsZSwgdGhlXHJcbiAqIFtbSUxlbmd0aE1hdGhdXSBpbnRlcmZhY2Ugc3BlY2lmaWVzIGl0IGFzIFtbQ3NzTGVuZ3RoXV0uXHJcbiAqIEB0eXBlcGFyYW0gVSBUeXBlIHRoYXQgY29udGFpbnMgc3RyaW5nIGxpdGVyYWxzIGRlZmluaW5nIHVuaXRzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIG51bWVyaWNcclxuICogdHlwZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU51bWVyaWNNYXRoPFQsIFUgZXh0ZW5kcyBzdHJpbmc+XHJcbntcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBudW1iZXIgYW5kIHVuaXQuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGR5bmFtaWNhbGx5XHJcbiAgICAgKiBjb25zdHJ1Y3QgdGhlIG5lZWRlZCBkaW1lbnNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG4gTnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB1bml0IFVuaXQgdG8gYXBwZW5kIHRvIHRoZSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgRnVuY3Rpb24gaW1wbGVtZW50aW5nIHRoZSBgSUdlbmVyaWNQcm94eTxVPmAgY2FsbGFibGUgaW50ZXJmYWNlLiBUaGlzIGFsbG93cyB0aGVcclxuICAgICAqIHJlc3VsdCBvZiB0aGUgYHVuaXRzYCBtZXRob2QgdG8gYmUgYXNzaWduZWQgb25seSB0byB0aGUgcHJvcGVydGllcyBvZiBjb21wYXRpYmxlIG51bWVyaWNcclxuICAgICAqIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHVuaXRzKCBuOiBudW1iZXIsIHVuaXQ6IFUpOiBJR2VuZXJpY1Byb3h5PFU+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBwcm9wZXJ0eSB2YWx1ZSB1c2luZyB0aGUgQ1NTIGBtaW4oKWAgZnVuY3Rpb24uIFBhcmFtZXRlcnMgYXJlIG9mIHRoZSB0eXBlXHJcbiAgICAgKiBgRXh0ZW5kZWQ8VD5gOyB0aGF0IGlzLCB0aGV5IGNhbiBiZSBlaXRoZXIgb2YgdGhlIGdlbmVyaWMgdHlwZSBgVGAsIG9yIGEgQ1NTIGN1c3RvbSB2YXJpYWJsZVxyXG4gICAgICogb3IgY29uc3RhbnQgb2YgdHlwZSBgVGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBPbmUgb3IgbW9yZSB2YWx1ZXMgdG8gY2hvb3NlIHRoZSBtaW5pbXVtIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBGdW5jdGlvbiBpbXBsZW1lbnRpbmcgdGhlIGBJR2VuZXJpY1Byb3h5PFU+YCBjYWxsYWJsZSBpbnRlcmZhY2UuIFRoaXMgYWxsb3dzIHRoZVxyXG4gICAgICogcmVzdWx0IG9mIHRoZSBgbWluYCBtZXRob2QgdG8gYmUgYXNzaWduZWQgb25seSB0byB0aGUgcHJvcGVydGllcyBvZiBhIGNvbXBhdGlibGUgbnVtZXJpY1xyXG4gICAgICogdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBtaW4oIDIwMHB4LCAyNS41ZW0sIDQ1JSlcclxuICAgICAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICB3aWR0aDogY3NzLkxlbi5taW4oIDIwMCwgMjUuNSwgY3NzLnBlcmNlbnQoNDUpKVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgbWluKCAuLi5wYXJhbXM6IEV4dGVuZGVkPFQ+W10pOiBJR2VuZXJpY1Byb3h5PFU+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBwcm9wZXJ0eSB2YWx1ZSB1c2luZyB0aGUgQ1NTIGBtYXgoKWAgZnVuY3Rpb24uIFBhcmFtZXRlcnMgYXJlIG9mIHRoZSB0eXBlXHJcbiAgICAgKiBgRXh0ZW5kZWQ8VD5gOyB0aGF0IGlzLCB0aGV5IGNhbiBiZSBlaXRoZXIgb2YgdGhlIGdlbmVyaWMgdHlwZSBgVGAsIG9yIGEgQ1NTIGN1c3RvbSB2YXJpYWJsZVxyXG4gICAgICogb3IgY29uc3RhbnQgb2YgdHlwZSBgVGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBPbmUgb3IgbW9yZSB2YWx1ZXMgdG8gY2hvb3NlIHRoZSBtYXhpbXVtIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBGdW5jdGlvbiBpbXBsZW1lbnRpbmcgdGhlIGBJR2VuZXJpY1Byb3h5PFU+YCBjYWxsYWJsZSBpbnRlcmZhY2UuIFRoaXMgYWxsb3dzIHRoZVxyXG4gICAgICogcmVzdWx0IG9mIHRoZSBgbWF4YCBtZXRob2QgdG8gYmUgYXNzaWduZWQgb25seSB0byB0aGUgcHJvcGVydGllcyBvZiBhIGNvbXBhdGlibGUgbnVtZXJpY1xyXG4gICAgICogdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBtYXgoIDIwMHB4LCAyNS41ZW0sIDQ1JSlcclxuICAgICAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICB3aWR0aDogY3NzLkxlbi5tYXgoIDIwMCwgMjUuNSwgY3NzLnBlcmNlbnQoNDUpKVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgbWF4KCAuLi5wYXJhbXM6IEV4dGVuZGVkPFQ+W10pOiBJR2VuZXJpY1Byb3h5PFU+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBwcm9wZXJ0eSB2YWx1ZSB1c2luZyB0aGUgQ1NTIGBjbGFtcCgpYCBmdW5jdGlvbi4gUGFyYW1ldGVycyBhcmUgb2YgdGhlIHR5cGVcclxuICAgICAqIGBFeHRlbmRlZDxUPmA7IHRoYXQgaXMsIHRoZXkgY2FuIGJlIGVpdGhlciBvZiB0aGUgZ2VuZXJpYyB0eXBlIGBUYCwgb3IgYSBDU1MgY3VzdG9tIHZhcmlhYmxlXHJcbiAgICAgKiBvciBjb25zdGFudCBvZiB0eXBlIGBUYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWluIExvd2VyIGJvdW5kIGZvciB0aGUgcmV0dXJuIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHByZWYgUHJlZmVycmVkIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIG1heCBVcHBlciBib3VuZCBmb3IgdGhlIHJldHVybiB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uIGltcGxlbWVudGluZyB0aGUgYElHZW5lcmljUHJveHk8VT5gIGNhbGxhYmxlIGludGVyZmFjZS4gVGhpcyBhbGxvd3MgdGhlXHJcbiAgICAgKiByZXN1bHQgb2YgdGhlIGBjbGFtcGAgbWV0aG9kIHRvIGJlIGFzc2lnbmVkIG9ubHkgdG8gdGhlIHByb3BlcnRpZXMgb2YgYSBjb21wYXRpYmxlIG51bWVyaWNcclxuICAgICAqIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gY2xhbXAoIDIwMHB4LCAyNS41ZW0sIDQ1JSlcclxuICAgICAqICAgICBjbHMxID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICB3aWR0aDogY3NzLkxlbi5jbGFtcCggMjAwLCAyNS41LCBjc3MucGVyY2VudCg0NSkpXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBjbGFtcCggbWluOiBFeHRlbmRlZDxUPiwgcHJlZjogRXh0ZW5kZWQ8VD4sIG1heDogRXh0ZW5kZWQ8VD4pOiBJR2VuZXJpY1Byb3h5PFU+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBwcm9wZXJ0eSB2YWx1ZSB1c2luZyB0aGUgQ1NTIGBjYWxjKClgIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBpcyBhIHRhZyBmdW5jdGlvbiBhbmQgbXVzdFxyXG4gICAgICogYmUgaW52b2tlZCB3aXRoIGEgdGVtcGxhdGUgc3RyaW5nIHdpdGhvdXQgcGFyZW50aGVzZXMuIFBhcmFtZXRlcnMgaW4gdGhlIHRlbXBsYXRlIHN0cmluZ1xyXG4gICAgICogYXJlIG9mIHRoZSB0eXBlIGBFeHRlbmRlZDxUPmA7IHRoYXQgaXMsIHRoZXkgY2FuIGJlIGVpdGhlciBvZiB0aGUgZ2VuZXJpYyB0eXBlIGBUYCwgb3IgYVxyXG4gICAgICogQ1NTIGN1c3RvbSB2YXJpYWJsZSBvciBjb25zdGFudCBvZiB0eXBlIGBUYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9ybXVsYXJQYXJ0cyBBcnJheSBvZiBzdHJpbmdzLCB3aGljaCBhcmUgcGFydCBvZiB0aGUgdGVtcGxhdGUgc3RyaW5nIGFuZCB3aGljaCBhcmVcclxuICAgICAqIG5vdCBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBBcnJheSBvZiBwYXJhbWV0ZXJzIGZyb20gdGhlIHRlbXBsYXRlIHN0cmluZy5cclxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uIGltcGxlbWVudGluZyB0aGUgYElHZW5lcmljUHJveHk8VT5gIGNhbGxhYmxlIGludGVyZmFjZS4gVGhpcyBhbGxvd3MgdGhlXHJcbiAgICAgKiByZXN1bHQgb2YgdGhlIGBjYWxjYCBtZXRob2QgdG8gYmUgYXNzaWduZWQgb25seSB0byB0aGUgcHJvcGVydGllcyBvZiBhIGNvbXBhdGlibGUgbnVtZXJpY1xyXG4gICAgICogdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBkZWZhdWx0UGFkZGluZyA9IGNzcy52YXIoIFwiQ3NzTGVuZ3RoXCIsIDgpXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIGNhbGMoIDIwMHB4IC0gKDIgKiB2YXIoLS1kZWZhdWx0UGFkZGluZykpKVxyXG4gICAgICogICAgIGNsczEgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIHdpZHRoOiBjc3MuTGVuLmNhbGNgIDIwMHB4IC0gKDIgKiAke3RoaXMuZGVmYXVsdFBhZGRpbmd9KWBcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGNhbGMoIGZvcm11bGFQYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnBhcmFtczogRXh0ZW5kZWQ8VD5bXSk6IElHZW5lcmljUHJveHk8VT47XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIENTUyBgPG51bWJlcj5gIHR5cGUuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqIFByb3h5IGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdmFsdWVzIG9mIHRoZSBgPHBlcmNlbnQ+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElOdW1iZXJQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJcIj4ge307XHJcblxyXG4vKiogVHlwZSBmb3IgYSB2YWx1ZSBvZiB0aGUgYDxudW1iZXI+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgdHlwZSBDc3NOdW1iZXIgPSBudW1iZXIgfCBJR2VuZXJpY1Byb3h5PFwiXCI+O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgSU51bWJlck1hdGhgIGludGVyZmFjZSBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxudW1iZXI+YCBDU1MgdHlwZXMuIFRoaXMgaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBbW051bV1dIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU51bWJlck1hdGggZXh0ZW5kcyBJTnVtZXJpY01hdGg8Q3NzTnVtYmVyLFwiXCI+IHt9XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBQZXJjZW50XHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqIFVuaXRzIG9mIHBlcmNlbnQgKi9cclxuZXhwb3J0IHR5cGUgUGVyY2VudFVuaXRzID0gXCIlXCI7XHJcblxyXG4vKiogUHJveHkgaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB2YWx1ZXMgb2YgdGhlIGA8cGVyY2VudD5gIENTUyB0eXBlICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBlcmNlbnRQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8UGVyY2VudFVuaXRzPiB7fTtcclxuXHJcbi8qKlxyXG4gKiBUeXBlIGZvciBzdHlsZSBwcm9wZXJ0aWVzIG9mIHRoZSBgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZS4gVmFsdWVzIG9mIHRoaXMgdHlwZSBjYW4gYmUgc3BlY2lmZWQgYXM6XHJcbiAqIC0gb25lIG9mIHByZS1kZWZpbmVkIHN0cmluZ3MgbGlrZSBgXCIxMDAlXCJgXHJcbiAqIC0gcmV0dXJuIHZhbHVlIGZyb20gdGhlIFtbcGVyY2VudF1dIGZ1bmN0aW9uXHJcbiAqIC0gYSBudW1iZXI6XHJcbiAqICAgLSBpZiB0aGUgbnVtYmVyIGlzIGFuIGludGVnZXIsIGl0IGlzIHRha2VuIGFzIGlzIGFuZCBhIHBlcmNlbnQgc2lnbiBpcyBhcHBlbmRlZCB0byBpdFxyXG4gKiAgIC0gaWYgdGhlIG51bWJlciBpcyBhIGZsb2F0aW5nIHBvaW50LCBpdCBpcyBtdWx0aXBsaWVkIGJ5IDEwMCBhbmQgYSBwZXJjZW50IHNpZ24gaXMgYXBwZW5kZWQgdG8gaXRcclxuICovXHJcbmV4cG9ydCB0eXBlIENzc1BlcmNlbnQgPSBudW1iZXIgfCBJUGVyY2VudFByb3h5IHxcclxuICAgIFwiNSVcIiB8IFwiMTAlXCIgfCBcIjE1JVwiIHwgXCIyMCVcIiB8IFwiMjUlXCIgfCBcIjMwJVwiIHwgXCIzNSVcIiB8IFwiNDAlXCIgfCBcIjQ1JVwiIHwgXCI1MCVcIiB8XHJcbiAgICBcIjU1JVwiIHwgXCI2MCVcIiB8IFwiNjUlXCIgfCBcIjcwJVwiIHwgXCI3NSVcIiB8IFwiODAlXCIgfCBcIjg1JVwiIHwgXCI5MCVcIiB8IFwiOTUlXCIgfCBcIjEwMCVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYElQZXJjZW50TWF0aGAgaW50ZXJmYWNlIGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHBlcmNlbnQ+YCBDU1MgdHlwZXMuIFRoaXMgaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBbW1BlcmNlbnRdXSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElQZXJjZW50TWF0aCBleHRlbmRzIElOdW1lcmljTWF0aDxDc3NQZXJjZW50LCBQZXJjZW50VW5pdHM+XHJcbntcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIGA8bGVuZ3RoPmAgdHlwZS5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKiogVW5pdHMgb2YgbGVuZ3RoICovXHJcbmV4cG9ydCB0eXBlIExlbmd0aFVuaXRzID0gXCJRXCIgfCBcImNoXCIgfCBcImNtXCIgfCBcImVtXCIgfCBcImV4XCIgfCBcImljXCIgfCBcImluXCIgfCBcImxoXCIgfCBcIm1tXCIgfCBcInBjXCIgfFxyXG4gICAgICAgICAgICAgICAgXCJwdFwiIHwgXCJweFwiIHwgXCJ2YlwiIHwgXCJ2aFwiIHwgXCJ2aVwiIHwgXCJ2d1wiIHwgXCJyZW1cIiB8IFwicmxoXCIgfCBcInZtYXhcIiB8IFwidm1pblwiIHwgXCJmclwiO1xyXG5cclxuLyoqIFByb3h5IGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdmFsdWVzIG9mIHRoZSBgPGxlbmd0aD5gIENTUyB0eXBlICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUxlbmd0aFByb3h5IGV4dGVuZHMgSUdlbmVyaWNQcm94eTxMZW5ndGhVbml0cz4ge307XHJcblxyXG4vKipcclxuICogVHlwZSBmb3Igc2luZ2xlIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT5gIENTUyB0eXBlLiBWYWx1ZXMgb2YgdGhpcyB0eXBlXHJcbiAqIGNhbiBiZSBzcGVjaWZlZCBhczpcclxuICogLSBvbmUgb2YgcHJlLWRlZmluZWQgc3RyaW5ncyBsaWtlIGBcIjEwMHZoXCJgIG9yIGBcIjFmclwiYFxyXG4gKiAtIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsZW5ndGggdW5pdCBmdW5jdGlvbnMgc3VjaCBhcyBbW3JlbV1dLCBbW3ZoXV0sIFtbdm1pbl1dLCBbW3BlcmNlbnRdXSwgZXRjLlxyXG4gKiAtIGEgbnVtYmVyOlxyXG4gKiAgIC0gaWYgdGhlIG51bWJlciBpcyBhbiBpbnRlZ2VyLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBgXCJweFwiYCB1bml0c1xyXG4gKiAgIC0gaWYgdGhlIG51bWJlciBpcyBhIGZsb2F0aW5nIHBvaW50LCBpdCBpcyBpbnRlcnByZXRlZCBhcyBgXCJlbVwiYCB1bml0c1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ3NzTGVuZ3RoID0gQ3NzUGVyY2VudCB8IElMZW5ndGhQcm94eSB8XHJcbiAgICBcIjEwMHZoXCIgfCBcIjEwMHZ3XCIgfFxyXG4gICAgXCIxZnJcIiB8IFwiMmZyXCIgfCBcIjNmclwiIHwgXCI0ZnJcIiB8IFwiNWZyXCIgfCBcIjZmclwiIHwgXCI3ZnJcIiB8IFwiOGZyXCIgfCBcIjlmclwiIHwgXCIxMGZyXCIgfCBcIjExZnJcIiB8IFwiMTJmclwiO1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgdGhhdCBjb21iaW5lcyBbW0Nzc0xlbmd0aF1dIGFuZCB0aGUgc3RyaW5nIGxpdGVyYWwgYFwiYXV0b1wiYC4gVGhpcyB0eXBlIGlzIG9mdGVuIHVzZWQgd2hlbiBhXHJcbiAqIHByb3BlcnR5IGFjY2VwdHMgdGhlIGA8bGVuZ3RoPmAgdHlwZSBhbmQgdGhlIGBcImF1dG9cImAgbGl0ZXJhbCAtIGZvciBleGFtcGxlLCB3aGVuIHNwZWNpZnlpbmdcclxuICogbWFyZ2lucy5cclxuICovXHJcbmV4cG9ydCB0eXBlIENzc0xlbmd0aE9yQXV0byA9IENzc0xlbmd0aCB8IFwiYXV0b1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgSUxlbmd0aE1hdGhgIGludGVyZmFjZSBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxsZW5ndGg+YCBDU1MgdHlwZXMuIFRoaXMgaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBbW0xlbl1dIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUxlbmd0aE1hdGggZXh0ZW5kcyBJTnVtZXJpY01hdGg8Q3NzTGVuZ3RoLCBMZW5ndGhVbml0cyB8IFBlcmNlbnRVbml0cz5cclxue1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgYDxhbmdsZT5gIHR5cGUuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqIFVuaXRzIG9mIGFuZ2xlICovXHJcbmV4cG9ydCB0eXBlIEFuZ2xlVW5pdHMgPSBcImRlZ1wiIHwgXCJyYWRcIiB8IFwiZ3JhZFwiIHwgXCJ0dXJuXCI7XHJcblxyXG4vKiogUHJveHkgaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB2YWx1ZXMgb2YgdGhlIGA8YW5nbGU+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElBbmdsZVByb3h5IGV4dGVuZHMgSUdlbmVyaWNQcm94eTxBbmdsZVVuaXRzPiB7fTtcclxuXHJcbi8qKiBUeXBlIGZvciBzaW5nbGUgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGA8YW5nbGU+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgdHlwZSBDc3NBbmdsZSA9IG51bWJlciB8IElBbmdsZVByb3h5O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgSUFuZ2xlTWF0aGAgaW50ZXJmYWNlIGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPGFuZ2xlPmAgQ1NTIHR5cGVzLiBUaGlzIGludGVyZmFjZSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgW1tBbmdsZV1dIG9iamVjdC5cclxuICogVHlwZSBmb3Igc2luZ2xlIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT5gIENTUyB0eXBlLiBWYWx1ZXMgb2YgdGhpcyB0eXBlXHJcbiAqIGNhbiBiZSBzcGVjaWZlZCBhczpcclxuICogLSBvbmUgb2YgcHJlLWRlZmluZWQgc3RyaW5ncyBsaWtlIGBcIjEwMHZoXCJgIG9yIGBcIjFmclwiYFxyXG4gKiAtIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsZW5ndGggdW5pdCBmdW5jdGlvbnMgc3VjaCBhcyBbW3JlbV1dLCBbW3ZoXV0sIFtbdm1pbl1dLCBbW3BlcmNlbnRdXSwgZXRjLlxyXG4gKiAtIGEgbnVtYmVyOlxyXG4gKiAgIC0gaWYgdGhlIG51bWJlciBpcyBhbiBpbnRlZ2VyLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBgXCJkZWdcImAgdW5pdHNcclxuICogICAtIGlmIHRoZSBudW1iZXIgaXMgYSBmbG9hdGluZyBwb2ludCwgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYFwidHVyblwiYCB1bml0c1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJQW5nbGVNYXRoIGV4dGVuZHMgSU51bWVyaWNNYXRoPENzc0FuZ2xlLCBBbmdsZVVuaXRzIHwgUGVyY2VudFVuaXRzPlxyXG57XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIENTUyBgPHRpbWU+YCB0eXBlLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBVbml0cyBvZiB0aW1lICovXHJcbmV4cG9ydCB0eXBlIFRpbWVVbml0cyA9IFwic1wiIHwgXCJtc1wiO1xyXG5cclxuLyoqIFByb3h5IGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdmFsdWVzIG9mIHRoZSBgPHRpbWU+YCBDU1MgdHlwZSovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRpbWVQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8VGltZVVuaXRzPiB7fTtcclxuXHJcbi8qKiBUeXBlIGZvciBzaW5nbGUgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGA8dGltZT5gIENTUyB0eXBlICovXHJcbmV4cG9ydCB0eXBlIENzc1RpbWUgPSBudW1iZXIgfCBJVGltZVByb3h5O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgSVRpbWVNYXRoYCBpbnRlcmZhY2UgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlXHJcbiAqIGA8dGltZT5gIENTUyB0eXBlcy4gVGhpcyBpbnRlcmZhY2UgaXMgaW1wbGVtZW50ZWQgYnkgdGhlIFtbVGltZV1dIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRpbWVNYXRoIGV4dGVuZHMgSU51bWVyaWNNYXRoPENzc1RpbWUsIFRpbWVVbml0cz5cclxue1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgYDxyZXNvbHV0aW9uPmAgdHlwZS5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKiogVW5pdHMgb2YgcmVzb2x1dGlvbiAqL1xyXG5leHBvcnQgdHlwZSBSZXNvbHV0aW9uVW5pdHMgPSBcImRwaVwiIHwgXCJkcGNtXCIgfCBcImRwcHhcIiB8IFwieFwiO1xyXG5cclxuLyoqIFByb3h5IGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdmFsdWVzIG9mIHRoZSBgPHJlc29sdXRpb24+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElSZXNvbHV0aW9uUHJveHkgZXh0ZW5kcyBJR2VuZXJpY1Byb3h5PFJlc29sdXRpb25Vbml0cz4ge307XHJcblxyXG4vKiogVHlwZSBmb3Igc2luZ2xlIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBgPHJlc29sdXRpb24+YCBDU1MgdHlwZSAqL1xyXG5leHBvcnQgdHlwZSBDc3NSZXNvbHV0aW9uID0gbnVtYmVyIHwgSVJlc29sdXRpb25Qcm94eSB8XHJcbiAgICBcIjF4XCIgfCBcIjJ4XCIgfCBcIjN4XCIgfCBcIjR4XCIgfCBcIjV4XCIgfCBcIjZ4XCIgfCBcIjd4XCIgfCBcIjh4XCIgfCBcIjl4XCIgfCBcIjEweFwiIHxcclxuICAgIFwiMWRwcHhcIiB8IFwiMmRwcHhcIiB8IFwiM2RwcHhcIiB8IFwiNGRwcHhcIiB8IFwiNWRwcHhcIiB8IFwiNmRwcHhcIiB8IFwiN2RwcHhcIiB8IFwiOGRwcHhcIiB8IFwiOWRwcHhcIiB8IFwiMTBkcHB4XCI7XHJcblxyXG4vKipcclxuICogVGhlIGBJUmVzb2x1dGlvbk1hdGhgIGludGVyZmFjZSBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxyZXNvbHV0aW9uPmAgQ1NTIHR5cGVzLiBUaGlzIGludGVyZmFjZSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgW1tSZXNvbHV0aW9uXV0gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUmVzb2x1dGlvbk1hdGggZXh0ZW5kcyBJTnVtZXJpY01hdGg8Q3NzUmVzb2x1dGlvbiwgUmVzb2x1dGlvblVuaXRzPlxyXG57XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIENTUyBgPGZyZXF1ZW5jeT5gIHR5cGUuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqIFVuaXRzIG9mIGZyZXF1ZW5jeSAqL1xyXG5leHBvcnQgdHlwZSBGcmVxdWVuY3lVbml0cyA9IFwiSHpcIiB8IFwia0h6XCI7XHJcblxyXG4vKiogUHJveHkgaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB2YWx1ZXMgb2YgdGhlIGA8ZnJlcXVlbmN5PmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJRnJlcXVlbmN5UHJveHkgZXh0ZW5kcyBJR2VuZXJpY1Byb3h5PEZyZXF1ZW5jeVVuaXRzPiB7fTtcclxuXHJcbi8qKiBUeXBlIGZvciBzaW5nbGUgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGA8ZnJlcXVlbmN5PmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IHR5cGUgQ3NzRnJlcXVlbmN5ID0gbnVtYmVyIHwgSUZyZXF1ZW5jeVByb3h5O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgSUZyZXF1ZW5jeU1hdGhgIGludGVyZmFjZSBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxmcmVxdWVuY3k+YCBDU1MgdHlwZXMuIFRoaXMgaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBbW0ZyZXF1ZW5jeV1dIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUZyZXF1ZW5jeU1hdGggZXh0ZW5kcyBJTnVtZXJpY01hdGg8Q3NzRnJlcXVlbmN5LCBGcmVxdWVuY3lVbml0cz5cclxue1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBTaXplLCBQb2ludCwgUG9zaXRpb24sIFJhZGl1c1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBUeXBlIGZvciBgd2lkdGhgLCBgaGVpZ2h0YCwgYGJsb2NrLXNpemVgIGFuZCBgaW5saW5lLXNpemVgIHN0eWxlIHByb3BlcnRpZXMgKi9cclxuZXhwb3J0IHR5cGUgQ3NzU2l6ZSA9IFwiYXV0b1wiIHwgXCJtYXgtY29udGVudFwiIHwgXCJtaW4tY29udGVudFwiIHwgXCJmaXQtY29udGVudFwiIHwgXCJzdHJldGNoXCIgfFxyXG4gICAgQ3NzTGVuZ3RoIHwgSUZpdENvbnRlbnRQcm94eTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgSUZpdENvbnRlbnRQcm94eSBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBDU1MgYGZpdC1jb250ZW50KClgIGZ1bmN0aW9uLiBJdFxyXG4gKiBpcyByZXR1cm5lZCBmcm9tIHRoZSBbW2ZpdENvbnRlbnRdXSBmdW5jdGlvbi5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUZpdENvbnRlbnRQcm94eSBleHRlbmRzIElHZW5lcmljUHJveHk8XCJmaXQtY29udGVudFwiPiB7fVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSByZXByZXNlbnRpbmcgYSBwb2ludCBhcyBhIHR3byBlbGVtZW50IHR1cGxlIHdoZXJlIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIHNwZWNpZmllZCB1c2luZ1xyXG4gKiB0aGUgW1tDc3NMZW5ndGhdXSB0eXBlLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ3NzUG9pbnQgPSBbRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiwgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPl07XHJcblxyXG5cclxuXHJcbi8qKiBIb3Jpem9udGFsIHBvc2l0aW9uIGtleXdvcmRzICovXHJcbmV4cG9ydCB0eXBlIEhvcml6b250YWxQb3NpdGlvbktleXdvcmQgPSBcImxlZnRcIiB8IFwiY2VudGVyXCIgfCBcInJpZ2h0XCI7XHJcblxyXG4vKiogVHlwZSBvZiBhIHZhbHVlIHNwZWNpZnlpbmcgdGhlIGhvcml6b250YWwgcG9zaXRpb24gKi9cclxuZXhwb3J0IHR5cGUgSG9yaXpvbnRhbFBvc2l0aW9uID0gSG9yaXpvbnRhbFBvc2l0aW9uS2V5d29yZCB8IENzc0xlbmd0aDtcclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgaG9yaXpvbnRhbCBwb3NpdGlvbiBDU1MgdHlwZSBjb25zaXN0aW5nIG9mIDIgdmFsdWVzIHVzaW5nIGEgdHVwbGUgKi9cclxuZXhwb3J0IHR5cGUgSG9yaXpvbnRhbFBvc2l0aW9uVHVwbGUgPSBbRXh0ZW5kZWQ8SG9yaXpvbnRhbFBvc2l0aW9uS2V5d29yZD4sIEV4dGVuZGVkPENzc0xlbmd0aD5dO1xyXG5cclxuLyoqIFZlcnRpY2FsIHBvc2l0aW9uIGtleXdvcmRzICovXHJcbmV4cG9ydCB0eXBlIFZlcnRpY2FsUG9zaXRpb25LZXl3b3JkID0gXCJ0b3BcIiB8IFwiY2VudGVyXCIgfCBcImJvdHRvbVwiO1xyXG5cclxuLyoqIFR5cGUgb2YgYSB2YWx1ZSBzcGVjaWZ5aW5nIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiAqL1xyXG5leHBvcnQgdHlwZSBWZXJ0aWNhbFBvc2l0aW9uID0gVmVydGljYWxQb3NpdGlvbktleXdvcmQgfCBDc3NMZW5ndGg7XHJcblxyXG4vKiogVHlwZSBkZXNjcmliaW5nIHZlcnRpY2FsIHBvc2l0aW9uIENTUyB0eXBlIGNvbnNpc3Rpbmcgb2YgMiB2YWx1ZXMgdXNpbmcgYSB0dXBsZSAqL1xyXG5leHBvcnQgdHlwZSBWZXJ0aWNhbFBvc2l0aW9uVHVwbGUgPSBbRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxDc3NMZW5ndGg+XTtcclxuXHJcblxyXG5cclxuLyoqIFR5cGUgZGVzY3JpYmluZyBgPHBvc2l0aW9uLXg+YCBDU1MgdHlwZSBjb25zaXN0aW5nIG9mIHVwIHRvIDIgdmFsdWVzICovXHJcbmV4cG9ydCB0eXBlIENzc1Bvc2l0aW9uWCA9IEhvcml6b250YWxQb3NpdGlvbiB8IEhvcml6b250YWxQb3NpdGlvblR1cGxlO1xyXG5cclxuLyoqIFR5cGUgZGVzY3JpYmluZyBtdWx0aXBsZSBgPHBvc2l0aW9uLXg+YCBDU1MgdHlwZXMgY29uc2lzdGluZyBvZiB1cCB0byAyIHZhbHVlcyAqL1xyXG5leHBvcnQgdHlwZSBDc3NNdWx0aVBvc2l0aW9uWCA9IENzc1Bvc2l0aW9uWCB8IChbRXh0ZW5kZWQ8SG9yaXpvbnRhbFBvc2l0aW9uPl0gfCBFeHRlbmRlZDxIb3Jpem9udGFsUG9zaXRpb25UdXBsZT4pW107XHJcblxyXG5cclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgYDxwb3NpdGlvbi15PmAgQ1NTIHR5cGUgY29uc2lzdGluZyBvZiB1cCB0byAyIHZhbHVlcyAqL1xyXG5leHBvcnQgdHlwZSBDc3NQb3NpdGlvblkgPSBWZXJ0aWNhbFBvc2l0aW9uIHwgVmVydGljYWxQb3NpdGlvblR1cGxlO1xyXG5cclxuLyoqIFR5cGUgZGVzY3JpYmluZyBtdWx0aXBsZSBgPHBvc2l0aW9uLXk+YCBDU1MgdHlwZXMgY29uc2lzdGluZyBvZiB1cCB0byAyIHZhbHVlcyAqL1xyXG5leHBvcnQgdHlwZSBDc3NNdWx0aVBvc2l0aW9uWSA9IENzc1Bvc2l0aW9uWSB8IChbRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvbj5dIHwgRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvblR1cGxlPilbXTtcclxuXHJcblxyXG5cclxuLyoqIFR5cGUgZGVzY3JpYmluZyBhIHNpbmdsZSBpdGVtIGluIHRoZSBgPHBvc2l0aW9uPmAgQ1NTIHR5cGUgKi9cclxuZXhwb3J0IHR5cGUgQ3NzUG9zaXRpb25JdGVtID0gSG9yaXpvbnRhbFBvc2l0aW9uS2V5d29yZCB8IFZlcnRpY2FsUG9zaXRpb25LZXl3b3JkIHwgQ3NzTGVuZ3RoO1xyXG5cclxuLyoqIFR5cGUgZGVzY3JpYmluZyBgPHBvc2l0aW9uPmAgQ1NTIHR5cGUgY29uc2lzdGluZyBvZiAxIHRvIDQgdmFsdWVzIHVzaW5nIHRvdXBsZXMgKi9cclxuZXhwb3J0IHR5cGUgQ3NzUG9zaXRpb25UdXBsZSA9XHJcbiAgICBbRXh0ZW5kZWQ8SG9yaXpvbnRhbFBvc2l0aW9uPiwgRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvbj5dIHxcclxuICAgIFtFeHRlbmRlZDxWZXJ0aWNhbFBvc2l0aW9uPiwgRXh0ZW5kZWQ8SG9yaXpvbnRhbFBvc2l0aW9uPl0gfFxyXG4gICAgW0V4dGVuZGVkPEhvcml6b250YWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxWZXJ0aWNhbFBvc2l0aW9uS2V5d29yZD4sIEV4dGVuZGVkPENzc0xlbmd0aD5dIHxcclxuICAgIFtFeHRlbmRlZDxIb3Jpem9udGFsUG9zaXRpb25LZXl3b3JkPiwgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiwgRXh0ZW5kZWQ8VmVydGljYWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxDc3NMZW5ndGg+P10gfFxyXG4gICAgW0V4dGVuZGVkPFZlcnRpY2FsUG9zaXRpb25LZXl3b3JkPiwgRXh0ZW5kZWQ8SG9yaXpvbnRhbFBvc2l0aW9uS2V5d29yZD4sIEV4dGVuZGVkPENzc0xlbmd0aD5dIHxcclxuICAgIFtFeHRlbmRlZDxWZXJ0aWNhbFBvc2l0aW9uS2V5d29yZD4sIEV4dGVuZGVkPENzc0xlbmd0aD4sIEV4dGVuZGVkPEhvcml6b250YWxQb3NpdGlvbktleXdvcmQ+LCBFeHRlbmRlZDxDc3NMZW5ndGg+P107XHJcblxyXG4vKiogVHlwZSBkZXNjcmliaW5nIGA8cG9zaXRpb24+YCBDU1MgdHlwZSBjb25zaXN0aW5nIG9mIHVwIHRvIDQgdmFsdWVzICovXHJcbmV4cG9ydCB0eXBlIENzc1Bvc2l0aW9uID0gQ3NzUG9zaXRpb25JdGVtIHwgQ3NzUG9zaXRpb25UdXBsZTtcclxuXHJcbi8qKiBUeXBlIGRlc2NyaWJpbmcgbXVsdGlwbGUgYDxwb3NpdGlvbj5gIENTUyB0eXBlcyBjb25zaXN0aW5nIG9mIHVwIHRvIDQgdmFsdWVzICovXHJcbmV4cG9ydCB0eXBlIENzc011bHRpUG9zaXRpb24gPSBDc3NQb3NpdGlvbiB8IChbRXh0ZW5kZWQ8Q3NzUG9zaXRpb25JdGVtPl0gfCBFeHRlbmRlZDxDc3NQb3NpdGlvblR1cGxlPilbXTtcclxuXHJcblxyXG5cclxuLyoqIFR5cGUgZm9yIGEgc2luZ2xlIGNvcm5lciByYWRpdXMgKi9cclxuZXhwb3J0IHR5cGUgQ3NzUmFkaXVzID0gT25lT3JQYWlyPENzc0xlbmd0aD47XHJcblxyXG5cclxuXHJcbi8qKiBUeXBlIGZvciBib3JkZXItcmFkaXVzIHN0eWxlIHByb3BlcnR5ICovXHJcbmV4cG9ydCB0eXBlIEJvcmRlclJhZGl1c0l0ZW0gPSBbRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiwgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPj8sIEV4dGVuZGVkPENzc0xlbmd0aD4/LCBFeHRlbmRlZDxDc3NMZW5ndGg+P107XHJcblxyXG4vKiogVHlwZSBmb3IgYm9yZGVyLXJhZGl1cyBzdHlsZSBwcm9wZXJ0eSAqL1xyXG5leHBvcnQgdHlwZSBCb3JkZXJSYWRpdXMgPSBPbmVPckJveDxDc3NMZW5ndGg+IHwgW0JvcmRlclJhZGl1c0l0ZW0sIEJvcmRlclJhZGl1c0l0ZW1dO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQXNwZWN0IFJhdGlvXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBJQXNwZWN0UmF0aW9Qcm94eSBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBbW3JhdGlvXV0gZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElBc3BlY3RSYXRpb1Byb3h5IGV4dGVuZHMgSUdlbmVyaWNQcm94eTxcImFzcGVjdC1yYXRpb1wiPiB7fVxyXG5cclxuLyoqXHJcbiAqIFRoZSBgQ3NzQXNwZWN0UmF0aW9gIHR5cGUgcmVwcmVzZW50cyB0aGUgQ1NTIGA8cmF0aW8+YCB0eXBlLiBUaGlzIHR5cGUgY2FuIGJlIHVzZWQgZm9yIHRoZVxyXG4gKiBgYXNwZWN0LXJhdGlvYCBDU1MgcHJvcGVydHkgYW5kIGJ5IHRoZSBgYXNwZWN0LXJhdGlvYCBtZWRpYSBmZWF0dXJlIGluIGEgYEBtZWRpYWAgcnVsZS5cclxuICpcclxuICogKipFeGFtcGxlczoqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyB1c2luZyBwcmUtZGVmaW5lZCBzdHJpbmcgbGl0ZXJhbCB2YWx1ZVxyXG4gKiAgICAgY2xhc3MxID0gdGhpcy4kY2xhc3MoIHthc3BlY3RSYXRpbzogXCI0LzNcIn0pXHJcbiAqXHJcbiAqICAgICAvLyB1c2luZyB0aGUgYHJhdGlvKClgIGZ1bmN0aW9uXHJcbiAqICAgICBjbGFzczIgPSB0aGlzLiRjbGFzcygge2FzcGVjdFJhdGlvOiBjc3MucmF0aW8oIDQsIDMpfSlcclxuICpcclxuICogICAgIC8vIHVzaW5nIGEgc2luZ2xlIG51bWJlclxyXG4gKiAgICAgbWVkaWFSdWxlMSA9IHRoaXMuJG1lZGlhKCB7YXNwZWN0UmF0aW86IDEuMzN9LCAuLi4pXHJcbiAqXHJcbiAqICAgICAvLyB1c2luZyBhIHR1cGxlIHRvIHNwZWNpZnkgcmFuZ2U7IHRoaXMgd2lsbCByZXN1bHQgaW4gdGhlIGZvbGxvd2luZyBtZWRpYSBjb25kaXRpb246XHJcbiAqICAgICAvLyAobWluLWFzcGVjdC1yYXRpbzogNC8zKSBhbmQgKG1heC1hc3BlY3QtcmF0aW86MTYvOSlcclxuICogICAgIG1lZGlhUnVsZTIgPSB0aGlzLiRtZWRpYSgge2FzcGVjdFJhdGlvOiBbXCI0LzNcIixcIjE2LzlcIl19LCAuLi4pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDc3NBc3BlY3RSYXRpbyA9IENzc051bWJlciB8IElBc3BlY3RSYXRpb1Byb3h5IHwgXCIxLzFcIiB8IFwiNC8zXCIgfCBcIjE2LzlcIiB8IFwiMTg1LzEwMFwiIHwgXCIyMzkvMTAwXCI7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyByZWN0KCkgZnVuY3Rpb24gZm9yIGNsaXAgcHJvcGVydHlcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogVGhlIGBJUmVjdFByb3h5YCBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBbW3JlY3RdXSBmdW5jdGlvbiB1c2VkIGZvciB0aGUgYGNsaXBgXHJcbiAqIHN0eWxlIHByb3BlcnR5LlxyXG4gKiBAZGVwcmVjYXRlZCBUaGUgQ1NTIGBjbGlwYCBwcm9wZXJ0eSBhbmQgYHJlY3QoKWAgZnVuY3Rpb24gYXJlIGRlcHJlY2F0ZWQuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElSZWN0UHJveHkgZXh0ZW5kcyBJR2VuZXJpY1Byb3h5PFwicmVjdFwiPiB7fVxyXG5cclxuIiwi77u/aW1wb3J0IHtDc3NTZWxlY3RvciwgUGFnZVBzZXVkb0NsYXNzLCBPbmVPck1hbnksIEVsZW1lbnRUYWdOYW1lLCBFeHRlbmRlZFByb3B9IGZyb20gXCIuL0NvcmVUeXBlc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgSVN0eWxlUnVsZSwgSUNsYXNzUnVsZSwgSUlEUnVsZSwgQW5pbWF0aW9uRnJhbWUsIElBbmltYXRpb25SdWxlLCBJVmFyUnVsZSxcclxuICAgIElDb3VudGVyUnVsZSwgSUdyaWRMaW5lUnVsZSwgSUdyaWRBcmVhUnVsZSwgSUltcG9ydFJ1bGUsIElGb250RmFjZVJ1bGUsIElOYW1lc3BhY2VSdWxlLCBJUGFnZVJ1bGUsXHJcbiAgICBJU3R5bGVEZWZpbml0aW9uQ2xhc3MsIElTdXBwb3J0c1J1bGUsIElNZWRpYVJ1bGUsIElDbGFzc05hbWVSdWxlLCBJQ29uc3RSdWxlLCBDbGFzc1Byb3BUeXBlLFxyXG4gICAgTmFtZUdlbmVyYXRpb25NZXRob2QsIElDb3VudGVyU3R5bGVSdWxlLCBJU3R5bGVEZWZpbml0aW9uXHJcbn0gZnJvbSBcIi4vUnVsZVR5cGVzXCI7XHJcbmltcG9ydCB7TWVkaWFTdGF0ZW1lbnQsIFN1cHBvcnRzU3RhdGVtZW50fSBmcm9tIFwiLi9NZWRpYVR5cGVzXCJcclxuaW1wb3J0IHtFeHRlbmRlZEZvbnRGYWNlfSBmcm9tIFwiLi9Gb250VHlwZXNcIjtcclxuaW1wb3J0IHtFeHRlbmRlZENvdW50ZXJTdHlsZXNldH0gZnJvbSBcIi4vQ291bnRlclR5cGVzXCI7XHJcbmltcG9ydCB7U3R5bGVzZXQsIFZhclRlbXBsYXRlTmFtZSwgRXh0ZW5kZWRWYXJWYWx1ZSwgQ29tYmluZWRTdHlsZXNldCwgQ29tYmluZWRDbGFzc1N0eWxlc2V0LCBJU3ludGF4VHlwZVN0eWxlc2V0fSBmcm9tIFwiLi9TdHlsZXNldHNcIjtcclxuaW1wb3J0IHtlbWJlZGRlZERlY29yYXRvciwgZ2V0Q3VycmVudFRoZW1lLCBwcm9jZXNzU0QsIGNvbmZpZ05hbWVzLCBSdWxlQ29udGFpbmVyfSBmcm9tIFwiLi4vcnVsZXMvUnVsZUNvbnRhaW5lclwiO1xyXG5pbXBvcnQge0Fic3RyYWN0UnVsZSwgQ2xhc3NSdWxlLCBJRFJ1bGUsIFNlbGVjdG9yUnVsZX0gZnJvbSBcIi4uL3J1bGVzL1N0eWxlUnVsZXNcIlxyXG5pbXBvcnQge0FuaW1hdGlvblJ1bGV9IGZyb20gXCIuLi9ydWxlcy9BbmltYXRpb25SdWxlXCJcclxuaW1wb3J0IHtWYXJSdWxlLCBDb25zdFJ1bGUsIFByb3BlcnR5UnVsZX0gZnJvbSBcIi4uL3J1bGVzL1ZhclJ1bGVcIlxyXG5pbXBvcnQge0NvdW50ZXJSdWxlLCBDb3VudGVyU3R5bGVSdWxlfSBmcm9tIFwiLi4vcnVsZXMvQ291bnRlclJ1bGVzXCI7XHJcbmltcG9ydCB7R3JpZExpbmVSdWxlLCBHcmlkQXJlYVJ1bGV9IGZyb20gXCIuLi9ydWxlcy9HcmlkUnVsZXNcIjtcclxuaW1wb3J0IHtGb250RmFjZVJ1bGUsIEltcG9ydFJ1bGUsIE5hbWVzcGFjZVJ1bGUsIFBhZ2VSdWxlLCBDbGFzc05hbWVSdWxlfSBmcm9tIFwiLi4vcnVsZXMvTWlzY1J1bGVzXCJcclxuaW1wb3J0IHtTdXBwb3J0c1J1bGUsIE1lZGlhUnVsZX0gZnJvbSBcIi4uL3J1bGVzL0dyb3VwUnVsZXNcIlxyXG5pbXBvcnQge3Yyc30gZnJvbSBcIi4uL2ltcGwvVXRpbHNcIjtcclxuaW1wb3J0IHtnZXRBY3RpdmF0b3J9IGZyb20gXCIuLi9pbXBsL1NjaGVkdWxpbmdJbXBsXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTeW1ib2wgdGhhdCBpcyB1c2VkIGJ5IHRoZSBgJHBhcmVudGAgcHJvcGVydHkgaW4gdGhlIFN0eWxlRGVmaW5pdGlvbiBjbGFzcyB0aGF0IGtlZXBzIHJlZmVyZW5jZVxyXG4gKiB0byB0aGUgcGFybnQgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gRGV2ZWxvcGVycyBjYW4gdXNlIHRoaXMgcHJvcGVydHkgdG8gYWNjZXNzIHJ1bGVzIGluXHJcbiAqIHRoZSBjaGFpbiBvZiBuZXN0ZWQgZ3JvdXBpbmcgcnVsZXMuIFdlIG5lZWQgdGhpcyBzeW1ib2wgdG8gYXZvaWQgZW51bWVyYXRpbmcgdGhlIGAkcGFyZW50YFxyXG4gKiBwcm9wZXJ0eSB3aGVuIHByb2Nlc3NpbmcgdGhlIHJ1bGVzIGluIHRoZSBzdHlsZSBkZWZpbml0aW9uIG9iamVjdC5cclxuICovXHJcbmNvbnN0IHN5bVBhcmVudCA9IFN5bWJvbChcInBhcmVudFwiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgU3R5bGVEZWZpbml0aW9uYCBjbGFzcyBpcyBhIGJhc2UgZm9yIGFsbCBjbGFzc2VzIHRoYXQgY29udGFpbiBkZWZpbmluaXRpb25zIG9mIENTUyBydWxlcy5cclxuICogU3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIGFyZSByZWd1bGFyIFR5cGVTY3JpcHQgY2xhc3NlcyBhbmQgYXMgc3VjaCBjYW4gaGF2ZSBhbnkgZmllbGRzIGFuZFxyXG4gKiBtZXRob2RzIC0gYm90aCBpbnN0YW5jZSBhbmQgc3RhdGljLiBOb3JtYWxseSwgaG93ZXZlciwgdGhleSBjb250YWluIGluc3RhbmNlIHByb3BlcnRpZXNcclxuICogaW5pdGlhbGl6ZWQgd2l0aCBmdW5jdGlvbnMgcmV0dXJuaW5nIHN0eWxlIHJ1bGVzIGFuZCBhdC1ydWxlcywgc3VjaCBhcyBbWyRjbGFzc11dLFxyXG4gKiBbWyR0YWddXSwgW1skbWVkaWFdXSwgW1skY291bnRlcl1dIGFuZCBvdGhlcnMuXHJcbiAqXHJcbiAqICoqRXhhbXBsZXMqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIC8vIHRvcC1sZXZlbCBzdHlsZSBkZWZpbml0aW9uIGNsYXNzXHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICBjbHMgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiBcInJlZFwifSlcclxuICpcclxuICogICAgIC8vIHVzaW5nIHN0eWxlLWRlZmluaXRpb24gY2xhc3MgZm9yIEBtZWRpYSBydWxlXHJcbiAqICAgICBpZk5hcnJvd1NjcmVlbiA9IHRoaXMuJG1lZGlhKCB7IG1heFdpZHRoOiA4MDAgfSxcclxuICogICAgICAgICBjbGFzcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb248TXlTdHlsZXM+XHJcbiAqICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICBjbHMgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiBcInBpbmtcIn0pXHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFAgUGFyZW50IHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFBhcmVudCBvZiBhIHRvcC1sZXZlbCBjbGFzcyBpcyBudWxsLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0eWxlRGVmaW5pdGlvbjxQIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uID0gYW55PiBpbXBsZW1lbnRzIElTdHlsZURlZmluaXRpb248UD5cclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlcyBhcmUgY3JlYXRlZCBkaXJlY3RseSBvbmx5IGJ5IHRoZSAqc3R5bGVkIGNvbXBvbmVudHMqIC0gdGhhdCBpcyxcclxuICAgICAqIGNvbXBvbmVudHMgdGhhdCB1c2UgZGlmZmVyZW50IHN0eWxlcyBmb3IgZWFjaCBpbnN0YW5jZS4gT3RoZXJ3aXNlLCBzdHlsZSBkZWZpbml0aW9uXHJcbiAgICAgKiBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgd2hlbiBlaXRoZXIgdGhlIFtbJHVzZV1dIG1ldGhvZCBvciBbW2FjdGl2YXRlXV0gZnVuY3Rpb24gaXMgY2FsbGVkLlxyXG4gICAgICogQHBhcmFtIHBhcmVudCBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBzdHlsZSBkZWZpbml0aW9uIGNsYXNzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciggcGFyZW50PzogUClcclxuICAgIHtcclxuICAgICAgICB0aGlzW3N5bVBhcmVudF0gPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgIC8vIGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGluc3RhbmNlIG9mIG91ciBjbGFzcywgdGhlIGNvbnN0cnVjdG9yIHJldHVybnMgYSBwcm94eS4gVGhpc1xyXG4gICAgICAgIC8vIGFsbG93cyBjcmVhdGluZyBwcm94aWVzIGZvciBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBjbGFzcywgd2hpY2ggYWxsb3dzIHByb2Nlc3NpbmdcclxuICAgICAgICAvLyB0aGUgcHJvcGVydGllcyBpbW1lZGlhdGVseSB1cG9uIGRlZmluaXRpb24uXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eTxTdHlsZURlZmluaXRpb248UD4+KCB0aGlzLCBuZXcgUnVsZUNvbnRhaW5lciggdGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJzIHRvIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB3aGljaCBpcyB0aGUgcGFybnQgb2YgdGhpcyBzdHlsZVxyXG4gICAgICogZGVmaW5pdGlvbiBvYmplY3QgaW4gdGhlIGNoYWluIG9mIHN0eWxlIGRlZmluaXRpb24gY2xhc3Nlcy4gVGhyb3VnaCB0aGlzIG1lbWJlciwgYWxsIHJ1bGVzXHJcbiAgICAgKiBhbmQgb3RoZXIgbWVtYmVycyBkZWZpbmVkIGluIHRoZSBwYXJlbnQgZGVmaW5pdGlvbiBjbGFzcyBjYW4gYmUgYWNjZXNzZWQuIEZvciB0b3AtbGV2ZWxcclxuICAgICAqIHN0eWxlIGRlZmluaXRpb25zLCB0aGlzIHByb3BlcnR5IGlzIGFsd2F5cyB1bmRlZmluZWQuIFRoaXMgcHJvcGVydHkgY2FuIGFsc28gYmUgdW5kZWZpbmVkXHJcbiAgICAgKiBpZiBpdCB3YXMgbm90IHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciB3aGVuIGNyZWF0aW5nIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIG1hbnVhbGx5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgJHBhcmVudGAgcmVmZXJlbmNlIGlzIHVzZWQgd2hlbiB0aGVyZSBpcyBhIG5lZWQgdG8gcmVmZXIgZnJvbSBncm91cGluZyBydWxlcyAoY3JlYXRlZFxyXG4gICAgICogYnkgYCRtZWRpYSgpYCBvciBgJHN1cHBvcnQoKWAgZnVuY3Rpb25zKSB0byB0aGUgcnVsZXMgZGVmaW5lZCBpbiB0aGUgcGFyZW50IHN0eWxlIGRlZmluaXRpb25cclxuICAgICAqIGNsYXNzLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgbmVzdGVkIGdyb3VwaW5nIHJ1bGVzLCB0aGVuIHRoZSBjb25zdHVjdCBgdGhpcy4kcGFyZW50LiRwYXJlbnQuLi5gXHJcbiAgICAgKiBhbGxvd3MgcmVhY2hpbmcgdG8gcnVsZXMgZGVmaW5lZCBpbiBhbnkgYW5jZXN0b3Igc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBkZWZhdWx0Q29sb3IgPSB0aGlzLiR2YXIoIFwiY29sb3JcIiwgXCJibHVlXCIpXHJcbiAgICAgKlxyXG4gICAgICogICAgIGlmU21hbGxTY3JlZW4gPSB0aGlzLiRtZWRpYSggeyBtYXhXaWR0aDogNjAwIH0sXHJcbiAgICAgKiAgICAgICAgIGNsYXNzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvbjxNeVN0eWxlcz5cclxuICAgICAqICAgICAgICAge1xyXG4gICAgICogICAgICAgICAgICAgcCA9IHRoaXMuJHN0eWxlKCBcInBcIiwgeyBjb2xvcjogdGhpcy4kcGFyZW50LmRlZmF1bHRDb2xvciB9KVxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgKVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgJHBhcmVudCgpOiBQIHwgdW5kZWZpbmVkIHsgcmV0dXJuIHRoaXNbc3ltUGFyZW50XTsgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFic3RyYWN0IHJ1bGUsIHdoaWNoIGRlZmluZXMgYSBzdHlsZXNldCB0aGF0IGNhbiBiZSBleHRlbmRlZCBieSBvdGhlciBzdHlsZSBydWxlcy5cclxuICAgICAqIEFic3RyYWN0IHJ1bGVzIGRvbid0IGhhdmUgc2VsZWN0b3JzIGFuZCBhcmUgbm90IGluc2VydGVkIGludG8gdGhlIERPTS4gQWJzdHJhY3QgcnVsZXMgY2FuXHJcbiAgICAgKiB0aGVtc2VsdmVzIGV4dGVuZCBvdGhlciBydWxlcyAtIGJvdGggYWJzdHJhY3QgYW5kIG5vbi1hYnN0cmFjdC5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBjb2xvckJveCA9IHRoaXMuJGFic3RyYWN0KHtcclxuICAgICAqICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIm9yYW5nZVwiLFxyXG4gICAgICogICAgICAgICBib3JkZXJSYWRpdXM6IGNzcy5wZXJjZW50KDEwKSxcclxuICAgICAqICAgICAgICAgYm9yZGVyOiBbNCwgXCJzb2xpZFwiLCBcInJlZFwiXSxcclxuICAgICAqICAgICAgICAgXCI6aG92ZXJcIjoge1xyXG4gICAgICogICAgICAgICAgICAgb3BhY2l0eTogMC43XHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICB9KVxyXG4gICAgICpcclxuICAgICAqICAgICBib3ggPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIFwiK1wiOiB0aGlzLmNvbG9yQm94LFxyXG4gICAgICogICAgICAgICB3aWR0aDogMjAwLFxyXG4gICAgICogICAgICAgICBoZWlnaHQ6IDIwMCxcclxuICAgICAqICAgICB9KVxyXG4gICAgICpcclxuICAgICAqICAgICBzcGVjaWFsRWxtID0gdGhpcy4kaWQoe1xyXG4gICAgICogICAgICAgICBcIitcIjogdGhpcy5jb2xvckJveCxcclxuICAgICAqICAgICAgICAgd2lkdGg6IDYwMCxcclxuICAgICAqICAgICAgICAgaGVpZ2h0OiA0MDAsXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHlsZXNldCBPbmUgb3IgbW9yZSBzdHlsZXNldCBvYmplY3RzIHRoYXQgd2lsbCBiZSBpbmhlcml0ZWQgYnkgc3R5bGUgcnVsZXMgdGhhdFxyXG4gICAgICogZXh0ZW5kIHRoaXMgYWJzdHJhY3QgcnVsZS5cclxuICAgICAqIEByZXR1cm5zIGBJU3R5bGVSdWxlYCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCBieSB0aGUgZGVyaXZlZCBydWxlcyBpbiB0aGUgYFwiK1wiYCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRhYnN0cmFjdCggc3R5bGVzZXQ6IENvbWJpbmVkU3R5bGVzZXQgfCBDb21iaW5lZFN0eWxlc2V0W10pOiBJU3R5bGVSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBYnN0cmFjdFJ1bGUoIHN0eWxlc2V0KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGFzcyBydWxlLiBUaGUgY2xhc3MgbmFtZSB3aWxsIGJlIGNyZWF0ZWQgd2hlbiB0aGUgcnVsZSBpcyBwcm9jZXNzZWQgYXMgcGFydCBvZlxyXG4gICAgICogdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBuYW1lIGNhbiBiZSBhbHNvIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nIGVpdGhlciBhbiBleHBsaWNpdFxyXG4gICAgICogbmFtZSBvciBhbm90aGVyIGNsYXNzIHJ1bGUuIFRoZSBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgcGFyYW1ldGVycyBqdXN0IHRvIFwiZGVjbGFyZVwiXHJcbiAgICAgKiB0aGUgY2xhc3MuIFN1Y2ggY2xhc3MgY2FuIGJlIGxhdGVyIHVzZWQgZWl0aGVyIGluIGNvbmRpdGlvbmFsIGdyb3VwaW5nIHJ1bGVzIG9yIGluIGRlcml2ZWRcclxuICAgICAqIHN0eWxlIGRlZmluaXRpb24gY2xhc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcmV0dXJuZWQgW1tJQ2xhc3NSdWxlXV0gaW50ZXJmYWNlIGhhcyB0aGUgYG5hbWVgIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gYXNzaWduXHJcbiAgICAgKiB0aGUgY2xhc3MgdG8gYW4gSFRNTCBlbGVtZW50XHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgdmJveCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgKiAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXHJcbiAgICAgKiAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogLi4uXHJcbiAgICAgKiBsZXQgc3R5bGVzID0gY3NzLmFjdGl2YXRlKCBNeUNsYXNzZXMpO1xyXG4gICAgICogLi4uXHJcbiAgICAgKiByZW5kZXJcclxuICAgICAqIHtcclxuICAgICAqICAgICByZXR1cm4gPGRpdiBjbGFzcz17c3R5bGVzLnZib3gubmFtZX0+XHJcbiAgICAgKiAgICAgICAgIDxzcGFuPkhlbGxvPC9zcGFuPlxyXG4gICAgICogICAgICAgICA8c3Bhbj5Xb3JsZCE8L3NwYW4+XHJcbiAgICAgKiAgICAgPC9kaXY+XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVzZXQgT25lIG9yIG1vcmUgc3R5bGVzZXQgb2JqZWN0cyB0aGF0IGRlZmluZSBzdHlsZSBwcm9wZXJ0aWVzIG9mIHRoZSBjbGFzcy5cclxuICAgICAqIEBwYXJhbSBuYW1lT3ZlcnJpZGUgc3RyaW5nIG9yIGFub3RoZXIgYElDbGFzc1J1bGVgIG9iamVjdCB0aGF0IGRldGVybWluZXMgdGhlIG5hbWUgb2YgdGhlIGNsYXNzLlxyXG4gICAgICogSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWUgYXNzaWdubWVudFxyXG4gICAgICogbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBjbGFzcyB0byBtYXRjaCBhIG5hbWUgb2YgYW5vdGhlcixcclxuICAgICAqIHByb2JhYmx5IGV4dGVybmFsLCBjbGFzcy5cclxuICAgICAqIEByZXR1cm5zIGBJQ2xhc3NSdWxlYCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgZ2V0dGluZyB0aGUgY2xhc3MgbmFtZSBhbmQgZm9yIGFjY2Vzc2luZ1xyXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgaWYgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGNsYXNzKCBzdHlsZXNldD86IENvbWJpbmVkQ2xhc3NTdHlsZXNldCB8IENvbWJpbmVkQ2xhc3NTdHlsZXNldFtdLFxyXG4gICAgICAgIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElDbGFzc1J1bGUpOiBJQ2xhc3NSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGFzc1J1bGUoIHN0eWxlc2V0LCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsYXNzIG5hbWUgcnVsZSwgd2hpY2ggY29tYmluZXMgb25lIG9yIG1vcmUgb3RoZXIgY2xhc3MgbmFtZXMuIFRoaXMgY3JlYXRlcyBhXHJcbiAgICAgKiBcInN5bm9ueW1cIiB0aGF0IGlzIGVhc2llciB0byBhcHBseSB0byBhbiBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIHRoYW4gYW4gYXJyYXkgb2YgdHdvIG9yXHJcbiAgICAgKiBtb3JlIGNsYXNzIHJ1bGVzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIGRlY2xhcmUgY2xhc3MgLSBqdXN0IHRvIGJlIHVzZWQgbGF0ZXJcclxuICAgICAqICAgICBzcGFjZWQgPSBjc3MuY2xhc3Moe2dhcDogOH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZib3ggPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICogICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNlICRjbGFzc25hbWUgcnVsZSB0byBjb21iaW5lIHRoZSBuYW1lcyBvZiBjbGFzc2VzIHZib3ggYW5kIHNwYWNlZFxyXG4gICAgICogICAgIHNwYWNlZFZib3ggPSB0aGlzLiRjbGFzc25hbWUoIHRoaXMudmJveCwgdGhpcy5zcGFjZWQpXHJcbiAgICAgKiB9XHJcbiAgICAgKiAuLi5cclxuICAgICAqIGxldCBzdHlsZXMgPSBjc3MuYWN0aXZhdGUoIE15Q2xhc3Nlcyk7XHJcbiAgICAgKiAuLi5cclxuICAgICAqIHJlbmRlclxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIHdpdGhvdXQgc3BhY2VkVmJveCwgdGhlIGNsYXNzIHdvdWxkIGJlOiB7W3N0eWxlcy52Ym94Lm5hbWUsIHN0eWxlcy5zcGFjZWQubmFtZV19XHJcbiAgICAgKiAgICAgcmV0dXJuIDxkaXYgY2xhc3M9e3N0eWxlcy5zcGFjZWRWYm94Lm5hbWV9PlxyXG4gICAgICogICAgICAgICA8c3Bhbj5IZWxsbzwvc3Bhbj5cclxuICAgICAqICAgICAgICAgPHNwYW4+V29ybGQhPC9zcGFuPlxyXG4gICAgICogICAgIDwvZGl2PlxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC4uLmNsYXNzZXMgTGlzdCBvZiBjbGFzcyBuYW1lcyBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgc3RyaW5nIG9yIFtbSUNsYXNzUnVsZV1dIG9yXHJcbiAgICAgKiBbW0lDbGFzc05hbWVSdWxlXV0gb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm5zIGBJQ2xhc3NOYW1lUnVsZWAgb2JqZWN0IHdob3NlIGBuYW1lYCBwcm9wZXJ0eSBjb250YWlucyB0aGUgY29tYmluZWQgY2xhc3MgbmFtZSwgZS5nLlxyXG4gICAgICogYFwiY2xhc3MxIGNsYXNzMlwiYC4gVGhlIGBjc3NDbGFzc05hbWVgIHByb3BlcnR5IGNvbnRhaW5zIHRoZSBjb21iaW5lZCBzZWxlY3RvciwgZS5nLlxyXG4gICAgICogYFwiLmNsYXNzMS5jbGFzczJcImAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkY2xhc3NuYW1lKCAuLi5jbGFzc2VzOiAoSUNsYXNzUnVsZSB8IElDbGFzc05hbWVSdWxlIHwgc3RyaW5nKVtdKTogSUNsYXNzTmFtZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsYXNzTmFtZVJ1bGUoIGNsYXNzZXMpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElEIHJ1bGUuIFRoZSBJRCBuYW1lIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBydWxlIGlzIHByb2Nlc3NlZCBhcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlIGFsc28gb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgZWl0aGVyIGFuIGV4cGxpY2l0XHJcbiAgICAgKiBuYW1lIG9yIGFub3RoZXIgSUQgcnVsZS4gVGhlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXJzIGp1c3QgdG8gXCJkZWNsYXJlXCJcclxuICAgICAqIHRoZSBJRC4gU3VjaCBJRCBjYW4gYmUgbGF0ZXIgdXNlZCBlaXRoZXIgaW4gY29uZGl0aW9uYWwgZ3JvdXBpbmcgcnVsZXMgb3IgaW4gZGVyaXZlZFxyXG4gICAgICogc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXR1cm5lZCBbW0lJRFJ1bGVdXSBpbnRlcmZhY2UgaGFzIHRoZSBgbmFtZWAgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBhc3NpZ25cclxuICAgICAqIHRoZSBJRCB0byBhbiBIVE1MIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgY29udGFpbmVyID0gdGhpcy4kaWQoe1xyXG4gICAgICogICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcclxuICAgICAqICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcclxuICAgICAqICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiAuLi5cclxuICAgICAqIGxldCBzdHlsZXMgPSBjc3MuYWN0aXZhdGUoIE15Q2xhc3Nlcyk7XHJcbiAgICAgKiAuLi5cclxuICAgICAqIHJlbmRlclxyXG4gICAgICoge1xyXG4gICAgICogICAgIHJldHVybiA8ZGl2IGlkPXtzdHlsZXMuY29udGFpbmVyLm5hbWV9PlxyXG4gICAgICogICAgICAgICA8c3Bhbj5IZWxsbzwvc3Bhbj5cclxuICAgICAqICAgICAgICAgPHNwYW4+V29ybGQhPC9zcGFuPlxyXG4gICAgICogICAgIDwvZGl2PlxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0eWxlc2V0IE9uZSBvciBtb3JlIHN0eWxlc2V0IG9iamVjdHMgdGhhdCBkZWZpbmUgc3R5bGUgcHJvcGVydGllcyBvZiB0aGUgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBuYW1lT3ZlcnJpZGUgc3RyaW5nIG9yIGFub3RoZXIgYElJRFJ1bGVgIG9iamVjdCB0aGF0IGRldGVybWluZXMgdGhlIG5hbWUgb2YgdGhlIElELlxyXG4gICAgICogSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWUgYXNzaWdubWVudFxyXG4gICAgICogbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBJRCB0byBtYXRjaCBhIG5hbWUgb2YgYW5vdGhlciBJRC5cclxuICAgICAqIEByZXR1cm5zIGBJSURSdWxlYCBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgZ2V0dGluZyB0aGUgSUQgbmFtZSBhbmQgZm9yIGFjY2Vzc2luZ1xyXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgaWYgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGlkKCBzdHlsZXNldD86IENvbWJpbmVkU3R5bGVzZXQgfCBDb21iaW5lZFN0eWxlc2V0W10sIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElJRFJ1bGUpOiBJSURSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJRFJ1bGUoIHN0eWxlc2V0LCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN0eWxlIHJ1bGUgZm9yIHRoZSBnaXZlbiBIVE1MIG9yIFNWRyBlbGVtZW50IHRhZ3MuIFRoZSBgdGFnYCBwYXJhbWV0ZXIgc3BlY2lmaWVzXHJcbiAgICAgKiBlaXRoZXIgYSBzaW5nbGUgdGFnIG9yIGFuIGFycmF5IG9mIHRhZ3MuIEluIGFkZGl0aW9uLCBhbiBhc3RlcmlzayBzeW1ib2wgKGBcIipcImApIGNhbiBiZVxyXG4gICAgICogc3BlY2lmaWVkIHRvIHRhcmdldCBhbGwgZWxlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBtdWx0aXBsZSB0YWdzIGFyZSBzcGVjaWZpZWQsIHRoZXkgd2lsbCBiZSB0cmVhdGVkIGFzIGEgc2VsZWN0b3IgbGlzdDsgdGhhdCBpcywgdGhleSB3aWxsXHJcbiAgICAgKiBiZSBzZXBhcmF0ZWQgYnkgY29tbWFzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZXM6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyB1c2luZyBzdHJpbmcgZm9yIHNlbGVjdGluZyBhIHNpbmdsZSBlbGVtZW5ldCB0YWdcclxuICAgICAqICAgICB0ciA9IHRoaXMuJHRhZyggXCJ0clwiLCB7fSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNpbmcgYXJyYXkgZm9yIHNlbGVjdGluZyBtdWx0aXBsZSBlbGVtZW5ldCB0YWdzXHJcbiAgICAgKiAgICAgaGVhZGVyMTIzID0gdGhpcy4kdGFnKCBbXCJoMVwiLCBcImgyXCIsIFwiaDNcIl0sIHt9KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyB1c2luZyBhc3RlcmlzayB0byBhZGRyZXNzIGFsbCBlbGVtZW50c1xyXG4gICAgICogICAgIGFsbCA9IHRoaXMuJHRhZyggXCIqXCIsIHt9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhZyBPbmUgb3IgbW9yZSBlbGVtZW50IHRhZ3NcclxuICAgICAqIEBwYXJhbSBzdHlsZXNldCBPbmUgb3IgbW9yZSBzdHlsZXNldCBvYmplY3RzIHRoYXQgZGVmaW5lIHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoZSB0YWdzLlxyXG4gICAgICogQHJldHVybnMgYElTdHlsZVJ1bGVgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRhZyBydWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJHRhZyggdGFnOiBcIipcIiB8IE9uZU9yTWFueTxFbGVtZW50VGFnTmFtZT4sIHN0eWxlc2V0OiBDb21iaW5lZFN0eWxlc2V0IHwgQ29tYmluZWRTdHlsZXNldFtdKTogSVN0eWxlUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3JSdWxlKCBBcnJheS5pc0FycmF5KHRhZykgPyB0YWcuam9pbihcIixcIikgOiB0YWcsIHN0eWxlc2V0KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBydWxlIHdpdGggYW4gYXJiaXRyYXJ5IGNvbXBsZXggc2VsZWN0b3IuIFNlbGVjdG9ycyBjYW4gYmUgc3BlY2lmaWVkIGFzXHJcbiAgICAgKiBvbmUgb3IgYXJyYXkgb2YgW1tTZWxlY3Rvckl0ZW1dXSBvYmplY3RzIHdoZXJlIGVhY2ggYFNlbGVjdG9ySXRlbWAgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcclxuICAgICAqIHR5cGVzOlxyXG4gICAgICogLSBzdHJpbmcgLSBhbGxvd3MgYW55IGNvbnRlbnQgYnV0IGxhY2tzIHR5cGUtc2FmZXR5IGNoZWNrcy5cclxuICAgICAqIC0gYW55IHN0eWxlIHJ1bGUsIHRoYXQgaXMgYSBydWxlIHRoYXQgaW1wbGVtZW50cyB0aGUgW1tJU3R5bGVSdWxlXV0gaW50ZXJmYWNlLiBUaGlzIGFsbG93c1xyXG4gICAgICogICB1c2luZyBwcmV2b3VzbHkgZGVmaW5lZCB0YWcsIGNsYXNzLCBJRCBhbmQgb3RoZXIgc3R5bGUgcnVsZXMgYXMgc2VsZWN0b3IgaXRlbXNcclxuICAgICAqIC0gW1tzZWxlY3Rvcl1dIGZ1bmN0aW9uIC0gYSB0YWcgZnVuY3Rpb24gdGhhdCBhbGxvd3MgY29udmVuaWVudCBtaXhpbmcgb2YgZnJlZS1mb3JtYXQgc3RyaW5nc1xyXG4gICAgICogICBhbmQgc3Ryb25nbHkgdHlwZWQgc3R5bGUgcnVsZXMuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBtdWx0aXBsZSBzZWxlY3RvciBpdGVtcyBhcmUgc3BlY2lmaWVkLCB0aGV5IHdpbGwgYmUgY29uY2F0ZW5hdGVkIGludG8gYSBzaW5nbGUgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBhbHRob3VnaCBzdHlsZSBydWxlcyBjYW4gYmUgdXNlZCBmb3Igc2VsZWN0aW5nIGVsZW1lbnQgdGFncywgdGhlIFtbJHRhZ11dIGZ1bmN0aW9uIHdvdWxkXHJcbiAgICAgKiBiZSBtb3JlIGFwcHJvcHJpYXRlIGJlY2F1c2UgaXQgd2lsbCBjYXRjaCBtaXNzcGVsbGluZ3Mgb2YgdGFnIG5hbWVzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZXM6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyB1c2luZyBhIHN0cmluZ1xyXG4gICAgICogICAgIHN0eWxlMSA9IHRoaXMuJHN0eWxlKCBcImxpOjpiZWZvcmVcIiwge30pXHJcbiAgICAgKlxyXG4gICAgICogICAgIGlkID0gdGhpcy4kaWQoKVxyXG4gICAgICogICAgIGNscyA9IHRoaXMuJGNsYXNzKClcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNpbmcgYW4gYXJyYXkgb2Ygc3R5bGUgcnVsZXMuIFRoZSBzZWxlY3RvciB3aWxsIGJlIFwiI2lkLmNsc1wiXHJcbiAgICAgKiAgICAgc3R5bGUyID0gdGhpcy4kc3R5bGUoIFt0aGlzLmlkLCB0aGlzLmNsc10sIHt9KVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyB1c2luZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24uIFRoZSBzZWxlY3RvciB3aWxsIGJlIFwiI2lkID4gLmNsc1wiXHJcbiAgICAgKiAgICAgc3R5bGUzID0gdGhpcy4kc3R5bGUoIGNzcy5zZWxlY3RvcmAke3RoaXMuaWR9ID4gJHt0aGlzLmNsc31gLCB7fSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNpbmcgYSBzdHJpbmcgZm9yIHNlbGVjdGluZyBlbGVtZW50IHRhZy5cclxuICAgICAqICAgICBoMSA9IHRoaXMuJHN0eWxlKCBcImgxXCIsIHt9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIFN0eWxlIHJ1bGUgc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSBzdHlsZXNldCBPbmUgb3IgbW9yZSBzdHlsZXNldCBvYmplY3RzIHRoYXQgZGVmaW5lIHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoaXMgc2VsZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBgSVN0eWxlUnVsZWAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3R5bGUgcnVsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRzdHlsZSggc2VsZWN0b3I6IENzc1NlbGVjdG9yLCBzdHlsZXNldDogQ29tYmluZWRTdHlsZXNldCB8IENvbWJpbmVkU3R5bGVzZXRbXSk6IElTdHlsZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdG9yUnVsZSggc2VsZWN0b3IsIHN0eWxlc2V0KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYW5pbWF0aW9uIHJ1bGUuIFRoZSBhbmltYXRpb24gbmFtZSB3aWxsIGJlIGNyZWF0ZWQgd2hlbiB0aGUgcnVsZSBpcyBwcm9jZXNzZWQgYXNcclxuICAgICAqIHBhcnQgb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBuYW1lIGNhbiBiZSBhbHNvIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nIGVpdGhlciBhblxyXG4gICAgICogZXhwbGljaXQgbmFtZSBvciBhbm90aGVyIGFuaW1hdGlvbiBydWxlLiBUaGUgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB3aXRob3V0IHBhcmFtZXRlcnMganVzdCB0b1xyXG4gICAgICogXCJkZWNsYXJlXCIgdGhlIGFuaW1hdGlvbi4gU3VjaCBhbmltYXRpb24gY2FuIGJlIGxhdGVyIHVzZWQgZWl0aGVyIGluIGNvbmRpdGlvbmFsIGdyb3VwaW5nIHJ1bGVzXHJcbiAgICAgKiBvciBpbiBkZXJpdmVkIHN0eWxlIGRlZmluaXRpb24gY2xhc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcmV0dXJuZWQgW1tJQW5pbWF0aW9uUnVsZV1dIGludGVyZmFjZSByZXByZXNlbnRzIGFuIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW5cclxuICAgICAqIHVzaW5nIHRoZSBrZXlmcmFtZXMgbmFtZSBpbiB0aGUgYGFuaW1hdGlvbi1uYW1lYCBvciBgYW5pbWF0aW9uYCBzdHlsZSBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIHZhbmlzaCA9IHRoaXMuJGtleWZyYW1lcyhbXHJcbiAgICAgKiAgICAgICAgIFswLCB7IG9wYWNpdHk6IDEwMCB9XSxcclxuICAgICAqICAgICBcdCAgIFsxMDAsIHsgb3BhY2l0eTogMCB9XSxcclxuICAgICAqICAgICBdKVxyXG4gICAgICpcclxuICAgICAqICAgICB2YW5pc2hpbmdCbG9jayA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgYW5pbWF0aW9uOiB7IG5hbWU6IHRoaXMudmFuaXNoLCBkdXJhdGlvbjogMjAwMCwgY291bnQ6IFwiaW5maW5pdGVcIiwgZGlyZWN0aW9uOiBcImFsdGVybmF0ZVwiIH1cclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZyYW1lcyBBcnJheSBvZiBbW0FuaW1hdGlvbkZyYW1lXV0gb2JqZWN0cy4gRWFjaCBhbmltYXRpb24gZnJhbWUgY29udGFpbnMgYSB3YXlwb2ludFxyXG4gICAgICogYW5kIGEgc3R5bGVzZXQuXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJQW5pbWF0aW9uUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGFuaW1hdGlvbi4gSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWVcclxuICAgICAqIGFzc2lnbm1lbnQgbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBuYW1lIHRvIG1hdGNoIGEgbmFtZSBvZlxyXG4gICAgICogYW5vdGhlciBhbmltYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyBgSUFuaW1hdGlvblJ1bGVgIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBnZXR0aW5nIHRoZSBhbmltYXRpb24gbmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRrZXlmcmFtZXMoIGZyYW1lcz86IEFuaW1hdGlvbkZyYW1lW10sIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElBbmltYXRpb25SdWxlKTogSUFuaW1hdGlvblJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblJ1bGUoIGZyYW1lcywgbmFtZU92ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgY3VzdG9tIHZhcmlhYmxlIG9iamVjdCB0aGF0IGRlZmluZXMgYSBjdXN0b20gQ1NTIHByb3BlcnR5LiBUaGUgdmFyaWFibGUgbmFtZSB3aWxsXHJcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gdGhlIHJ1bGUgaXMgcHJvY2Vzc2VkIGFzIHBhcnQgb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBuYW1lIGNhbiBiZVxyXG4gICAgICogYWxzbyBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBlaXRoZXIgYW4gZXhwbGljaXQgbmFtZSBvciBhbm90aGVyIGN1c3RvbSB2YXJpYWJsZSBydWxlLiBUaGVcclxuICAgICAqIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSB2YWx1ZSBqdXN0IHRvIFwiZGVjbGFyZVwiIHRoZSB2YXJpYWJsZS4gU3VjaFxyXG4gICAgICogdmFyaWFibGUgY2FuIGJlIGxhdGVyIHVzZWQgZWl0aGVyIGluIGNvbmRpdGlvbmFsIGdyb3VwaW5nIHJ1bGVzIG9yIGluIGRlcml2ZWQgc3R5bGUgZGVmaW5pdGlvblxyXG4gICAgICogY2xhc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBDdXN0b20gcHJvcGVydGllcyBkZWZpbmVkIHVzaW5nIHRoZSBgJHZhcmAgZnVuY3Rpb24gYXJlIGluY2x1ZGVkIGludG8gdGhlIGA6cm9vdCB7fWAgYmxvY2s7XHJcbiAgICAgKiBob3dldmVyLCB0aGV5IGNhbiBiZSByZWRlZmluZWQgd2l0aCBkaWZmZXJlbnQgdmFsdWVzIHVuZGVyIGFueSBzdHlsZSBydWxlLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIGRlZmluZSBhbmQgdXNlIGN1c3RvbSBDU1MgcHJvcGVydHlcclxuICAgICAqICAgICBpbXBvcnRhbnRUZXh0Q29sb3IgPSB0aGlzLiR2YXIoIFwiY29sb3JcIiwgXCJyZWRcIilcclxuICAgICAqICAgICBpbXBvcnRhbnQgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGNvbG9yOiB0aGlzLmltcG9ydGFudFRleHRDb2xvclxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHVzZSBkaWZmZXJlbnQgdmFsdWUgZm9yIHRoZSBjdXN0b20gcHJvcGVydHkgdW5kZXIgYW5vdGhlciBDU1MgY2xhc3NcclxuICAgICAqICAgICBzcGVjaWFsID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBcIitcIjogdGhpcy5pbXBvcnRhbnQsXHJcbiAgICAgKiAgICAgICAgIFwiLS1cIjogWyBbdGhpcy5pbXBvcnRhbnRUZXh0Q29sb3IsIFwibWFyb29uXCJdIF1cclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIEVpdGhlciBhIG5hbWUgb2YgYSBzdHlsZSBwcm9wZXJ0eSAoaW4gY2FtZWwtY2FzZSkgb3IgYSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBmcm9tXHJcbiAgICAgKiB0aGUgW1tJVmFyVGVtcGxhdGVTdHlsZXNldF1dIGludGVyZmFjZS4gVGhlIHR5cGUgY29ycmVzcG9uZGluZyB0byB0aGlzIHByb3BlcnR5IGRlZmluZXMgdGhlIHR5cGVcclxuICAgICAqIG9mIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJVmFyUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGN1c3RvbSBwcm9wZXJ0eS4gSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWVcclxuICAgICAqIGFzc2lnbm1lbnQgbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBuYW1lIHRvIG1hdGNoIGEgbmFtZSBvZlxyXG4gICAgICogZXhpc3RpbmcgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYElWYXJSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXN0b20gcHJvcGVydHkuIEFueSB1c2FnZSBvZiB0aGlzIG9iamVjdCBpblxyXG4gICAgICogc3R5bGUgcHJvcGVydGllcyBvciBmdW5jdGlvbiBwYXJhbWV0ZXJzIGlzIHN1YnN0aXR1dGVkIGJ5IHRoZSBgdmFyKClgIENTUyBmdW5jdGlvbiBpbnZvY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJHZhcjxLIGV4dGVuZHMgVmFyVGVtcGxhdGVOYW1lPiggdGVtcGxhdGU6IEssIHZhbHVlPzogRXh0ZW5kZWRWYXJWYWx1ZTxLPixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJVmFyUnVsZTxLPik6IElWYXJSdWxlPEs+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJSdWxlKCB0ZW1wbGF0ZSwgdmFsdWUsIG5hbWVPdmVycmlkZSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGBAcHJvcGVydHlgIHJ1bGUuIFRoZSBwcm9wZXJ0eSBuYW1lIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBydWxlIGlzIHByb2Nlc3NlZFxyXG4gICAgICogYXMgcGFydCBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlIGFsc28gb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgZWl0aGVyXHJcbiAgICAgKiBhbiBleHBsaWNpdCBuYW1lIG9yIGFub3RoZXIgY3VzdG9tIHZhcmlhYmxlIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB2YXJpYW50IGFsbG93cyBzcGVjaWZ5aW5nIHN5bnRheCBhcyBvbmUgb2YgcHJlZGVmaW5lZCBzeW50YXggaXRlbXMgc3VjaCBhcyBgPG51bWJlcj5gXHJcbiAgICAgKiBvciBgPGNvbG9yPmAgb3B0aW9uYWxseSBhY2NvbXBhbmllZCB3aXRoIHRoZSBtdWx0aXBsaWVycyBgXCIjXCJgIG9yIGBcIitcIi4gVGhlIHR5cGUgb2YgaW5pdGlhbFxyXG4gICAgICogdmFsdWUgYXMgd2VsbCBhcyB0aGUgdHlwZSB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBzZXRWYWx1ZWAgbWV0aG9kIG9mIHRoZSByZXR1cm5lZFxyXG4gICAgICogW1tJVmFyUnVsZV1dIGludGVyZmFjZSB3aWxsIGJlIGVuZm9yY2VkIGFjY29yZGluZyB0byB0aGUgc3ludGF4IHNwZWNpZmllZC5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICAvLyBkZWZpbmUgYW5kIHVzZSBjdXN0b20gQ1NTIHByb3BlcnR5XHJcbiAgICAgKiAgICAgaW1wb3J0YW50VGV4dENvbG9yID0gdGhpcy4kcHJvcGVydHkoIFwiPGNvbG9yPlwiLCBcInJlZFwiLCBmYWxzZSlcclxuICAgICAqICAgICBpbXBvcnRhbnQgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGNvbG9yOiB0aGlzLmltcG9ydGFudFRleHRDb2xvclxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHVzZSBkaWZmZXJlbnQgdmFsdWUgZm9yIHRoZSBjdXN0b20gcHJvcGVydHkgdW5kZXIgYW5vdGhlciBDU1MgY2xhc3NcclxuICAgICAqICAgICBzcGVjaWFsID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBcIitcIjogdGhpcy5pbXBvcnRhbnQsXHJcbiAgICAgKiAgICAgICAgIFwiLS1cIjogWyBbdGhpcy5pbXBvcnRhbnRUZXh0Q29sb3IsIFwibWFyb29uXCJdIF1cclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN5bnRheCBOYW1lIG9mIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBbW0lTeW50YXhUeXBlU3R5bGVzZXRdXSBpbnRlcmZhY2UuIFRoZSB0eXBlXHJcbiAgICAgKiBjb3JyZXNwb25kaW5nIHRvIHRoaXMgcHJvcGVydHkgZGVmaW5lcyB0aGUgdHlwZSBvZiB0aGUgaW5pdGlhbCB2YWx1ZSBwYXJhbWV0ZXIuXHJcbiAgICAgKiBAcGFyYW0gaW5pdFZhbHVlIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGFzIGluaXRpYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIGluaGVyaXRzIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjdXN0b20gcHJvcGVydHkgcmVnaXN0cmF0aW9uIGluaGVyaXRzIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJVmFyUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGN1c3RvbSBwcm9wZXJ0eS4gSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWVcclxuICAgICAqIGFzc2lnbm1lbnQgbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBuYW1lIHRvIG1hdGNoIGEgbmFtZSBvZlxyXG4gICAgICogZXhpc3RpbmcgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYElWYXJSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBgQHByb3BlcnR5YCBydWxlLiBBbnkgdXNhZ2Ugb2YgdGhpcyBvYmplY3QgaW5cclxuICAgICAqIHN0eWxlIHByb3BlcnRpZXMgb3IgZnVuY3Rpb24gcGFyYW1ldGVycyBpcyBzdWJzdGl0dXRlZCBieSB0aGUgYHZhcigpYCBDU1MgZnVuY3Rpb24gaW52b2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRwcm9wZXJ0eTxLIGV4dGVuZHMga2V5b2YgSVN5bnRheFR5cGVTdHlsZXNldD4oXHJcbiAgICAgICAgc3ludGF4OiBLLCBpbml0VmFsdWU6IEV4dGVuZGVkVmFyVmFsdWU8Sz4sIGluaGVyaXRzOiBib29sZWFuLFxyXG4gICAgICAgIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElWYXJSdWxlPEs+KTogSVZhclJ1bGU8Sz5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGBAcHJvcGVydHlgIHJ1bGUuIFRoZSBwcm9wZXJ0eSBuYW1lIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBydWxlIGlzIHByb2Nlc3NlZFxyXG4gICAgICogYXMgcGFydCBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlIGFsc28gb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgZWl0aGVyXHJcbiAgICAgKiBhbiBleHBsaWNpdCBuYW1lIG9yIGFub3RoZXIgY3VzdG9tIHZhcmlhYmxlIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB2YXJpYW50IGFsbG93cyBzcGVjaWZ5aW5nIGFyYml0cmFyeSBzeW50YXggYW5kIHRoZSBkZXZlbG9wZXJzIGFyZSByZXNwb25zaWJsZSB0b1xyXG4gICAgICogcHJvdmlkZSBjb3JyZWN0IHN5bnRheC4gVGhlIHR5cGUgb2YgaW5pdGlhbCB2YWx1ZSBhcyB3ZWxsIGFzIHRoZSB0eXBlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xyXG4gICAgICogdGhlIGBzZXRWYWx1ZWAgbWV0aG9kIG9mIHRoZSByZXR1cm5lZCBbW0lWYXJSdWxlXV0gaW50ZXJmYWNlIGFyZSBsaW1pdGVkIHRvIHN0cmluZy4gVGhlXHJcbiAgICAgKiBkZXZlbG9wZXJzIGFyZSByZXNwb25zaWJsZSB0byBwYXNzIHZhbHVlcyB0aGF0IGNvbmZvcm0gdG8gdGhlIHNwZWNpZmllZCBzeW50YXguXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgLy8gZGVmaW5lIGFuZCB1c2UgY3VzdG9tIENTUyBwcm9wZXJ0eVxyXG4gICAgICogICAgIGltcG9ydGFudFRleHRDb2xvciA9IHRoaXMuJHByb3BlcnR5KCBbXCI8Y29sb3I+IyB8IG5vbmVcIl0sIFwicmVkXCIsIGZhbHNlKVxyXG4gICAgICogICAgIGltcG9ydGFudCA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgY29sb3I6IHRoaXMuaW1wb3J0YW50VGV4dENvbG9yXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gdXNlIGRpZmZlcmVudCB2YWx1ZSBmb3IgdGhlIGN1c3RvbSBwcm9wZXJ0eSB1bmRlciBhbm90aGVyIENTUyBjbGFzc1xyXG4gICAgICogICAgIHNwZWNpYWwgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIFwiK1wiOiB0aGlzLmltcG9ydGFudCxcclxuICAgICAqICAgICAgICAgXCItLVwiOiBbIFt0aGlzLmltcG9ydGFudFRleHRDb2xvciwgXCJtYXJvb25cIl0gXVxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3ludGF4IFNpbmdsZS1lbGVtZW50IHR1cGxlIGNvbnRhaW5pbmcgdGhlIHN5bnRheCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gaW5pdFZhbHVlIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGFzIGluaXRpYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIGluaGVyaXRzIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjdXN0b20gcHJvcGVydHkgcmVnaXN0cmF0aW9uIGluaGVyaXRzIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBAcGFyYW0gbmFtZU92ZXJyaWRlIFN0cmluZyBvciBhbm90aGVyIGBJVmFyUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGN1c3RvbSBwcm9wZXJ0eS4gSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWVcclxuICAgICAqIGFzc2lnbm1lbnQgbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBuYW1lIHRvIG1hdGNoIGEgbmFtZSBvZlxyXG4gICAgICogZXhpc3RpbmcgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYElWYXJSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBgQHByb3BlcnR5YCBydWxlLiBBbnkgdXNhZ2Ugb2YgdGhpcyBvYmplY3QgaW5cclxuICAgICAqIHN0eWxlIHByb3BlcnRpZXMgb3IgZnVuY3Rpb24gcGFyYW1ldGVycyBpcyBzdWJzdGl0dXRlZCBieSB0aGUgYHZhcigpYCBDU1MgZnVuY3Rpb24gaW52b2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRwcm9wZXJ0eSggc3ludGF4OiBbc3RyaW5nXSwgaW5pdFZhbHVlOiBFeHRlbmRlZFByb3A8c3RyaW5nPiwgaW5oZXJpdHM6IGJvb2xlYW4sXHJcbiAgICAgICAgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSVZhclJ1bGU8XCIqXCI+KTogSVZhclJ1bGU8XCIqXCI+O1xyXG5cclxuICAgIC8vIGltcGxlbWVudGF0aW9uXHJcbiAgICAkcHJvcGVydHk8SyBleHRlbmRzIGtleW9mIElTeW50YXhUeXBlU3R5bGVzZXQgPSBhbnksIFQgZXh0ZW5kcyBLIHwgW3N0cmluZ10gPSBhbnk+KFxyXG4gICAgICAgIHN5bnRheDogVCwgaW5pdFZhbHVlOiBFeHRlbmRlZFZhclZhbHVlPEs+LCBpbmhlcml0cyA9IHRydWUsXHJcbiAgICAgICAgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSVZhclJ1bGU8Sz4pOiBJVmFyUnVsZTxLPlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSdWxlKCBzeW50YXgsIGluaXRWYWx1ZSwgaW5oZXJpdHMsIG5hbWVPdmVycmlkZSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBcImNvbnN0YW50XCIgdGhhdCBjYW4gYmUgdXNlZCBhbnl3aGVyZSB0aGUgdHlwZSBkZWZpbmVkIGJ5IHRoZSBgdGVtcGxhdGVgIHBhcmFtZXRlciBjYW5cclxuICAgICAqIGJlIHVzZWQuIFRoZXkgYXJlIGNhbGxlZCBjb25zdGFudHMsIGJlY2F1c2UgdGhleSBwcm92aWRlIGEgY29udmVuaWVudCBhbmQgbGlnaHR3ZWlnaHQgd2F5IG9mXHJcbiAgICAgKiBkZWZpbmluZyB2YWx1ZXMgdGhhdCBhcmUgdW5jaGFuZ2VkIGR1cmluZyB0aGUgYXBwbGljYXRpb24gbGlmZXRpbWUuIEFsdGhvdWdoIGNvbnN0YW50cyBhcmVcclxuICAgICAqIGRlZmluZWQgdmVyeSBzaW1pbGFybHkgdG8gY3VzdG9tIHByb3BlcnRpZXMgKHNlZSB0aGUgW1skdmFyXV0gZnVuY3Rpb24pLCB0aGV5IGNhbm5vdCBwYXJ0aWNpcGF0ZVxyXG4gICAgICogaW4gdGhlIGNhc2NhZGUgYW5kIGNhbm5vdCBiZSByZWRlZmluZWQgdW5kZXIgc3R5bGUgcnVsZXMuIENvbnN0YW50IGNhbiB1c2UgYW55IGV4cHJlc3Npb24gdGhhdFxyXG4gICAgICogc2F0aXNmaWVzIHRoZSB0eXBlIGRlZmluZWQgYnkgdGhlIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIGluY2x1ZGluZyBvdGhlciBjb25zdGFudHMsIGN1c3RvbVxyXG4gICAgICogcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqIE5vIENTUyBydWxlcyBhcmUgY3JlYXRlZCBmb3IgY29uc3RhbnRzIGFuZCwgZHVlIHRvIHRoaXMgZmFjdCwgY29uc3RhbnRzIGFyZSBwcmVmZXJhYmxlIHRvIGN1c3RvbVxyXG4gICAgICogcHJvcGVydGllcyB1bmxlc3MgdGhlIGludGVudGlvbiBpcyB0byBjaGFuZ2UgdGhlIHZhcmlhYmxlIHZhbHVlIGF0IHJ1bi10aW1lIG9yIHRvIHJlZGVmaW5lIGl0c1xyXG4gICAgICogdmFsdWUgdW5kZXIgZGlmZmVyZW50IHN0eWxlIHJ1bGVzLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIC8vIGRlZmluaW5nIGFuZCB1c2luZyBjdXN0b20gQ1NTIHByb3BlcnR5XHJcbiAgICAgKiAgICAgZGVmYXVsdFRleHRDb2xvciA9IHRoaXMuJGNvbnN0KCBcImNvbG9yXCIsIFwicmVkXCIpXHJcbiAgICAgKiAgICAgcGFyYSA9IHRoaXMuJHN0eWxlKCBcInBcIiwge1xyXG4gICAgICogICAgICAgICBjb2xvcjogdGhpcy5kZWZhdWx0VGV4dENvbG9yXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSBFaXRoZXIgYSBuYW1lIG9mIGEgc3R5bGUgcHJvcGVydHkgKGluIGNhbWVsLWNhc2UpIG9yIGEgbmFtZSBvZiB0aGUgcHJvcGVydHkgZnJvbVxyXG4gICAgICogdGhlIFtbSVZhclRlbXBsYXRlU3R5bGVzZXRdXSBpbnRlcmZhY2UuIFRoZSB0eXBlIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBwcm9wZXJ0eSBkZWZpbmVzIHRoZSB0eXBlXHJcbiAgICAgKiBvZiB0aGUgc2Vjb25kIHBhcmFtZXRlci5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIGNvbnN0YW50LlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJQ29uc3RSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZiB0aGUgY29uc3RhbnQuIFRoZSB2YWx1ZSBpc1xyXG4gICAgICogY29tcHV0ZWQgb25jZSB3aGVuIHRoZSBzdHlsZSBkZWZpbml0aW9uIGlzIHByb2Nlc3NlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRjb25zdDxLIGV4dGVuZHMgVmFyVGVtcGxhdGVOYW1lPiggdGVtcGxhdGU6IEssIHZhbHVlPzogRXh0ZW5kZWRWYXJWYWx1ZTxLPik6IElDb25zdFJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbnN0UnVsZSggdGVtcGxhdGUsIHZhbHVlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgY291bnRlciBvYmplY3QuIFRoZSBjb3VudGVyIG5hbWUgd2lsbCBiZSBjcmVhdGVkIHdoZW4gdGhlIHJ1bGUgaXMgcHJvY2Vzc2VkIGFzXHJcbiAgICAgKiBwYXJ0IG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBUaGUgbmFtZSBjYW4gYmUgYWxzbyBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBlaXRoZXIgYW5cclxuICAgICAqIGV4cGxpY2l0IG5hbWUgb3IgYW5vdGhlciBjb3VudGVyIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogQ291bnRlciBydWxlcyBkb24ndCBjcmVhdGUgYW55IENTUyBydWxlcywgYnV0IHRoZXkgY3JlYXRlIHVuaXF1ZSBuYW1lcyB0aGF0IGNhbiBiZSB1c2VkXHJcbiAgICAgKiBmb3IgYGNvdW50ZXItcmVzZXRgIGFuZCBgY291bnRlci1pbmNyZW1lbnRgIHN0eWxlIHByb3BlcnRpZXMuIENvdW50ZXIgcnVsZXMgYXJlIHVzdWFsbHkgdXNlZFxyXG4gICAgICogaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgW1tjb3VudGVyXV0gYW5kIFtbY291bnRlcnNdXSBmdW5jdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgY291bnRlciA9IHRoaXMuJGNvdW50ZXIoKVxyXG4gICAgICogICAgIG9sID0gdGhpcy4kc3R5bGUoIFwib2xcIiwgeyBjb3VudGVyUmVzZXQ6IHRoaXMuY291bnRlciwgbGlzdFN0eWxlVHlwZTogXCJub25lXCIgfSlcclxuICAgICAqICAgICBsaSA9IHRoaXMuJHN0eWxlKCBcImxpXCIsIHtcclxuICAgICAqICAgICAgICAgY291bnRlckluY3JlbWVudDogdGhpcy5jb3VudGVyLFxyXG4gICAgICogICAgICAgICBcIjo6YmVmb3JlXCI6IHsgY29udGVudDogY3NzLmNvdW50ZXJzKCB0aGlzLmNvdW50ZXIpIH1cclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWVPdmVycmlkZSBTdHJpbmcgb3IgYW5vdGhlciBgSUNvdW50ZXJSdWxlYCBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBuYW1lIG9mIHRoZVxyXG4gICAgICogY291bnRlci4gSWYgdGhpcyBvcHRpb25hbCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCwgdGhlIG5hbWUgd2lsbCBvdmVycmlkZSB0aGUgTWltY3NzIG5hbWVcclxuICAgICAqIGFzc2lnbm1lbnQgbWVjaGFuaXNtLiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCBpZiB0aGVyZSBpcyBhIG5lZWQgZm9yIHRoZSBuYW1lIHRvIG1hdGNoIGEgbmFtZSBvZlxyXG4gICAgICogZXhpc3RpbmcgY291bnRlci5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSUNvdW50ZXJSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjb3VudGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGNvdW50ZXIoIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElDb3VudGVyUnVsZSk6IElDb3VudGVyUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ291bnRlclJ1bGUoIG5hbWVPdmVycmlkZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBjb3VudGVyIHN0eWxlIHJ1bGUuIFRoZSBjb3VudGVyIHN0eWxlIG5hbWUgd2lsbCBiZSBjcmVhdGVkIHdoZW4gdGhlIHJ1bGUgaXNcclxuICAgICAqIHByb2Nlc3NlZCBhcyBwYXJ0IG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBUaGUgbmFtZSBjYW4gYmUgYWxzbyBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZ1xyXG4gICAgICogZWl0aGVyIGFuIGV4cGxpY2l0IG5hbWUgb3IgYW5vdGhlciBjb3VudGVyIHN0eWxlIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgY291bnRlclN0eWxlID0gdGhpcy4kY291bnRlclN0eWxlKHtcclxuICAgICAqICAgICAgICAgc3lzdGVtOiBcImN5Y2xpY1wiLFxyXG4gICAgICogICAgICAgICBzeW1ib2xzOiBbXCJvbmVcIiwgXCJ0d29cIiwgXCJ0aHJlZVwiXSxcclxuICAgICAqICAgICAgICAgc3VmZml4OiBcIiAtIFwiXHJcbiAgICAgKiAgICAgfSlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb3VudGVyU3R5bGVzZXQgQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBjb3VudGVyIHN0eWxlIGZlYXR1cmVzLlxyXG4gICAgICogQHBhcmFtIG5hbWVPdmVycmlkZSBTdHJpbmcgb3IgYW5vdGhlciBgSUNvdW50ZXJTdHlsZVJ1bGVgIG9iamVjdCB0aGF0IGRldGVybWluZXMgdGhlIG5hbWUgb2YgdGhlXHJcbiAgICAgKiBjb3VudGVyIHN0eWxlLiBJZiB0aGlzIG9wdGlvbmFsIHBhcmFtZXRlciBpcyBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIG92ZXJyaWRlIHRoZSBNaW1jc3MgbmFtZVxyXG4gICAgICogYXNzaWdubWVudCBtZWNoYW5pc20uIFRoaXMgbWlnaHQgYmUgdXNlZnVsIGlmIHRoZXJlIGlzIGEgbmVlZCBmb3IgdGhlIG5hbWUgdG8gbWF0Y2ggYSBuYW1lIG9mXHJcbiAgICAgKiBleGlzdGluZyBjb3VudGVyIHN0eWxlLlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJQ291bnRlclN0eWxlUnVsZWAgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY291bnRlciBzdHlsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRjb3VudGVyU3R5bGUoIGNvdW50ZXJTdHlsZXNldD86IEV4dGVuZGVkQ291bnRlclN0eWxlc2V0LFxyXG4gICAgICAgIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElDb3VudGVyU3R5bGVSdWxlKTogSUNvdW50ZXJTdHlsZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvdW50ZXJTdHlsZVJ1bGUoIGNvdW50ZXJTdHlsZXNldCwgbmFtZU92ZXJyaWRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZ3JpZCBsaW5lIHJ1bGUuIFRoZSBsaW5lIG5hbWUgd2lsbCBiZSBjcmVhdGVkIHdoZW4gdGhlIHJ1bGUgaXMgcHJvY2Vzc2VkIGFzXHJcbiAgICAgKiBwYXJ0IG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLiBUaGUgbmFtZSBjYW4gYmUgYWxzbyBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBlaXRoZXIgYW5cclxuICAgICAqIGV4cGxpY2l0IG5hbWUgb3IgYW5vdGhlciBncmlkIGxpbmUgcnVsZS4gVGhlIGdyaWQgbGluZSBydWxlcyBhcmUgdXNlZCB0byBkZWZpbmUgdmFsdWVzIG9mXHJcbiAgICAgKiBzdHlsZSBwcm9wZXJ0aWVzIGBncmlkLXJvdy1zdGFydC9lbmRgIGFuZCBgZ3JpZC1jb2x1bW4tc3RhcnQvZW5kYC5cclxuICAgICAqXHJcbiAgICAgKiBObyBDU1MgcnVsZSBpcyBjcmVhdGVkIGZvciBncmlkIGxpbmVzIC0gdGhlc2Ugb2JqZWN0cyBhcmUgc29sZWx5IHVzZWQgZm9yIGNyZWF0aW5nIG5hbWVzLCB3aGljaFxyXG4gICAgICogY2FuIGJlIHR5cGUtc2FmZWx5IHJlZmVycmVkIHRvIGZyb20gc3R5bGUgcnVsZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgZ3JpZExpbmVGaXJzdCA9IHRoaXMuJGdyaWRsaW5lKClcclxuICAgICAqICAgICBncmlkTGluZUxhc3QgPSB0aGlzLiRncmlkbGluZSgpXHJcbiAgICAgKlxyXG4gICAgICogICAgIGdyaWQgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGRpc3BsYXk6IFwiZ3JpZFwiLFxyXG4gICAgICogICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBbIFt0aGlzLmdyaWRMaW5lRmlyc3RdLCBcIjFmclwiLCBcIjJmclwiLCBbdGhpcy5ncmlkTGluZUxhc3RdIF0sXHJcbiAgICAgKiAgICAgICAgIGdyaWRUZW1wbGF0ZVJvd3M6IGNzcy5yZXBlYXQoIDIsIFwiMWZyXCIpLFxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIGZpcnN0ID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBncmlkQ29sdW1uU3RhcnQ6IHRoaXMuZ3JpZExpbmVGaXJzdCxcclxuICAgICAqICAgICB9KVxyXG4gICAgICpcclxuICAgICAqICAgICBsYXN0ID0gdGhpcy4kY2xhc3Moe1xyXG4gICAgICogICAgICAgICBncmlkQ29sdW1uRW5kOiB0aGlzLmdyaWRMaW5lTGFzdCxcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWVPdmVycmlkZSBTdHJpbmcgb3IgYW5vdGhlciBgSUdyaWRMaW5lUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGxpbmUuIElmIHRoaXMgb3B0aW9uYWwgcGFyYW1ldGVyIGlzIGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgb3ZlcnJpZGUgdGhlIE1pbWNzcyBuYW1lXHJcbiAgICAgKiBhc3NpZ25tZW50IG1lY2hhbmlzbS4gVGhpcyBtaWdodCBiZSB1c2VmdWwgaWYgdGhlcmUgaXMgYSBuZWVkIGZvciB0aGUgbmFtZSB0byBtYXRjaCBhIG5hbWUgb2ZcclxuICAgICAqIGV4aXN0aW5nIGdyaWQgbGluZS5cclxuICAgICAqIEBwYXJhbSBpc1N0YXJ0RW5kT3JOb25lIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgXCItc3RhcnRcImAgb3IgYFwiLWVuZFwiYCBzdWZmaXggc2hvdWxkIGJlXHJcbiAgICAgKiBhcHBlbmRlZCB0byB0aGUgcnVsZSBuYW1lLiBJZiB0aGUgZmxhZyBpcyB0cnVlLCBgXCItc3RhcnRcImAgaXMgYXBwZW5kZWQ7IGlmIHRoZSBmbGFnIGlzIGZhbHNlLFxyXG4gICAgICogYFwiLWVuZFwiYCBpcyBhcHBlbmRlZDsgaWYgdGhlIGZsYWcgaXMgdW5kZWZpbmVkLCBubyBzdWZmaXggaXMgYXBwZW5kZWQgdG8gdGhlIHJ1bGUgbmFtZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSUdyaWRMaW5lUnVsZWAgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ3JpZCBsaW5lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGdyaWRsaW5lKCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJR3JpZExpbmVSdWxlLFxyXG4gICAgICAgIGlzU3RhcnRFbmRPck5vbmU/OiBib29sZWFuKTogSUdyaWRMaW5lUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3JpZExpbmVSdWxlKCBuYW1lT3ZlcnJpZGUsIGlzU3RhcnRFbmRPck5vbmUpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGdyaWQgYXJlYSBydWxlLiBUaGUgYXJlYSBuYW1lIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBydWxlIGlzIHByb2Nlc3NlZCBhc1xyXG4gICAgICogcGFydCBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIG5hbWUgY2FuIGJlIGFsc28gb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgZWl0aGVyIGFuXHJcbiAgICAgKiBleHBsaWNpdCBuYW1lIG9yIGFub3RoZXIgZ3JpZCBhcmVhIHJ1bGUuIFRoZSBncmlkIGFyZWEgcnVsZXMgYXJlIHVzZWQgdG8gZGVmaW5lIHZhbHVlcyBvZlxyXG4gICAgICogc3R5bGUgcHJvcGVydGllcyBgZ3JpZC1hcmVhYCwgYGdyaWQtcm93LXN0YXJ0L2VuZGAsIGBncmlkLWNvbHVtbi1zdGFydC9lbmRgIGFuZFxyXG4gICAgICogYGdyaWQtdGVtcGxhdGUtYXJlYXNgLlxyXG4gICAgICpcclxuICAgICAqIE5vIENTUyBydWxlIGlzIGNyZWF0ZWQgZm9yIGdyaWQgYXJlYXMgLSB0aGVzZSBvYmplY3RzIGFyZSBzb2xlbHkgdXNlZCBmb3IgY3JlYXRpbmcgbmFtZXMsIHdoaWNoXHJcbiAgICAgKiBjYW4gYmUgdHlwZS1zYWZlbHkgcmVmZXJyZWQgdG8gZnJvbSBzdHlsZSBydWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBFdmVyeSBncmlkIGFyZWEgZGVmaW5lcyB0d28gZ3JpZCBsaW5lIHJ1bGVzIGluIGVhY2ggZGlyZWN0aW9uLCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgdGhlXHJcbiAgICAgKiBbW0lHcmlkQXJlYVJ1bGUuc3RhcnRMaW5lXV0gYW5kIFtbSUdyaWRBcmVhUnVsZS5lbmRMaW5lXV0gcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiAqKkV4YW1wbGU6KipcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICAgICAqIHtcclxuICAgICAqICAgICBoZWFkZXJBcmVhID0gdGhpcy4kZ3JpZGFyZWEoKTtcclxuICAgICAqICAgICBtYWluQXJlYSA9IHRoaXMuJGdyaWRhcmVhKCk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIGdyaWQgPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGRpc3BsYXk6IFwiZ3JpZFwiLFxyXG4gICAgICogICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBcIjFmclwiLFxyXG4gICAgICogICAgICAgICBncmlkVGVtcGxhdGVSb3dzOiBbXCIzZW1cIiwgXCIxZnJcIl0sXHJcbiAgICAgKiAgICAgICAgIGdyaWRUZW1wbGF0ZUFyZWFzOiBbXHJcbiAgICAgKiAgICAgICAgICAgICBbdGhpcy5oZWFkZXJBcmVhLCAxLDEsIDEsMV0sXHJcbiAgICAgKiAgICAgICAgICAgICBbdGhpcy5tYWluQXJlYSwgMiwxLCAyLDFdLFxyXG4gICAgICogICAgICAgICBdLFxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIGhlYWRlciA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgZ3JpZEFyZWE6IHRoaXMuaGVhZGVyQXJlYSxcclxuICAgICAqICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImJsdWVcIlxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKlxyXG4gICAgICogICAgIG1haW4gPSB0aGlzLiRjbGFzcyh7XHJcbiAgICAgKiAgICAgICAgIGdyaWRBcmVhOiB0aGlzLm1haW5BcmVhLFxyXG4gICAgICogICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwibGlnaHRncmV5XCJcclxuICAgICAqICAgICB9KVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWVPdmVycmlkZSBTdHJpbmcgb3IgYW5vdGhlciBgSUdyaWRBcmVhUnVsZWAgb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbmFtZSBvZiB0aGVcclxuICAgICAqIGFyZWEuIElmIHRoaXMgb3B0aW9uYWwgcGFyYW1ldGVyIGlzIGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgb3ZlcnJpZGUgdGhlIE1pbWNzcyBuYW1lXHJcbiAgICAgKiBhc3NpZ25tZW50IG1lY2hhbmlzbS4gVGhpcyBtaWdodCBiZSB1c2VmdWwgaWYgdGhlcmUgaXMgYSBuZWVkIGZvciB0aGUgbmFtZSB0byBtYXRjaCBhIG5hbWUgb2ZcclxuICAgICAqIGV4aXN0aW5nIGdyaWQgYXJlYS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSUdyaWRBcmVhUnVsZWAgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ3JpZCBhcmVhLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJGdyaWRhcmVhKCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJR3JpZEFyZWFSdWxlKTogSUdyaWRBcmVhUnVsZVxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3JpZEFyZWFSdWxlKCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBAZm9udC1mYWNlYCBydWxlLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGZvbnQgPSB0aGlzLiRmb250ZmFjZSh7XHJcbiAgICAgKiAgICAgICAgIGZvbnRGYW1pbHk6IFwiUm9ib3RvXCIsXHJcbiAgICAgKiAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIixcclxuICAgICAqICAgICAgICAgZm9udFdlaWdodDogNzAwLFxyXG4gICAgICogICAgICAgICBzcmM6IHt1cmw6ICdyb2JvdG8ud29mZicsIGZvcm1hdDogJ3dvZmYnfVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZvbnRmYWNlIE9iamVjdCBpbXBsZW1lbnRpbmcgdGhlIGBJRm9udEZhY2VgIGludGVyZmFjZSBkZWZpbmluZyB0aGUgcGFyYW1ldGVyIG9mIHRoZVxyXG4gICAgICogZm9udCB0byB1c2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYElGb250RmFjZVJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIEBmb250LWZhY2UgcnVsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljICRmb250ZmFjZSggZm9udGZhY2U6IEV4dGVuZGVkRm9udEZhY2UpOiBJRm9udEZhY2VSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGb250RmFjZVJ1bGUoIGZvbnRmYWNlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQGltcG9ydGAgcnVsZSByZWZlcmVuY2luZyB0aGUgZ2l2ZW4gQ1NTIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgaW1wb3J0ZWRDc3NGaWxlcyA9IFtcclxuICAgICAqICAgICAgICAgdGhpcy4kaW1wb3J0KCBcImNvbW1vbi0zcmRwYXJ0eS5jc3NcIiksXHJcbiAgICAgKiAgICAgICAgIHRoaXMuJGltcG9ydCggXCJzbWFsbC1zY3JlZW4tM3JkcGFydHkuY3NzXCIsIHttYXhXaWR0aDogNjAwfSksXHJcbiAgICAgKiAgICAgXVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybCBVUkwgdG8gdGhlIENTUyBmaWxlLiBSZWxhdGl2ZSBVUkxzIGFyZSByZXNvbHZlZCByZWxhdGl2ZSB0byB0aGUgYmFzZSBVUkwgb2YgdGhlXHJcbiAgICAgKiBwYWdlIHdoZXJlIHRoZSBNaW1jc3MgbGlicmFyeSBpcyBpbnZva2VkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGBJSW1wb3J0UnVsZWAgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgYEBpbXBvcnRgIHJ1bGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkaW1wb3J0KCB1cmw6IHN0cmluZywgbWVkaWFRdWVyeT86IHN0cmluZyB8IE1lZGlhU3RhdGVtZW50LFxyXG4gICAgICAgIHN1cHBvcnRzUXVlcnk/OiBzdHJpbmcgfCBTdXBwb3J0c1N0YXRlbWVudCk6IElJbXBvcnRSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBvcnRSdWxlKCB1cmwsIG1lZGlhUXVlcnksIHN1cHBvcnRzUXVlcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYEBuYW1lc3BhY2VgIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgaW5pdCA9IFtcclxuICAgICAqICAgICAgICAgdGhpcy4kbmFtZXNwYWNlKCBjc3MuV2ViTmFtZXNwYWNlcy5TVkcsIFwic3ZnXCIpXHJcbiAgICAgKiAgICAgXVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSBOYW1lc3BhY2Ugc3RyaW5nIC0gdXNlIHRoZSBbW1dlYk5hbWVzcGFjZXNdXSBmb3Igd2VsbC1rbm93biBuYW1lc3BhY2VzLlxyXG4gICAgICogQHBhcmFtIHByZWZpeCBQcmVmaXggc3RyaW5nIHRvIHVzZSBmb3IgdGhlIG5hbWVzcGFjZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSU5hbWVzcGFjZVJ1bGVgIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIG5hbWVzcGFjZSBydWxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJG5hbWVzcGFjZSggbmFtZXNwYWNlOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZyk6IElOYW1lc3BhY2VSdWxlXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lc3BhY2VSdWxlKCBuYW1lc3BhY2UsIHByZWZpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgQHBhZ2VgIHJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogKipFeGFtcGxlOioqXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgaW5pdCA9IFtcclxuICAgICAqICAgICAgICAgdGhpcy4kcGFnZSggXCI6Zmlyc3RcIiwgeyBtYXJnaW46IFwiYXV0b1wiIH0pXHJcbiAgICAgKiAgICAgXVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBzZXVkb0NsYXNzIE9wdGlvbmFsIG5hbWUgb2YgdGhlIHBhZ2UgcHNldWRvIHN0eWxlLlxyXG4gICAgICogQHBhcmFtIHN0eWxlc2V0IFN0eWxlcyB0byBhcHBseS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBgSVBhZ2VSdWxlYCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYWdlIHJ1bGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkcGFnZSggcHNldWRvQ2xhc3M/OiBQYWdlUHNldWRvQ2xhc3MsIHN0eWxlc2V0PzogU3R5bGVzZXQpOiBJUGFnZVJ1bGVcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBhZ2VSdWxlKCBwc2V1ZG9DbGFzcywgc3R5bGVzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQHN1cHBvcnRzYCBydWxlLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGNscyA9IHRoaXMuJGNsYXNzKHsgY29sb3I6IFwicmVkXCJ9KVxyXG4gICAgICpcclxuICAgICAqICAgICBpZkdyaWRTdXBwb3J0ZWQgPSB0aGlzLiRtZWRpYSggeyBkaXNwbGF5OiBcImdyaWRcIiB9LFxyXG4gICAgICogICAgICAgICBjbGFzcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb248TXlTdHlsZXM+XHJcbiAgICAgKiAgICAgICAgIHtcclxuICAgICAqICAgICAgICAgICAgIGNscyA9IHRoaXMuJGNsYXNzKHsgY29sb3I6IFwicGlua1wifSlcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIClcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZW1lbnQgU3VwcG9ydHMgc3RhdGVtZW50IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3VwcG9ydHMgcXVlcmllcy5cclxuICAgICAqIEBwYXJhbSBpbnN0T3JDbGFzcyBFaXRoZXIgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBvciBhbiBpbnN0YW5jZSBvZiBhIHN0eWxlIGRlZmludGlvbiBjbGFzcy5cclxuICAgICAqIEByZXR1cm5zIGBJU3VwcG9ydHNSdWxlYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdXBwb3J0cyBydWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAkc3VwcG9ydHM8VCBleHRlbmRzIFN0eWxlRGVmaW5pdGlvbjxTdHlsZURlZmluaXRpb248UD4+Piggc3RhdGVtZW50OiBTdXBwb3J0c1N0YXRlbWVudCxcclxuICAgICAgICBpbnN0T3JDbGFzczogVCB8IElTdHlsZURlZmluaXRpb25DbGFzczxUPik6IElTdXBwb3J0c1J1bGU8VD5cclxuICAgIHtcclxuICAgICAgICByZXR1cm4gbmV3IFN1cHBvcnRzUnVsZSggc3RhdGVtZW50LCBpbnN0T3JDbGFzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgQG1lZGlhYCBydWxlLlxyXG4gICAgICpcclxuICAgICAqICoqRXhhbXBsZToqKlxyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGNscyA9IHRoaXMuJGNsYXNzKHsgY29sb3I6IFwicmVkXCJ9KVxyXG4gICAgICpcclxuICAgICAqICAgICBpZk5hcnJvd1NjcmVlbiA9IHRoaXMuJG1lZGlhKCB7IG1heFdpZHRoOiA4MDAgfSxcclxuICAgICAqICAgICAgICAgY2xhc3MgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uPE15U3R5bGVzPlxyXG4gICAgICogICAgICAgICB7XHJcbiAgICAgKiAgICAgICAgICAgICBjbHMgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiBcInBpbmtcIn0pXHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICApXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVtZW50IE1lZGlhIHN0YXRlbWVudCBjb250YWluaW5nIG9uZSBvciBtb3JlIG1lZGlhIHF1ZXJpZXMuXHJcbiAgICAgKiBAcGFyYW0gaW5zdE9yQ2xhc3MgRWl0aGVyIHN0eWxlIGRlZmluaXRpb24gY2xhc3Mgb3IgYW4gaW5zdGFuY2Ugb2YgYSBzdHlsZSBkZWZpbnRpb24gY2xhc3MuXHJcbiAgICAgKiBAcmV0dXJucyBgSU1lZGlhUnVsZWAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbWVkaWEgcnVsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJG1lZGlhPFQgZXh0ZW5kcyBTdHlsZURlZmluaXRpb248U3R5bGVEZWZpbml0aW9uPFA+Pj4oIHN0YXRlbWVudDogTWVkaWFTdGF0ZW1lbnQsXHJcbiAgICAgICAgaW5zdE9yQ2xhc3M6IFQgfCBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VD4pOiBJTWVkaWFSdWxlPFQ+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZWRpYVJ1bGUoIHN0YXRlbWVudCwgaW5zdE9yQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gY2xhc3Mgb3IgaW5zdGFuY2UgYW5kIGNyZWF0ZXMgdW5pcXVlIG5hbWVzIGZvciBhbGwgbmFtZWRcclxuICAgICAqIGVudGl0aWVzLiBGb3IgYSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIG9ubHkgYSBzaW5nbGUgaW5zdGFuY2UgaXMgY3JlYXRlZCwgbm8gbWF0dGVyIGhvd1xyXG4gICAgICogbWFueSB0aW1lcyB0aGlzIGZ1bmN0aW9uIGlzIGludm9rZWQuIEhvd2V2ZXIsIGlmIGFuIGluc3RhbmNlLCB3aGljaCBoYXMgbm90IHlldCBiZWVuIHByb2Nlc3NlZCxcclxuICAgICAqIGlzIHBhc3NlZCwgdGhlbiBhIG5ldyBzZXQgb2YgdW5pcXVlIG5hbWVzIHdpbGwgYmUgY3JlYXRlZCBmb3IgaXQuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGAkdXNlYCBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlZmVyZW5jZSBhIHN0eWxlIGRlZmluaXRpb24gZnJvbSBhbm90aGVyIHN0eWxlIGRlZmluaXRpb24sIGZvclxyXG4gICAgICogZXhhbXBsZTpcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjbGFzcyBDb21tb25TdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgZXJyb3IgPSB0aGlzLiRjbGFzcyh7IGNvbG9yOiBcInJlZFwifSlcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBjbGFzcyBQYWdlU3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gICAgICoge1xyXG4gICAgICogICAgIGNvbW1vbiA9IHRoaXMuJHVzZSggQ29tbW9uU3R5bGVzKVxyXG4gICAgICpcclxuICAgICAqICAgICBlcnJvTWVzc2FnZSA9IHRoaXMuJGNsYXNzKHtcclxuICAgICAqICAgICAgICAgXCIrXCI6IHRoaXMuY29tbW9uLmVycm9yLFxyXG4gICAgICogICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIlxyXG4gICAgICogICAgIH0pXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHRoZSBgJHVzZWAgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgcnVsZXMgZnJvbSB0aGUgcmVmZXJlbmNlZCBzdHlsZSBkZWZpbml0aW9uIGFyZSBub3RcclxuICAgICAqIGluc2VydGVkIGludG8gdGhlIERPTTsgdGhleSB3aWxsIGJlIGluc2VydGVkIHdoZW4gdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MgdGhhdCBjb250YWluc1xyXG4gICAgICogdGhlIGAkdXNlYCBjYWxsIGlzIGFjdGl2YXRlZC4gVGhlIHNhbWUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBjYW4gYmUgdXNlZCBmcm9tIHNldmVyYWxcclxuICAgICAqIG90aGVyIHN0eWxlIGRlZmluaXRpb25zOiBhcyBsb25nIGFzIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSByZWZlcmVuY2luZyBzdHlsZSBkZWZpbml0aW9uIHRoYXRcclxuICAgICAqIGlzIGFjdGl2YXRlZCwgdGhlIHJ1bGVzIHdpbGwgYmUgaW4gdGhlIERPTTsgYXMgc29vbiBhcyBhbGwgcmVmZXJlbmNpbmcgc3R5bGUgZGVmaW5pdGlvbnMgYXJlXHJcbiAgICAgKiBkZWFjdGl2YXRlZCwgdGhlIHJ1bGVzIGZyb20gdGhlIHJlZmVyZW5jZWQgZGVmaW5pdGlvbiBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBET00uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluc3RPckNsYXNzIEVpdGhlciBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIG9yIGFuIGluc3RhbmNlIG9mIGEgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLCB3aGljaCB3aWxsIGJlIGFjdGl2YXRlZCBhbmQgZGVhY3RpdmF0ZWRcclxuICAgICAqIGFsb25nIHdpdGggdGhlIGVuY2xvc2luZyBzdHlsZSBkZWZpbml0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgJHVzZTxUIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uPiggaW5zdE9yQ2xhc3M6IFQgfCBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VD4pOiBUXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NTRCggaW5zdE9yQ2xhc3MpIGFzIFQ7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciBmdW5jdGlvbiBmb3Igc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIHRoYXQgd2lsbCBiZSBlbWJlZGRlZCBpbnRvIGFuIGVtYmVkZGluZ1xyXG4gKiBjb250YWluZXIgZm9yIHRoZSBnaXZlbiBjYXRlZ29yeS4gQWxsIHN0eWxlIGRlZmluaXRpb25zIGZvciBhIGdpdmVuIGNhdGVnb3J5IHdpbGwgYmUgYWN0aXZhdGVkXHJcbiAqIGFuZCBkZWFjdGl2YXRlZCB0b2dldGhlciBhbmQgdGhlaXIgcnVsZXMgd2lsbCBiZSBpbnNlcnRlZCBpbnRvIGEgc2luZ2xlIGA8c3R5bGU+YCBlbGVtZW50LlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBAY3NzLmVtYmVkZGVkKFwid2lkZ2V0c1wiKVxyXG4gKiBjbGFzcyBGaXJzdFdpZGdldFN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb24gey4uLn1cclxuICpcclxuICogQGNzcy5lbWJlZGRlZChcIndpZGdldHNcIilcclxuICogY2xhc3MgU2Vjb25kV2lkZ2V0U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvbiB7Li4ufVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjb25zdCBlbWJlZGRlZCA9IChjYXRlZ29yeTogc3RyaW5nKTogQ2xhc3NEZWNvcmF0b3IgPT5cclxuICAgIC8vIHdlIHJldHVybiB0aGUgZnVuY3Rpb24gdGhhdCBpcyB0aGUgYWN0dWFsIGRlY29yYXRvci5cclxuICAgIGVtYmVkZGVkRGVjb3JhdG9yLmJpbmQoIHVuZGVmaW5lZCwgY2F0ZWdvcnkpO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gTmFtZSBnZW5lcmF0aW9uLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBtZXRob2QgdXNlcyB0byBnZW5lcmF0ZSBuYW1lcyBvZiBDU1MgZW50aXRpZXMuIElmIHllcywgdGhlIG5hbWVzIHdpbGwgYmUgY3JlYXRlZCBieVxyXG4gKiBhcHBlbmRpbmcgYSB1bmlxdWUgbnVtYmVyIHRvIHRoZSBnaXZlbiBwcmVmaXguIElmIHRoZSBwcmVmaXggaXMgbm90IHNwZWNpZmllZCwgdGhlIHN0YW5kYXJkXHJcbiAqIHByZWZpeCBcIm5cIiB3aWxsIGJlIHVzZWQuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQgdGhlIGRldmVsb3BtZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkgKG1pbWNzcy5kZXYuanMpIHVzZXMgdGhlIFtbVW5pcXVlU2NvcGVkXV1cclxuICogbWV0aG9kIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIChtaW1jc3MuanMpIHVzZXMgdGhlIFtbT3B0aW1pemVkXV0gbWV0aG9kLiBUaGlzIGZ1bmN0aW9uIGNhblxyXG4gKiBiZSBjYWxsZWQgdG8gc3dpdGNoIHRvIHRoZSBhbHRlcm5hdGl2ZSBtZXRob2Qgb2YgbmFtZSBnZW5lcmF0aW9uIGluIGVpdGhlciB0aGUgZGV2ZWxvcG1lbnQgb3JcclxuICogdGhlIHByb2R1Y3Rpb24gYnVpbGRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWV0aG9kIEluZGljYXRlcyB3aGF0IG1ldGhvZCB0byB1c2UuXHJcbiAqIEBwYXJhbSBwcmVmaXggT3B0aW9uYWwgc3RyaW5nIHRoYXQgd2lsbCBzZXJ2ZSBhcyBhIHByZWZpeCB0byB3aGljaCB1bmlxdWUgbnVtYmVycyB3aWxsIGJlIGFkZGVkXHJcbiAqIHRvIGdlbmVyYXRlIG9wdGltaXplZCBuYW1lcy4gSWdub3JlZCBpZiB0aGUgYG1ldGhvZGAgcGFyYW1ldGVyIGlzIGFueXRoaW5nIG90aGVyIHRoYW5cclxuICogW1tOYW1lR2VuZXJhdGlvbk1ldGhvZC5PcHRpbWl6ZWRdXS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjb25maWdOYW1lR2VuZXJhdGlvbiA9IChtZXRob2Q6IE5hbWVHZW5lcmF0aW9uTWV0aG9kLCBwcmVmaXg/OiBzdHJpbmcpOiB2b2lkID0+XHJcblx0Y29uZmlnTmFtZXMoIG1ldGhvZCwgcHJlZml4KTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEhlbHBlciBmdW5jdGlvbnMuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIENvbmNhdGVuYXRlcyB0aGUgbmFtZXMgb2YgdGhlIGdpdmVuIGNsYXNzZXMgaW50byBhIHNpbmdsZSBzdHJpbmcgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gYVxyXG4gKiBgY2xhc3NgIHByb3BlcnR5IG9mIGFuIEhUTUwgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGNsYXNzUHJvcHMgVmFyaWFibGUgYXJndW1lbnQgbGlzdCBvZiBlaXRoZXIgY2xhc3MgbmFtZXMgb3IgY2xhc3MgcnVsZSBvYmplY3RzLlxyXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIHRoYXQgY29tYmluZXMgYWxsIGNsYXNzIG5hbWVzIChzZXBhcmF0ZWQgd2l0aCBzcGFjZSkgZnJvbSB0aGUgaW5wdXQgYXJyYXkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2xhc3NlcyA9ICguLi5jbGFzc1Byb3BzOiBDbGFzc1Byb3BUeXBlW10pOiBzdHJpbmcgPT5cclxuXHR2MnMoIGNsYXNzUHJvcHMsIHtcclxuXHRcdG9iajogKHY6IElDbGFzc1J1bGUgfCBJQ2xhc3NOYW1lUnVsZSkgPT4gdi5uYW1lLFxyXG5cdFx0aXRlbTogY2xhc3Nlc1xyXG5cdH0pO1xyXG5cclxuLyoqXHJcbiAqIENob29zZXMgdGhlIGZpcnN0IG5vbi1udWxsIG5hbWUgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBvZiBjbGFzc2VzLlxyXG4gKiBAcGFyYW0gY2xhc3NQcm9wc1xyXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgbm9uLWVtcHR5IGNsYXNzIG5hbWUgZnJvbSB0aGUgaW5wdXQgYXJyYXkgb3IgbnVsbCBpZiBhbGwgaW5wdXRzIGFyZSBlbXB0eS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaG9vc2VDbGFzcyA9ICguLi5jbGFzc1Byb3BzOiBDbGFzc1Byb3BUeXBlW10pOiBzdHJpbmcgfCBudWxsID0+XHJcbntcclxuICAgIGZvciggbGV0IGNsYXNzUHJvcCBvZiBjbGFzc1Byb3BzKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghY2xhc3NQcm9wKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2xhc3NQcm9wID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NQcm9wO1xyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NQcm9wKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBuYW1lID0gY2hvb3NlQ2xhc3MoIGNsYXNzUHJvcCk7XHJcbiAgICAgICAgICAgIGlmIChuYW1lKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNsYXNzUHJvcC5uYW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NQcm9wLm5hbWU7XHJcbiAgICB9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBSdWxlIHZpcnR1YWxpemF0aW9uIGFuZCB0aGVtaW5nLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhIHJ1bGUgaWYgaXQgaXMgZGVmaW5lZCBhbmQgdXNlZCBpbiB0aGUgc2FtZSBzdHlsZVxyXG4gKiBkZWZpbml0aW9uIGNsYXNzIGJ1dCB0aGVuIGlzIG92ZXJyaWRkZW4gaW4gYSBkZXJpdmVkIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFRoZSBwcm9ibGVtXHJcbiAqIHRoaXMgc29sdmVzIGlzIHRoaXM6IHdoZW4gYSBydWxlIGlzIGRlZmluZWQgaW4gYSBiYXNlIGNsYXNzIGFuZCB0aGVuIG92ZXJyaWRkZW4gaW4gYSBkZXJpdmVkXHJcbiAqIGNsYXNzLCB3aGVuIGFuIGluc3RhbmNlIG9mIHRoZSBkZXJpdmVkIGNsYXNzIGlzIGNyZWF0ZWQsIHRoZSBydWxlcyB0aGF0IGFyZSBjcmVhdGVkIGluIHRoZVxyXG4gKiBiYXNlIGFuZCBkZXJpdmVkIGNsYXNzZXMgc2VlIGRpZmZlcmVudCB2YWx1ZXMgb2YgdGhlIHJ1bGUuIFNpbmNlIG91ciBydWxlcyBhcmUgZGVmaW5lZCBhc1xyXG4gKiBwYXJ0IG9mIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGJhc2UgY2xhc3MgY29uc3RydWN0b3IncyBjb2RlIG9ubHkgc2VlcyB0aGUgdmFsdWUgYXNzaWduZWQgaW4gdGhhdFxyXG4gKiBjb2RlLiBJZiBhbm90aGVyIHJ1bGUgaW4gdGhlIGJhc2UgY2xhc3MgdXNlcyB0aGlzIGZpcnN0IHJ1bGUsIHRoaXMgdmFsdWUgaXMgcmVtZW1iZXJlZC5cclxuICpcclxuICogVGhlIGBAdmlydHVhbGAgZGVjb3JhdG9yIGNyZWF0ZXMgYSBQcm94eSBvYmplY3QgZm9yIHRoZSBydWxlIHdpdGggdGhlIGhhbmRsZXIgdGhhdCBrZWVwcyB0aGVcclxuICogbW9zdCByZWNlbnQgdmFsdWUgc2V0LiBUaHVzIHdoZW4gYSBydWxlIGluIHRoZSBiYXNlIGNsYXNzJ3MgY29uc3RydWN0b3IgdXNlcyBhIHZpcnR1YWxpemVkXHJcbiAqIHJ1bGUsIHRoZSBmaXJzdCBydWxlIHdpbGwgc2VlIHRoZSBvdmVycmlkZGVuIHZhbHVlIG9mIHRoZSBydWxlIHdoZW4gYWNjZXNzZWQgaW4gdGhlXHJcbiAqIHBvc3QtY29uc3RydWN0b3IgY29kZS5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgVGhpcyBkZWNvcmF0b3IgaXMgZGVwcmVjYXRlZCBhcyAgYWxsIHJ1bGVzIGRlZmluZWQgaW4gc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIGFyZVxyXG4gKiBhbHdheXMgdmlydHVhbGl6ZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdmlydHVhbCA9ICh0YXJnZXQ6IGFueSwgbmFtZTogc3RyaW5nKTogdm9pZCA9PiB7fTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBgVGhlbWVEZWZpbml0aW9uYCBjbGFzcyBpcyBhIGJhc2UgZm9yIGFsbCBjbGFzc2VzIHRoYXQgZGVmaW5lIHRoZW1lcy4gSW4gYWRkaXRpb24gdG9cclxuICogYmVpbmcgYSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLCB0aGVtZXMgcHJvdmlkZSBzb21lIGV4dHJhIGNhcGFiaWxpdGllcyByZWxhdGVkIHRvIHN0eWxlXHJcbiAqIGluaGVyaXRhbmNlIGFuZCB0aGVtZSBhY3RpdmF0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFAgUGFyZW50IHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIFBhcmVudCBvZiBhIHRvcC1sZXZlbCBjbGFzcyBpcyBudWxsLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRoZW1lRGVmaW5pdGlvbjxQIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uID0gYW55PiBleHRlbmRzIFN0eWxlRGVmaW5pdGlvbjxQPlxyXG57XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEFjdGl2YXRpb24uXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIEFjdGl2YXRlcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBvciBpbnN0YW5jZSBhbmQgaW5zZXJ0cyBhbGwgaXRzIHJ1bGVzIGludG8gRE9NLiBJZlxyXG4gKiB0aGUgaW5wdXQgb2JqZWN0IGlzIG5vdCBhbiBpbnN0YW5jZSBidXQgYSBjbGFzcywgd2hpY2ggaXMgbm90IHlldCBhc3NvY2lhdGVkIHdpdGggYW4gaW5zdGFuY2UsXHJcbiAqIHRoZSBpbnN0YW5jZSBpcyBmaXJzdCBjcmVhdGVkIGFuZCBwcm9jZXNzZWQuIE5vdGUgdGhhdCBlYWNoIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2UgbWFpbnRhaW5zXHJcbiAqIGEgcmVmZXJlbmNlIGNvdW50ZXIgb2YgaG93IG1hbnkgdGltZXMgaXQgd2FzIGFjdGl2YXRlZCBhbmQgZGVhY3RpdmF0ZWQuIFRoZSBydWxlcyBhcmUgaW5zZXJ0ZWRcclxuICogaW50byBET00gb25seSB1cG9uIGZpcnN0IGFjdGl2YXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWN0aXZhdGUgPSA8VCBleHRlbmRzIElTdHlsZURlZmluaXRpb24+KGluc3RPckNsYXNzOiBUIHwgSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFQ+LFxyXG5cdHNjaGVkdWxlclR5cGU/OiBudW1iZXIpOiBUID0+XHJcbntcclxuXHRsZXQgaW5zdGFuY2UgPSBwcm9jZXNzU0QoIGluc3RPckNsYXNzKSBhcyBUO1xyXG5cdGlmIChpbnN0YW5jZSlcclxuICAgICAgICBnZXRBY3RpdmF0b3Ioc2NoZWR1bGVyVHlwZSkuYWN0aXZhdGUoIGluc3RhbmNlKTtcclxuXHJcblx0cmV0dXJuIGluc3RhbmNlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEZWFjdGl2YXRlcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZSBieSByZW1vdmluZyBpdHMgcnVsZXMgZnJvbSBET00uIE5vdGUgdGhhdCBlYWNoXHJcbiAqIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2UgbWFpbnRhaW5zIGEgcmVmZXJlbmNlIGNvdW50ZXIgb2YgaG93IG1hbnkgdGltZXMgaXQgd2FzIGFjdGl2YXRlZCBhbmRcclxuICogZGVhY3RpdmF0ZWQuIFRoZSBydWxlcyBhcmUgcmVtb3ZlZCBmcm9tIERPTSBvbmx5IHdoZW4gdGhpcyByZWZlcmVuY2UgY291bnRlciBnb2VzIGRvd24gdG8gMC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWFjdGl2YXRlID0gKGluc3RhbmNlOiBJU3R5bGVEZWZpbml0aW9uLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZCA9PlxyXG5cdGdldEFjdGl2YXRvcihzY2hlZHVsZXJUeXBlKS5kZWFjdGl2YXRlKCBpbnN0YW5jZSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0aGVtZSBkZWZpbml0aW9uIG9iamVjdCwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2ZSBmb3IgdGhlIGdpdmVuIHRoZW1lIGRlY2xhcmF0aW9uXHJcbiAqIGNsYXNzLlxyXG4gKiBAcGFyYW0gdGhlbWVDbGFzcyBUaGVtZSBkZWNsYXJhdGlvbiBjbGFzc1xyXG4gKiBAcmV0dXJucyBUaGVtZSBpbnN0YW5jZSwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2ZSBmb3IgdGhlIGdpdmVuIHRoZW1lIGNsYXNzIG9yIHVuZGVmaW5lZFxyXG4gKiBpZiBubyBpbnN0YW5jZSBpcyBjdXJyZW50bHkgYWN0aXZlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEFjdGl2ZVRoZW1lID0gKHRoZW1lQ2xhc3M6IElTdHlsZURlZmluaXRpb25DbGFzczxUaGVtZURlZmluaXRpb24+KTogVGhlbWVEZWZpbml0aW9uIHwgdW5kZWZpbmVkID0+XHJcbiAgICBnZXRDdXJyZW50VGhlbWUoIHRoZW1lQ2xhc3MpO1xyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQge0lTY2hlZHVsZXJ9IGZyb20gXCIuLi9hcGkvU2NoZWR1bGluZ1R5cGVzXCI7XHJcbmltcG9ydCAqIGFzIGltcGwgZnJvbSBcIi4uL2ltcGwvU2NoZWR1bGluZ0ltcGxcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gU2NoZWR1bGluZy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgdG8gRE9NIGFsbCBzdHlsZSBjaGFuZ2VzIGNhdXNlZCBieSB0aGUgY2FsbHMgdG8gdGhlIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9uc1xyXG4gKiBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdCBhY3RpdmF0aW9uIG9mIHRoZSBnaXZlbiBzY2hlZHVsaW5nIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZm9yY2VET01VcGRhdGUgPSAoc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQgPT5cclxuXHRpbXBsLmdldEFjdGl2YXRvcihzY2hlZHVsZXJUeXBlKS5mb3JjZURPTVVwZGF0ZSgpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwgc2NoZWR1bGVkIGFjdGl2YXRpb25zIGNhdXNlZCBieSB0aGUgY2FsbHMgdG8gdGhlIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9uc1xyXG4gKiBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdCBhY3RpdmF0aW9uIG9mIHRoZSBnaXZlbiBzY2hlZHVsaW5nIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FuY2VsRE9NVXBkYXRlID0gKHNjaGVkdWxlclR5cGU/OiBudW1iZXIpOiB2b2lkID0+XHJcblx0aW1wbC5nZXRBY3RpdmF0b3Ioc2NoZWR1bGVyVHlwZSkuY2FuY2VsRE9NVXBkYXRlKCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlZmF1bHQgc2NoZWR1bGVyIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdFNjaGVkdWxlciA9ICgpOiBudW1iZXIgPT5cclxuICAgIGltcGwuZ2V0RGVmYXVsdFNjaGVkdWxlcigpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgZGVmYXVsdCBzY2hlZHVsaW5nIHR5cGUgdGhhdCBpcyB1c2VkIGJ5IGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIGZ1bmN0aW9ucyB0aGF0IGFyZVxyXG4gKiBjYWxsZWQgd2l0aG91dCBleHBsaWNpdGx5IHByb3ZpZGluZyB2YWx1ZSB0byB0aGUgc2NoZWR1bGluZyBwYXJhbWV0ZXIuIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlXHJcbiAqIHByZXZpb3VzIGRlZmF1bHQgYWN0aXZhdG9yIG9yIDAgaWYgYW4gZXJyb3Igb2NjdXJzIChlLmcuIHRoZSBnaXZlbiBzY2hlZHVsZXIgdHlwZSBJRCBpcyBub3RcclxuICogcmVnaXN0ZXJlZCkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0RGVmYXVsdFNjaGVkdWxlciA9IChzY2hlZHVsZXJUeXBlOiBudW1iZXIpOiBudW1iZXIgPT5cclxuICAgIGltcGwuc2V0RGVmYXVsdFNjaGVkdWxlciggc2NoZWR1bGVyVHlwZSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHNjaGVkdWxlciBvYmplY3QgYW5kIHJldHVybnMgdGhlIHNjaGVkdWxlciB0eXBlIGlkZW50aWZpZXIsIHdoaWNoXHJcbiAqIHNob3VsZCBiZSB1c2VkIHdoZW4gY2FsbGluZyBhY3RpdmF0ZSBhbmQgZGVhY3RpdmF0ZSBmdW5jdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJTY2hlZHVsZXIgPSAoc2NoZWR1bGVyOiBJU2NoZWR1bGVyKTogbnVtYmVyID0+XHJcbiAgICBpbXBsLnJlZ2lzdGVyU2NoZWR1bGVyKCBzY2hlZHVsZXIpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVW5yZWdpc3RlcnMgYSBzY2hlZHVsZXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNjaGVkdWxlciB0eXBlIGlkZW50aWZpZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdW5yZWdpc3RlclNjaGVkdWxlciA9IChzY2hlZHVsZXJUeXBlOiBudW1iZXIpOiB2b2lkID0+XHJcbiAgICBpbXBsLnVucmVnaXN0ZXJTY2hlZHVsZXIoIHNjaGVkdWxlclR5cGUpO1xyXG5cclxuXHJcblxyXG4iLCLvu79pbXBvcnQge0Nzc0ltYWdlLCBFeHRlbmRlZCwgRXh0ZW50S2V5d29yZH0gZnJvbSBcIi4vQ29yZVR5cGVzXCI7XHJcbmltcG9ydCB7Qm9yZGVyUmFkaXVzLCBDc3NBbmdsZSwgQ3NzTGVuZ3RoLCBDc3NOdW1iZXIsIENzc1BlcmNlbnQsIENzc1BvaW50LCBDc3NQb3NpdGlvbn0gZnJvbSBcIi4vTnVtZXJpY1R5cGVzXCI7XHJcbmltcG9ydCB7Q3NzQ29sb3J9IGZyb20gXCIuL0NvbG9yVHlwZXNcIjtcclxuaW1wb3J0IHtcclxuICAgIEdyYWRpZW50U3RvcE9ySGludCwgTGluZWFyR3JhZGllbnRBbmdsZSwgU2hhcGVSYWRpdXMsIElNaW5NYXhGdW5jLCBJUGF0aEJ1aWxkZXIsXHJcbiAgICBJUmVwZWF0RnVuYywgSUdyaWRTcGFuRnVuYywgRmlsbFJ1bGUsIElDaXJjbGVCdWlsZGVyLCBJRWxsaXBzZUJ1aWxkZXIsXHJcbiAgICBJSW5zZXRCdWlsZGVyLCBJUG9seWdvbkJ1aWxkZXIsIFBhdGhDb21tYW5kLCBQYXRoQ29tbWFuZFBhcmFtLCBJUmF5RnVuYyxcclxuICAgIFBlcmNlbnRGaWx0ZXJOYW1lcywgSVBlcmNlbnRGaWx0ZXJGdW5jLCBJQmx1ckZ1bmMsIElEcm9wU2hhZG93RnVuYywgSUh1ZVJvdGF0ZUZ1bmMsIElNYXRyaXhGdW5jLFxyXG4gICAgSU1hdHJpeDNkRnVuYywgSVBlcnNwZWN0aXZlRnVuYywgSVJvdGF0ZUZ1bmMsIElSb3RhdGUzZEZ1bmMsIElTY2FsZTFkRnVuYywgSVNjYWxlRnVuYywgSVNjYWxlM2RGdW5jLFxyXG4gICAgSVNrZXdGdW5jLCBJU2tldzFkRnVuYywgSVRyYW5zbGF0ZTFkRnVuYywgSVRyYW5zbGF0ZTNkRnVuYywgSVRyYW5zbGF0ZUZ1bmMsIElMaW5lYXJHcmFkaWVudEJ1aWxkZXIsXHJcbiAgICBJTGluZWFyR3JhZGllbnRGdW5jLCBJUmFkaWFsR3JhZGllbnRCdWlsZGVyLCBJUmFkaWFsR3JhZGllbnRGdW5jLCBJQ29uaWNHcmFkaWVudEJ1aWxkZXIsXHJcbiAgICBJQ29uaWNHcmFkaWVudEZ1bmMsIElHcmFkaWVudEJ1aWxkZXIsIElHcmFkaWVudEZ1bmMsIElDcm9zc0ZhZGVCdWlsZGVyLCBJQ3Jvc3NGYWRlRnVuYywgSUltYWdlU2V0RnVuYyxcclxuICAgIEltYWdlU2V0SXRlbSwgSW1hZ2VTZXRSZXNvbHV0aW9uLCBJUGFpbnRXb3JrbGV0cywgSVBhaW50RnVuY1xyXG59IGZyb20gXCIuL1NoYXBlVHlwZXNcIjtcclxuaW1wb3J0IHtHcmlkTGluZUNvdW50T3JOYW1lLCBHcmlkVHJhY2ssIEdyaWRUcmFja1NpemV9IGZyb20gXCIuL1N0eWxlVHlwZXNcIjtcclxuaW1wb3J0IHttdjJzLCBXS0YsIHYycywgd2tmLCBhMnMsIGZkbywgZjJzfSBmcm9tIFwiLi4vaW1wbC9VdGlsc1wiO1xyXG5pbXBvcnQgeyBNYXBwZWRTeW50YXhUeXBlcywgU3ludGF4S2V5IH0gZnJvbSBcIi4vU3R5bGVzZXRzXCI7XHJcbmltcG9ydCB7IHNwMnMgfSBmcm9tIFwiLi4vaW1wbC9TdHlsZUltcGxcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEltYWdlcyBhbmQgZ3JhZGllbnRzLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmNvbnN0IGdyYWRpZW50TmFtZVRvU3RyaW5nID0gKHZhbDogSUdyYWRpZW50RnVuYzxhbnk+KTogc3RyaW5nID0+IGAke3ZhbC5yZXBlYXQgPyBcInJlcGVhdGluZy1cIiA6IFwiXCJ9JHt2YWwuZm59YDtcclxuXHJcbmNvbnN0IGdyYWRpZW50U3RvcHNPckhpbnRzVG9TdHJpbmcgPSAodmFsOiBHcmFkaWVudFN0b3BPckhpbnQ8YW55PltdLCBtYXRoOiBXS0YuTGVuZ3RoIHwgV0tGLkFuZ2xlKTogc3RyaW5nID0+XHJcbiAgICB2MnMoIHZhbCwge1xyXG4gICAgICAgIGl0ZW06IHtcclxuICAgICAgICAgICAgbnVtOiBXS0YuQ29sb3IsXHJcbiAgICAgICAgICAgIGFycjogeyAxOiBbbWF0aF0sIGFueTogW1dLRi5Db2xvciwgbWF0aCwgbWF0aF0gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIElMaW5lYXJHcmFkaWVudEJ1aWxkZXIgaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgYGxpbmVhci1ncmFkaWVudGAgQ1NTIGZ1bmN0aW9ucy5cclxuICpcclxuICogKkV4YW1wbGVzOipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IGxpbmVhckdyYWRpZW50KCBcInJlZFwiLCBcImJsdWVcIilcclxuICpcclxuICogYmFja2dyb3VuZEltYWdlOiBsaW5lYXJHcmFkaWVudCggW1wicmVkXCIsIDMwXSwgW1wiZ3JlZW5cIiwgNTAsIDYwXSwgW1wiYmx1ZVwiLCA4MF0pLnJlcGVhdGluZygpXHJcbiAqXHJcbiAqIGJhY2tncm91bmRJbWFnZTogbGluZWFyR3JhZGllbnQoIFwicmVkXCIsIFwiYmx1ZVwiKS50byggNDUpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gc3RvcHMgVmFyaWFibGUgYXJndW1lbnQgbGlzdCBzcGVjaWZ5aW5nIHN0b3BzIG9yIGhpbnRzIHRoYXQgd2lsbCBiZSBhZGRlZCB0b1xyXG4gKiB0aGUgZ3JhZGllbnQgZGVmaW5pdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IEltYWdlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGluZWFyR3JhZGllbnQgPSAoLi4uc3RvcHM6IEdyYWRpZW50U3RvcE9ySGludDxDc3NMZW5ndGg+W10pOiBJTGluZWFyR3JhZGllbnRCdWlsZGVyID0+XHJcbiAgICBuZXcgTGluZWFyR3JhZGllbnRCdWlsZGVyKCBzdG9wcyk7XHJcblxyXG5mZG9bXCJsaW5lYXItZ3JhZGllbnRcIl0gPSB7XHJcbiAgICBmbjogZ3JhZGllbnROYW1lVG9TdHJpbmcsXHJcbiAgICBmOiAodmFsOiBJTGluZWFyR3JhZGllbnRGdW5jKSA9PiBtdjJzKFtcclxuICAgICAgICB2MnMoIHZhbC5hbmdsZSwge251bTogV0tGLkFuZ2xlLCBzdHI6IHYgPT4gXCJ0byBcIiArIHZ9KSxcclxuICAgICAgICBncmFkaWVudFN0b3BzT3JIaW50c1RvU3RyaW5nKCB2YWwuc3RvcHMsIFdLRi5MZW5ndGgpXHJcbiAgICBdLCBcIixcIilcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBJUmFkaWFsR3JhZGllbnQgaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgYHJhZGlhbC1ncmFkaWVudGAgQ1NTIGZ1bmN0aW9ucy5cclxuICpcclxuICogKkV4YW1wbGVzOipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBiYWNrZ3JvdW5kSW1hZ2U6IHJhZGlhbEdyYWRpZW50KCBcInJlZFwiLCBcImJsdWVcIilcclxuICpcclxuICogYmFja2dyb3VuZEltYWdlOiByYWRpYWxHcmFkaWVudCggXCJyZWRcIiwgXCJibHVlXCIpLmNpcmNsZSggY3NzLnBlcmNlbnQoMzApKS5hdCggW1wiY2VudGVyXCIsIGNzcy5wZXJjZW50KDY1KV0pXHJcbiAqXHJcbiAqIGJhY2tncm91bmRJbWFnZTogcmFkaWFsR3JhZGllbnQoIFwicmVkXCIsIFwiYmx1ZVwiKS5jaXJjbGUoIDIwMCkucmVwZWF0aW5nKClcclxuICpcclxuICogYmFja2dyb3VuZEltYWdlOiByYWRpYWxHcmFkaWVudCggXCJyZWRcIiwgXCJibHVlXCIpLmVsbGlwc2UoIFwiY2xvc2VzdC1zaWRlXCIpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gc3RvcHMgVmFyaWFibGUgYXJndW1lbnQgbGlzdCBzcGVjaWZ5aW5nIHN0b3BzIG9yIGhpbnRzIHRoYXQgd2lsbCBiZSBhZGRlZCB0b1xyXG4gKiB0aGUgZ3JhZGllbnQgZGVmaW5pdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IEltYWdlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmFkaWFsR3JhZGllbnQgPSAoLi4uc3RvcHM6IEdyYWRpZW50U3RvcE9ySGludDxDc3NMZW5ndGg+W10pOiBJUmFkaWFsR3JhZGllbnRCdWlsZGVyID0+XHJcbiAgICBuZXcgUmFkaWFsR3JhZGllbnRCdWlsZGVyKCBzdG9wcyk7XHJcblxyXG5mZG9bXCJyYWRpYWwtZ3JhZGllbnRcIl0gPSB7XHJcbiAgICBmbjogZ3JhZGllbnROYW1lVG9TdHJpbmcsXHJcbiAgICBmOiAodmFsOiBJUmFkaWFsR3JhZGllbnRGdW5jKSA9PiBtdjJzKFtcclxuICAgICAgICBtdjJzKFsgdmFsLnNoYXBlLCBbdmFsLnNpemUsIFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZV0sIFt2YWwucG9zLCBXS0YuQXRQb3NpdGlvbl0gXSksXHJcbiAgICAgICAgZ3JhZGllbnRTdG9wc09ySGludHNUb1N0cmluZyggdmFsLnN0b3BzLCBXS0YuTGVuZ3RoKVxyXG4gICAgXSwgXCIsXCIpXHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIElDb25pY0dyYWRpZW50IGludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIGByYWRpYWwtZ3JhZGllbnRgIENTUyBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqICpFeGFtcGxlczoqXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogYmFja2dyb3VuZEltYWdlOiBjb25pY0dyYWRpZW50KCBcInJlZFwiLCBcImJsdWVcIilcclxuICpcclxuICogYmFja2dyb3VuZEltYWdlOiBjb25pY0dyYWRpZW50KCkucmVwZWF0aW5nKCkuYWRkKCBcInJlZFwiLCBcImJsdWVcIilcclxuICpcclxuICogYmFja2dyb3VuZEltYWdlOiBjb25pY0dyYWRpZW50KCBcInJlZFwiLCBcImJsdWVcIikuZnJvbSggMC4yNSkuYXQoIFtcImNlbnRlclwiLCBjc3MucGVyY2VudCg2NSldKVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHN0b3BzIFZhcmlhYmxlIGFyZ3VtZW50IGxpc3Qgc3BlY2lmeWluZyBzdG9wcyBvciBoaW50cyB0aGF0IHdpbGwgYmUgYWRkZWQgdG9cclxuICogdGhlIGdyYWRpZW50IGRlZmluaXRpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBJbWFnZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbmljR3JhZGllbnQgPSAoLi4uc3RvcHM6IEdyYWRpZW50U3RvcE9ySGludDxDc3NBbmdsZT5bXSk6IElDb25pY0dyYWRpZW50QnVpbGRlciA9PlxyXG4gICAgbmV3IENvbmljR3JhZGllbnRCdWlsZGVyKCBzdG9wcyk7XHJcblxyXG5mZG9bXCJjb25pYy1ncmFkaWVudFwiXSA9IHtcclxuICAgIGZuOiBncmFkaWVudE5hbWVUb1N0cmluZyxcclxuICAgIGY6ICh2YWw6IElDb25pY0dyYWRpZW50RnVuYykgPT4gbXYycyhbXHJcbiAgICAgICAgbXYycyhbIFt2YWwuYW5nbGUsICh2OiBFeHRlbmRlZDxDc3NBbmdsZT4pID0+IFwiZnJvbSBcIiArIHYycyggdiwgV0tGLkFuZ2xlKV0sIFt2YWwucG9zLCBXS0YuQXRQb3NpdGlvbl0gXSksXHJcbiAgICAgICAgZ3JhZGllbnRTdG9wc09ySGludHNUb1N0cmluZyggdmFsLnN0b3BzLCBXS0YuQW5nbGUpXHJcbiAgICBdLCBcIixcIilcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGdyYWRpZW50IGltcGxlbWVudGF0aW9uXHJcbiAqL1xyXG5hYnN0cmFjdCBjbGFzcyBHcmFkaWVudEJ1aWxkZXI8VCBleHRlbmRzIChDc3NMZW5ndGggfCBDc3NBbmdsZSk+IGltcGxlbWVudHMgSUdyYWRpZW50QnVpbGRlcjxUPlxyXG57XHJcbiAgICBmbjogXCJsaW5lYXItZ3JhZGllbnRcIiB8IFwicmFkaWFsLWdyYWRpZW50XCIgfCBcImNvbmljLWdyYWRpZW50XCI7XHJcblxyXG4gICAgcmVwZWF0PzogYm9vbGVhbjtcclxuICAgIHN0b3BzOiBHcmFkaWVudFN0b3BPckhpbnQ8VD5bXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvciggc3RvcHM6IEdyYWRpZW50U3RvcE9ySGludDxUPltdKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RvcHMgPSBzdG9wcyA/PyBbXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVwZWF0aW5nKCBmbGFnPzogYm9vbGVhbik6IHRoaXNcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJlcGVhdCA9IGZsYWcgPT0gbnVsbCA/IHRydWUgOiBmbGFnOyByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkKCAuLi5zdG9wc09ySGludHM6IEdyYWRpZW50U3RvcE9ySGludDxUPltdKTogdGhpc1xyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc3RvcHMucHVzaCggLi4uc3RvcHNPckhpbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBmdW5jdGlvbmFsaXR5IG9mIGxpbmVhciBncmFkaWVudHNcclxuICovXHJcbmNsYXNzIExpbmVhckdyYWRpZW50QnVpbGRlciBleHRlbmRzIEdyYWRpZW50QnVpbGRlcjxDc3NMZW5ndGg+IGltcGxlbWVudHMgSUxpbmVhckdyYWRpZW50QnVpbGRlclxyXG57XHJcbiAgICBmbjogXCJsaW5lYXItZ3JhZGllbnRcIiA9IFwibGluZWFyLWdyYWRpZW50XCI7XHJcblxyXG4gICAgYW5nbGU/OiBMaW5lYXJHcmFkaWVudEFuZ2xlO1xyXG5cclxuICAgIHB1YmxpYyB0byggYW5nbGU/OiBMaW5lYXJHcmFkaWVudEFuZ2xlKTogdGhpcyB7IHRoaXMuYW5nbGUgPSBhbmdsZTsgcmV0dXJuIHRoaXM7IH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBmdW5jdGlvbmFsaXR5IG9mIHJhZGlhbCBncmFkaWVudHNcclxuICovXHJcbmNsYXNzIFJhZGlhbEdyYWRpZW50QnVpbGRlciBleHRlbmRzIEdyYWRpZW50QnVpbGRlcjxDc3NMZW5ndGg+IGltcGxlbWVudHMgSVJhZGlhbEdyYWRpZW50QnVpbGRlclxyXG57XHJcbiAgICBmbjogXCJyYWRpYWwtZ3JhZGllbnRcIiA9IFwicmFkaWFsLWdyYWRpZW50XCI7XHJcblxyXG4gICAgc2hhcGU/OiBcImNpcmNsZVwiIHwgXCJlbGxpcHNlXCI7XHJcblx0c2l6ZT86IEV4dGVuZGVkPENzc0xlbmd0aD4gfCBFeHRlbmRlZDxFeHRlbnRLZXl3b3JkPiB8IFtFeHRlbmRlZDxDc3NMZW5ndGg+LCBFeHRlbmRlZDxDc3NMZW5ndGg+XTtcclxuICAgIHBvcz86IEV4dGVuZGVkPENzc1Bvc2l0aW9uPjtcclxuXHJcblx0cHVibGljIGNpcmNsZSggc2l6ZU9yRXh0ZW50PzogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiB8IEV4dGVuZGVkPEV4dGVudEtleXdvcmQ+KTogdGhpc1xyXG4gICAge1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBcImNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemVPckV4dGVudDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcblx0cHVibGljIGVsbGlwc2UoIC4uLnBhcmFtczogYW55W10pOiB0aGlzXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IFwiZWxsaXBzZVwiO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9XHJcbiAgICAgICAgICAgIHBhcmFtcy5sZW5ndGggPT09IDEgPyBwYXJhbXNbMF0gYXMgRXh0ZW5kZWQ8RXh0ZW50S2V5d29yZD4gOlxyXG4gICAgICAgICAgICBwYXJhbXMubGVuZ3RoID09PSAyID8gW3BhcmFtc1swXSBhcyBFeHRlbmRlZDxDc3NMZW5ndGg+LCBwYXJhbXNbMV0gYXMgRXh0ZW5kZWQ8Q3NzTGVuZ3RoPl0gOlxyXG4gICAgICAgICAgICB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuXHJcblx0cHVibGljIGV4dGVudCggZXh0ZW50OiBFeHRlbmRlZDxFeHRlbnRLZXl3b3JkPik6IHRoaXMgeyB0aGlzLnNpemUgPSBleHRlbnQ7IHJldHVybiB0aGlzOyB9XHJcblx0cHVibGljIGF0KCBwb3M6IEV4dGVuZGVkPENzc1Bvc2l0aW9uPik6IHRoaXMgeyB0aGlzLnBvcyA9IHBvczsgcmV0dXJuIHRoaXM7IH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBmdW5jdGlvbmFsaXR5IG9mIGNvbmljIGdyYWRpZW50c1xyXG4gKi9cclxuY2xhc3MgQ29uaWNHcmFkaWVudEJ1aWxkZXIgZXh0ZW5kcyBHcmFkaWVudEJ1aWxkZXI8Q3NzQW5nbGU+IGltcGxlbWVudHMgSUNvbmljR3JhZGllbnRCdWlsZGVyXHJcbntcclxuICAgIGZuOiBcImNvbmljLWdyYWRpZW50XCIgPSBcImNvbmljLWdyYWRpZW50XCI7XHJcblxyXG4gICAgYW5nbGU/OiBFeHRlbmRlZDxDc3NBbmdsZT47XHJcbiAgICBwb3M/OiBFeHRlbmRlZDxDc3NQb3NpdGlvbj47XHJcblxyXG5cdHB1YmxpYyBmcm9tKCBhbmdsZT86IEV4dGVuZGVkPENzc0FuZ2xlPik6IHRoaXMgeyB0aGlzLmFuZ2xlID0gYW5nbGU7IHJldHVybiB0aGlzOyB9XHJcblx0cHVibGljIGF0KCBwb3M/OiBFeHRlbmRlZDxDc3NQb3NpdGlvbj4pOiB0aGlzIHsgdGhpcy5wb3MgPSBwb3M7IHJldHVybiB0aGlzOyB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgSUNyb3NzRmFkZUZ1bmMgaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgXCJvbGRlclwiIGBjcm9zcy1mYWRlYCBDU1NcclxuICogZnVuY3Rpb24gaW52b2NhdGlvbiB0aGF0IGFjY2VwdHMgdHdvIGltYWdlcyBhbmQgYSBzaW5nbGUgcGVyY2VudGFnZS5cclxuICpcclxuICogQGNhdGVnb3J5IEltYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NGYWRlKCBvbGQ6IFtFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD5dKTogSUNyb3NzRmFkZUZ1bmM7XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBJQ3Jvc3NGYWRlRnVuYyBpbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBcIm5ld2VyXCIgYGNyb3NzLWZhZGVgIENTU1xyXG4gKiBmdW5jdGlvbiBpbnZvY2F0aW9uIHRoYXQgYWNjZXB0cyBtdWx0aXBsZSBpbWFnZXMgLSBlYWNoIHdpdGggYW4gb3B0aW9uYWwgcGVyY2VudGFnZS5cclxuICpcclxuICogQGNhdGVnb3J5IEltYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NGYWRlKCAuLi5pbWFnZXM6IChFeHRlbmRlZDxDc3NJbWFnZT4gfCBbRXh0ZW5kZWQ8Q3NzSW1hZ2U+LCBFeHRlbmRlZDxDc3NQZXJjZW50Pl0pW10pOiBJQ3Jvc3NGYWRlQnVpbGRlcjtcclxuXHJcbi8qKiBJbXBsZW1lbnRhdGlvbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NGYWRlKCk6IElDcm9zc0ZhZGVCdWlsZGVyXHJcbntcclxuICAgIHJldHVybiBuZXcgQ3Jvc3NGYWRlQnVpbGRlciggLi4uYXJndW1lbnRzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgZnVuY3Rpb25hbGl0eSBvZiBjcm9zcy1mYWRlKClcclxuICovXHJcbmNsYXNzIENyb3NzRmFkZUJ1aWxkZXIgaW1wbGVtZW50cyBJQ3Jvc3NGYWRlQnVpbGRlclxyXG57XHJcbiAgICBmbjogXCJjcm9zcy1mYWRlXCIgPSBcImNyb3NzLWZhZGVcIjtcclxuXHJcbiAgICBvbGQ/OiBbRXh0ZW5kZWQ8Q3NzSW1hZ2U+LCBFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc1BlcmNlbnQ+XTtcclxuICAgIGltYWdlcz86IFtFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc1BlcmNlbnQ+P11bXTtcclxuICAgIGM/OiBFeHRlbmRlZDxDc3NDb2xvcj47XHJcblxyXG4gICAgLy8gY29uc3RydWN0b3IgZm9yIG9sZCBmdW5jdGlvbiBzaWduYXR1cmVcclxuXHRjb25zdHJ1Y3Rvciggb2xkOiBbRXh0ZW5kZWQ8Q3NzSW1hZ2U+LCBFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc1BlcmNlbnQ+XSk7XHJcblxyXG4gICAgLy8gY29uc3RydWN0b3IgZm9yIG5ldyBmdW5jdGlvbiBzaWduYXR1cmVcclxuXHRjb25zdHJ1Y3RvciggLi4uaW1hZ2VzOiAoRXh0ZW5kZWQ8Q3NzSW1hZ2U+IHwgW0V4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD5dKVtdKTtcclxuXHJcblx0Y29uc3RydWN0b3IoKVxyXG4gICAge1xyXG4gICAgICAgIGxldCBwMSA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSggcDEpICYmIHAxLmxlbmd0aCA9PT0gMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIG9sZCBzaWduYXR1cmVcclxuICAgICAgICAgICAgdGhpcy5vbGQgPSBwMSBhcyBbRXh0ZW5kZWQ8Q3NzSW1hZ2U+LCBFeHRlbmRlZDxDc3NJbWFnZT4sIEV4dGVuZGVkPENzc1BlcmNlbnQ+XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgbmV3IHNpZ25hdHVyZVxyXG4gICAgICAgICAgICB0aGlzLmFkZCggLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cdGFkZCggLi4uaW1hZ2VzOiAoRXh0ZW5kZWQ8Q3NzSW1hZ2U+IHwgW0V4dGVuZGVkPENzc0ltYWdlPiwgRXh0ZW5kZWQ8Q3NzUGVyY2VudD5dKVtdKTogdGhpc1xyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5pbWFnZXMpXHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzID0gW107XHJcblxyXG4gICAgICAgIGZvciggbGV0IGl0ZW0gb2YgaW1hZ2VzKVxyXG4gICAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKCBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuXHRjb2xvciggYzogRXh0ZW5kZWQ8Q3NzQ29sb3I+KTogdGhpcyB7IHRoaXMuYyA9IGM7IHJldHVybiB0aGlzOyB9XHJcbn1cclxuXHJcbmZkb1tcImNyb3NzLWZhZGVcIl0gPSAodmFsOiBJQ3Jvc3NGYWRlRnVuYyk6IHN0cmluZyA9PlxyXG4gICAgZjJzKCBcImNyb3NzLWZhZGVcIiwgW1xyXG4gICAgICAgIHZhbC5pbWFnZXNcclxuICAgICAgICAgICAgPyBtdjJzKCBbW3ZhbC5pbWFnZXMsIHsgaXRlbTogeyBhcnI6IFtXS0YuRGVmYXVsdCwgV0tGLlBlcmNlbnRdIH0sIHNlcDogXCIsXCIgfV0sIFt2YWwuYywgV0tGLkNvbG9yXV0sIFwiLFwiKVxyXG4gICAgICAgICAgICA6IHYycyggdmFsLm9sZCwgeyBhcnI6IFtXS0YuRGVmYXVsdCwgV0tGLkRlZmF1bHQsIFdLRi5QZXJjZW50XSwgc2VwOiBcIixcIiB9KVxyXG4gICAgXSlcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSUltYWdlU2V0RnVuYyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgaW1hZ2Utc2V0KClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtIGl0ZW1zIE9uZSBvciBtb3JlIGl0ZW1zIHNwZWNpZnlpbmcgYW4gaW1hZ2UgYW5kIG9wdGlvbmFsbHkgaW1hZ2UgdHlwZSBhbmQgcmVzb2x1dGlvbi5cclxuICogQHJldHVybnNcclxuICpcclxuICogQGNhdGVnb3J5IEltYWdlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW1hZ2VTZXQgPSAoLi4uaXRlbXM6IEltYWdlU2V0SXRlbVtdKTogSUltYWdlU2V0RnVuYyA9PiAoeyBmbjogXCJpbWFnZS1zZXRcIiwgaXRlbXMgfSlcclxuXHJcbmNvbnN0IGltYWdlVHlwZVRvU3RyaW5nID0gKHZhbDogRXh0ZW5kZWQ8c3RyaW5nPik6IHN0cmluZyA9PiB2MnMoIHZhbCwge1xyXG4gICAgc3RyOiB2ID0+IGB0eXBlKFwiJHt2LmluZGV4T2YoXCIvXCIpID4gMCA/IHZhbCA6IFwiaW1hZ2UvXCIgKyB2YWx9XCIpYFxyXG59KTtcclxuXHJcbmNvbnN0IGltYWdlUmVzb2x1dGlvblRvU3RyaW5nID0gKHZhbDogRXh0ZW5kZWQ8SW1hZ2VTZXRSZXNvbHV0aW9uPik6IHN0cmluZyA9PiB2MnMoIHZhbCwge1xyXG4gICAgbnVtOiB2ID0+IHYgKyBcInhcIlxyXG59KTtcclxuXHJcbmZkb1tcImltYWdlLXNldFwiXSA9IFtcclxuICAgIFtcclxuICAgICAgICBcIml0ZW1zXCIsIHtcclxuICAgICAgICAgICAgaXRlbToge1xyXG4gICAgICAgICAgICAgICAgc3RyOiBXS0YuUXVvdGVkLFxyXG4gICAgICAgICAgICAgICAgYXJyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgMTogW1dLRi5RdW90ZWRdLFxyXG4gICAgICAgICAgICAgICAgICAgIDI6IFtXS0YuUXVvdGVkLCB7c3RyOiBpbWFnZVR5cGVUb1N0cmluZywgbnVtOiBpbWFnZVJlc29sdXRpb25Ub1N0cmluZ31dLFxyXG4gICAgICAgICAgICAgICAgICAgIDM6IFtXS0YuUXVvdGVkLCBpbWFnZVR5cGVUb1N0cmluZywgaW1hZ2VSZXNvbHV0aW9uVG9TdHJpbmddLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXA6IFwiLFwiXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBwYWludCB3b3JrbGV0IHdpdGggdGhlIGdpdmVuIG5hbWUsIG9wdGlvbmFsIGFyZ3VtZW50IHN5bnRheCBhbmQgb3B0aW9uYWwgVVJMIG9mXHJcbiAqIHRoZSB3b3JrbGV0IG1vZHVsZS4gVGhlIHdvcmtsZXQgbmFtZSBzaG91bGQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBbW0lQYWludFdvcmtsZXRzXV0gaW50ZXJmYWNlXHJcbiAqIHVzaW5nIHRoZSBtb2R1bGUgYXVnbWVudGF0aW9uIHRlY2huaXF1ZS4gQWx0aG91Z2ggaXQgaXMgcG9zc2libGUgdG8gdXNlIHBhaW50IHdvcmtsZXRzIHdpdGhvdXRcclxuICogYWRkaW5nIHRoZW0gdG8gdGhlIFtbSVBhaW50V29ya2xldHNdXSBpbnRlcmZhY2UsIHRoaXMgd2lsbCBwcmV2ZW50IE1pbWNzcyBmcm9tIGVuZm9yY2luZyB0aGVcclxuICogdHlwZXMgb2YgYXJndW1lbnRzIHdoZW4gdGhlIFtbcGFpbnRdXSBmdW5jdGlvbiBpcyBpbnZva2VkLlxyXG4gKiBAcGFyYW0gbmFtZSBXb3JrbGV0IG5hbWVcclxuICogQHBhcmFtIHN5bnRheCBUdXBsZSBjb250YWluaW5nIHN5bnRheCBkZWZpbml0aW9ucyBmb3Igd29ya2xldCBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB1cmwgVVJMIHRvIHRoZSB3b3JrbGV0IG1vZHVsZS4gSWYgc3BlY2lmaWVkLCB0aGUgbW9kdWxlIHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlclBhaW50V29ya2xldCA9IGFzeW5jIDxLIGV4dGVuZHMga2V5b2YgSVBhaW50V29ya2xldHM+KCBuYW1lOiBLLFxyXG4gICAgc3ludGF4OiBJUGFpbnRXb3JrbGV0c1tLXSA9IFtdLCB1cmw/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+XHJcbntcclxuICAgIGlmICgoQ1NTIGFzIGFueSkucGFpbnRXb3JrbGV0KVxyXG4gICAge1xyXG4gICAgICAgIGlmICghcmVnaXN0ZXJlZFBhaW50V29ya2xldEluZm9zW25hbWVdKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJlZFBhaW50V29ya2xldEluZm9zW25hbWVdID0ge3N5bnRheCwgdXJsfTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIFVSTCBpcyBzcGVjaWZpZWQgdXNlIGl0IHRvIGFkZCB3b3JrbGV0IG1vZHVsZVxyXG4gICAgICAgICAgICBpZiAodXJsICYmICFhZGRlZFBhaW50V29ya2xldE1vZHVsZXMuaGFzKHVybCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFkZGVkUGFpbnRXb3JrbGV0TW9kdWxlcy5hZGQodXJsKTtcclxuICAgICAgICAgICAgICAgIHRyeVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IChDU1MgYXMgYW55KS5wYWludFdvcmtsZXQuYWRkTW9kdWxlKCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goeClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBgRXJyb3IgYWRkaW5nIG1vZHVsZSAnJHt1cmx9JyBmb3IgcGFpbnQgd29ya2xldCAnJHtuYW1lfSdgLCB4KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lcyBpbmZvcm1hdGlvbiB3ZSBrZWVwIGZvciByZWdpc3RlcmVkIHBhaW50IHdvcmtsZXRzLlxyXG4gKi9cclxudHlwZSBQYWludFdvcmtsZXRJbmZvPEsgZXh0ZW5kcyBrZXlvZiBJUGFpbnRXb3JrbGV0cz4gPSB7IHN5bnRheDogSVBhaW50V29ya2xldHNbS10sIHVybD86IHN0cmluZyB9O1xyXG5cclxuLyoqXHJcbiAqIEluZm9ybWF0aW9uIGFib3V0IHJlZ2lzdGVyZWQgcGFpbnQgd29ya2xldHMuXHJcbiAqL1xyXG5sZXQgcmVnaXN0ZXJlZFBhaW50V29ya2xldEluZm9zOiB7IFtLIGluIGtleW9mIElQYWludFdvcmtsZXRzXT86IFBhaW50V29ya2xldEluZm88Sz4gfSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFNldCBvZiBVUkxzIG9mIGFscmVhZHkgYWRkZWQgcGFpbnQgd29ya2xldCBtb2R1bGVzLlxyXG4gKi9cclxubGV0IGFkZGVkUGFpbnRXb3JrbGV0TW9kdWxlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgSVBhaW50RnVuYyBvYmplY3QgZGVzY3JpYmluZyBhbiBpbnZvY2F0aW9uIG9mIHRoZSBgcGFpbnQoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSBQYWludCB3b3JrbGV0IG5hbWUuXHJcbiAqIEBwYXJhbSBhcmdzIFBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBwYWludCB3b3JrbGV0LlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgSW1hZ2VcclxuICpcclxuICogQHRzLWV4cGVjdC1lcnJvcjogRXJyb25lb3VzbHkgcmVwb3J0cyBUUzIzNzAgYWx0aG91Z2ggdGhlIHJlc3QncyB0eXBlIGlzIGFuIGFycmF5IChhIHR1cGxlKSAqL1xyXG5leHBvcnQgY29uc3QgcGFpbnQgPSA8SyBleHRlbmRzIGtleW9mIElQYWludFdvcmtsZXRzPiggbmFtZTogSywgLi4uYXJnczogTWFwcGVkU3ludGF4VHlwZXM8SVBhaW50V29ya2xldHNbS10+KTogSVBhaW50RnVuYyA9PlxyXG4gICAgKHsgZm46IFwicGFpbnRcIiwgbmFtZTogbmFtZSBhcyBzdHJpbmcsIGFyZ3M6IGFyZ3MgYXMgYW55IGFzIHN0cmluZ1tdIH0pXHJcblxyXG5mZG9bXCJwYWludFwiXSA9ICh2OiBJUGFpbnRGdW5jKTogc3RyaW5nID0+XHJcbntcclxuICAgIGlmICghdj8uYXJncz8ubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBgcGFpbnQoJHt2Lm5hbWV9KWA7XHJcblxyXG4gICAgbGV0IGluZm8gPSByZWdpc3RlcmVkUGFpbnRXb3JrbGV0SW5mb3Nbdi5uYW1lXTtcclxuICAgIGxldCBidWY6IHN0cmluZ1tdID0gW107XHJcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IHYuYXJncy5sZW5ndGg7IGkrKylcclxuICAgIHtcclxuICAgICAgICBsZXQgc3ludGF4ID0gaW5mbz8uc3ludGF4W2ldO1xyXG4gICAgICAgIGJ1Zi5wdXNoKCBzeW50YXggPyBzcDJzKCBzeW50YXgsIHYuYXJnc1tpXSkgOiB2MnMoIHYuYXJnc1tpXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBgcGFpbnQoJHt2Lm5hbWV9LCR7YnVmLmZpbHRlcih2PT4hIXYpLmpvaW4oXCIsXCIpfSlgO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEZpbHRlcnNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElGaWx0ZXJQcm94eSBmdW5jdGlvbiByZXByZXNlbnRpbmcgb25lIG9mIHRoZSBmaWx0ZXIgQ1NTIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgZmlsdGVyUGVyY2VudCA9IChmbjogUGVyY2VudEZpbHRlck5hbWVzLCBwOiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElQZXJjZW50RmlsdGVyRnVuYyA9PiAoeyBmbiwgcCB9KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJUGVyY2VudEZpbHRlckZ1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgYnJpZ2h0bmVzcygpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqXHJcbiAqIGBgYHRzeFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gZmlsdGVyOiBicmlnaHRuZXNzKDE1MCUpXHJcbiAqICAgICBicmlnaHQgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmJyaWdodG5lc3MoMTUwKX0pXHJcbiAqXHJcbiAqICAgICAvLyBmaWx0ZXI6IGJyaWdodG5lc3MoNTAlKVxyXG4gKiAgICAgZGltID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5icmlnaHRuZXNzKDAuNSl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gcCBWYWx1ZSBpbnRlcnByZXRlZCBhcyBwZXJjZW50YWdlLiBJbnRlZ2VyIG51bWJlciBpcyB1c2VkIGFzIGlzIHdoaWxlICBmbG9hdGluZyBwb2ludFxyXG4gKiBudW1iZXJzIGFyZSBtdWx0aXBsaWVkIGJ5IDEwMC5cclxuICogQHJldHVybnMgVGhlIGBJUGVyY2VudEZpbHRlckZ1bmNgIGludGVyZmFjZSBjb250YWluaW5nIHBlcmNlbnRhZ2UgdmFsdWVcclxuICogQGNhdGVnb3J5IEZpbHRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJyaWdodG5lc3MgPSAocDogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4pOiBJUGVyY2VudEZpbHRlckZ1bmMgPT4gZmlsdGVyUGVyY2VudCggXCJicmlnaHRuZXNzXCIsIHApO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lQZXJjZW50RmlsdGVyRnVuY11dIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBjb250cmFzdCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqXHJcbiAqIGBgYHRzeFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gZmlsdGVyOiBjb250cmFzdCgxNTAlKVxyXG4gKiAgICAgaGlnaENvbnRyYXN0ID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5jb250cmFzdCgxNTApfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogY29udHJhc3QoNTAlKVxyXG4gKiAgICAgbG93Q29udHJhc3QgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmNvbnRyYXN0KDAuNSl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gcCBWYWx1ZSBpbnRlcnByZXRlZCBhcyBwZXJjZW50YWdlLiBJbnRlZ2VyIG51bWJlciBpcyB1c2VkIGFzIGlzIHdoaWxlICBmbG9hdGluZyBwb2ludFxyXG4gKiBudW1iZXJzIGFyZSBtdWx0aXBsaWVkIGJ5IDEwMC5cclxuICogQHJldHVybnMgVGhlIGBJUGVyY2VudEZpbHRlckZ1bmNgIGludGVyZmFjZSBjb250YWluaW5nIHBlcmNlbnRhZ2UgdmFsdWVcclxuICogQGNhdGVnb3J5IEZpbHRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbnRyYXN0ID0gKHA6IEV4dGVuZGVkPENzc1BlcmNlbnQ+KTogSVBlcmNlbnRGaWx0ZXJGdW5jID0+IGZpbHRlclBlcmNlbnQoIFwiY29udHJhc3RcIiwgcCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFtbSVBlcmNlbnRGaWx0ZXJGdW5jXV0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYGdyYXlzY2FsZSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqXHJcbiAqIGBgYHRzeFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gZmlsdGVyOiBncmF5c2NhbGUoMTAwJSlcclxuICogICAgIGdyYXkgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmdyYXlzY2FsZSgxMDApfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogZ3JheXNjYWxlKDUwJSlcclxuICogICAgIGhhbGZDb2xvciA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuZ3JheXNjYWxlKDAuNSl9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gcCBWYWx1ZSBpbnRlcnByZXRlZCBhcyBwZXJjZW50YWdlLiBJbnRlZ2VyIG51bWJlciBpcyB1c2VkIGFzIGlzIHdoaWxlICBmbG9hdGluZyBwb2ludFxyXG4gKiBudW1iZXJzIGFyZSBtdWx0aXBsaWVkIGJ5IDEwMC5cclxuICogQHJldHVybnMgVGhlIGBJUGVyY2VudEZpbHRlckZ1bmNgIGludGVyZmFjZSBjb250YWluaW5nIHBlcmNlbnRhZ2UgdmFsdWVcclxuICogQGNhdGVnb3J5IEZpbHRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdyYXlzY2FsZSA9IChwOiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElQZXJjZW50RmlsdGVyRnVuYyA9PiBmaWx0ZXJQZXJjZW50KCBcImdyYXlzY2FsZVwiLCBwKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJUGVyY2VudEZpbHRlckZ1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgaW52ZXJ0KClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IGludmVydCgxMDAlKVxyXG4gKiAgICAgaW52ZXJ0ZWQgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmludmVydCgxMDApfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogaW52ZXJ0KDc1JSlcclxuICogICAgIHNvbWV3aGF0bnZlcnRlZCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuaW52ZXJ0KDAuNzUpfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogaW52ZXJ0KDUwJSlcclxuICogICAgIGdyYXkgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmludmVydCgwLjUpfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHAgVmFsdWUgaW50ZXJwcmV0ZWQgYXMgcGVyY2VudGFnZS4gSW50ZWdlciBudW1iZXIgaXMgdXNlZCBhcyBpcyB3aGlsZSAgZmxvYXRpbmcgcG9pbnRcclxuICogbnVtYmVycyBhcmUgbXVsdGlwbGllZCBieSAxMDAuXHJcbiAqIEByZXR1cm5zIFRoZSBgSVBlcmNlbnRGaWx0ZXJGdW5jYCBpbnRlcmZhY2UgY29udGFpbmluZyBwZXJjZW50YWdlIHZhbHVlXHJcbiAqIEBjYXRlZ29yeSBGaWx0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBpbnZlcnQgPSAocDogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4pOiBJUGVyY2VudEZpbHRlckZ1bmMgPT4gZmlsdGVyUGVyY2VudCggXCJpbnZlcnRcIiwgcCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFtbSVBlcmNlbnRGaWx0ZXJGdW5jXV0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYG9wYWNpdHkoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUqKlxyXG4gKlxyXG4gKiBgYGB0c3hcclxuICogY2xhc3MgTXlTdHlsZXMgZXh0ZW5kcyBjc3MuU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIGZpbHRlcjogb3BhY2l0eSg1MCUpXHJcbiAqICAgICBoYWxmVHJhbnNwYXJlbnQgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLm9wYWNpdHkoMC41KX0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFZhbHVlIGludGVycHJldGVkIGFzIHBlcmNlbnRhZ2UuIEludGVnZXIgbnVtYmVyIGlzIHVzZWQgYXMgaXMgd2hpbGUgIGZsb2F0aW5nIHBvaW50XHJcbiAqIG51bWJlcnMgYXJlIG11bHRpcGxpZWQgYnkgMTAwLlxyXG4gKiBAcmV0dXJucyBUaGUgYElQZXJjZW50RmlsdGVyRnVuY2AgaW50ZXJmYWNlIGNvbnRhaW5pbmcgcGVyY2VudGFnZSB2YWx1ZVxyXG4gKiBAY2F0ZWdvcnkgRmlsdGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgb3BhY2l0eSA9IChwOiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElQZXJjZW50RmlsdGVyRnVuYyA9PiBmaWx0ZXJQZXJjZW50KCBcIm9wYWNpdHlcIiwgcCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFtbSVBlcmNlbnRGaWx0ZXJGdW5jXV0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYHNhdHVyYXRlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IHNhdHVyYXRlKDE1MCUpXHJcbiAqICAgICBzdXBlclNhdHVyYXRlZCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3Muc2F0dXJhdGUoMTUwKX0pXHJcbiAqXHJcbiAqICAgICAvLyBmaWx0ZXI6IHNhdHVyYXRlKDUwJSlcclxuICogICAgIHVuZGVyU2F0dXJhdGVkID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5zYXR1cmF0ZSgwLjUpfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHAgVmFsdWUgaW50ZXJwcmV0ZWQgYXMgcGVyY2VudGFnZS4gSW50ZWdlciBudW1iZXIgaXMgdXNlZCBhcyBpcyB3aGlsZSAgZmxvYXRpbmcgcG9pbnRcclxuICogbnVtYmVycyBhcmUgbXVsdGlwbGllZCBieSAxMDAuXHJcbiAqIEByZXR1cm5zIFRoZSBgSVBlcmNlbnRGaWx0ZXJGdW5jYCBpbnRlcmZhY2UgY29udGFpbmluZyBwZXJjZW50YWdlIHZhbHVlXHJcbiAqIEBjYXRlZ29yeSBGaWx0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBzYXR1cmF0ZSA9IChwOiBFeHRlbmRlZDxDc3NQZXJjZW50Pik6IElQZXJjZW50RmlsdGVyRnVuYyA9PiBmaWx0ZXJQZXJjZW50KCBcInNhdHVyYXRlXCIsIHApO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBbW0lQZXJjZW50RmlsdGVyRnVuY11dIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBzZXBpYSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICoqRXhhbXBsZSoqXHJcbiAqXHJcbiAqIGBgYHRzeFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIGNzcy5TdHlsZURlZmluaXRpb25cclxuICoge1xyXG4gKiAgICAgLy8gZmlsdGVyOiBzZXBpYSgxMDAlKVxyXG4gKiAgICAgdmludGFnZSA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3Muc2VwaWEoMTAwKX0pXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFZhbHVlIGludGVycHJldGVkIGFzIHBlcmNlbnRhZ2UuIEludGVnZXIgbnVtYmVyIGlzIHVzZWQgYXMgaXMgd2hpbGUgIGZsb2F0aW5nIHBvaW50XHJcbiAqIG51bWJlcnMgYXJlIG11bHRpcGxpZWQgYnkgMTAwLlxyXG4gKiBAcmV0dXJucyBUaGUgYElQZXJjZW50RmlsdGVyRnVuY2AgaW50ZXJmYWNlIGNvbnRhaW5pbmcgcGVyY2VudGFnZSB2YWx1ZVxyXG4gKiBAY2F0ZWdvcnkgRmlsdGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VwaWEgPSAocDogRXh0ZW5kZWQ8Q3NzUGVyY2VudD4pOiBJUGVyY2VudEZpbHRlckZ1bmMgPT4gZmlsdGVyUGVyY2VudCggXCJzZXBpYVwiLCBwKTtcclxuXHJcbmZkby5icmlnaHRuZXNzID0gZmRvLmNvbnRyYXN0ID0gZmRvLmdyYXlzY2FsZSA9IGZkby5pbnZlcnQgPSBmZG8ub3BhY2l0eSA9IGZkby5zYXR1cmF0ZSA9XHJcbiAgICBmZG8uc2VwaWEgPSBXS0YuUGVyY2VudDtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJQmx1ckZ1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgYmx1cigpYCBDU1MgZnVuY3Rpb24gcGFyYW1ldGVycy5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IGJsdXIoMClcclxuICogICAgIHNoYXJwID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5ibHVyKDApfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogYmx1cigycHgpXHJcbiAqICAgICBibHVycmVkID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5ibHVyKDIpfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogYmx1cigxLjVlbSlcclxuICogICAgIHN1cGVyQmx1cnJlZCA9IHRoaXMuJGNsYXNzKHsgZmlsdGVyOiBjc3MuYmx1cigxLjUpfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHIgUmFkaXVzIG9mIHRoZSBibHVyLlxyXG4gKiBAcmV0dXJucyBUaGUgYElCbHVyRnVuY2AgaW50ZXJmYWNlIGNvbnRhaW5pbmcgdGhlIGJsdXIgcmFkaXVzXHJcbiAqIEBjYXRlZ29yeSBGaWx0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBibHVyID0gKCByOiBFeHRlbmRlZDxDc3NMZW5ndGg+KTogSUJsdXJGdW5jID0+ICh7IGZuOiBcImJsdXJcIiwgciB9KTtcclxuXHJcbmZkby5ibHVyID0gV0tGLkxlbmd0aDtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gW1tJRHJvcFNoYWRvd0Z1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgZHJvcFNoYWRvdygpYCBDU1MgZnVuY3Rpb24gcGFyYW1ldGVycy5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IGRyb3Atc2hhZG93KDMwcHggMTBweCA0cHggYmx1ZSlcclxuICogICAgIGJsdXJyZWRTaGFkb3cgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmRyb3BTaGFkb3coIDMwLCAxMCwgXCJibHVlXCIsIDQpfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogZHJvcC1zaGFkb3coMi41ZW0gLTEuNWVtIGdyZWVuKVxyXG4gKiAgICAgc2hhcnBTaGFkb3cgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmRyb3BTaGFkb3coIDIuNSwgLTEuNSwgXCJncmVlblwiKX0pXHJcbiAqXHJcbiAqICAgICAvLyBmaWx0ZXI6IGRyb3Atc2hhZG93KDAgMCAyMHB4IG9yYW5nZSlcclxuICogICAgIGhhbG9TaGFkb3cgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmRyb3BTaGFkb3coIDAsIDAsIFwib3JhbmdlXCIsIDIwcHgpfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHggSG9yaXpvbnRhbCBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cclxuICogQHBhcmFtIHkgVmVydGljYWwgb2Zmc2V0IG9mIHRoZSBzaGFkb3cuXHJcbiAqIEBwYXJhbSBjb2xvciBDb2xvciBvZiB0aGUgc2hhZG93LiBJZiB1bmRlZmluZWQsIHRoZSBjb2xvciBvZiB0aGUgc2hhZG93IGlzIHRha2VuIGZyb20gdGhlIGNvbG9yXHJcbiAqIHByb3BlcnR5LlxyXG4gKiBAcGFyYW0gYmx1ciBWYWx1ZSBvZiB0aGUgc2hhZG93J3MgYmx1cnJpbmcuIElmIHVuZGVmaW5lZCwgdGhlIHNoYWRvdyB3aWxsIGJlIHNoYXJwIChub3QgYmx1cnJlZCkuXHJcbiAqIEByZXR1cm5zIFRoZSBgSURyb3BTaGFkb3dGdW5jYCBpbnRlcmZhY2UgY29udGFpbmluZyB0aGUgc2hhZG93IHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBGaWx0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBkcm9wU2hhZG93ID0gKHg6IEV4dGVuZGVkPENzc0xlbmd0aD4sIHk6IEV4dGVuZGVkPENzc0xlbmd0aD4sXHJcbiAgICBjb2xvcj86IEV4dGVuZGVkPENzc0NvbG9yPiwgYmx1cj86IEV4dGVuZGVkPENzc0xlbmd0aD4pOiBJRHJvcFNoYWRvd0Z1bmMgPT4gKHsgZm46IFwiZHJvcC1zaGFkb3dcIiwgeCwgeSwgY29sb3IsIGJsdXIgfSk7XHJcblxyXG5mZG9bXCJkcm9wLXNoYWRvd1wiXSA9IHtcclxuICAgIHA6IFsgXCJ4XCIsIFwieVwiLCBcImJsdXJcIiwgW1wiY29sb3JcIiwgV0tGLkNvbG9yXSBdLFxyXG4gICAgZG86IFdLRi5MZW5ndGgsXHJcbiAgICBzOiBcIiBcIlxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFtbSUh1ZVJvdGF0ZUZ1bmNdXSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgaHVlLXJvdGF0ZSgpYCBDU1MgZnVuY3Rpb24gcGFyYW1ldGVycy5cclxuICpcclxuICogKipFeGFtcGxlKipcclxuICpcclxuICogYGBgdHN4XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgY3NzLlN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBmaWx0ZXI6IGh1ZS1yb3RhdGUoOTBkZWcpXHJcbiAqICAgICB0b1RoZVJpZ2h0ID0gdGhpcy4kY2xhc3MoeyBmaWx0ZXI6IGNzcy5odWVSb3RhdGUoOTApfSlcclxuICpcclxuICogICAgIC8vIGZpbHRlcjogaHVlLXJvdGF0ZSgtMC4yNXR1cm4pXHJcbiAqICAgICB0b1RoZUxlZnQgPSB0aGlzLiRjbGFzcyh7IGZpbHRlcjogY3NzLmJsdXIoLTAuMjUpfSlcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGEgVGhlIHJlbGF0aXZlIGNoYW5nZSBpbiBodWUgb2YgdGhlIGlucHV0IHNhbXBsZS5cclxuICogQHJldHVybnMgVGhlIGBJSHVlUm90YXRlRnVuY2AgaW50ZXJmYWNlIGNvbnRhaW5pbmcgdGhlIGh1ZSByb3RhdGlvbiBhbmdsZVxyXG4gKiBAY2F0ZWdvcnkgRmlsdGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaHVlUm90YXRlID0gKGE6IEV4dGVuZGVkPENzc0FuZ2xlPik6IElIdWVSb3RhdGVGdW5jID0+ICh7IGZuOiBcImh1ZS1yb3RhdGVcIiwgYSB9KTtcclxuXHJcbmZkb1tcImh1ZS1yb3RhdGVcIl0gPSBXS0YuQW5nbGVcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gVHJhbnNmb3Jtc1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSU1hdHJpeEZ1bmMgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYG1hdHJpeCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXRyaXggPSAoYTogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYjogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYzogRXh0ZW5kZWQ8Q3NzTnVtYmVyPixcclxuXHRkOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCB0eDogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgdHk6IEV4dGVuZGVkPENzc051bWJlcj4pOiBJTWF0cml4RnVuYyA9PlxyXG4gICAgKHtmbjogXCJtYXRyaXhcIiwgYSwgYiwgYywgZCwgdHgsIHR5IH0pO1xyXG5cclxuZmRvLm1hdHJpeCA9IFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwidHhcIiwgXCJ0eVwiIF07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElNYXRyaXgzZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgbWF0cml4M2QoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWF0cml4M2QgPSAoXHJcblx0XHRhMTogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYjE6IEV4dGVuZGVkPENzc051bWJlcj4sIGMxOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBkMTogRXh0ZW5kZWQ8Q3NzTnVtYmVyPixcclxuXHRcdGEyOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBiMjogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYzI6IEV4dGVuZGVkPENzc051bWJlcj4sIGQyOiBFeHRlbmRlZDxDc3NOdW1iZXI+LFxyXG5cdFx0YTM6IEV4dGVuZGVkPENzc051bWJlcj4sIGIzOiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBjMzogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgZDM6IEV4dGVuZGVkPENzc051bWJlcj4sXHJcblx0XHRhNDogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiwgYjQ6IEV4dGVuZGVkPENzc051bWJlcj4sIGM0OiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBkNDogRXh0ZW5kZWQ8Q3NzTnVtYmVyPixcclxuXHQpOiBJTWF0cml4M2RGdW5jID0+ICh7IGZuOiBcIm1hdHJpeDNkXCIsIGExLCBiMSwgYzEsIGQxLCBhMiwgYjIsIGMyLCBkMiwgYTMsIGIzLCBjMywgZDMsIGE0LCBiNCwgYzQsIGQ0IH0pO1xyXG5cclxuZmRvLm1hdHJpeCA9IFsgXCJhMVwiLCBcImIxXCIsIFwiYzFcIiwgXCJkMVwiLCBcImEyXCIsIFwiYjJcIiwgXCJjMlwiLCBcImQyXCIsIFwiYTNcIiwgXCJiM1wiLCBcImMzXCIsIFwiZDNcIiwgXCJhNFwiLCBcImI0XCIsIFwiYzRcIiwgXCJkNFwiIF07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElQZXJzcGVjdGl2ZUZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgcGVyc3BlY3RpdmUoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGVyc3BlY3RpdmUgPSAoZDogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElQZXJzcGVjdGl2ZUZ1bmMgPT4gKHsgZm46IFwicGVyc3BlY3RpdmVcIiwgZCB9KTtcclxuXHJcbmZkby5wZXJzcGVjdGl2ZSA9IFdLRi5MZW5ndGg7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElSb3RhdGVGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHJvdGF0ZSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCByb3RhdGUgPSAoYTogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogSVJvdGF0ZUZ1bmMgPT4gKHsgZm46IFwicm90YXRlXCIsIGEgfSk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJVHJhbnNmb3JtUHJveHkgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgcm90YXRlWCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCByb3RhdGVYID0gKGE6IEV4dGVuZGVkPENzc0FuZ2xlPik6IElSb3RhdGVGdW5jID0+ICh7IGZuOiBcInJvdGF0ZVhcIiwgYSB9KTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElUcmFuc2Zvcm1Qcm94eSBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGByb3RhdGVZKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJvdGF0ZVkgPSAoYTogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogSVJvdGF0ZUZ1bmMgPT4gKHsgZm46IFwicm90YXRlWVwiLCBhIH0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVRyYW5zZm9ybVByb3h5IGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHJvdGF0ZVooKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgcm90YXRlWiA9IChhOiBFeHRlbmRlZDxDc3NBbmdsZT4pOiBJUm90YXRlRnVuYyA9PiAoeyBmbjogXCJyb3RhdGVaXCIsIGEgfSk7XHJcblxyXG5mZG8ucm90YXRlID0gZmRvLnJvdGF0ZVggPSBmZG8ucm90YXRlWSA9IGZkby5yb3RhdGVaID0gV0tGLkFuZ2xlO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJUm90YXRlM2RGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHJvdGF0ZTNkKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJvdGF0ZTNkID0gKHg6IEV4dGVuZGVkPENzc051bWJlcj4sIHk6IEV4dGVuZGVkPENzc051bWJlcj4sXHJcbiAgICB6OiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBhOiBFeHRlbmRlZDxDc3NBbmdsZT4pOiBJUm90YXRlM2RGdW5jID0+ICh7IGZuOiBcInJvdGF0ZTNkXCIsIHgsIHksIHosIGEgfSk7XHJcblxyXG5mZG8ucm90YXRlM2QgPSBbIFwieFwiLCBcInlcIiwgXCJ6XCIsIFtcImFcIiwgV0tGLkFuZ2xlXSBdO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJU2NhbGVGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHNjYWxlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNjYWxlID0gKHN4OiBFeHRlbmRlZDxDc3NOdW1iZXI+LCBzeT86IEV4dGVuZGVkPENzc051bWJlcj4pOiBJU2NhbGVGdW5jID0+ICh7IGZuOiBcInNjYWxlXCIsIHN4LCBzeSB9KTtcclxuXHJcbmZkby5zY2FsZSA9IFtcInN4XCIsIFwic3lcIl1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElTY2FsZTFkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBzY2FsZVgoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2NhbGVYID0gKHM6IEV4dGVuZGVkPENzc051bWJlcj4pOiBJU2NhbGUxZEZ1bmMgPT4gKHsgZm46IFwic2NhbGVYXCIsIHMgfSk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJU2NhbGUxZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgc2NhbGVZKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNjYWxlWSA9IChzOiBFeHRlbmRlZDxDc3NOdW1iZXI+KTogSVNjYWxlMWRGdW5jID0+ICh7IGZuOiBcInNjYWxlWVwiLCBzIH0pO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVNjYWxlMWRGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHNjYWxlWigpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzY2FsZVogPSAoczogRXh0ZW5kZWQ8Q3NzTnVtYmVyPik6IElTY2FsZTFkRnVuYyA9PiAoeyBmbjogXCJzY2FsZVpcIiwgcyB9KTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElTY2FsZTNkRnVuYyBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGBzY2FsZTNkKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNjYWxlM2QgPSAoc3g6IEV4dGVuZGVkPENzc051bWJlcj4sIHN5OiBFeHRlbmRlZDxDc3NOdW1iZXI+LFxyXG4gICAgc3o6IEV4dGVuZGVkPENzc051bWJlcj4pOiBJU2NhbGUzZEZ1bmMgPT4gKHsgZm46IFwic2NhbGUzZFwiLCBzeCwgc3ksIHN6IH0pO1xyXG5cclxuZmRvLnNjYWxlM2QgPSBbXCJzeFwiLCBcInN5XCIsIFwic3pcIl1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVNrZXdGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHNrZXcoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2tldyA9IChheDogRXh0ZW5kZWQ8Q3NzQW5nbGU+LCBheT86IEV4dGVuZGVkPENzc0FuZ2xlPik6IElTa2V3RnVuYyA9PiAoeyBmbjogXCJza2V3XCIsIGF4LCBheSB9KTtcclxuXHJcbmZkby5za2V3ID0ge1xyXG4gICAgcDogW1wiYXhcIiwgXCJheVwiXSxcclxuICAgIGRvOiBXS0YuQW5nbGVcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVNrZXcxZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgc2tld1goKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgVHJhbnNmb3JtXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2tld1ggPSAoYTogRXh0ZW5kZWQ8Q3NzQW5nbGU+KTogSVNrZXcxZEZ1bmMgPT4gKHsgZm46IFwic2tld1hcIiwgYSB9KTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElTa2V3MWRGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHNrZXdZKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNrZXdZID0gKGE6IEV4dGVuZGVkPENzc0FuZ2xlPik6IElTa2V3MWRGdW5jID0+ICh7IGZuOiBcInNrZXdZXCIsIGEgfSk7XHJcblxyXG5mZG8uc2tld1ggPSBmZG8uc2tld1kgPSBXS0YuQW5nbGU7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElUcmFuc2xhdGVGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHRyYW5zbGF0ZSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCB0cmFuc2xhdGUgPSAoeDogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiwgeT86IEV4dGVuZGVkPENzc0xlbmd0aD4pOiBJVHJhbnNsYXRlRnVuYyA9PiAoeyBmbjogXCJ0cmFuc2xhdGVcIiwgeCwgeSB9KTtcclxuXHJcbmZkby50cmFuc2xhdGUgPSB7XHJcbiAgICBwOiBbXCJ4XCIsIFwieVwiXSxcclxuICAgIGRvOiBXS0YuTGVuZ3RoXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElUcmFuc2xhdGUxZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgdHJhbnNsYXRlWCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCB0cmFuc2xhdGVYID0gKGQ6IEV4dGVuZGVkPENzc0xlbmd0aD4pOiBJVHJhbnNsYXRlMWRGdW5jID0+ICh7IGZuOiBcInRyYW5zbGF0ZVhcIiwgZCB9KTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElUcmFuc2xhdGUxZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgdHJhbnNsYXRlWSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCB0cmFuc2xhdGVZID0gKGQ6IEV4dGVuZGVkPENzc0xlbmd0aD4pOiBJVHJhbnNsYXRlMWRGdW5jID0+ICh7IGZuOiBcInRyYW5zbGF0ZVlcIiwgZCB9KTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElUcmFuc2xhdGUxZEZ1bmMgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBgdHJhbnNsYXRlWigpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBUcmFuc2Zvcm1cclxuICovXHJcbmV4cG9ydCBjb25zdCB0cmFuc2xhdGVaID0gKGQ6IEV4dGVuZGVkPENzc0xlbmd0aD4pOiBJVHJhbnNsYXRlMWRGdW5jID0+ICh7IGZuOiBcInRyYW5zbGF0ZVpcIiwgZCB9KTtcclxuXHJcbmZkby50cmFuc2xhdGVYID0gZmRvLnRyYW5zbGF0ZVkgPSBmZG8udHJhbnNsYXRlWiA9IFdLRi5MZW5ndGg7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJVHJhbnNsYXRlM2RGdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHRyYW5zbGF0ZTNkKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogQGNhdGVnb3J5IFRyYW5zZm9ybVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRyYW5zbGF0ZTNkID0gKHg6IEV4dGVuZGVkPENzc0xlbmd0aD4sIHk6IEV4dGVuZGVkPENzc0xlbmd0aD4sXHJcblx0ejogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPik6IElUcmFuc2xhdGUzZEZ1bmMgPT4gKHsgZm46IFwidHJhbnNsYXRlM2RcIiwgeCwgeSwgeiB9KTtcclxuXHJcbmZkby50cmFuc2xhdGUzZCA9IHtcclxuICAgIHA6IFtcInhcIiwgXCJ5XCIsIFwielwiXSxcclxuICAgIGRvOiBXS0YuTGVuZ3RoXHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQmFzaWMgc2hhcGVzXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJSW5zZXRCdWlsZGVyIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBpbnNldCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICpFeGFtcGxlOipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGlwUGF0aDogaW5zZXQoIGNzcy5wZXJjZW50KDE1KSlcclxuICpcclxuICogY2xpcFBhdGg6IGluc2V0KCAxMCwgMTIsIDE0LCAxNikucm91bmQoIDgpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgQmFzaWMgU2hhcGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBpbnNldCA9IChvMTogRXh0ZW5kZWQ8Q3NzTGVuZ3RoPiwgbzI/OiBFeHRlbmRlZDxDc3NMZW5ndGg+LFxyXG4gICAgbzM/OiBFeHRlbmRlZDxDc3NMZW5ndGg+LCBvND86IEV4dGVuZGVkPENzc0xlbmd0aD4pOiBJSW5zZXRCdWlsZGVyID0+XHJcbiAgICAoe1xyXG4gICAgICAgIGZuOiBcImluc2V0XCIsIG8xLCBvMiwgbzMsIG80LFxyXG4gICAgICAgIHJvdW5kKCByOiBFeHRlbmRlZDxCb3JkZXJSYWRpdXM+KSB7IHRoaXMuciA9IHI7IHJldHVybiB0aGlzOyB9XHJcbiAgICB9KTtcclxuXHJcbmZkby5pbnNldCA9IHtcclxuICAgIHA6IFsgXCJvMVwiLCBcIm8yXCIsIFwibzNcIiwgXCJvNFwiLCBbXCJyXCIsIHYgPT4gXCJyb3VuZCBcIiArIHdrZltXS0YuQm9yZGVyUmFkaXVzXSh2KV0gXSxcclxuICAgIGRvOiBXS0YuTGVuZ3RoLFxyXG4gICAgczogXCIgXCJcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJQ2lyY2xlQnVpbGRlciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgY2lyY2xlKClgIENTUyBmdW5jdGlvbi5cclxuICpcclxuICogKkV4YW1wbGU6KlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsaXBQYXRoOiBjaXJjbGUoIDEwMClcclxuICpcclxuICogY2xpcFBhdGg6IGNpcmNsZSggMTAwKS5hdCggW1wiY2VudGVyXCIsIGNzcy5wZXJjZW50KDMwKV0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgQmFzaWMgU2hhcGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBjaXJjbGUgPSAocj86IFNoYXBlUmFkaXVzKTogSUNpcmNsZUJ1aWxkZXIgPT5cclxuICAgICh7XHJcbiAgICAgICAgZm46IFwiY2lyY2xlXCIsIHIsXHJcbiAgICAgICAgYXQoIHBvczogRXh0ZW5kZWQ8Q3NzUG9zaXRpb24+KSB7IHRoaXMucG9zID0gcG9zOyByZXR1cm4gdGhpczsgfVxyXG4gICAgfSk7XHJcblxyXG5mZG8uY2lyY2xlID0ge1xyXG4gICAgcDogWyBbXCJyXCIsIFdLRi5MZW5ndGhdLCBbXCJwb3NcIiwgV0tGLkF0UG9zaXRpb25dIF0sXHJcbiAgICBzOiBcIiBcIlxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElFbGxpcHNlQnVpbGRlciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgZWxsaXBzZSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICpFeGFtcGxlOipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGlwUGF0aDogZWxsaXBzZSgpLmF0KCBbXCJ0b3BcIiwgXCI1MCVcIl0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgQmFzaWMgU2hhcGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbGxpcHNlKCk6IElFbGxpcHNlQnVpbGRlcjtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElFbGxpcHNlQnVpbGRlciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgZWxsaXBzZSgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICpFeGFtcGxlOipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGlwUGF0aDogZWxsaXBzZSggMTAwLCA1MClcclxuICpcclxuICogY2xpcFBhdGg6IGVsbGlwc2UoIDEwMCwgNTApLmF0KCBbXCJjZW50ZXJcIiwgY3NzLnBlcmNlbnQoMzApXSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBCYXNpYyBTaGFwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2UoIHJ4OiBTaGFwZVJhZGl1cywgcnk6IFNoYXBlUmFkaXVzKTogSUVsbGlwc2VCdWlsZGVyO1xyXG5cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2UoKTogSUVsbGlwc2VCdWlsZGVyXHJcbntcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZm46IFwiZWxsaXBzZVwiLCByeDogYXJndW1lbnRzWzBdLCByeTogYXJndW1lbnRzWzFdLFxyXG4gICAgICAgIGF0KCBwb3M6IEV4dGVuZGVkPENzc1Bvc2l0aW9uPikgeyB0aGlzLnBvcyA9IHBvczsgcmV0dXJuIHRoaXM7IH1cclxuICAgIH1cclxufVxyXG5cclxuZmRvLmVsbGlwc2UgPSB7XHJcbiAgICBwOiBbIFwicnhcIiwgXCJyeVwiLCBbXCJwb3NcIiwgV0tGLkF0UG9zaXRpb25dIF0sXHJcbiAgICBkbzogV0tGLkxlbmd0aCxcclxuICAgIHM6IFwiIFwiXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJUG9seWdvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBgcG9seWdvbigpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICpFeGFtcGxlOipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGlwUGF0aDogY3NzLnBvbHlnb24oIFswLDEwMF0sIFs1MCwwXSwgWzEwMCwxMDBdKVxyXG4gKlxyXG4gKiBjbGlwUGF0aDogY3NzLnBvbHlnb24oIFswLDEwMF0sIFs1MCwwXSwgWzEwMCwxMDBdKS5maWxsKCBcImV2ZW5vZGRcIilcclxuICogYGBgXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBCYXNpYyBTaGFwZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBvbHlnb24gPSAoLi4ucG9pbnRzOiBDc3NQb2ludFtdKTogSVBvbHlnb25CdWlsZGVyID0+XHJcbiAgICAoe1xyXG4gICAgICAgIGZuOiBcInBvbHlnb25cIiwgcG9pbnRzOiBwb2ludHMgPz8gW10sXHJcbiAgICAgICAgYWRkKCAuLi5wb2ludHM6IENzc1BvaW50W10pIHsgdGhpcy5wb2ludHMucHVzaCggLi4ucG9pbnRzKTsgcmV0dXJuIHRoaXM7IH0sXHJcbiAgICAgICAgZmlsbCggcnVsZTogRmlsbFJ1bGUpIHsgdGhpcy5ydWxlID0gcnVsZTsgcmV0dXJuIHRoaXM7IH1cclxuICAgIH0pO1xyXG5cclxuZmRvLnBvbHlnb24gPSBbXHJcbiAgICBcInJ1bGVcIixcclxuICAgIFtcInBvaW50c1wiLCB7IGl0ZW06IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSwgc2VwOiBcIixcIn1dLFxyXG5dXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIElQYXRoQnVpbGRlciBvYmplY3QgdGhhdCBhbGxvd3MgYnVpbGRpbmcgYSBDU1MgcGF0aC5cclxuICpcclxuICogQGNhdGVnb3J5IEJhc2ljIFNoYXBlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGF0aCA9IChmaWxsUnVsZT86IEZpbGxSdWxlKTogSVBhdGhCdWlsZGVyID0+IG5ldyBQYXRoQnVpbGRlciggZmlsbFJ1bGUpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIElQYXRoQnVpbGRlciBpbnRlcmZhY2UgcmVwcmVzZW50cyB0aGUgb2JqZWN0IHRoYXQgYWNjdW11bGF0ZXMgcGF0aCBjb21tYW5kcyB0aGF0IGFyZSB0aGVuXHJcbiAqIGNvbnZlcnRlZCB0byBhIHN0cmluZyBwYXJhbWV0ZXIgb2YgdGhlIENTUyBgcGF0aCgpYCBmdW5jdGlvbi5cclxuICovXHJcbmNsYXNzIFBhdGhCdWlsZGVyIGltcGxlbWVudHMgSVBhdGhCdWlsZGVyXHJcbntcclxuICAgIGZuOiBcInBhdGhcIiA9IFwicGF0aFwiO1xyXG4gICAgcnVsZT86IEZpbGxSdWxlO1xyXG4gICAgaXRlbXM6IFBhdGhDb21tYW5kW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoIHJ1bGU/OiBGaWxsUnVsZSlcclxuICAgIHtcclxuICAgICAgICB0aGlzLnJ1bGUgPSBydWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZHMgdGhlIGdpdmVuIGNvbW1hbmQgYW5kIHBhcmFtZXRlcnMgdG8gdGhlIHBhdGguXHJcbiAgICBwdWJsaWMgYWRkKCBjb21tYW5kOiBzdHJpbmcsIHBhcmFtcz86IFBhdGhDb21tYW5kUGFyYW1bXSk6IHRoaXNcclxuICAgIHtcclxuICAgICAgICB0aGlzLml0ZW1zLnB1c2goIFtjb21tYW5kLCBwYXJhbXNdKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgTSggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwiTVwiLCBwYXJhbXMpOyB9XHJcbiAgICBwdWJsaWMgbSggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwibVwiLCBwYXJhbXMpOyB9XHJcblxyXG4gICAgcHVibGljIEwoIC4uLnBhcmFtczogW251bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcIkxcIiwgcGFyYW1zKTsgfVxyXG4gICAgcHVibGljIGwoIC4uLnBhcmFtczogW251bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcImxcIiwgcGFyYW1zKTsgfVxyXG5cclxuICAgIHB1YmxpYyBIKCAuLi5wYXJhbXM6IG51bWJlcltdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJIXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyBoKCAuLi5wYXJhbXM6IG51bWJlcltdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJoXCIsIHBhcmFtcyk7IH1cclxuXHJcbiAgICBwdWJsaWMgViggLi4ucGFyYW1zOiBudW1iZXJbXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwiVlwiLCBwYXJhbXMpOyB9XHJcbiAgICBwdWJsaWMgdiggLi4ucGFyYW1zOiBudW1iZXJbXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwidlwiLCBwYXJhbXMpOyB9XHJcblxyXG4gICAgcHVibGljIEMoIC4uLnBhcmFtczogW251bWJlcixudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJDXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyBjKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwiY1wiLCBwYXJhbXMpOyB9XHJcblxyXG4gICAgcHVibGljIFMoIC4uLnBhcmFtczogW251bWJlcixudW1iZXIsbnVtYmVyLG51bWJlcl1bXSk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwiU1wiLCBwYXJhbXMpOyB9XHJcbiAgICBwdWJsaWMgcyggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJzXCIsIHBhcmFtcyk7IH1cclxuXHJcbiAgICBwdWJsaWMgUSggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJRXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyBxKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcInFcIiwgcGFyYW1zKTsgfVxyXG5cclxuICAgIHB1YmxpYyBUKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJUXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyB0KCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJ0XCIsIHBhcmFtcyk7IH1cclxuXHJcbiAgICBwdWJsaWMgQSggLi4ucGFyYW1zOiBbbnVtYmVyLG51bWJlcixudW1iZXIsMHwxLDB8MSxudW1iZXIsbnVtYmVyXVtdKTogdGhpcyB7IHJldHVybiB0aGlzLmFkZCggXCJBXCIsIHBhcmFtcyk7IH1cclxuICAgIHB1YmxpYyBhKCAuLi5wYXJhbXM6IFtudW1iZXIsbnVtYmVyLG51bWJlciwwfDEsMHwxLG51bWJlcixudW1iZXJdW10pOiB0aGlzIHsgcmV0dXJuIHRoaXMuYWRkKCBcImFcIiwgcGFyYW1zKTsgfVxyXG5cclxuICAgIHB1YmxpYyB6KCk6IHRoaXMgeyByZXR1cm4gdGhpcy5hZGQoIFwielwiKTsgfVxyXG59XHJcblxyXG5mZG8ucGF0aCA9IFsgXCJydWxlXCIsIFtcIml0ZW1zXCIsICh2OiBQYXRoQ29tbWFuZFtdKSA9PiBgXCIke2Eycyh2KX1cImBdIF1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVJheSBvYmplY3QgcmVwcmVzZW50aW5nIGludm9jYXRpb24gb2YgdGhlIGByYXkoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgQmFzaWMgU2hhcGVcclxuICovXHJcbiBleHBvcnQgY29uc3QgcmF5ID0gKGFuZ2xlOiBFeHRlbmRlZDxDc3NBbmdsZT4sIHNpemU/OiBFeHRlbmRlZDxFeHRlbnRLZXl3b3JkIHwgQ3NzTGVuZ3RoPixcclxuICAgIGNvbnRhaW4/OiBib29sZWFuKTogSVJheUZ1bmMgPT4gKHsgZm46IFwicmF5XCIsIGFuZ2xlLCBzaXplLCBjb250YWluIH0pO1xyXG5cclxuZmRvLnJheSA9IHtcclxuICAgIHA6IFtcclxuICAgICAgICBbXCJhbmdsZVwiLCBXS0YuQW5nbGVdLFxyXG4gICAgICAgIFtcInNpemVcIiwgV0tGLkxlbmd0aF0sXHJcbiAgICAgICAgW1wiY29udGFpblwiLCAodjogYm9vbGVhbikgPT4gKHYgPyBcImNvbnRhaW5cIiA6IFwiXCIpXVxyXG4gICAgXSxcclxuICAgIHM6IFwiIFwiXHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gR3JpZHNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAvKipcclxuICogUmV0dXJucyBhbiBJTWluTWF4IGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYG1pbm1heCgpYCBDU1MgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBHcmlkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWlubWF4ID0gKG1pbjogR3JpZFRyYWNrU2l6ZSwgbWF4OiBHcmlkVHJhY2tTaXplKTogSU1pbk1heEZ1bmMgPT5cclxuICAgICh7IGZuOiBcIm1pbm1heFwiLCBtaW4sIG1heCB9KTtcclxuXHJcbmZkby5taW5tYXggPSBbIFtcIm1pblwiLCBXS0YuTGVuZ3RoXSwgW1wibWF4XCIsIFdLRi5MZW5ndGhdIF1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gSVJlcGVhdCBmdW5jdGlvbiByZXByZXNlbnRpbmcgdGhlIGByZXBlYXQoKWAgQ1NTIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAY2F0ZWdvcnkgR3JpZFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlcGVhdCA9IChjb3VudDogRXh0ZW5kZWQ8Q3NzTnVtYmVyPiB8IFwiYXV0by1maWxsXCIgfCBcImF1dG8tZml0XCIsXHJcbiAgICAuLi50cmFja3M6IEdyaWRUcmFja1tdKTogSVJlcGVhdEZ1bmMgPT4gKHsgZm46IFwicmVwZWF0XCIsIGNvdW50LCB0cmFja3MgfSk7XHJcblxyXG5mZG8ucmVwZWF0ID0gWyBcImNvdW50XCIsIFtcInRyYWNrc1wiLCB7IGl0ZW06IFdLRi5HcmlkVHJhY2sgfV0gXVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBJR3JpZFNwYW5GdW5jIGZ1bmN0aW9uIHJlcHJlc2VudGluZyB0aGUgYHNwYW5gIGV4cHJlc3Npb24gZm9yIGdyaWQgbGF5b3V0cy4gSWYgdGhlIGZpcnN0XHJcbiAqIHBhcmFtZXRlciBpcyBhIG51bWJlciwgdGhlIHNlY29uZCBwYXJhbWV0ZXIgKGlmIGRlZmluZWQpIG11c3QgYmUgYSBuYW1lOyBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyXHJcbiAqIGlzIGEgbmFtZSwgdGhlIHNlY29uZCBwYXJhbWV0ZXIgKGlmIGRlZmluZWQpIG11c3QgYmUgYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBjYXRlZ29yeSBHcmlkXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3BhbiA9IChwMTogRXh0ZW5kZWQ8R3JpZExpbmVDb3VudE9yTmFtZT4sIHAyPzogRXh0ZW5kZWQ8R3JpZExpbmVDb3VudE9yTmFtZT4pOiBJR3JpZFNwYW5GdW5jID0+XHJcbiAgICAoeyBmbjogXCJzcGFuXCIsIHAxLCBwMiB9KTtcclxuXHJcbmZkby5zcGFuID0gKHY6IElHcmlkU3BhbkZ1bmMpID0+IG12MnMoIFtcInNwYW5cIiwgdi5wMSwgdi5wMl0pXHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7SVN0eWxlRGVmaW5pdGlvbkNsYXNzLCBJU3R5bGVEZWZpbml0aW9uLCBJQ3NzU2VyaWFsaXplcn0gZnJvbSBcIi4vUnVsZVR5cGVzXCI7XHJcbmltcG9ydCB7RXh0ZW5kZWRNZWRpYUZlYXR1cmVzZXQsIElNZWRpYVF1ZXJ5UHJveHksIElTdXBwb3J0c1F1ZXJ5UHJveHksIE1lZGlhU3RhdGVtZW50LCBTdXBwb3J0c1N0YXRlbWVudH0gZnJvbSBcIi4vTWVkaWFUeXBlc1wiO1xyXG5pbXBvcnQge1N0eWxlc2V0LCBFeHRlbmRlZElTdHlsZXNldCwgU3RyaW5nU3R5bGVzZXQsIElTdHlsZXNldH0gZnJvbSBcIi4vU3R5bGVzZXRzXCJcclxuaW1wb3J0IHtzcDJzLCBzX3JlZ2lzdGVyU1AsIHMyc3MsIHN0eWxlc2V0MnN9IGZyb20gXCIuLi9pbXBsL1N0eWxlSW1wbFwiXHJcbmltcG9ydCB7c2NoZWR1bGVTdHlsZVVwZGF0ZX0gZnJvbSBcIi4uL2ltcGwvU2NoZWR1bGluZ0ltcGxcIjtcclxuaW1wb3J0IHtJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0fSBmcm9tIFwiLi4vcnVsZXMvUnVsZVwiO1xyXG5pbXBvcnQge3Byb2Nlc3NTRCwgc2VyaWFsaXplU0R9IGZyb20gXCIuLi9ydWxlcy9SdWxlQ29udGFpbmVyXCI7XHJcbmltcG9ydCB7bWVkaWEycywgc3VwcG9ydHMyc30gZnJvbSBcIi4uL2ltcGwvTWlzY0ltcGxcIjtcclxuaW1wb3J0IHt0YWcyc30gZnJvbSBcIi4uL2ltcGwvVXRpbHNcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFN0eWxlc2V0IG1hbmlwdWxhdGlvblxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgdmFsdWVzIG9mIHRoZSBnaXZlbiBzdHlsZSBwcm9wZXJ0eSB0b1xyXG4gKiBzdHJpbmcuIFRoZSBgcmVnaXN0ZXJTdHlsZVByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgYWZ0ZXIgYWRkaW5nIHRoZSBwcm9wZXJ0eSB0byB0aGVcclxuICogW1tJU3R5bGVzZXRdXSBpbnRlcmZhY2UgdmlhIHRoZSBtb2R1bGUgYXVnbWVudGF0aW9uIHRlY2huaXF1ZSBpZiB0aGUgY29udmVyc2lvbiB0byBzdHJpbmdcclxuICogcmVxdWlyZXMgbm9uLXN0YW5kYXJkIG9wZXJhdGlvbnMuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgZm9yIHByb3BldGllcyB3aG9zZVxyXG4gKiB2YWx1ZXMgb25seSBpbmNsdWRlIG51bWJlcnMsIHN0cmluZ3MsIGZ1bmN0aW9ucyByZXR1cm5pbmcgYSBzdHJpbmcsIG9iamVjdHMgd2hvc2UgYHRvU3RyaW5nYFxyXG4gKiBtZXRob2QgcHJvZHVjZXMgdGhlIG5lY2Vzc2FyeSBzdHJpbmcgb3IgYXJyYXlzIG9mIHRoZSBhYm92ZSB0eXBlcy5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBmb3Igc3R5bGUgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgeWV0IHN1cHBvcnRlZCBieSBNaW1jc3MuIFRoaXMgaXNcclxuICogYWxzbyB0aGUgd2F5IHRvIHN1cHBvcnQgcHJvcGVydGllcyB3aXRoIHZlbmRvciBwcmVmaXhlcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlclN0eWxlUHJvcGVydHkgPSAobmFtZTogc3RyaW5nLCB0b1N0cmluZ0Z1bmM6ICh2OiBhbnkpID0+IHN0cmluZyk6IGJvb2xlYW4gPT5cclxuICAgIHNfcmVnaXN0ZXJTUCggbmFtZSwgdG9TdHJpbmdGdW5jKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBzdHlsZSBwcm9wZXJ0eSB0byBhIENTUyBzdHJpbmcuXHJcbiAqIEBwYXJhbSBzdHlsZVByb3BOYW1lIFN0eWxlIHByb3BlcnR5IG5hbWUgdGhhdCBkZXRlcm1pbmVzIGhvdyB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZFxyXG4gKiB0byBhIENTUyBjb21wbGlhbnQgc3RyaW5nLlxyXG4gKiBAcGFyYW0gc3R5bGVQcm9wVmFsdWUgVmFsdWUgdG8gY29udmVydC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRTdHlsZVByb3BWYWx1ZSA9IDxLIGV4dGVuZHMga2V5b2YgSVN0eWxlc2V0Piggc3R5bGVQcm9wTmFtZTogSyxcclxuXHRzdHlsZVByb3BWYWx1ZTogRXh0ZW5kZWRJU3R5bGVzZXRbS10pOiBzdHJpbmcgPT4gc3Aycyggc3R5bGVQcm9wTmFtZSwgc3R5bGVQcm9wVmFsdWUpO1xyXG5cclxuXHJcblxyXG4vLyBTZXRzIHN0eWxlIHByb3BlcnR5IG9uIEhUTUwgb3IgU1ZHIGVsZW1lbnRcclxuY29uc3Qgc2V0RWxlbWVudFN0eWxlUHJvcCA9IDxLIGV4dGVuZHMga2V5b2YgSVN0eWxlc2V0PiggZWxtOiBFbGVtZW50Q1NTSW5saW5lU3R5bGUsIG5hbWU6IEssXHJcbiAgICB2YWx1ZTogRXh0ZW5kZWRJU3R5bGVzZXRbS10sIHNjaGVkdWxlclR5cGU/OiBudW1iZXIpOiB2b2lkID0+XHJcbiAgICBzY2hlZHVsZVN0eWxlVXBkYXRlKCBlbG0sIG5hbWUsIHNwMnMoIG5hbWUsIHZhbHVlKSwgZmFsc2UsIHNjaGVkdWxlclR5cGUpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogU2V0cyB2YWx1ZXMgb2YgdGhlIHN0eWxlIHByb3BlcnRpZXMgZnJvbSB0aGUgZ2l2ZW4gU3R5bGVzZXQgb2JqZWN0IHRvIHRoZSBgc3R5bGVgIGF0dHJpYnV0ZVxyXG4gKiBvZiB0aGUgZ2l2ZW4gSFRNTCBlbGVtZW50LlxyXG4gKiBAcGFyYW0gZWxtIEhUTUwvU1ZHIGVsZW1lbnQgd2hvc2Ugc3R5bGVzIHdpbGwgYmUgc2V0LlxyXG4gKiBAcGFyYW0gc3R5bGVzZXQgU3R5bGVzZXQgb2JqZWN0IHdoaWNoIHByb3ZpZGVzIHZhbHVlcyBmb3Igc3R5bGUgcHJvcGVydGllcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXRFbGVtZW50U3R5bGUgPSAoZWxtOiBFbGVtZW50Q1NTSW5saW5lU3R5bGUsIHN0eWxlc2V0OiBTdHlsZXNldCB8IG51bGwgfCB1bmRlZmluZWQsXHJcblx0c2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQgPT5cclxuICAgIHNldEVsZW1lbnRTdHJpbmdTdHlsZSggZWxtLCBzdHlsZXNldCA/IHN0eWxlc2V0VG9TdHJpbmdTdHlsZXNldChzdHlsZXNldCkgOiBudWxsLCBzY2hlZHVsZXJUeXBlKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFNldHMgdmFsdWVzIG9mIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGdpdmVuIFN0cmluZ1N0eWxlc2V0IG9iamVjdCB0byB0aGUgYHN0eWxlYCBhdHRyaWJ1dGVcclxuICogb2YgdGhlIGdpdmVuIEhUTUwgZWxlbWVudC5cclxuICogQHBhcmFtIGVsbSBIVE1ML1NWRyBlbGVtZW50IHdob3NlIHN0eWxlcyB3aWxsIGJlIHNldC5cclxuICogQHBhcmFtIHN0eWxlc2V0IFtbU3RyaW5nU3R5bGVzZXRdXSBvYmplY3Qgd2hpY2ggcHJvdmlkZXMgdmFsdWVzIGZvciBzdHlsZSBwcm9wZXJ0aWVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldEVsZW1lbnRTdHJpbmdTdHlsZSA9IChlbG06IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgc3R5bGVzZXQ6IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuXHRzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZCA9PlxyXG4gICAgc2NoZWR1bGVTdHlsZVVwZGF0ZSggZWxtLCBudWxsLCBzdHlsZXNldCwgZmFsc2UsIHNjaGVkdWxlclR5cGUpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gW1tTdHlsZXNldF1dIHRvIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0gc3R5bGVzZXRcclxuICovXHJcbmV4cG9ydCBjb25zdCBzdHlsZXNldFRvU3RyaW5nID0gKHN0eWxlc2V0OiBTdHlsZXNldCk6IHN0cmluZyA9PiBzdHlsZXNldDJzKCBzdHlsZXNldCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gW1tTdHlsZXNldF1dIG9iamVjdCBpbnRvIGFuIG9iamVjdCwgd2hlcmUgZWFjaCBTdHlsZXNldCdzIHByb3BlcnR5IGlzXHJcbiAqIGNvbnZlcnRlZCB0byBpdHMgc3RyaW5nIHZhbHVlLlxyXG4gKiBAcGFyYW0gc3R5bGVzZXRcclxuICovXHJcbmV4cG9ydCBjb25zdCBzdHlsZXNldFRvU3RyaW5nU3R5bGVzZXQgPSAoc3R5bGVzZXQ6IFN0eWxlc2V0KTogU3RyaW5nU3R5bGVzZXQgPT4gczJzcyggc3R5bGVzZXQpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdHdvIFN0eWxlc2V0IG9iamVjdHMgYnkgY29udmVydGluZyBzdHlsZSBwcm9wZXJ0aWVzIHRvIHN0cmluZ3MgYW5kIHJldHVybnMgYW4gb2JqZWN0XHJcbiAqIHRoYXQgY29udGFpbnMgc3RyaW5nIHZhbHVlcyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBuZXcgb3IgaGF2ZSBkaWZmZXJlbnQgdmFsdWVzIGluIHRoZSBuZXdcclxuICogc3R5bGVzZXQgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZm9yIHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiB0aGUgb2xkIHN0eWxlc2V0IGJ1dCBkb24ndCBleGlzdFxyXG4gKiBpbiB0aGUgbmV3IG9uZS5cclxuICogQHBhcmFtIG9sZFN0eWxlc2V0XHJcbiAqIEBwYXJhbSBuZXdTdHlsZXNldFxyXG4gKiBAcmV0dXJucyBTdHJpbmdTdHlsZXNldCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBkaWZmZXJlbnQgdmFsdWVzIGluIHRoZSBvbGQgYW5kIG5ld1xyXG4gKiBzdHlsZXNldHMuIFByb3BlcnRpZXMgdGhhdCBleGlzdGVkIGluIHRoZSBvbGQgYnV0IGRvbid0IGV4aXN0IGluIHRoZSBuZXcgc3R5bGVzZXQsIHdpbGwgaGF2ZVxyXG4gKiB0aGVpciB2YWx1ZXMgc2V0IHRvIGBcInVuc2V0XCJgLiBJZiB0aGVyZSBpcyBubyBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gc3R5bGVzZXRzIG51bGwgaXNcclxuICogcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGlmZlN0eWxlc2V0cyA9IChvbGRTdHlsZXNldDogU3R5bGVzZXQsIG5ld1N0eWxlc2V0OiBTdHlsZXNldCk6IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCA9PlxyXG57XHJcblx0aWYgKCFvbGRTdHlsZXNldCAmJiAhbmV3U3R5bGVzZXQpXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHRlbHNlIGlmICghb2xkU3R5bGVzZXQpXHJcblx0XHRyZXR1cm4gczJzcyggbmV3U3R5bGVzZXQpO1xyXG5cdGVsc2UgaWYgKCFuZXdTdHlsZXNldClcclxuXHRcdHJldHVybiBzMnNzKCBvbGRTdHlsZXNldCk7XHJcblxyXG5cdC8vIGZpcnN0IGNvbnZlcnQgYm90aCBzdHlsZXNldHMgdG8gdGhlaXIgc3RyaW5nIHZlcnNpb25zXHJcblx0bGV0IG9sZFN0cmluZ1N0eWxlc2V0ID1cdHMyc3MoIG9sZFN0eWxlc2V0KTtcclxuXHRsZXQgbmV3U3RyaW5nU3R5bGVzZXQgPVx0czJzcyggbmV3U3R5bGVzZXQpO1xyXG5cclxuXHRsZXQgdXBkYXRlVmFsOiBTdHJpbmdTdHlsZXNldCB8IG51bGwgPSBudWxsO1xyXG5cclxuXHQvLyBsb29wIG92ZXIga2V5cyBpbiB0aGUgb2xkIHN0eWxlIG9iamVjdCBhbmQgZmluZCB0aG9zZSB0aGF0IGFyZSBub3QgaW4gdGhlIG5ldyBvbmUuIFRoZXNlXHJcblx0Ly8gd2lsbCBiZSByZW1vdmVkLlxyXG5cdGZvciggbGV0IGtleSBpbiBvbGRTdHJpbmdTdHlsZXNldClcclxuXHR7XHJcblx0XHRsZXQgbmV3U3RyaW5nVmFsID0gbmV3U3RyaW5nU3R5bGVzZXRba2V5XTtcclxuXHRcdGlmIChuZXdTdHJpbmdWYWwgPT0gbnVsbClcclxuXHRcdHtcclxuXHRcdFx0dXBkYXRlVmFsID0gdXBkYXRlVmFsIHx8IHt9O1xyXG5cdFx0XHR1cGRhdGVWYWxba2V5XSA9IFwidW5zZXRcIjtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0bGV0IG9sZFN0cmluZ1ZhbCA9IG9sZFN0cmluZ1N0eWxlc2V0W2tleV07XHJcblx0XHRcdGlmIChvbGRTdHJpbmdWYWwgIT09IG5ld1N0cmluZ1ZhbClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHVwZGF0ZVZhbCA9IHVwZGF0ZVZhbCB8fCB7fTtcclxuXHRcdFx0XHR1cGRhdGVWYWxba2V5XSA9IG5ld1N0cmluZ1ZhbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbG9vcCBvdmVyIGtleXMgaW4gdGhlIG5ldyBzdHlsZSBvYmplY3QgYW5kIGZpbmQgdGhvc2UgdGhhdCBhcmUgbm90IGluIHRoZSBvbGQgb25lLiBUaGVzZVxyXG5cdC8vIHdpbGwgYmUgYWRkZWQuXHJcblx0Zm9yKCBsZXQga2V5IGluIG5ld1N0cmluZ1N0eWxlc2V0KVxyXG5cdHtcclxuXHRcdGxldCBvbGRTdHJpbmdWYWwgPSBvbGRTdHJpbmdTdHlsZXNldFtrZXldO1xyXG5cdFx0aWYgKG9sZFN0cmluZ1ZhbCA9PSBudWxsKVxyXG5cdFx0e1xyXG5cdFx0XHR1cGRhdGVWYWwgPSB1cGRhdGVWYWwgfHwge307XHJcblx0XHRcdHVwZGF0ZVZhbFtrZXldID0gbmV3U3RyaW5nU3R5bGVzZXRba2V5XTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB1cGRhdGVWYWw7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEFkZGluZyBtZXRob2RzIHRvIHNldmVyYWwgRE9NIHByb3RvdHlwZXMgdXNpbmcgbW9kdWxlIGF1Z21lbnRhdGlvblxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmRlY2xhcmUgZ2xvYmFsXHJcbntcclxuICAgIGludGVyZmFjZSBFbGVtZW50Q1NTSW5saW5lU3R5bGVcclxuICAgIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBnaXZlbiBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0gbmFtZSBQcm9wZXJ0eSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHNjaGVkdWxlclR5cGUgU2NoZWR1bGVyIGlkZW50aWZpZXIuIElmIG9taXR0ZWQsIHRoZSBjdXJyZW50IGRlZmF1bHQgc2NoZWR1bGVyXHJcbiAgICAgICAgICogd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFN0eWxlUHJvcDxLIGV4dGVuZHMga2V5b2YgSVN0eWxlc2V0PiggbmFtZTogSywgdmFsdWU6IEV4dGVuZGVkSVN0eWxlc2V0W0tdLFxyXG4gICAgICAgICAgICBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWVyZ2VzIG9yIHJlcGxhY2VzIHRoZSBlbGVtZW50J3Mgc3R5bGVzIHdpdGggdGhlIGdpdmVuIHN0eWxlc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSBzdHlsZXNldCBTdHlsZXNldCB0byBzZXQgb3IgcmVwbGFjZVxyXG4gICAgICAgICAqIEBwYXJhbSByZXBsYWNlIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBuZXcgc3R5bGVzZXQgc2hvdWxkIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGVcclxuICAgICAgICAgKiBleGlzdGluZyBlbGVtZW50IHN0eWxlcyB3aXRoIHRoZSBuZXcgc3R5bGVzICh0cnVlKSBvciBtZXJnZSB0aGUgbmV3IHN0eWxlcyB3aXRoIHRoZVxyXG4gICAgICAgICAqIGV4aXN0aW5nIG9uZXMgKGZhbHNlKS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXHJcbiAgICAgICAgICogQHBhcmFtIHNjaGVkdWxlclR5cGUgU2NoZWR1bGVyIGlkZW50aWZpZXIuIElmIG9taXR0ZWQsIHRoZSBjdXJyZW50IGRlZmF1bHQgc2NoZWR1bGVyXHJcbiAgICAgICAgICogd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFN0eWxlc2V0KCBzdHlsZXNldDogU3R5bGVzZXQsIHNjaGVkdWxlclR5cGU/OiBudW1iZXIpOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8gZnVuY3Rpb25zIG9uIEhUTUwgYW5kIFNWRyBlbGVtZW50IHByb3RvdHlwZXNcclxuSFRNTEVsZW1lbnQucHJvdG90eXBlLnNldFN0eWxlUHJvcCA9IHNldFRoaXNFbGVtZW50U3R5bGVQcm9wO1xyXG5TVkdFbGVtZW50LnByb3RvdHlwZS5zZXRTdHlsZVByb3AgPSBzZXRUaGlzRWxlbWVudFN0eWxlUHJvcDtcclxuXHJcbkhUTUxFbGVtZW50LnByb3RvdHlwZS5zZXRTdHlsZXNldCA9IHNldFRoaXNFbGVtZW50U3R5bGU7XHJcblNWR0VsZW1lbnQucHJvdG90eXBlLnNldFN0eWxlc2V0ID0gc2V0VGhpc0VsZW1lbnRTdHlsZTtcclxuXHJcblxyXG5cclxuLy8gU2V0cyBzdHlsZSBwcm9wZXJ0eSBvbiBIVE1MIG9yIFNWRyBlbGVtZW50XHJcbmZ1bmN0aW9uIHNldFRoaXNFbGVtZW50U3R5bGVQcm9wPEsgZXh0ZW5kcyBrZXlvZiBJU3R5bGVzZXQ+KCBuYW1lOiBLLFxyXG4gICAgdmFsdWU6IEV4dGVuZGVkSVN0eWxlc2V0W0tdLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG57XHJcbiAgICBzZXRFbGVtZW50U3R5bGVQcm9wKCB0aGlzLCBuYW1lLCB2YWx1ZSwgc2NoZWR1bGVyVHlwZSk7XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gc2V0VGhpc0VsZW1lbnRTdHlsZSggc3R5bGVzZXQ6IFN0eWxlc2V0LCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG57XHJcbiAgICBzZXRFbGVtZW50U3R5bGUoIHRoaXMsIHN0eWxlc2V0LCBzY2hlZHVsZXJUeXBlKTtcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQG1lZGlhIGFuZCBAc3VwcG9ydHMgcXVlcmllcy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogVGFnIGZ1bmN0aW9uIHRoYXQgcmVwcmVzZW50cyBhIG1lZGlhIHF1ZXJ5LiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBleHByZXNzaW5nIG1lZGlhIHF1ZXJpZXMgaW5cclxuICogYSBuYXR1cmFsIHN0cmluZyBmb3JtIHdoaWxlIGVtYmVkZGluZyBtZWRpYSBmZWF0dXJlIHZhbHVlcyBpbiB0eXBlIHNhZmUgbWFubmVyLiBUaGUgc3RyaW5nIGNhblxyXG4gKiBjb250YWluIGFueSBtZWRpYSBleHByZXNzaW9ucyB3aGlsZSB0aGUgZW1iZWRkZWQgb2JqZWN0cyBtdXN0IGJlIG9mIHR5cGUgW1tJTWVkaWFGZWF0dXJlc2V0XV0uXHJcbiAqIE11bHRpcGxlIGZlYXR1cmVzIGluIHRoZSBmZWF0dXJlIHNldCB3aWxsIGJlIGV4cGFuZGVkIGludG8gY2xhdXNlcyBjb21iaW5lZCB3aXRoIHRoZSBcImFuZFwiXHJcbiAqIG9wZXJhdG9yLlxyXG4gKlxyXG4gKiAqKkV4YW1wbGU6KipcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeVN0eWxlcyBleHRlbmRzIFN0eWxlRGVmaW5pdGlvblxyXG4gKiB7XHJcbiAqICAgICAvLyBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwMHB4KSBhbmQgKG1heC13aWR0aDogNjAwcHgpIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KVxyXG4gKiAgICAgaWZOYXJyb3dEZXZpY2UgPSB0aGlzLiRtZWRpYShcclxuICogICAgICAgICBjc3MubWVkaWFgc2NyZWVuIGFuZCAke3t3aWR0aDpbNDAwLDYwMF0sIG9yaWVudGF0aW9uOiBcInBvcnRyYWl0XCJ9fWAsIC4uLilcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbiBleHBvcnQgY29uc3QgbWVkaWEgPSAocGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5wYXJhbXM6IEV4dGVuZGVkTWVkaWFGZWF0dXJlc2V0W10pOiBJTWVkaWFRdWVyeVByb3h5ID0+XHJcbiAgICAoKSA9PiB0YWcycyggcGFydHMsIHBhcmFtcywgdiA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYgOiBtZWRpYTJzKHYpKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBtZWRpYSBxdWVyeSB2YWx1ZSB0byB0aGUgQ1NTIG1lZGlhIHF1ZXJ5IHN0cmluZy4gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZFxyXG4gKiBieSBsaWJyYXJpZXMgdGhhdCBhbGxvdyBzcGVjaWZ5aW5nIFtbTWVkaWFTdGF0ZW1lbnRdXSBmb3IgdGhlIGBtZWRpYWAgYXR0cmlidXRlIG9mIGVsZW1lbnRzXHJcbiAqIHN1Y2ggYXMgYDxsaW5rPmAsIGA8c3R5bGU+YCBhbmQgYDxzb3VyY2U+YFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1lZGlhVG9TdHJpbmcgPSAocXVlcnk6IE1lZGlhU3RhdGVtZW50KTogc3RyaW5nID0+IG1lZGlhMnMoIHF1ZXJ5KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRhZyBmdW5jdGlvbiB0aGF0IHJlcHJlc2VudHMgYSBzdXBwb3J0cyBxdWVyeS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgZXhwcmVzc2luZyBzdXBwb3J0c1xyXG4gKiBxdWVyaWVzIGluIGEgbmF0dXJhbCBzdHJpbmcgZm9ybSB3aGlsZSBlbWJlZGRpbmcgbWVkaWEgZmVhdHVyZSB2YWx1ZXMgaW4gdHlwZSBzYWZlIG1hbm5lci4gVGhlXHJcbiAqIHN0cmluZyBjYW4gY29udGFpbiBhbnkgc3VwcG9ydHMgZXhwcmVzc2lvbnMgd2hpbGUgdGhlIGVtYmVkZGVkIG9iamVjdHMgbXVzdCBiZSBvZiB0eXBlXHJcbiAqIFN0eWxlc2V0LiBNdWx0aXBsZSBwcm9wZXJ0aWVzIGluIHRoZSBzdHlsZXNldCB3aWxsIGJlIGV4cGFuZGVkIGludG8gY2xhdXNlcyBjb21iaW5lZCB3aXRoIHRoZVxyXG4gKiBcIm9yXCIgb3BlcmF0b3IuXHJcbiAqXHJcbiAqICoqRXhhbXBsZToqKlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3R5bGVzIGV4dGVuZHMgU3R5bGVEZWZpbml0aW9uXHJcbiAqIHtcclxuICogICAgIC8vIG5vdCAodHJhbnNmb3JtLW9yaWdpbjogMzBweCAzMHB4IDMwcHgpXHJcbiAqICAgICBpZk5vVHJhbnNmb3JtT3JpZ2luID0gdGhpcy4kc3VwcG9ydHMoXHJcbiAqICAgICAgICAgY3NzLnN1cHBvcnRzYG5vdCAoJHt7dHJhbnNmb3JtLW9yaWdpbjogWzMwLCAzMCwgMzBdfX0pYCwgLi4uKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuIGV4cG9ydCBjb25zdCBzdXBwb3J0cyA9IChwYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLnBhcmFtczogU3R5bGVzZXRbXSk6IElTdXBwb3J0c1F1ZXJ5UHJveHkgPT5cclxuICAgICgpID0+IHRhZzJzKCBwYXJ0cywgcGFyYW1zLCB2ID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA6IHN1cHBvcnRzMnModikpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIHN1cHBvcnRzIHF1ZXJ5IHZhbHVlIHRvIHRoZSBDU1Mgc3VwcG9ydHMgcXVlcnkgc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN1cHBvcnRzVG9TdHJpbmcgPSAocXVlcnk6IFN1cHBvcnRzU3RhdGVtZW50KTogc3RyaW5nID0+IHN1cHBvcnRzMnMoIHF1ZXJ5KTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gU3R5bGUgc2VyaWFsaXphdGlvbi5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IElDc3NTZXJpYWxpemVyIG9iamVjdCB0aGF0IGFsbG93cyBhZGRpbmcgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzXHJcbiAqIGFuZCBpbnN0YW5jZXMgYW5kIHNlcmlhbGl6aW5nIHRoZW0gdG8gYSBzdHJpbmcuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZyB3aGVuXHJcbiAqIHRoZSByZXN1bHRhbnQgc3RyaW5nIGNhbiBiZSBzZXQgYXMgdGhlIGNvbnRlbnQgb2YgYSBgPHN0eWxlPmAgZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDc3NTZXJpYWxpemVyID0gKCk6IElDc3NTZXJpYWxpemVyID0+IG5ldyBDc3NTZXJpYWxpemVyKCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXJpYWxpemVzIG9uZSBvciBtb3JlIHN0eWxlIGRlZmluaXRpb24gY2xhc3NlcyBhbmQgaW5zdGFuY2VzIGFuZCByZXR1cm5zIHRoZWlyIENTUyBzdHJpbmdcclxuICogcmVwcmVzZW50YXRpb24uIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZyB3aGVuIHRoZSByZXN1bHRhbnQgc3RyaW5nIGNhbiBiZVxyXG4gKiBzZXQgYXMgdGhlIGNvbnRlbnQgb2YgYSBgPHN0eWxlPmAgZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXJpYWxpemVUb0NTUyA9ICguLi5hcmdzOiAoSVN0eWxlRGVmaW5pdGlvbiB8IElTdHlsZURlZmluaXRpb25DbGFzcylbXSk6IHN0cmluZyA9PlxyXG57XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgbGV0IHNlcmlhbGl6ZXIgPSBuZXcgQ3NzU2VyaWFsaXplcigpO1xyXG4gICAgYXJncy5mb3JFYWNoKCBpbnN0T3JDbGFzcyA9PiBzZXJpYWxpemVyLmFkZCggaW5zdE9yQ2xhc3MpKTtcclxuICAgIHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZSgpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgU3R5bGVTZXJpYWxpemVyIGNsYXNzIGFsbG93cyBhZGRpbmcgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIGFuZCBvYmplY3RzXHJcbiAqIGFuZCBzZXJpYWxpemluZyB0aGVtIHRvIGEgc2luZ2xlIHN0cmluZy4gVGhpcyBjYW4gYmUgdXNlZCBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdoZW5cclxuICogdGhlIHJlc3VsdGFudCBzdHJpbmcgY2FuIGJlIHNldCBhcyB0aGUgY29udGVudCBvZiBhIGA8c3R5bGU+YCBlbGVtZW50LlxyXG4gKi9cclxuY2xhc3MgQ3NzU2VyaWFsaXplciBpbXBsZW1lbnRzIElDc3NTZXJpYWxpemVyXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIG9yIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKCBpbnN0T3JDbGFzczogSVN0eWxlRGVmaW5pdGlvbiB8IElTdHlsZURlZmluaXRpb25DbGFzcyk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICBsZXQgaW5zdGFuY2UgPSBwcm9jZXNzU0QoIGluc3RPckNsYXNzKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlIHx8IHRoaXMuc2RzLmhhcyhpbnN0YW5jZSkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5zZHMuYWRkKCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNvbmNhdGVuYXRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIENTUyBydWxlcyBhZGRlZCB0byB0aGUgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5zZHMuc2l6ZSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgICAgIGxldCBjdHggPSBuZXcgUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0KCk7XHJcbiAgICAgICAgdGhpcy5zZHMuZm9yRWFjaCggaW5zdGFuY2UgPT4gY3R4LmFkZFNEKCBpbnN0YW5jZSkpO1xyXG4gICAgICAgIHJldHVybiBjdHgudGwgKyBjdHgubnRsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBvZiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlcy4gVGhpcyBpcyBuZWVkZWQgdG8gbm90IGFkZCBzdHlsZSBkZWZpbml0aW9ucyBtb3JlIHRoYW4gb25jZVxyXG4gICAgc2RzID0gbmV3IFNldDxJU3R5bGVEZWZpbml0aW9uPigpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0IGNsYXNzIGltcGxlbWVudHMgdGhlIElSdWxlU2VyaWFsaXphdGlvbkNvbnRleHQgaW50ZXJmYWNlIGFuZFxyXG4gKiBhY2N1bXVsYXRlcyB0ZXh0IG9mIHNlcmlhbGl6ZWQgQ1NTIHJ1bGVzLlxyXG4gKi9cclxuY2xhc3MgUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0IGltcGxlbWVudHMgSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dFxyXG57XHJcbiAgICAvLyBBZGRzIHJ1bGUgdGV4dFxyXG4gICAgcHVibGljIGFkZFJ1bGUoIHM6IHN0cmluZywgaXNUb3BMZXZlbFJ1bGU/OiBib29sZWFuKTogdm9pZFxyXG4gICAge1xyXG4gICAgICAgIGlmIChpc1RvcExldmVsUnVsZSlcclxuICAgICAgICAgICAgdGhpcy50bCArPSBzO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5udGwgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGRzIHJ1bGUgdGV4dFxyXG4gICAgcHVibGljIGFkZFNEKCBpbnN0YW5jZTogSVN0eWxlRGVmaW5pdGlvbik6IHZvaWRcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2RzLmhhcyggaW5zdGFuY2UpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5zZHMuYWRkKCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZVNEKCBpbnN0YW5jZSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmluZyBidWZmZXIgdGhhdCBhY2N1bXVsYXRlcyB0b3AtbGV2ZWwgcnVsZSB0ZXh0cy5cclxuICAgIHB1YmxpYyB0bCA9IFwiXCI7XHJcblxyXG4gICAgLy8gU3RyaW5nIGJ1ZmZlciB0aGF0IGFjY3VtdWxhdGVzIG5vbi10b3AtbGV2ZWwgcnVsZSB0ZXh0cy5cclxuICAgIHB1YmxpYyBudGwgPSBcIlwiO1xyXG5cclxuICAgIC8vIFNldCBvZiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlcyB0aGF0IHdlcmUgYWxyZWFkeSBzZXJpYWxpemVkIGluIHRoaXMgY29udGV4dC5cclxuICAgIHByaXZhdGUgc2RzID0gbmV3IFNldDxJU3R5bGVEZWZpbml0aW9uPigpO1xyXG59XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7Q3NzU2VsZWN0b3IsIElBdHRyU2VsZWN0b3JGdW5jfSBmcm9tIFwiLi4vYXBpL0NvcmVUeXBlc1wiO1xyXG5pbXBvcnQge2ZkbywgdjJzfSBmcm9tIFwiLi9VdGlsc1wiO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIHNlbGVjdG9yLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VsZWN0b3IycyA9ICh2YWw6IENzc1NlbGVjdG9yKTogc3RyaW5nID0+IHYycyggdmFsLCB7IHNlcDogXCJcIiwgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG5cclxuXHJcblxyXG4vLyBDb252ZXJ0aW5nIGF0dHJpYnV0ZSBzZWxlY3RvciBkZWZpbml0aW9uIHRvIHN0cmluZ1xyXG5mZG9bXCJhdHRyLXNlbFwiXSA9ICh2OiBJQXR0clNlbGVjdG9yRnVuYykgPT4gYFske3YubnMgPyAodHlwZW9mIHYubnMgPT09IFwic3RyaW5nXCIgPyB2Lm5zIDogdi5ucy5wcmVmaXgpICsgXCJ8XCIgOiBcIlwifSR7di5uYW1lfWAgK1xyXG4gICAgKHYudmFsID09IG51bGwgPyBcIl1cIiA6IGAke3Yub3AgPz8gXCI9XCJ9XCIke3YudmFsfVwiJHt2LmNmID8gXCIgXCIgKyB2LmNmIDogXCJcIn1dYClcclxuXHJcblxyXG5cclxuLy8gQ29udmVydGluZyBcIm50aFwiIHBzZXVkbyBjbGFzc2VzIHRvIHN0cmluZ1xyXG5mZG9bXCI6bnRoLWNoaWxkXCJdID0gZmRvW1wiOm50aC1sYXN0LWNoaWxkXCJdID0gZmRvW1wiOm50aC1vZi10eXBlXCJdID0gZmRvW1wiOm50aC1sYXN0LW9mLXR5cGVcIl0gPSBbXHJcbiAgICBbXCJwXCIsIHtcclxuICAgICAgICBhcnI6IFtcclxuICAgICAgICAgICAgdiA9PiB2ICsgXCJuXCIsXHJcbiAgICAgICAgICAgIHYgPT4gIXYgPyBcIlwiIDogdiA+IDAgPyBcIitcIiArIHYgOiBcIi1cIiArIC12XHJcbiAgICAgICAgXSxcclxuICAgICAgICBzZXA6IFwiXCJcclxuICAgIH1dXHJcbl1cclxuXHJcblxyXG5cclxuLy8gLy8gQ29udmVydGluZyBwc2V1ZG8gZW50aXRpZXMgdGhhdCBhY2NlcHQgQ3NzU2VsZWN0b3IgdG8gc3RyaW5nXHJcbi8vIGZkb1tcIjppc1wiXSA9IGZkb1tcIjpoYXNcIl0gPSBmZG9bXCI6aG9zdC1jb250ZXh0XCJdID0gZmRvW1wiOm5vdFwiXSA9IGZkb1tcIjp3aGVyZVwiXSA9IGZkb1tcIjo6c2xvdHRlZFwiXSA9IFtcclxuLy8gICAgIFtcInBcIiwgc2VsZWN0b3Iyc11cclxuLy8gICAgIC8vIFtcInBcIiwge3NlcDogXCIsXCIsIHJlY3Vyc2l2ZTogdHJ1ZX1dXHJcbi8vIF1cclxuXHJcblxyXG5cclxuIiwi77u/aW1wb3J0IHtFeHRlbmRlZEZvbnRGYWNlLCBJRm9udEZhY2V9IGZyb20gXCIuLi9hcGkvRm9udFR5cGVzXCJcclxuaW1wb3J0IHtJTWVkaWFGZWF0dXJlc2V0LCBNZWRpYVF1ZXJ5LCBNZWRpYVN0YXRlbWVudCwgU3VwcG9ydHNRdWVyeSwgU3VwcG9ydHNTdGF0ZW1lbnR9IGZyb20gXCIuLi9hcGkvTWVkaWFUeXBlc1wiO1xyXG5pbXBvcnQge3NwMnN9IGZyb20gXCIuL1N0eWxlSW1wbFwiO1xyXG5pbXBvcnQge2NhbWVsVG9EYXNoLCB2MnMsIGEycywgV0tGLCBWMlNPcHRpb25zLCBkYXNoVG9DYW1lbCwgd2tmLCBwcm9wU2V0MnN9IGZyb20gXCIuL1V0aWxzXCI7XHJcbmltcG9ydCB7RXh0ZW5kZWRDb3VudGVyU3R5bGVzZXQsIElDb3VudGVyU3R5bGVzZXR9IGZyb20gXCIuLi9hcGkvQ291bnRlclR5cGVzXCI7XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgQG1lZGlhIHJ1bGUuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBtZWRpYSBxdWVyeSBvYmplY3QgdG8gdGhlIENTUyBtZWRpYSBxdWVyeSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtZWRpYTJzID0gKHN0YXRlbWVudDogTWVkaWFTdGF0ZW1lbnQpOiBzdHJpbmcgPT5cclxuICAgIHYycyggc3RhdGVtZW50LCB7XHJcbiAgICAgICAgYW55OiBtZWRpYVF1ZXJ5MnMsXHJcbiAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgfSlcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbWVkaWEgcXVlcnkgb2JqZWN0IHRvIHRoZSBDU1MgbWVkaWEgcXVlcnkgc3RyaW5nXHJcbiAqL1xyXG5jb25zdCBtZWRpYVF1ZXJ5MnMgPSAocXVlcnk6IE1lZGlhUXVlcnkpOiBzdHJpbmcgPT5cclxuICAgIHByb3BTZXQycyggcXVlcnksIG1lZGlhRmVhdHVyZUluZm9zLCB7XHJcbiAgICAgICAgc2VwYXJhdG9yOiBcIiBhbmQgXCIsXHJcbiAgICAgICAgcHJvcEZ1bmM6IG1lZGlhRmVhdHVyZTJzLFxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIG1lZGlhIGZlYXR1cmUgdG8gdGhlIENTUyBtZWRpYSBxdWVyeSBzdHJpbmdcclxuICovXHJcbmNvbnN0IG1lZGlhRmVhdHVyZTJzID0gKGRhc2hOYW1lOiBzdHJpbmcsIGNhbWVsTmFtZTogc3RyaW5nLCB2YWw6IGFueSwgb3B0aW9uczogVjJTT3B0aW9ucyk6IHN0cmluZyA9PlxyXG57XHJcbiAgICBpZiAodmFsID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgLy8gaWYgZGVmYXVsdFZhbHVlIGlzIGRlZmluZWQgYW5kIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBlcXVhbCB0byBpdCwgbm8gdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkLlxyXG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IG1lZGlhRmVhdHVyZURlZmF1bHRWYWx1ZXMuZ2V0KGNhbWVsTmFtZSk7XHJcbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsID09PSBkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgcmV0dXJuIGRhc2hOYW1lO1xyXG5cclxuICAgIGxldCBpc1JhbmdlID0gcmFuZ2VNZWRpYUZlYXR1cmVzLmhhcyggY2FtZWxOYW1lKTtcclxuICAgIGlmIChpc1JhbmdlICYmIEFycmF5LmlzQXJyYXkoIHZhbCkpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtcIm1pbi1cIiArIGRhc2hOYW1lfToke3YycyggdmFsWzBdLCBvcHRpb25zKX0pIGFuZCAoJHtcIm1heC1cIiArIGRhc2hOYW1lfToke3YycyggdmFsWzFdLCBvcHRpb25zKX0pYDtcclxuXHJcbiAgICAgICAgLy8gdGhpcyBzeW50YXggaXMgbm90IHdpZGVseSBzdXBwb3J0ZWQgeWV0XHJcbiAgICAgICAgLy8gcmV0dXJuIGAke3MxfSA8PSAke2Rhc2hOYW1lfSA8PSAke3MyfWA7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGAoJHtkYXNoTmFtZX06JHt2MnMoIHZhbCwgb3B0aW9ucyl9KWA7XHJcbn1cclxuXHJcblxyXG5cclxuY29uc3QgbWVkaWFGZWF0dXJlSW5mb3M6IHsgW0sgaW4ga2V5b2YgSU1lZGlhRmVhdHVyZXNldF0/OiBWMlNPcHRpb25zIH0gPVxyXG57XHJcbiAgICBhc3BlY3RSYXRpbzoge1xyXG4gICAgICAgIG51bTogKHY6IG51bWJlcikgPT4gdiArIFwiLzFcIlxyXG4gICAgfSxcclxuICAgIGhlaWdodDogV0tGLkxlbmd0aCxcclxuICAgIG1pbkhlaWdodDogV0tGLkxlbmd0aCxcclxuICAgIG1heEhlaWdodDogV0tGLkxlbmd0aCxcclxuICAgIHJlc29sdXRpb246IFdLRi5SZXNvbHV0aW9uLFxyXG4gICAgbWluUmVzb2x1dGlvbjogV0tGLlJlc29sdXRpb24sXHJcbiAgICBtYXhSZXNvbHV0aW9uOiBXS0YuUmVzb2x1dGlvbixcclxuICAgIHdpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWluV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXhXaWR0aDogV0tGLkxlbmd0aCxcclxufTtcclxuXHJcbi8vIFNldCBvZiBtZWRpYSBmZWF0dXJlcyB0aGF0IGFsbG93IHJhbmdlIG9mIHZhbHVlc1xyXG5jb25zdCByYW5nZU1lZGlhRmVhdHVyZXMgPSBuZXcgU2V0PHN0cmluZz4oW1wiYXNwZWN0UmF0aW9cIiwgXCJjb2xvclwiLCBcImNvbG9ySW5kZXhcIiwgXCJoZWlnaHRcIiwgXCJtb25vY2hyb21lXCIsIFwicmVzb2x1dGlvblwiLCBcIndpZHRoXCJdKTtcclxuXHJcbi8vIE1hcCBvZiBtZWRpYSBmZWF0dXJlcyB0byBkZWZhdWx0IHZhbHVlc1xyXG5jb25zdCBtZWRpYUZlYXR1cmVEZWZhdWx0VmFsdWVzID0gbmV3IE1hcDxzdHJpbmcsYW55PihbXHJcbiAgICBbXCJjb2xvclwiLCAwXSxcclxuICAgIFtcImNvbG9ySW5kZXhcIiwgMF0sXHJcbiAgICBbXCJtb25vY2hyb21lXCIsIDBdXHJcbl0pO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIEBzdXBwb3J0cyBydWxlLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc3VwcG9ydHMgc3RhdGVtZW50IHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24gKi9cclxuZXhwb3J0IGNvbnN0IHN1cHBvcnRzMnMgPSAoc3RhdGVtZW50OiBTdXBwb3J0c1N0YXRlbWVudCk6IHN0cmluZyA9PlxyXG4gICAgdjJzKCBzdGF0ZW1lbnQsIHtcclxuICAgICAgICBhbnk6IHN1cHBvcnRzUXVlcnkycyxcclxuICAgICAgICBzZXA6IFwiIG9yIFwiXHJcbiAgICB9KTtcclxuXHJcbi8qKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc3VwcG9ydHMgcXVlcnkgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbiAqL1xyXG5jb25zdCBzdXBwb3J0c1F1ZXJ5MnMgPSAocXVlcnk6IFN1cHBvcnRzUXVlcnkpOiBzdHJpbmcgPT5cclxuICAgIHYycyggcXVlcnksIHtcclxuICAgICAgICBvYmo6ICh2OiBFeGNsdWRlPFN1cHBvcnRzUXVlcnksc3RyaW5nPikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoIHYpO1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGAoJHtwcm9wTmFtZXMubWFwKCAocHJvcE5hbWUpID0+XHJcbiAgICAgICAgICAgICAgICBgJHtjYW1lbFRvRGFzaChwcm9wTmFtZSl9OiR7c3AycyggcHJvcE5hbWUsIHF1ZXJ5W3Byb3BOYW1lXSl9YCkuam9pbiggXCIpIGFuZCAoXCIpfSlgO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gQ1NTIEBmb250LWZhY2UgcnVsZS5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgZmFjZSBvYmplY3QgdG8gdGhlIENTUyBzdHlsZSBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZm9udEZhY2UycyA9IChmb250ZmFjZTogRXh0ZW5kZWRGb250RmFjZSk6IHN0cmluZyA9PiBwcm9wU2V0MnMoIGZvbnRmYWNlLCBmb250RmFjZVByb3BlcnR5SW5mb3MpO1xyXG5cclxud2tmW1dLRi5Gb250U3R5bGVdID0gdiA9PiB2MnMoIHYsIHtcclxuICAgIG51bTogdiA9PiBgb2JsaXF1ZSAke3drZltXS0YuQW5nbGVdKHYpfWAsXHJcbiAgICBhcnI6IHYgPT4gYG9ibGlxdWUgJHthMnMoIHYsIFdLRi5BbmdsZSl9YFxyXG59KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIE1hcCBvZiBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgVjJTT3B0aW9ucyBvYmplY3RzIGRlc2NyaWJpbmcgY3VzdG9tIGFjdGlvbnMgbmVjZXNzYXJ5IHRvXHJcbiAqIGNvbnZlcnQgdGhlIHByb3BlcnR5IHZhbHVlIHRvIHRoZSBDU1MtY29tcGxpYW50IHN0cmluZy5cclxuICovXHJcbmNvbnN0IGZvbnRGYWNlUHJvcGVydHlJbmZvczogeyBbSyBpbiBrZXlvZiBJRm9udEZhY2VdPzogVjJTT3B0aW9ucyB9ID1cclxue1xyXG4gICAgYXNjZW50T3ZlcnJpZGU6IFdLRi5QZXJjZW50LFxyXG4gICAgZGVzY2VudE92ZXJyaWRlOiBXS0YuUGVyY2VudCxcclxuICAgIGZvbnRTdHJldGNoOiB7IGFueTogV0tGLlBlcmNlbnQgfSxcclxuICAgIGZvbnRTdHlsZTogV0tGLkZvbnRTdHlsZSxcclxuICAgIGZvbnRXZWlnaHQ6IHsgYW55OiBXS0YuTnVtYmVyIH0sXHJcbiAgICBsaW5lR2FwT3ZlcnJpZGU6IFdLRi5QZXJjZW50LFxyXG4gICAgc3JjOiB7XHJcbiAgICAgICAgYW55OiB7XHJcbiAgICAgICAgICAgIG9iajogW1xyXG4gICAgICAgICAgICAgICAgW1wibG9jYWxcIiwgdiA9PiBgbG9jYWwoJHt2fSlgXSxcclxuICAgICAgICAgICAgICAgIFtcInVybFwiLCB2ID0+IGB1cmwoJHt2fSlgXSxcclxuICAgICAgICAgICAgICAgIFtcImZvcm1hdFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW55OiB2ID0+IGBmb3JtYXQoXFxcIiR7dn1cXFwiKWAsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgfSxcclxuICAgIHNpemVBZGp1c3Q6IFdLRi5QZXJjZW50LFxyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBDU1MgQGNvdW50ZXItc3R5bGUgcnVsZS5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGNvdW50ZXIgc3R5bGVzZXQgcHJvcGVydHkgdG8gdGhlIENTUyBzdHlsZSBzdHJpbmcuIFByb3BlcnR5IG5hbWUgY2FuIGJlIGluXHJcbiAqIGVpdGhlciBkYXNoIG9yIGNhbWVsIGZvcm0uXHJcbiAqL1xyXG4gY29uc3QgY291bnRlclN0eWxlc2V0UHJvcDJzID0gKHByb3BOYW1lOiBzdHJpbmcsIHByb3BWYWw6IGFueSwgaW5jbHVkZU5hbWU/OiBib29sZWFuKTogc3RyaW5nID0+XHJcbiB7XHJcbiAgICAgaWYgKCFwcm9wTmFtZSlcclxuICAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgIC8vIGNvbnZlcnQgdGhlIHZhbHVlIHRvIHN0cmluZyBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gb2JqZWN0IGZvciB0aGUgcHJvcGVydHkgKGlmIGRlZmluZWQpXHJcbiAgICAgbGV0IHN0cmluZ1ZhbHVlID0gdjJzKCBwcm9wVmFsLCBjb3VudGVyU3R5bGVQcm9wZXJ0eUluZm9zW2Rhc2hUb0NhbWVsKHByb3BOYW1lKV0pO1xyXG5cclxuICAgICAvLyBpZiB0aGUgcmVzdWx0aW5nIHN0cmluZyBpcyBlbXB0eSBhbmQgdGhlIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkLCB0aGVuIHdlIHJldHVyblxyXG4gICAgIC8vIFwibmFtZTo7IG90aGVyd2lzZSB3ZSB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgaWYgKCFzdHJpbmdWYWx1ZSAmJiBpbmNsdWRlTmFtZSlcclxuICAgICAgICAgc3RyaW5nVmFsdWUgPSBcIlwiO1xyXG5cclxuICAgICByZXR1cm4gaW5jbHVkZU5hbWUgPyBgJHtjYW1lbFRvRGFzaCggcHJvcE5hbWUpfToke3N0cmluZ1ZhbHVlfWAgOiBzdHJpbmdWYWx1ZTtcclxuIH1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gY291bnRlciBzdHlsZXNldCBvYmplY3QgdG8gdGhlIENTUyBtZWRpYSBxdWVyeSBzdHJpbmdcclxuICovXHJcbiBleHBvcnQgY29uc3QgY291bnRlclN0eWxlc2V0MnMgPSAoY291bnRlclN0eWxlc2V0OiBFeHRlbmRlZENvdW50ZXJTdHlsZXNldCk6IHN0cmluZyA9PlxyXG4ge1xyXG4gICAgaWYgKCFjb3VudGVyU3R5bGVzZXQpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgbGV0IHMgPSBcIlwiO1xyXG5cdGZvciggbGV0IG5hbWUgaW4gY291bnRlclN0eWxlc2V0KVxyXG4gICAgICAgIHMgKz0gY291bnRlclN0eWxlc2V0UHJvcDJzKCBuYW1lLCBjb3VudGVyU3R5bGVzZXRbbmFtZV0sIHRydWUpICsgXCI7XCI7XHJcblxyXG4gICAgcmV0dXJuIHM7XHJcbiB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuIC8qKlxyXG4gKiBNYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gdGhlIFYyU09wdGlvbnMgb2JqZWN0cyBkZXNjcmliaW5nIGN1c3RvbSBhY3Rpb25zIG5lY2Vzc2FyeSB0b1xyXG4gKiBjb252ZXJ0IHRoZSBwcm9wZXJ0eSB2YWx1ZSB0byB0aGUgQ1NTLWNvbXBsaWFudCBzdHJpbmcuXHJcbiAqL1xyXG5jb25zdCBjb3VudGVyU3R5bGVQcm9wZXJ0eUluZm9zOiB7IFtLIGluIGtleW9mIElDb3VudGVyU3R5bGVzZXRdPzogVjJTT3B0aW9ucyB9ID1cclxue1xyXG4gICAgc3lzdGVtOiB7XHJcbiAgICAgICAgbnVtOiB2ID0+IFwiZml4ZWQgXCIgKyB2LFxyXG4gICAgICAgIGFycjogdiA9PiBcImV4dGVuZHMgXCIgKyB2MnModlswXSlcclxuICAgIH0sXHJcbiAgICBuZWdhdGl2ZToge1xyXG4gICAgICAgIGFueTogV0tGLlF1b3RlZFxyXG4gICAgfSxcclxuICAgIHByZWZpeDogV0tGLlF1b3RlZCxcclxuICAgIHN1ZmZpeDogV0tGLlF1b3RlZCxcclxuICAgIHJhbmdlOiB7XHJcbiAgICAgICAgYXJyMjogeyBzZXA6IFwiLFwiIH1cclxuICAgIH0sXHJcbiAgICBwYWQ6IHtcclxuICAgICAgICBpdGVtOiBXS0YuUXVvdGVkXHJcbiAgICB9LFxyXG4gICAgc3ltYm9sczoge1xyXG4gICAgICAgIGl0ZW06IFdLRi5RdW90ZWRcclxuICAgIH0sXHJcbiAgICBhZGRpdGl2ZVN5bWJvbHM6IHtcclxuICAgICAgICBhcnIyOiB7IGl0ZW06IHsgaXRlbTogV0tGLlF1b3RlZCB9LCBzZXA6IFwiLFwiIH0sXHJcbiAgICAgICAgYW55OiBXS0YuUXVvdGVkXHJcbiAgICB9LFxyXG59XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7RXh0ZW5kZWQsIElHZW5lcmljUHJveHksIE9uZU9yTWFueX0gZnJvbSBcIi4uL2FwaS9Db3JlVHlwZXNcIjtcclxuaW1wb3J0IHtcclxuICAgIElOdW1lcmljTWF0aCwgQ3NzTGVuZ3RoLCBDc3NBbmdsZSwgQ3NzVGltZSwgQ3NzUmVzb2x1dGlvbixcclxuICAgIENzc0ZyZXF1ZW5jeSwgQ3NzUG9zaXRpb24sIExlbmd0aFVuaXRzLCBQZXJjZW50VW5pdHMsIEFuZ2xlVW5pdHMsIFRpbWVVbml0cyxcclxuICAgIFJlc29sdXRpb25Vbml0cywgRnJlcXVlbmN5VW5pdHMsIENzc051bWJlciwgQ3NzUGVyY2VudCwgQ3NzUmFkaXVzLCBCb3JkZXJSYWRpdXNcclxufSBmcm9tIFwiLi4vYXBpL051bWVyaWNUeXBlc1wiO1xyXG5pbXBvcnQge2EycywgTnVtYmVyVG9TdHJpbmdGdW5jLCB0YWcycywgdjJzLCB3a2YsIFdLRn0gZnJvbSBcIi4vVXRpbHNcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIE51bWJlcnNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBzaW5nbGUgbnVtZXJpYyB2YWx1ZSB0byBhIENTUyBzdHJpbmcgb3B0aW9uYWxseSBhcHBlbmRpbmcgdW5pdHMgdGhhdCBjYW4gYmUgZGlmZmVyZW50XHJcbiAqIGZvciBpbnRlZ2VyIGFuZCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxyXG4gKiBAcGFyYW0gbiBOdW1iZXIgdG8gY29udmVydCB0byBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSBpbnRVbml0IFVuaXRzIHRvIGFwcGVuZCBpZiB0aGUgbnVtYmVyIGlzIGludGVnZXIuXHJcbiAqIEBwYXJhbSBmbG9hdFVuaXQgVW5pdHMgdG8gYXBwZW5kIGlmIHRoZSBudW1iZXIgaXMgZmxvYXRpbmcgcG9pbnQuXHJcbiAqL1xyXG5jb25zdCBudW1iZXJUb1N0cmluZyA9IChuOiBudW1iZXIsIGludFVuaXQ6IHN0cmluZyA9IFwiXCIsIGZsb2F0VWludDogc3RyaW5nID0gXCJcIik6IHN0cmluZyA9PlxyXG4gICAgbiArIChOdW1iZXIuaXNJbnRlZ2VyKG4pID8gIGludFVuaXQgOiBmbG9hdFVpbnQpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIE51bWVyaWNNYXRoIGNsYXNzIGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBudW1lcmljIENTUyB0eXBlcy4gV2hlbiBhcmd1bWVudHMgZm9yIHRoZXNlIGZ1bmN0aW9ucyBhcmUgb2YgdGhlIG51bWJlciBKYXZhU2NyaXB0IHR5cGUgdGhleVxyXG4gKiBhcmUgY29udmVydGVkIHRvIHN0cmluZ3MgYnkgY2FsbGluZyBhIGZ1bmN0aW9uIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTnVtZXJpY01hdGg8VCA9IGFueSwgVSBleHRlbmRzIHN0cmluZyA9IGFueT4gaW1wbGVtZW50cyBJTnVtZXJpY01hdGg8VCxVPlxyXG57XHJcbiAgICBwdWJsaWMgbjJzOiBOdW1iZXJUb1N0cmluZ0Z1bmM7XHJcblxyXG4gICAgY29uc3RydWN0b3IoIG4yczogTnVtYmVyVG9TdHJpbmdGdW5jKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMubjJzID0gbjJzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2MnMoIHZhbDogRXh0ZW5kZWQ8VD4pOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdjJzKCB2YWwsIHsgbnVtOiB0aGlzLm4ycyB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbXYycyggdmFsOiBPbmVPck1hbnk8VD4sIHNlcGFyYXRvcjogc3RyaW5nKTogc3RyaW5nXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHYycyggdmFsLCB7XHJcbiAgICAgICAgICAgIGFueTogdiA9PiB0aGlzLnYycyh2KSxcclxuICAgICAgICAgICAgc2VwOiBzZXBhcmF0b3JcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlcyBDc3NMZW5ndGggdmFsdWUgZnJvbSB0aGUgbnVtYmVyIGFuZCB0aGUgZ2l2ZW4gdW5pdC4gKi9cclxuICAgIHB1YmxpYyB1bml0cyggbjogbnVtYmVyLCB1bml0OiBVKTogSUdlbmVyaWNQcm94eTxVPlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBuICsgdW5pdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbWluKCAuLi5wYXJhbXM6IEV4dGVuZGVkPFQ+W10pOiBJR2VuZXJpY1Byb3h5PFU+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMubSggXCJtaW5cIiwgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbWF4KCAuLi5wYXJhbXM6IEV4dGVuZGVkPFQ+W10pOiBJR2VuZXJpY1Byb3h5PFU+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMubSggXCJtYXhcIiwgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xhbXAoIG1pbjogRXh0ZW5kZWQ8VD4sIHByZWY6IEV4dGVuZGVkPFQ+LCBtYXg6IEV4dGVuZGVkPFQ+KTogSUdlbmVyaWNQcm94eTxVPlxyXG4gICAge1xyXG4gICAgICAgIC8vIHJldHVybiAoKSA9PiBtYXRoRnVuYyggXCJjbGFtcFwiLCBbbWluLCBwcmVmLCBtYXhdLCB0aGlzLm4ycyk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMubSggXCJjbGFtcFwiLCBbbWluLCBwcmVmLCBtYXhdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2FsYyggZm9ybXVsYVBhcnRzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4ucGFyYW1zOiBFeHRlbmRlZDxUPltdKTogSUdlbmVyaWNQcm94eTxVPlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBgY2FsYygke3RhZzJzKCBmb3JtdWxhUGFydHMsIHBhcmFtcywgKHY6IEV4dGVuZGVkPFQ+KSA9PiB0aGlzLnYycyh2KSl9KWA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtKCBuYW1lOiBzdHJpbmcsIHBhcmFtczogRXh0ZW5kZWQ8VD5bXSk6IHN0cmluZ1xyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfSgke3RoaXMubXYycyggcGFyYW1zLCBcIixcIil9KWA7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBOdW1iZXJNYXRoIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGUgYDxudW1iZXI+YFxyXG4gKiBDU1MgdHlwZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBOdW1iZXJNYXRoID0gbmV3IE51bWVyaWNNYXRoPENzc051bWJlcixcIlwiPiggbiA9PiBuLnRvU3RyaW5nKCkpO1xyXG5cclxud2tmW1dLRi5OdW1iZXJdID0gdiA9PiBOdW1iZXJNYXRoLnYycyggdik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUGVyY2VudE1hdGggb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHBlcmNlbnRhZ2U+YCBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSBcIiVcIiB1bml0IHN1ZmZpeC4gSWYgdGhlIG51bWJlciBpcyBiZXR3ZWVuIC0xIGFuZCAxIChub25cclxuICogaW5jbHVzaXZlKSwgbXVsdGlwbGllcyB0aGUgbnVtYmVyIGJ5IDEwMC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQZXJjZW50TWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NQZXJjZW50LFBlcmNlbnRVbml0cz4oXHJcbiAgICBuID0+IChuID49IDEgfHwgbiA8PSAtMSA/IG4gOiBNYXRoLnJvdW5kKG4gKiAxMDApKSArIFwiJVwiKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbnVtYmVyIHRvIHN0cmluZyB1c2luZyB0aGUgZm9sbG93aW5nIHJ1bGVzOlxyXG4gKiAtIGlmIHRoZSBudW1iZXIgaXMgYmV0d2VlbiAtMSBhbmQgMSAobm9uIGluY2x1c2l2ZSksIG11bHRpcGxpZXMgdGhlIG51bWJlciBieSAxMDAgYW5kIGFwcGVuZHMgXCIlXCJcclxuICogLSBvdGhlcndpc2UsIGNvbnZlcnRzIHRoZSBudW1iZXIgdG8gc3RyaW5nIHdpdGhvdXQgYXBwZW5kaW5nIGFueSB1bml0cy5cclxuICovXHJcbmNvbnN0IHVuaXRsZXNzT3JQZXJjZW50VG9TdHJpbmcgPSAobjogbnVtYmVyKTogc3RyaW5nID0+IG4gPj0gMSB8fCBuIDw9IC0xID8gbi50b1N0cmluZygpIDogKE1hdGgucm91bmQobiAqIDEwMCkgKyBcIiVcIik7XHJcblxyXG53a2ZbV0tGLlBlcmNlbnRdID0gdiA9PiBQZXJjZW50TWF0aC52MnMoIHYpO1xyXG53a2ZbV0tGLlVuaXRsZXNzT3JQZXJjZW50XSA9IHVuaXRsZXNzT3JQZXJjZW50VG9TdHJpbmc7XHJcbndrZltXS0YuQWx3YXlzUGVyY2VudF0gPSB2ID0+IHYgKyBcIiVcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBMZW5ndGhNYXRoIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGUgYDxsZW5ndGg+YFxyXG4gKiBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSBsZW5ndGggdW5pdCBzdWZmaXguXHJcbiAqIEludGVnZXIgbnVtYmVycyB1c2UgXCJweFwiOyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHVzZSBcImVtXCIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTGVuZ3RoTWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NMZW5ndGgsTGVuZ3RoVW5pdHM+KCBuID0+IG51bWJlclRvU3RyaW5nKCBuLCBcInB4XCIsIFwiZW1cIikpO1xyXG5cclxud2tmW1dLRi5MZW5ndGhdID0gdiA9PiBMZW5ndGhNYXRoLnYycyggdik7XHJcbndrZltXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2VdID0gdiA9PiBMZW5ndGhNYXRoLm12MnMoIHYsIFwiIFwiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBBbmdsZU1hdGggb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZSBgPGFuZ2xlPmBcclxuICogQ1NTIHR5cGUgYnkgYXBwZW5kaW5nIGFuIGFuZ2xlIHVuaXQgc3VmZml4LlxyXG4gKiBJbnRlZ2VyIG51bWJlcnMgdXNlIFwiZGVnXCI7IGZsb2F0aW5nIHBvaW50IG51bWJlcnMgdXNlIFwidHVyblwiLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEFuZ2xlTWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NBbmdsZSxBbmdsZVVuaXRzPiggbiA9PiBudW1iZXJUb1N0cmluZyggbiwgXCJkZWdcIiwgXCJ0dXJuXCIpKTtcclxuXHJcbndrZltXS0YuQW5nbGVdID0gdiA9PiBBbmdsZU1hdGgudjJzKCB2KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBUaW1lTWF0aCBvYmplY3QgY29udGFpbnMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBDU1MgbWF0aGVtYXRpYyBmdW5jdGlvbnMgb24gdGhlIGA8dGltZT5gXHJcbiAqIENTUyB0eXBlIGJ5IGFwcGVuZGluZyBhIHRpbWUgdW5pdCBzdWZmaXguXHJcbiAqIEludGVnZXIgbnVtYmVycyB1c2UgXCJtc1wiOyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHVzZSBcInNcIi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBUaW1lTWF0aCA9IG5ldyBOdW1lcmljTWF0aDxDc3NUaW1lLFRpbWVVbml0cz4oIG4gPT4gbnVtYmVyVG9TdHJpbmcoIG4sIFwibXNcIiwgXCJzXCIpKTtcclxuXHJcbndrZltXS0YuVGltZV0gPSB2ID0+IFRpbWVNYXRoLnYycyggdik7XHJcbndrZltXS0YuTXVsdGlUaW1lV2l0aENvbW1hXSA9IHYgPT4gVGltZU1hdGgubXYycyggdiwgXCIsXCIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUmVzb2x1dGlvbk1hdGggb2JqZWN0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQ1NTIG1hdGhlbWF0aWMgZnVuY3Rpb25zIG9uIHRoZVxyXG4gKiBgPHJlc29sdXRpb24+YCBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSByZXNvbHV0aW9uIHVuaXQgc3VmZml4LlxyXG4gKiBJbnRlZ2VyIG51bWJlcnMgdXNlIFwiZHBpXCI7IGZsb2F0aW5nIHBvaW50IG51bWJlcnMgdXNlIFwieFwiLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFJlc29sdXRpb25NYXRoID0gbmV3IE51bWVyaWNNYXRoPENzc1Jlc29sdXRpb24sUmVzb2x1dGlvblVuaXRzPiggbiA9PiBudW1iZXJUb1N0cmluZyggbiwgXCJkcGlcIiwgXCJ4XCIpKTtcclxuXHJcbndrZltXS0YuUmVzb2x1dGlvbl0gPSB2ID0+IFJlc29sdXRpb25NYXRoLnYycyggdik7XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBGcmVxdWVuY3lNYXRoIG9iamVjdCBjb250YWlucyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IENTUyBtYXRoZW1hdGljIGZ1bmN0aW9ucyBvbiB0aGVcclxuICogYDxmcmVxdWVuY3k+YCBDU1MgdHlwZSBieSBhcHBlbmRpbmcgYSBmcmVxdWVuY3kgdW5pdCBzdWZmaXguXHJcbiAqIEludGVnZXIgbnVtYmVycyB1c2UgXCJIelwiOyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHVzZSBcImtIelwiLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEZyZXF1ZW5jeU1hdGggPSBuZXcgTnVtZXJpY01hdGg8Q3NzRnJlcXVlbmN5LCBGcmVxdWVuY3lVbml0cz4oIG4gPT4gbnVtYmVyVG9TdHJpbmcoIG4sIFwiSHpcIiwgXCJrSHpcIikpO1xyXG5cclxud2tmW1dLRi5GcmVxdWVuY3ldID0gdiA9PiBGcmVxdWVuY3lNYXRoLnYycyggdik7XHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFNpemUsIFBvaW50LCBQb3NpdGlvbiwgUmFkaXVzXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLy8gLy8gQ29udmVydHMgc2luZ2xlIHBvc2l0aW9uIHN0eWxlIHZhbHVlIHRvIHRoZSBDU1Mgc3RyaW5nLlxyXG4vLyBjb25zdCBwb3MycyA9ICh2YWw6IEV4dGVuZGVkPENzc1Bvc2l0aW9uPik6IHN0cmluZyA9PiB2MnMoIHZhbCwgeyBhbnk6IFdLRi5MZW5ndGggfSk7XHJcblxyXG53a2ZbV0tGLlBvc2l0aW9uXSA9ICh2YWw6IEV4dGVuZGVkPENzc1Bvc2l0aW9uPik6IHN0cmluZyA9PiB2MnMoIHZhbCwgeyBhbnk6IFdLRi5MZW5ndGggfSk7XHJcbndrZltXS0YuQXRQb3NpdGlvbl0gPSAodjogRXh0ZW5kZWQ8Q3NzUG9zaXRpb24+KSA9PiB2ID09IG51bGwgPyBcIlwiIDogXCJhdCBcIiArIHdrZltXS0YuUG9zaXRpb25dKHYpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIG11bHRpLXBvc2l0aW9uIHN0eWxlIHZhbHVlIHRvIHRoZSBDU1Mgc3RyaW5nLlxyXG4gKi9cclxuIHdrZltXS0YuTXVsdGlQb3NpdGlvbl0gPSAodmFsOiBPbmVPck1hbnk8Q3NzUG9zaXRpb24+KTogc3RyaW5nID0+XHJcbiAgICB2MnMoIHZhbCwge1xyXG4gICAgICAgIGFycjI6IHsgYW55OiBXS0YuUG9zaXRpb24sIHNlcDogXCIsXCIgfSxcclxuICAgICAgICBhbnk6IFdLRi5Qb3NpdGlvblxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcbi8vIENvbnZlcnRzIGNvcm5lciByYWRpdXMgc3R5bGUgdmFsdWUgdG8gdGhlIENTUyBzdHJpbmcuXHJcbndrZltXS0YuUmFkaXVzXSA9ICh2OiBFeHRlbmRlZDxDc3NSYWRpdXM+KSA9PiB2MnMoIHYsIHsgYW55OiBXS0YuTGVuZ3RoIH0pO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgYm9yZGVyIHJhZGl1cyBzdHlsZSB2YWx1ZSB0byB0aGUgQ1NTIHN0cmluZy5cclxuICovXHJcbiB3a2ZbV0tGLkJvcmRlclJhZGl1c10gPSAodmFsOiBFeHRlbmRlZDxCb3JkZXJSYWRpdXM+KTogc3RyaW5nID0+XHJcbiAgICB2MnMoIHZhbCwge1xyXG4gICAgICAgIGFycjI6IHsgYW55OiB7IGFueTogV0tGLkxlbmd0aCB9LCBzZXA6IFwiL1wiIH0sXHJcbiAgICAgICAgYW55OiBXS0YuTGVuZ3RoXHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7SVN0eWxlRGVmaW5pdGlvbn0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHtTY2hlZHVsZXJUeXBlLCBJU2NoZWR1bGVyfSBmcm9tIFwiLi4vYXBpL1NjaGVkdWxpbmdUeXBlc1wiO1xyXG5pbXBvcnQge1N0cmluZ1N0eWxlc2V0fSBmcm9tIFwiLi4vYXBpL1N0eWxlc2V0c1wiO1xyXG5pbXBvcnQge2FjdGl2YXRlU0QsIGRlYWN0aXZhdGVTRH0gZnJvbSBcIi4uL3J1bGVzL1J1bGVDb250YWluZXJcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJQWN0aXZhdG9yIGludGVyZmFjZSByZXByZXNlbnRzIGFuIG9iamVjdCByZXNwb25zaWJsZSBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgYWN0aXZhdGlvblxyXG4gKiBtZWNoYW5pc20uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTdHlsZUFjdGl2YXRvclxyXG57XHJcblx0LyoqXHJcblx0ICogSW5zdHJ1Y3RzIHRvIGFjdGl2YXRlIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuXHQgKiBhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICovXHJcblx0YWN0aXZhdGUoIGRlZmluaXRpb246IElTdHlsZURlZmluaXRpb24pOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gZGVhY3RpdmF0ZSB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlXHJcblx0ICogZGVhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICovXHJcblx0ZGVhY3RpdmF0ZSggZGVmaW5pdGlvbjogSVN0eWxlRGVmaW5pdGlvbik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RydWN0cyB0byBzZXQgdGhlIHZhbHVlIG9mIGVpdGhlciBhIHNpbmdsZSBwcm9wZXJ0eSBvciBhIHNldCBvZiBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlblxyXG4gICAgICogQ1NTIHN0eWxlIG9iamVjdC5cclxuXHQgKi9cclxuICAgIHVwZGF0ZVN0eWxlKCBydWxlT3JFbG06IENTU1N0eWxlUnVsZSB8IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgbmFtZTogc3RyaW5nIHwgbnVsbCxcclxuICAgICAgICB2YWx1ZT86IHN0cmluZyB8IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCwgaW1wb3J0YW50PzogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGZvciBhbGwgc3R5bGUgZGVmaW5pdGlvbnMgYWNjdW11bGF0ZWQgc2luY2UgdGhlIGxhc3RcclxuXHQgKiBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGZvcmNlRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdGZvcmNlRE9NVXBkYXRlKCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbmNlbHMgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gZm9yIGFsbCBzdHlsZSBkZWZpbml0aW9ucyBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdFxyXG5cdCAqIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgY2FuY2VsRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdGNhbmNlbERPTVVwZGF0ZSgpOiB2b2lkO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGVpdGhlciBhIHNpbmdsZSBwcm9wZXJ0eSBvciBhIHNldCBvZiBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlblxyXG4gKiBDU1Mgc3R5bGUgb2JqZWN0LlxyXG4gKi9cclxuY29uc3QgdXBkYXRlU3R5bGVQcm9wZXJ0eSA9IChydWxlT3JFbG06IENTU1N0eWxlUnVsZSB8IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgbmFtZTogc3RyaW5nIHwgbnVsbCxcclxuICAgIHZhbHVlPzogc3RyaW5nIHwgU3RyaW5nU3R5bGVzZXQgfCBudWxsLCBpbXBvcnRhbnQ/OiBib29sZWFuKTogdm9pZCA9PlxyXG57XHJcbiAgICBpZiAoIW5hbWUgJiYgdmFsdWUgPT0gbnVsbClcclxuICAgIHtcclxuICAgICAgICBpZiAocnVsZU9yRWxtIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlKVxyXG4gICAgICAgICAgICBydWxlT3JFbG0uY3NzVGV4dCA9IFwiXCI7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAocnVsZU9yRWxtIGFzIGFueSBhcyBFbGVtZW50KS5yZW1vdmVBdHRyaWJ1dGUoIFwic3R5bGVcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYW1lKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICBydWxlT3JFbG0uc3R5bGUucmVtb3ZlUHJvcGVydHkoIG5hbWUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcnVsZU9yRWxtLnN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSBhcyBzdHJpbmcsIGltcG9ydGFudCA/IFwiaW1wb3J0YW50XCIgOiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAge1xyXG4gICAgICAgIGxldCBzdHlsZXNldCA9IHZhbHVlIGFzIFN0cmluZ1N0eWxlc2V0O1xyXG4gICAgICAgIGZvciggbGV0IHByb3BOYW1lIGluIHN0eWxlc2V0KVxyXG4gICAgICAgICAgICBydWxlT3JFbG0uc3R5bGVbcHJvcE5hbWVdID0gc3R5bGVzZXRbcHJvcE5hbWVdO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgU3luY2hyb25vdXNBY3RpdmF0b3IgY2xhc3MgcmVwcmVzZW50cyB0aGUgc3luY2hyb25vdXMgYWN0aXZhdGlvbiBtZWNoYW5pc20sIHdoaWNoIHdyaXRlc1xyXG4gKiBzdHlsZSBjaGFuZ2VzIHRvIHRoZSBET00gd2hlbiB0aGUgYWN0aXZhdGUgYW5kIGRlYWN0aXZhdGUgZnVuY3Rpb25zIGFyZSBjYWxsZWQuXHJcbiAqL1xyXG5jbGFzcyBTeW5jaHJvbm91c0FjdGl2YXRvciBpbXBsZW1lbnRzIElTdHlsZUFjdGl2YXRvclxyXG57XHJcblx0LyoqXHJcblx0ICogSW5zdHJ1Y3RzIHRvIGFjdGl2YXRlIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuXHQgKiBhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICogQHBhcmFtIGRlZmluaXRpb25cclxuXHQgKi9cclxuXHRwdWJsaWMgYWN0aXZhdGUoIGRlZmluaXRpb246IElTdHlsZURlZmluaXRpb24pOiB2b2lkXHJcblx0e1xyXG5cdFx0YWN0aXZhdGVTRCggZGVmaW5pdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gZGVhY3RpdmF0ZSB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlXHJcblx0ICogZGVhY3RpdmF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHRoaXMgYWN0aXZhdGlvbiBtZWNoYW5pc20uXHJcblx0ICogQHBhcmFtIGRlZmluaXRpb25cclxuXHQgKi9cclxuXHRwdWJsaWMgZGVhY3RpdmF0ZSggZGVmaW5pdGlvbjogSVN0eWxlRGVmaW5pdGlvbik6IHZvaWRcclxuXHR7XHJcblx0XHRkZWFjdGl2YXRlU0QoIGRlZmluaXRpb24pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5zdHJ1Y3RzIHRvIHNldCB0aGUgdmFsdWUgb2YgZWl0aGVyIGEgc2luZ2xlIHByb3BlcnR5IG9yIGEgc2V0IG9mIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuXHJcbiAgICAgKiBDU1Mgc3R5bGUgb2JqZWN0LlxyXG5cdCAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVN0eWxlKCBydWxlT3JFbG06IENTU1N0eWxlUnVsZSB8IEVsZW1lbnRDU1NJbmxpbmVTdHlsZSwgbmFtZTogc3RyaW5nIHwgbnVsbCxcclxuICAgICAgICB2YWx1ZT86IHN0cmluZyB8IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCwgaW1wb3J0YW50PzogYm9vbGVhbik6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgdXBkYXRlU3R5bGVQcm9wZXJ0eSggcnVsZU9yRWxtLCBuYW1lLCB2YWx1ZSwgaW1wb3J0YW50KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGZvciBhbGwgc3R5bGUgZGVmaW5pdGlvbnMgYWNjdW11bGF0ZWQgc2luY2UgdGhlIGxhc3RcclxuXHQgKiBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGZvcmNlRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBmb3JjZURPTVVwZGF0ZSgpOiB2b2lkIHt9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbmNlbHMgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gZm9yIGFsbCBzdHlsZSBkZWZpbml0aW9ucyBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdFxyXG5cdCAqIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgY2FuY2VsRE9NVXBkYXRlIGZ1bmN0aW9uIGlzIGNhbGxlZFxyXG5cdCAqIGZvciB0aGlzIGFjdGl2YXRpb24gbWVjaGFuaXNtLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjYW5jZWxET01VcGRhdGUoKTogdm9pZCB7fVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgU2NoZWR1bGluZ0FjdGl2YXRvciBjbGFzcyBrZWVwcyBhIG1hcCBvZiBTdHlsZURlZmluaXRpb24gaW5zdGFuY2VzIHRoYXQgYXJlIHNjaGVkdWxlZCBmb3JcclxuICogYWN0aXZhdGlvbiBvciBkZWFjdGl2YXRpb24uIEVhY2ggaW5zdGFuY2UgaXMgbWFwcGVkIHRvIGEgcmVmZXJuY2UgY291bnQsIHdoaWNoIGlzIGluY3JlbWVudGVkXHJcbiAqIHVwb24gdGhlIGFjdGl2YXRlIGNhbGxzIGFuZCBkZWNyZW1lbnRlZCB1cG9uIHRoZSBkZWFjdGl2YXRlIGNhbGxzLiBXaGVuIHRoZSBkb0FjdGl2YXRpb25cclxuICogbWV0aG9kIGlzIGNhbGxlZCBUaGUgc3R5bGUgZGVmaW5pdGlvbiB3aWxsIGJlIGVpdGhlciBhY3RpdmF0ZWQgb3IgZGVhY3RpdmF0ZWQgYmFzZWQgb24gd2hldGhlclxyXG4gKiB0aGUgcmVmZXJlbmNlIGNvdW50IGlzIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxyXG4gKi9cclxuY2xhc3MgU2NoZWR1bGluZ0FjdGl2YXRvciBpbXBsZW1lbnRzIElTdHlsZUFjdGl2YXRvclxyXG57XHJcbiAgICAvLyBBcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBydW5zLlxyXG4gICAgcHJpdmF0ZSBhY3Rpb25zOiAoKCk9PnZvaWQpW10gPSBbXTtcclxuXHJcbiAgICAvLyBvcHRpb25hbCBzY2hlZHVsZXIgb2JqZWN0XHJcbiAgICBwcml2YXRlIHNjaGVkdWxlcj86IElTY2hlZHVsZXI7XHJcblxyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvciggc2NoZWR1bGVyPzogSVNjaGVkdWxlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoc2NoZWR1bGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2NoZWR1bGVyLmluaXQoICgpID0+IHRoaXMuZG9ET01VcGRhdGUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gYWN0aXZhdGUgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2UuXHJcblx0ICovXHJcblx0cHVibGljIGFjdGl2YXRlKCBkZWZpbml0aW9uOiBJU3R5bGVEZWZpbml0aW9uKTogdm9pZFxyXG5cdHtcclxuICAgICAgICBpZiAodGhpcy5pc1NjaGVkdWxpbmdOZWVkZWQpXHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyIS5zY2hlZHVsZURPTVVwZGF0ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaCggKCkgPT4gYWN0aXZhdGVTRCggZGVmaW5pdGlvbikpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gZGVhY3RpdmF0ZSB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS5cclxuXHQgKi9cclxuXHRwdWJsaWMgZGVhY3RpdmF0ZSggZGVmaW5pdGlvbjogSVN0eWxlRGVmaW5pdGlvbik6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTY2hlZHVsaW5nTmVlZGVkKVxyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlciEuc2NoZWR1bGVET01VcGRhdGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnB1c2goICgpID0+IGRlYWN0aXZhdGVTRCggZGVmaW5pdGlvbikpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdG8gc2V0IHRoZSB2YWx1ZSBvZiBlaXRoZXIgYSBzaW5nbGUgcHJvcGVydHkgb3IgYSBzZXQgb2YgcHJvcGVydGllcyBpbiB0aGUgZ2l2ZW5cclxuICAgICAqIENTUyBzdHlsZSBvYmplY3QuXHJcblx0ICovXHJcbiAgICBwdWJsaWMgdXBkYXRlU3R5bGUoIHJ1bGVPckVsbTogQ1NTU3R5bGVSdWxlIHwgRWxlbWVudENTU0lubGluZVN0eWxlLCBuYW1lOiBzdHJpbmcgfCBudWxsLFxyXG4gICAgICAgIHZhbHVlPzogc3RyaW5nIHwgU3RyaW5nU3R5bGVzZXQgfCBudWxsLCBpbXBvcnRhbnQ/OiBib29sZWFuKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICh0aGlzLmlzU2NoZWR1bGluZ05lZWRlZClcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIhLnNjaGVkdWxlRE9NVXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5hY3Rpb25zLnB1c2goICgpID0+IHVwZGF0ZVN0eWxlUHJvcGVydHkoIHJ1bGVPckVsbSwgbmFtZSwgdmFsdWUsIGltcG9ydGFudCkpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBmb3IgYWxsIHN0eWxlIGRlZmluaXRpb25zIGluIG91ciBpbnRlcm5hbCBtYXAuXHJcblx0ICovXHJcblx0cHVibGljIGZvcmNlRE9NVXBkYXRlKCk6IHZvaWRcclxuXHR7XHJcblx0XHRpZiAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IDApXHJcblx0XHR7XHJcbiAgICAgICAgICAgIHRoaXMuZG9ET01VcGRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIgJiYgdGhpcy5zY2hlZHVsZXIuY2FuY2VsRE9NVXBkYXRlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbmNlbHMgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gZm9yIGFsbCBzdHlsZSBkZWZpbml0aW9ucyBhY2N1bXVsYXRlZCBzaW5jZSB0aGUgbGFzdFxyXG5cdCAqIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjYW5jZWxET01VcGRhdGUoKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gMClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5hY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVyICYmIHRoaXMuc2NoZWR1bGVyLmNhbmNlbERPTVVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHRwcml2YXRlIGdldCBpc1NjaGVkdWxpbmdOZWVkZWQoKTogYm9vbGVhblxyXG4gICAge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5zY2hlZHVsZXIgJiYgIXRoaXMuYWN0aW9ucy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuXHQgKiBQZXJmb3JtcyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBhbmQgcHJvcGVydHkgc2V0IG9wZXJhdGlvbnMgYWNjdW11bGF0ZWQgaW50ZXJuYWxseS4gVGhpc1xyXG4gICAgICogbWV0aG9kIHNob3VsZCBiZSB1c2VkIGJ5IHRoZSBkZXJpdmVkIGNsYXNzZXMgd2hlbiBzY2hlZHVsZWQgYWN0aXZhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZC5cclxuXHQgKi9cclxuXHRwcml2YXRlIGRvRE9NVXBkYXRlKCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgLy8gdXBkYXRlIHN0eWxlIHByb3BlcnRpZXNcclxuICAgICAgICBmb3IoIGxldCBhY3Rpb24gb2YgdGhpcy5hY3Rpb25zKVxyXG4gICAgXHRcdGFjdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuYWN0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgaW1wbGVtZW50cyBzY2hlZHVsaW5nIHVzaW5nIGFuaW1hdGlvbiBmcmFtZXMuXHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb25GcmFtZVNjaGVkdWxlciBpbXBsZW1lbnRzIElTY2hlZHVsZXJcclxue1xyXG4gICAgLy8gSGFuZGxlIHJldHVybmVkIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbi5cclxuXHRwcml2YXRlIGggPSAwO1xyXG5cclxuICAgIC8vIENhbGxiYWNrIHRvIGNhbGwgdG8gd3JpdGUgY2hhbmdlcyB0byB0aGUgRE9NLlxyXG5cdHByaXZhdGUgY2I6ICgpID0+IHZvaWQ7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHNjaGVkdWxlciBvYmplY3QgYW5kIHByb3ZpZGVzIHRoZSBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlXHJcbiAgICAgKiBzY2hlZHVsZXIgZGVjaWRlcyB0byBtYWtlIGNoYW5nZXMgdG8gdGhlIERPTS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluaXQoIGRvRE9NVXBkYXRlOiAoKSA9PiB2b2lkKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuY2IgPSBkb0RPTVVwZGF0ZTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcblx0ICogSXMgaW52b2tlZCB3aGVuIHRoZSBzY2hlZHVsZXIgbmVlZHMgdG8gc2NoZWR1bGUgaXRzIGNhbGxiYWNrIG9yIGV2ZW50LlxyXG5cdCAqL1xyXG4gICAgcHVibGljIHNjaGVkdWxlRE9NVXBkYXRlKCk6IHZvaWRcclxuICAgIHtcclxuXHRcdHRoaXMuaCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGhpcy5vbkZyYW1lKVxyXG4gICAgfVxyXG5cclxuXHQvKipcclxuXHQgKiBJcyBpbnZva2VkIHdoZW4gdGhlIHNjaGVkdWxlciBuZWVkcyB0byBjYW5jZWxzIGl0cyBzY2hlZHVsZWQgY2FsbGJhY2sgb3IgZXZlbnQuXHJcblx0ICovXHJcbiAgICBwdWJsaWMgY2FuY2VsRE9NVXBkYXRlKCk6IHZvaWRcclxuICAgIHtcclxuXHRcdGlmICh0aGlzLmggPiAwKVxyXG5cdFx0e1xyXG5cdFx0XHRjYW5jZWxBbmltYXRpb25GcmFtZSggdGhpcy5oKTtcclxuXHRcdFx0dGhpcy5oID0gMDtcclxuXHRcdH1cclxuICAgIH1cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIElzIGludm9rZWQgd2hlbiBhbmltYXRpb24gZnJhbWUgc2hvdWxkIGJlIGV4ZWN1dGVkLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgb25GcmFtZSA9ICgpOiB2b2lkID0+XHJcblx0e1xyXG5cdFx0dGhpcy5oID0gMDtcclxuXHRcdHRoaXMuY2IoKTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFNjaGVkdWxlcyB0aGUgdXBkYXRlIG9mIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gQ1NTIHByb3BlcnR5IGluIHRoZSBnaXZlbiBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNjaGVkdWxlU3R5bGVVcGRhdGUgPSAocnVsZU9yRWxtOiBDU1NTdHlsZVJ1bGUgfCBFbGVtZW50Q1NTSW5saW5lU3R5bGUsXHJcbiAgICBuYW1lOiBzdHJpbmcgfCBudWxsLCB2YWx1ZT86IHN0cmluZyB8IFN0cmluZ1N0eWxlc2V0IHwgbnVsbCxcclxuICAgIGltcG9ydGFudD86IGJvb2xlYW4sIHNjaGVkdWxlclR5cGU/OiBudW1iZXIpXHJcbiAgICA6IHZvaWQgPT4gZ2V0QWN0aXZhdG9yKHNjaGVkdWxlclR5cGUpLnVwZGF0ZVN0eWxlKCBydWxlT3JFbG0sIG5hbWUsIHZhbHVlLCBpbXBvcnRhbnQpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYWN0aXZhdG9yIGZvciB0aGUgZ2l2ZW4gc2NoZWR1bGVyIHR5cGUuIElmIHNjaGVkdWxlciB0eXBlIGlzIG5vdCBzcGVjaWZpZWQgcmV0dXJuc1xyXG4gKiB0aGUgYWN0aXZhdG9yIGN1cnJlbnRseSBzZXQgYXMgZGVmYXVsdC4gSWYsIGZvciBzb21lIHJlYXNvbiwgdGhlIGRlZmF1bHQgYWN0aXZhdG9yIGlzIG5vdCBzZXQsXHJcbiAqIHJldHVybnMgdGhlIHN5bmNocm9ub3VzIGFjdGl2YXRvci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRBY3RpdmF0b3IgPSAoc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IElTdHlsZUFjdGl2YXRvciA9PlxyXG5cdChzY2hlZHVsZXJUeXBlID09IG51bGwgPyBzX2RlZmF1bHRBY3RpdmF0b3IgOiBzX3JlZ2lzdGVyZWRBY3RpdmF0b3JzLmdldCggc2NoZWR1bGVyVHlwZSkpID8/IHNfc3luY2hyb25vdXNBY3RpdmF0b3I7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlZmF1bHQgc2NoZWR1bGVyIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdFNjaGVkdWxlciA9ICgpOiBudW1iZXIgPT4gc19kZWZhdWx0U2NoZWR1bGVyVHlwZTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGRlZmF1bHQgc2NoZWR1bGluZyB0eXBlIHRoYXQgaXMgdXNlZCBieSBhY3RpdmF0ZSBhbmQgZGVhY3RpdmF0ZSBmdW5jdGlvbnMgdGhhdCBhcmVcclxuICogY2FsbGVkIHdpdGhvdXQgZXhwbGljaXRseSBwcm92aWRpbmcgdmFsdWUgdG8gdGhlIHNjaGVkdWxpbmcgcGFyYW1ldGVyLiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZVxyXG4gKiBwcmV2aW91cyBkZWZhdWx0IGFjdGl2YXRvciBvciAwIGlmIGFuIGVycm9yIG9jY3VycyAoZS5nLiB0aGUgZ2l2ZW4gc2NoZWR1bGVyIHR5cGUgSUQgaXMgbm90XHJcbiAqIHJlZ2lzdGVyZWQpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldERlZmF1bHRTY2hlZHVsZXIgPSAoc2NoZWR1bGVyVHlwZTogbnVtYmVyKTogbnVtYmVyID0+XHJcbntcclxuICAgIC8vIGNoZWNrIHRoYXQgdGhlIGdpdmVuIG51bWJlciBpcyBpbiBvdXIgbWFwIG9mIHJlZ2lzdGVyZWQgYWN0aXZhdG9yc1xyXG4gICAgbGV0IGFjdGl2YXRvciA9IHNfcmVnaXN0ZXJlZEFjdGl2YXRvcnMuZ2V0KCBzY2hlZHVsZXJUeXBlKTtcclxuXHRpZiAoIWFjdGl2YXRvcilcclxuXHRcdHJldHVybiAwO1xyXG5cclxuXHRsZXQgcHJldlNjaGVkdWxlclR5cGUgPSBzX2RlZmF1bHRTY2hlZHVsZXJUeXBlO1xyXG4gICAgc19kZWZhdWx0U2NoZWR1bGVyVHlwZSA9IHNjaGVkdWxlclR5cGU7XHJcbiAgICBzX2RlZmF1bHRBY3RpdmF0b3IgPSBhY3RpdmF0b3I7XHJcblx0cmV0dXJuIHByZXZTY2hlZHVsZXJUeXBlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHNjaGVkdWxlciBvYmplY3QgYW5kIHJldHVybnMgdGhlIHNjaGVkdWxlciB0eXBlIGlkZW50aWZpZXIsIHdoaWNoXHJcbiAqIHNob3VsZCBiZSB1c2VkIHdoZW4gY2FsbGluZyBhY3RpdmF0ZSBhbmQgZGVhY3RpdmF0ZSBmdW5jdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJTY2hlZHVsZXIgPSAoc2NoZWR1bGVyOiBJU2NoZWR1bGVyKTogbnVtYmVyID0+XHJcbntcclxuXHQvLyBnZXQgdGhlIHJlZ2lzdHJhdGlvbiBJRCBmb3IgdGhpcyBzY2hlZHVsZXJcclxuXHRsZXQgaWQgPSBzX25leHRDdXN0b21TY2hlZHVsZXJUeXBlKys7XHJcblx0c19yZWdpc3RlcmVkQWN0aXZhdG9ycy5zZXQoIGlkLCBuZXcgU2NoZWR1bGluZ0FjdGl2YXRvciggc2NoZWR1bGVyKSk7XHJcblx0cmV0dXJuIGlkO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBVbnJlZ2lzdGVycyBhIHNjaGVkdWxlciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gc2NoZWR1bGVyIHR5cGUgaWRlbnRpZmllci5cclxuICovXHJcbmV4cG9ydCBjb25zdCB1bnJlZ2lzdGVyU2NoZWR1bGVyID0gKGlkOiBudW1iZXIpOiB2b2lkID0+XHJcbntcclxuXHRpZiAoaWQgPj0gc19maXJzdEN1c3RvbVNjaGVkdWxlclR5cGUpXHJcblx0e1xyXG5cdFx0c19yZWdpc3RlcmVkQWN0aXZhdG9ycy5kZWxldGUoIGlkKTtcclxuXHJcblx0XHQvLyBpZiB0aGUgZGVsZXRlZCBzY2hlZHVsZXIgd2FzIG91ciBkZWZhdWx0IG9uZSwgd2Ugc2V0IHRoZSBkZWZhdWx0IHRvIFNZTkNcclxuICAgICAgICBpZiAoc19kZWZhdWx0U2NoZWR1bGVyVHlwZSA9PT0gaWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzX2RlZmF1bHRTY2hlZHVsZXJUeXBlID0gU2NoZWR1bGVyVHlwZS5TeW5jO1xyXG4gICAgICAgICAgICBzX2RlZmF1bHRBY3RpdmF0b3IgPSBzX3N5bmNocm9ub3VzQWN0aXZhdG9yO1xyXG4gICAgICAgIH1cclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEN1cnJlbnQgZGVmYXVsdCBzY2hlZHVsZXIuIFRoaXMgc2NoZWR1bGVyIHdpbGwgYmUgdXNlZCBpZiBzY2hlZHVsZXIgdHlwZSBpcyBub3QgZXhwbGljaXRseVxyXG4gKiBzcGVjaWZpZWQgaW4gY2FsbHMgc3VjaCBhcyBhY3RpdmF0ZSBvciBJU3R5bGVSdWxlLnNldFByb3AuXHJcbiAqL1xyXG5sZXQgc19kZWZhdWx0U2NoZWR1bGVyVHlwZTogbnVtYmVyID0gU2NoZWR1bGVyVHlwZS5TeW5jO1xyXG5cclxuLyoqXHJcbiAqIFN5bmNocm9ub3VzIGFjdGl2YXRvciBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IHNfc3luY2hyb25vdXNBY3RpdmF0b3IgPSBuZXcgU3luY2hyb25vdXNBY3RpdmF0b3IoKTtcclxuXHJcbi8qKlxyXG4gKiBDdXJyZW50IGRlZmF1bHQgYWN0aXZhdG9yLiBUaGlzIGFjdGl2YXRvciB3aWxsIGJlIHVzZWQgaWYgc2NoZWR1bGVyIHR5cGUgaXMgbm90IGV4cGxpY2l0bHlcclxuICogc3BlY2lmaWVkIGluIGNhbGxzIHN1Y2ggYXMgYWN0aXZhdGUgb3IgSVN0eWxlUnVsZS5zZXRQcm9wLlxyXG4gKi9cclxubGV0IHNfZGVmYXVsdEFjdGl2YXRvcjogSVN0eWxlQWN0aXZhdG9yID0gc19zeW5jaHJvbm91c0FjdGl2YXRvcjtcclxuXHJcbi8qKlxyXG4gKiBTY2hlZHVsZXIgdHlwZSBpZGVudGlmaWVyIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBmaXJzdCBjdXN0b20gc2NoZWR1bGVyIHRvIGJlIHJlZ2lzdGVyZWQuXHJcbiAqIEFsbCBjdXN0b20gc2NoZWR1bGVyIGlkZW50aWZpZXJzIGFyZSBncmVhdGVyIG9yIGVxdWFsIHRvIHRoaXMgbnVtYmVyLlxyXG4gKi9cclxuY29uc3Qgc19maXJzdEN1c3RvbVNjaGVkdWxlclR5cGU6IG51bWJlciA9IDEwMDE7XHJcblxyXG4vKipcclxuICogU2NoZWR1bGVyIHR5cGUgaWRlbnRpZmllciB0byBiZSBhc3NpZ25lZCB0byB0aGUgbmV4dCBjdXN0b20gc2NoZWR1bGVyIHRvIGJlIHJlZ2lzdGVyZWQuXHJcbiAqL1xyXG5sZXQgc19uZXh0Q3VzdG9tU2NoZWR1bGVyVHlwZTogbnVtYmVyID0gc19maXJzdEN1c3RvbVNjaGVkdWxlclR5cGU7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgcmVnaXN0ZXJlZCBidWlsdC1pbiBhbmQgY3VzdG9tIGFjdGl2YXRvcnMuXHJcbiAqL1xyXG5jb25zdCBzX3JlZ2lzdGVyZWRBY3RpdmF0b3JzID0gbmV3IE1hcDxudW1iZXIsSVN0eWxlQWN0aXZhdG9yPigpO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGJ1aWx0LWluIGFuZCBjdXN0b20gYWN0aXZhdG9ycy5cclxuICovXHJcbnNfcmVnaXN0ZXJlZEFjdGl2YXRvcnMuc2V0KCBTY2hlZHVsZXJUeXBlLlN5bmMsIHNfc3luY2hyb25vdXNBY3RpdmF0b3IpO1xyXG5zX3JlZ2lzdGVyZWRBY3RpdmF0b3JzLnNldCggU2NoZWR1bGVyVHlwZS5BbmltYXRpb25GcmFtZSwgbmV3IFNjaGVkdWxpbmdBY3RpdmF0b3IoIG5ldyBBbmltYXRpb25GcmFtZVNjaGVkdWxlcigpKSk7XHJcbnNfcmVnaXN0ZXJlZEFjdGl2YXRvcnMuc2V0KCBTY2hlZHVsZXJUeXBlLk1hbnVhbCwgbmV3IFNjaGVkdWxpbmdBY3RpdmF0b3IoKSk7XHJcblxyXG5cclxuXHJcbiIsIu+7v2ltcG9ydCB7RXh0ZW5kZWR9IGZyb20gXCIuLi9hcGkvQ29yZVR5cGVzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBCb3JkZXJJbWFnZV9PYmplY3QsIEJvcmRlcl9TdHlsZVR5cGUsIEdyaWRUZW1wbGF0ZUFyZWFzX1N0eWxlVHlwZSxcclxuICAgIEdyaWRUZW1wbGF0ZUFyZWFEZWZpbml0aW9uLCBHcmlkVHJhY2ssIEdyaWRUZW1wbGF0ZUF4aXNfU3R5bGVUeXBlLCBNYXJrZXJfU3R5bGVUeXBlLFxyXG4gICAgQm94U2hhZG93X1N0eWxlVHlwZSwgQm94U2hhZG93X1NpbmdsZSxcclxufSBmcm9tIFwiLi4vYXBpL1N0eWxlVHlwZXNcIjtcclxuaW1wb3J0IHsgQ3VzdG9tVmFyX1N0eWxlVHlwZSwgSVN0eWxlc2V0LCBTdHJpbmdTdHlsZXNldCwgU3R5bGVzZXQsIFZhclRlbXBsYXRlTmFtZSB9IGZyb20gXCIuLi9hcGkvU3R5bGVzZXRzXCI7XHJcbmltcG9ydCB7SUlEUnVsZX0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHt2MnMsIFYyU09wdGlvbnMsIG8ycywgV0tGLCBhMnMsIHdrZiwgY2FtZWxUb0Rhc2gsIGRhc2hUb0NhbWVsLCBBbnlUb1N0cmluZ0Z1bmN9IGZyb20gXCIuL1V0aWxzXCI7XHJcbmltcG9ydCB7Z2V0VmFyc0Zyb21TRH0gZnJvbSBcIi4uL3J1bGVzL1J1bGVDb250YWluZXJcIjtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEZ1bmN0aW9ucyBmb3IgY29udmVydGluZyBDU1MgcHJvcGVydHkgdHlwZXMgdG8gc3RyaW5ncy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5jb25zdCBib3JkZXJJbWFnZVRvU3RyaW5nID0gKHZhbDogQm9yZGVySW1hZ2VfT2JqZWN0KTogc3RyaW5nID0+XHJcbntcclxuICAgIC8vIGlmIHdpZHRoIGlzIHNwZWNpZmllZCwgYnV0IHNsaWNlIGlzIG5vdCwgd2UgbmVlZCB0byBzZXQgc2xpY2UgdG8gdGhlIGRlZmF1bHQgMTAwJSB2YWx1ZTtcclxuICAgIC8vIGlmIG91dHNldCBpcyBzcGVjaWZpZWQgYnV0IHdpZHRoIGlzIG5vdC4gd2UgbmVlZCB0byBzZXQgd2lkdGggdG8gdGhlIGRlZmF1bHQgMSB2YWx1ZTtcclxuICAgIGxldCB2YWxDb3B5OiBCb3JkZXJJbWFnZV9PYmplY3QgPSBPYmplY3QuYXNzaWduKCB7fSwgdmFsKTtcclxuICAgIGlmICh2YWwuc2xpY2UgPT0gbnVsbCAmJiAodmFsLndpZHRoICE9IG51bGwgfHwgdmFsLm91dHNldCAhPSBudWxsKSlcclxuICAgICAgICB2YWxDb3B5LnNsaWNlID0gXCIxMDAlXCI7XHJcbiAgICBpZiAodmFsLndpZHRoID09IG51bGwgJiYgdmFsLm91dHNldCAhPSBudWxsKVxyXG4gICAgICAgIHZhbENvcHkud2lkdGggPSAxO1xyXG5cclxuICAgIHJldHVybiBvMnMoIHZhbENvcHksIFtcclxuICAgICAgICBcInNvdXJjZVwiLFxyXG4gICAgICAgIFwic2xpY2VcIixcclxuICAgICAgICBbXCJ3aWR0aFwiLCB1bmRlZmluZWQsIFwiL1wiXSxcclxuICAgICAgICBbXCJvdXRzZXRcIiwgdW5kZWZpbmVkLCBcIi9cIl0sXHJcbiAgICAgICAgXCJyZXBlYXRcIixcclxuICAgICAgICBcIm1vZGVcIlxyXG4gICAgXSk7XHJcbn1cclxuXHJcblxyXG5cclxud2tmW1dLRi5Cb3hTaGFkb3dTaW5nbGVdID0gKHZhbDogQm94U2hhZG93X1NpbmdsZSkgPT4gdjJzKCB2YWwsIHtcclxuICAgIG9iajpbXHJcbiAgICAgICAgW1wiaW5zZXRcIiwgKHY6IGJvb2xlYW4pID0+IHYgPyBcImluc2V0XCIgOiBcIlwiXSxcclxuICAgICAgICBbXCJ4XCIsIFdLRi5MZW5ndGhdLFxyXG4gICAgICAgIFtcInlcIiwgV0tGLkxlbmd0aF0sXHJcbiAgICAgICAgW1wiYmx1clwiLCBXS0YuTGVuZ3RoXSxcclxuICAgICAgICBbXCJzcHJlYWRcIiwgV0tGLkxlbmd0aF0sXHJcbiAgICAgICAgW1wiY29sb3JcIiwgV0tGLkNvbG9yXVxyXG4gICAgXVxyXG59KTtcclxuXHJcbndrZltXS0YuQm94U2hhZG93XSA9ICh2YWw6IEJveFNoYWRvd19TdHlsZVR5cGUpID0+IHYycyggdmFsLCB7XHJcbiAgICBvYmo6IFdLRi5Cb3hTaGFkb3dTaW5nbGUsXHJcbiAgICBpdGVtOiBXS0YuQm94U2hhZG93U2luZ2xlLFxyXG4gICAgc2VwOiBcIixcIlxyXG59KTtcclxuXHJcblxyXG5cclxud2tmW1dLRi5Cb3JkZXJdID0gKHZhbDogRXh0ZW5kZWQ8Qm9yZGVyX1N0eWxlVHlwZT4pOiBzdHJpbmcgPT4gdjJzKCB2YWwsIHtcclxuICAgIG51bTogV0tGLkxlbmd0aCxcclxuICAgIGFycjogYXJyID0+IHtcclxuICAgICAgICBsZXQgbnVtYmVyc1Byb2Nlc3NlZCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGEycyggYXJyLCBpdGVtID0+IHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiXHJcbiAgICAgICAgICAgID8gdjJzKCBpdGVtLCBudW1iZXJzUHJvY2Vzc2VkKysgPyBXS0YuQ29sb3IgOiBXS0YuTGVuZ3RoKVxyXG4gICAgICAgICAgICA6IHYycyhpdGVtKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IGdyaWRUZW1wbGF0ZUFyZWFzVG9TdHJpbmcgPSAodmFsOiBFeHRlbmRlZDxHcmlkVGVtcGxhdGVBcmVhc19TdHlsZVR5cGU+KTogc3RyaW5nID0+XHJcbiAgICAvLyB2YWwgY2FuIGJlIGFycmF5IG9mIHN0cmluZ3Mgb3IgR3JpZFRlbXBsYXRlQXJlYV9EZWZpbml0aW9uIHRvdXBsZXNcclxuICAgIHYycyggdmFsLCB7XHJcbiAgICAgICAgYXJyOiB2ID0+IHR5cGVvZiB2WzBdID09PSBcInN0cmluZ1wiID8gYTJzKCB2LCBXS0YuUXVvdGVkKSA6IGNyZWF0ZUdyaWRUZW1wbGF0ZUFyZWFzRnJvbURlZmluaXRpb25zKHYpXHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBhcnJheSBvZiBHcmlkVGVtcGxhdGVBcmVhX0RlZmluaXRpb24gb2JqZWN0cyB0byBhIHN0cmluZyB0aGF0IGlzIHN1aXRhYmxlIGZvclxyXG4gKiB0aGUgZ3JpZC10ZW1wbGF0ZS1hcmVhcyBmb3JtYXQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVHcmlkVGVtcGxhdGVBcmVhc0Zyb21EZWZpbml0aW9ucyA9IChkZWZzOiBHcmlkVGVtcGxhdGVBcmVhRGVmaW5pdGlvbltdKTogc3RyaW5nID0+XHJcbntcclxuICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBzaXplIG9mIHRoZSBtYXRyaXggZnJvbSB0aGUgYXJlYXMnIHNpemVzXHJcbiAgICBsZXQgcm93Q291bnQgPSAwLCBjb2xDb3VudCA9IDA7XHJcbiAgICBmb3IoIGxldCBkZWYgb2YgZGVmcylcclxuICAgIHtcclxuICAgICAgICByb3dDb3VudCA9IE1hdGgubWF4KCByb3dDb3VudCwgZGVmWzNdKTtcclxuICAgICAgICBjb2xDb3VudCA9IE1hdGgubWF4KCBjb2xDb3VudCwgZGVmWzRdKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocm93Q291bnQgPT09IDAgfHwgY29sQ291bnQgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgLy8gY3JlYXRlIGFycmF5IG9mIHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBjZWxsc1xyXG4gICAgbGV0IG1hdHJpeCA9IG5ldyBBcnJheTxzdHJpbmdbXT4ocm93Q291bnQpO1xyXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKVxyXG4gICAgICAgIG1hdHJpeFtpXSA9IG5ldyBBcnJheTxzdHJpbmc+KGNvbENvdW50KTtcclxuXHJcbiAgICAvLyBnbyBvdmVyIGRlZmluaXRpb25zIGFuZCBmaWxsIHRoZSBhcHByb3ByaWF0ZSBwbGFjZXMgaW4gdGhlIGNlbGxzIHdpdGggYXJlYSBuYW1lc1xyXG4gICAgZm9yKCBsZXQgZGVmIG9mIGRlZnMpXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSB2MnMoIGRlZlswXSk7XHJcbiAgICAgICAgZm9yKCBsZXQgaSA9IGRlZlsxXTsgaSA8PSBkZWZbM107IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciggbGV0IGogPSBkZWZbMl07IGogPD0gZGVmWzRdOyBqKyspXHJcbiAgICAgICAgICAgICAgICBtYXRyaXhbaS0xXVtqLTFdID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ28gb3ZlciBvdXIgbWF0cml4IGFuZCBmb3IgZXZlcnkgcm93IGNyZWF0ZSBhIHF1b3RlZCBzdHJpbmcuIFNpbmNlIG91ciBjZWxsIGFycmF5cyBtYXkgYmVcclxuICAgIC8vIHNwYXJzZSwgdXNlIGRvdCBmb3IgdGhlIHVuZGVmaW5lZCBjZWxsc1xyXG4gICAgbGV0IHMgPSBcIlwiO1xyXG4gICAgZm9yKCBsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKVxyXG4gICAge1xyXG4gICAgICAgIGxldCByb3dOYW1lczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBmb3IoIGxldCBqID0gMDsgaiA8IHJvd0NvdW50OyBqKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgbmFtZSA9IG1hdHJpeFtpXVtqXTtcclxuICAgICAgICAgICAgcm93TmFtZXMucHVzaCggbmFtZSA/IG5hbWUgOiBcIi5cIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHMgKz0gYFwiJHtyb3dOYW1lcy5qb2luKFwiIFwiKX1cIlxcbmA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHM7XHJcbn1cclxuXHJcblxyXG5cclxud2tmW1dLRi5HcmlkVHJhY2tdID0gKHY6IEdyaWRUcmFjaykgPT4gdjJzKCB2LCB7XHJcbiAgICBudW06IFdLRi5MZW5ndGgsXHJcbiAgICBhcnI6IHYgPT4gYFske2Eycyh2KX1dYFxyXG59KTtcclxuXHJcblxyXG5cclxud2tmW1dLRi5HcmlkQXhpc10gPSAodjogRXh0ZW5kZWQ8R3JpZFRlbXBsYXRlQXhpc19TdHlsZVR5cGU+KSA9PiB2MnMoIHYsIHtcclxuICAgIG51bTogV0tGLkxlbmd0aCxcclxuICAgIGl0ZW06IFdLRi5HcmlkVHJhY2tcclxufSk7XHJcblxyXG5cclxuXHJcbndrZltXS0YuTWFya2VyXSA9ICh2YWw6IEV4dGVuZGVkPE1hcmtlcl9TdHlsZVR5cGU+KTogc3RyaW5nID0+XHJcbntcclxuICAgIHJldHVybiB2MnMoIHZhbCwge1xyXG4gICAgICAgIG9iajogdiA9PiBgdXJsKCMkeyh2IGFzIElJRFJ1bGUpLm5hbWV9KWBcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL1xyXG4vLyBGdW5jdGlvbnMgZm9yIGhhbmRsaW5nIFN0eWxlc2V0cy5cclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIHN0eWxlIHByb3BlcnR5IHRvIHRoZSBDU1Mgc3R5bGUgc3RyaW5nLiBQcm9wZXJ0eSBuYW1lIGNhbiBiZSBpbiBlaXRoZXJcclxuICogZGFzaCBvciBjYW1lbCBmb3JtLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNwMnMgPSAocHJvcE5hbWU6IHN0cmluZywgcHJvcFZhbDogYW55KTogc3RyaW5nID0+XHJcbntcclxuICAgIGlmICghcHJvcE5hbWUpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgLy8gaGFuZGxlIHNwZWNpYWwgcHJvcGVydGllcyBcIiFcIiBhbmQgXCJbXVwiXHJcbiAgICBsZXQgaW1wRmxhZyA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsID09PSBcIm9iamVjdFwiKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChcIiFcIiBpbiBwcm9wVmFsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBcIiFcIiBwcm9wZXJ0eSwgdGhlbiB0aGUgYWN0dWFsIHZhbHVlIGlzXHJcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGFuZCB3ZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBcIiFpbXBvcnRhbnRcIiBmbGFnLlxyXG4gICAgICAgICAgICBwcm9wVmFsID0gcHJvcFZhbFtcIiFcIl07XHJcbiAgICAgICAgICAgIGltcEZsYWcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcIltdXCIgaW4gcHJvcFZhbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgXCJbXVwiIHByb3BlcnR5LCB0aGVuIHdlIHRha2UgdGhlIGxhc3RcclxuICAgICAgICAgICAgLy8gdmFsdWUgZnJvbSB0aGlzIHByb3BlcnR5J3MgYXJyYXkuXHJcbiAgICAgICAgICAgIGxldCBhcnIgPSBwcm9wVmFsW1wiW11cIl0gYXMgYW55W107XHJcbiAgICAgICAgICAgIGlmICghYXJyIHx8IGFyci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlY3Vyc2Ugd2l0aCB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gc3AycyggcHJvcE5hbWUsIGFyclthcnIubGVuZ3RoLTFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29udmVydCB0aGUgdmFsdWUgdG8gc3RyaW5nIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBvYmplY3QgZm9yIHRoZSBwcm9wZXJ0eSAoaWYgZGVmaW5lZClcclxuICAgIGxldCBzdHJpbmdWYWx1ZSA9IHYycyggcHJvcFZhbCwgc3R5bGVQcm9wZXJ0eUluZm9zW2Rhc2hUb0NhbWVsKHByb3BOYW1lKV0pO1xyXG4gICAgaWYgKCFzdHJpbmdWYWx1ZSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICBpZiAoaW1wRmxhZylcclxuICAgICAgICBzdHJpbmdWYWx1ZSArPSBcIiAhaW1wb3J0YW50XCI7XHJcblxyXG4gICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc3R5bGVzZXQgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbiAqL1xyXG5leHBvcnQgY29uc3Qgc3R5bGVzZXQycyA9IChzdHlsZXNldDogU3R5bGVzZXQpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgaWYgKCFzdHlsZXNldClcclxuICAgICAgICByZXR1cm4gXCJ7fVwiO1xyXG5cclxuICAgIGxldCBzID0gXCJ7XCI7XHJcblxyXG4gICAgLy8gZW51bWVyYXRlIGFsbCBzdHlsZXNldCBwcm9wZXJ0aWVzIHJldHJpZXZpbmcgYWxzbyB2ZW5kb3ItcHJlZml4ZWQgdmFyaWFudHNcclxuXHRmb3JBbGxQcm9wc0luU3R5bHNldChcclxuICAgICAgICBzdHlsZXNldCxcclxuICAgICAgICAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCwgaXNDdXN0b206IGJvb2xlYW4sIGlzUHJlZml4ZWQ6IGJvb2xlYW4pOiB2b2lkID0+XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzICs9IGlzQ3VzdG9tXHJcbiAgICAgICAgICAgICAgICA/IGAke25hbWV9OiR7dmFsdWV9O2BcclxuICAgICAgICAgICAgICAgIDogYCR7aXNQcmVmaXhlZCA/IFwiLVwiIDogXCJcIn0ke2NhbWVsVG9EYXNoKG5hbWUpfToke3ZhbHVlfTtgO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHMgKyBcIn1cIjtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIFN0eWxlc2V0IG9iamVjdCBpbnRvIGEgU3RyaW5nU3R5bGVzZXQgb2JqZWN0LCB3aGVyZSBlYWNoIFN0eWxlc2V0J3MgcHJvcGVydHlcclxuICogaXMgY29udmVydGVkIHRvIGl0cyBzdHJpbmcgdmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgczJzcyA9IChzdHlsZXNldDogU3R5bGVzZXQpOiBTdHJpbmdTdHlsZXNldCA9PlxyXG57XHJcbiAgICAvLyBlbnVtZXJhdGUgYWxsIHN0eWxlc2V0IHByb3BlcnRpZXMgd2l0aG91dCByZXRyaWV2aW5nIHZlbmRvci1wcmVmaXhlZCB2YXJpYW50c1xyXG4gICAgbGV0IHJlczogU3RyaW5nU3R5bGVzZXQgPSB7fTtcclxuICAgIGZvckFsbFByb3BzSW5TdHlsc2V0KCBzdHlsZXNldCwgKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQgPT4ge3Jlc1tuYW1lXSA9IHZhbHVlfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgdHVwbGUgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHZlbmRvciBwcmVmaXhpbmcgb24gYSBwcm9wZXJ0eS5cclxuICogLSBwcm9wZXJ0eSBuYW1lICh0aGF0IG1heSBvciBtYXkgbm90IGJlIHByZWZpeGVkKS5cclxuICogLSBwcm9wZXJ0eSB2YWx1ZSAodGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIHByZWZpeGVkIGl0ZW1zKVxyXG4gKi9cclxudHlwZSBQcm9wUHJlZml4VmFyaWFudCA9IFtzdHJpbmcsIHN0cmluZ107XHJcblxyXG5cclxuLyoqIFR1cGxlIHRoYXQgY29udGFpbnMgbmFtZSwgdGVtcGxhdGUgYW5kIG9wdGlvbmFsIHZhbHVlIG9mIGEgY3VzdG9tIENTUyBwcm9wZXJ0eSBWYXJSdWxlICovXHJcbnR5cGUgVmFyTlRWID0gW3N0cmluZywgc3RyaW5nLCBzdHJpbmc/XTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIG5hbWUsIHRlbXBsYXRlIGFuZCBzdHJpbmcgdHVwbGVzIGZyb20gdGhlIGdpdmVuIGN1c3RvbSBDU1MgcHJvcGVydHkgZGVmaW5pdGlvbi5cclxuICogQHBhcmFtIGN1c3RvbVZhcnNcclxuICovXHJcbmNvbnN0IGdldFZhcnNOVFZzID0gKGN1c3RvbVZhcnM6IEN1c3RvbVZhcl9TdHlsZVR5cGUpOiBWYXJOVFZbXSA9PlxyXG57XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21WYXJzKSlcclxuICAgIHtcclxuICAgICAgICBsZXQgdmFyTmFtZTogc3RyaW5nO1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZTogc3RyaW5nO1xyXG4gICAgICAgIGxldCB2YWx1ZTogYW55O1xyXG4gICAgICAgIGlmIChjdXN0b21WYXJzLmxlbmd0aCA9PT0gMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhck5hbWUgPSBjdXN0b21WYXJzWzBdLm5hbWU7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlID0gY3VzdG9tVmFyc1swXS50ZW1wbGF0ZTtcclxuICAgICAgICAgICAgdmFsdWUgPSBjdXN0b21WYXJzWzFdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhck5hbWUgPSBjdXN0b21WYXJzWzBdO1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IGN1c3RvbVZhcnNbMV07XHJcbiAgICAgICAgICAgIHZhbHVlID0gY3VzdG9tVmFyc1syXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdmFyTmFtZSB8fCAhdGVtcGxhdGUpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgaWYgKCF2YXJOYW1lLnN0YXJ0c1dpdGgoXCItLVwiKSlcclxuICAgICAgICAgICAgdmFyTmFtZSA9IFwiLS1cIiArIHZhck5hbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBbW3Zhck5hbWUsIHRlbXBsYXRlLCBzcDJzKCB0ZW1wbGF0ZSwgdmFsdWUpXV07XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IHZhclJ1bGVzID0gZ2V0VmFyc0Zyb21TRChjdXN0b21WYXJzKTtcclxuICAgICAgICByZXR1cm4gdmFyUnVsZXMubWFwKCB2YXJSdWxlID0+IFt2YXJSdWxlLmNzc1Zhck5hbWUsIHZhclJ1bGUudGVtcGxhdGUsXHJcbiAgICAgICAgICAgIHNwMnMoIHZhclJ1bGUudGVtcGxhdGUsIHZhclJ1bGUuZ2V0VmFsdWUoKSldKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgc2lnbmF0dXJlIGZvciBlbnVtZXJhdGluZyBTdHlsZXNldCBwcm9wZXJ0aWVzIGNvbnZlcnRlZCB0byBzdHJpbmdzXHJcbiAqL1xyXG50eXBlIFN0eWxlc2V0UHJvcEVudW1DYWxsYmFjayA9IChuYW1lOiBzdHJpbmcsIHZhbDogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCxcclxuICAgIGlzQ3VzdG9tOiBib29sZWFuLCBpc1ByZWZpeGVkOiBib29sZWFuKSA9PiB2b2lkO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogRm9yIGVhY2ggcHJvcGVydHkgLSByZWd1bGFyIGFuZCBjdXN0b20gLSBpbiB0aGUgZ2l2ZW4gc3R5bGVzZXQgaW52b2tlcyB0aGUgYXBwcm9wcmlhdGVcclxuICogZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBwcm9wZXJ0eSBuYW1lIGFuZCB0aGUgdmFsdWUgY29udmVydGVkIHRvIHN0cmluZy5cclxuICogQHBhcmFtIHN0eWxlc2V0XHJcbiAqIEBwYXJhbSBjYWxsYmFja1xyXG4gKiBAcGFyYW0gZ2V0UHJlZml4ZWRWYXJpYW50cyBGbGFnIGluZGljYXRpbmcgd2hldGhlciB3ZSBuZWVkIHRvIHJldHJpZXZlIHByb3BlcnR5IHZhcmlhbnRzIHdpdGhcclxuICogdmVuZG9yIHByZWZpeGVzXHJcbiAqL1xyXG5jb25zdCBmb3JBbGxQcm9wc0luU3R5bHNldCA9IChzdHlsZXNldDogU3R5bGVzZXQsIGNhbGxiYWNrOiBTdHlsZXNldFByb3BFbnVtQ2FsbGJhY2spID0+XHJcbntcclxuXHRmb3IoIGxldCBwcm9wTmFtZSBpbiBzdHlsZXNldClcclxuXHR7XHJcbiAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBvZiB0aGUgXCItLVwiIHByb3BlcnR5LCB3aGljaCBpcyBhbiBhcnJheSB3aGVyZSBlYWNoIGl0ZW0gaXNcclxuICAgICAgICAvLyBhIHR3by1pdGVtIG9yIHRocmVlLWl0ZW0gYXJyYXlcclxuXHRcdGlmIChwcm9wTmFtZSA9PT0gXCItLVwiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGN1c3RvbVZhcnMgPSBzdHlsZXNldFtwcm9wTmFtZV0gYXMgQ3VzdG9tVmFyX1N0eWxlVHlwZVtdO1xyXG4gICAgICAgICAgICBmb3IoIGxldCBjdXN0b21WYXIgb2YgY3VzdG9tVmFycylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXN0b21WYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaW4gZWFjaCB0dXBsZSwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdmFyIG5hbWUsIHRoZSBzZWNvbmQgaXMgdGVtcGxhdGUgcHJvcGVydHkgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdGhpcmQgaXMgdGhlIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG50dnM6IFZhck5UVltdID0gZ2V0VmFyc05UVnMoIGN1c3RvbVZhcik7XHJcbiAgICAgICAgICAgICAgICBmb3IoIGxldCBudHYgb2YgbnR2cylcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggbnR2WzBdLCBudHZbMl0sIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgcHJvcFZhbCA9IHN0eWxlc2V0W3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgaWYgKHByb3BWYWwgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHByb3BlcnR5IGNvbnRhaW5zIGFuIGFycmF5IG9mIHZhbHVlcyBiZWhpbmQgdGhlIG9iamVjdCB3aXRoXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgXCJbXVwiIHByb3BlcnR5LiBJZiBub3QsIGNvbnZlcnQgdGhlIHNpbmdsZSB2YWx1ZSB0byBhbiBhcnJheSwgc28gdGhhdCB3ZSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBpdC5cclxuICAgICAgICAgICAgICAgIGxldCBwcm9wQXJyYXkgPSBwcm9wVmFsW1wiW11cIl0gYXMgYW55W107XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BBcnJheSlcclxuICAgICAgICAgICAgICAgICAgICBwcm9wQXJyYXkgPSBbcHJvcFZhbF07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKCBsZXQgcHJvcFZhbCBvZiBwcm9wQXJyYXkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3BlcnR5IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BTdHJpbmcgPSBzcDJzKCBwcm9wTmFtZSwgcHJvcFZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wU3RyaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHZlbmRvci1wcmVmaXhlZCB2YXJpYW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YXJpYW50cyA9IGdldFByZWZpeFZhcmlhbnRzKCBwcm9wTmFtZSBhcyBrZXlvZiBJU3R5bGVzZXQsIHByb3BTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYW50cylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciggbGV0IHZhcmlhbnQgb2YgdmFyaWFudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggdmFyaWFudFswXSwgdmFyaWFudFsxXSwgZmFsc2UsIHZhcmlhbnRbMF0gIT09IHByb3BOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBvcmlnaW5hbGx5IGZvdW5kIHByb3AgbmFtZSBhbmQgd2l0aCAocGVyaGFwcyB1cGRhdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soIHByb3BOYW1lLCBwcm9wU3RyaW5nLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cdH1cclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gUmVnaXN0cnkgb2YgQ1NTIHByb3BlcnRpZXMgdGhhdCBzcGVjaWZpZXMgaG93IHRoZWlyIHZhbHVlcyBzaG91bGQgYmUgY29udmVydGVkIHRvIHN0cmluZ3MuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuZXhwb3J0IGNvbnN0IHNfcmVnaXN0ZXJTUCA9IChuYW1lOiBzdHJpbmcsIHRvU3RyaW5nRnVuYzogQW55VG9TdHJpbmdGdW5jKSA9PlxyXG4gICAgbmFtZSBpbiBzdHlsZVByb3BlcnR5SW5mb3MgPyBmYWxzZSA6IChzdHlsZVByb3BlcnR5SW5mb3NbbmFtZV0gPSB0b1N0cmluZ0Z1bmMsIHRydWUpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogTWFwIG9mIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBWMlNPcHRpb25zIG9iamVjdHMgZGVzY3JpYmluZyBjdXN0b20gYWN0aW9ucyBuZWNlc3NhcnkgdG9cclxuICogY29udmVydCB0aGUgcHJvcGVydHkgdmFsdWUgdG8gdGhlIENTUy1jb21wbGlhbnQgc3RyaW5nLlxyXG4gKi9cclxuY29uc3Qgc3R5bGVQcm9wZXJ0eUluZm9zOiB7IFtLIGluIFZhclRlbXBsYXRlTmFtZV0/OiBWMlNPcHRpb25zIH0gPVxyXG57XHJcbiAgICBhY2NlbnRDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgYW5pbWF0aW9uOiB7XHJcbiAgICAgICAgYW55OiB7IG9iajogW1xyXG4gICAgICAgICAgICBbXCJkdXJhdGlvblwiLCBXS0YuVGltZV0sXHJcbiAgICAgICAgICAgIFwiZnVuY1wiLFxyXG4gICAgICAgICAgICBbXCJkZWxheVwiLCBXS0YuVGltZV0sXHJcbiAgICAgICAgICAgIFtcImNvdW50XCIsIFdLRi5OdW1iZXJdLFxyXG4gICAgICAgICAgICBcImRpcmVjdGlvblwiLFxyXG4gICAgICAgICAgICBcIm1vZGVcIixcclxuICAgICAgICAgICAgXCJzdGF0ZVwiLFxyXG4gICAgICAgICAgICBcIm5hbWVcIlxyXG4gICAgICAgIF19LFxyXG4gICAgICAgIHNlcDogXCIsXCIsXHJcbiAgICB9LFxyXG4gICAgYW5pbWF0aW9uRGVsYXk6IFdLRi5NdWx0aVRpbWVXaXRoQ29tbWEsXHJcbiAgICBhbmltYXRpb25EdXJhdGlvbjogV0tGLk11bHRpVGltZVdpdGhDb21tYSxcclxuICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYW5pbWF0aW9uRmlsbE1vZGU6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBhbmltYXRpb25OYW1lOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYW5pbWF0aW9uUGxheVN0YXRlOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcblxyXG4gICAgYmFja2dyb3VuZDoge1xyXG4gICAgICAgIG51bTogV0tGLkNvbG9yLFxyXG4gICAgICAgIGFueToge1xyXG4gICAgICAgICAgICBudW06IFdLRi5Db2xvcixcclxuICAgICAgICAgICAgb2JqOiBbXHJcbiAgICAgICAgICAgICAgICBbXCJjb2xvclwiLCBXS0YuQ29sb3JdLFxyXG4gICAgICAgICAgICAgICAgXCJpbWFnZVwiLFxyXG4gICAgICAgICAgICAgICAgW1wicG9zaXRpb25cIiwgV0tGLlBvc2l0aW9uXSxcclxuICAgICAgICAgICAgICAgIFtcInNpemVcIiwgV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLCBcIi9cIl0sXHJcbiAgICAgICAgICAgICAgICBcInJlcGVhdFwiLFxyXG4gICAgICAgICAgICAgICAgXCJhdHRhY2htZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIm9yaWdpblwiLFxyXG4gICAgICAgICAgICAgICAgXCJjbGlwXCJcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VwOiBcIixcIixcclxuICAgIH0sXHJcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIGJhY2tncm91bmRCbGVuZE1vZGU6IFdLRi5PbmVPck1hbnlXaXRoQ29tbWEsXHJcbiAgICBiYWNrZ3JvdW5kQ2xpcDogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgYmFja2dyb3VuZEltYWdlOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgYmFja2dyb3VuZE9yaWdpbjogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIGJhY2tncm91bmRQb3NpdGlvbjogV0tGLk11bHRpUG9zaXRpb24sXHJcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiBXS0YuTXVsdGlQb3NpdGlvbixcclxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IFdLRi5NdWx0aVBvc2l0aW9uLFxyXG4gICAgYmFja2dyb3VuZFJlcGVhdDogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIGJhY2tncm91bmRTaXplOiB7XHJcbiAgICAgICAgbnVtOiBXS0YuTGVuZ3RoLFxyXG4gICAgICAgIGl0ZW06IHsgYW55OiBXS0YuTGVuZ3RoIH0sXHJcbiAgICAgICAgc2VwOiBcIixcIlxyXG4gICAgfSxcclxuICAgIGJhc2VsaW5lU2hpZnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBibG9ja1NpemU6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXI6IFdLRi5Cb3JkZXIsXHJcbiAgICBib3JkZXJCbG9jazogV0tGLkJvcmRlcixcclxuICAgIGJvcmRlckJsb2NrQ29sb3I6IFdLRi5Db2xvcnMsXHJcbiAgICBib3JkZXJCbG9ja0VuZDogV0tGLkJvcmRlcixcclxuICAgIGJvcmRlckJsb2NrRW5kQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIGJvcmRlckJsb2NrRW5kV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJCbG9ja1N0YXJ0OiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVyQmxvY2tTdGFydENvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBib3JkZXJCbG9ja1N0YXJ0V2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJCbG9ja1dpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgYm9yZGVyQm90dG9tOiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IFdLRi5SYWRpdXMsXHJcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogV0tGLlJhZGl1cyxcclxuICAgIGJvcmRlckJvdHRvbVdpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgYm9yZGVyQ29sb3I6IFdLRi5Db2xvcnMsXHJcbiAgICBib3JkZXJFbmRFbmRSYWRpdXM6IFdLRi5SYWRpdXMsXHJcbiAgICBib3JkZXJFbmRTdGFydFJhZGl1czogV0tGLlJhZGl1cyxcclxuICAgIGJvcmRlckltYWdlOiB7XHJcbiAgICAgICAgb2JqOiBib3JkZXJJbWFnZVRvU3RyaW5nLFxyXG4gICAgfSxcclxuICAgIGJvcmRlcklubGluZTogV0tGLkJvcmRlcixcclxuICAgIGJvcmRlcklubGluZUNvbG9yOiBXS0YuQ29sb3JzLFxyXG4gICAgYm9yZGVySW5saW5lRW5kOiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVySW5saW5lRW5kQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIGJvcmRlcklubGluZUVuZFdpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgYm9yZGVySW5saW5lU3RhcnQ6IFdLRi5Cb3JkZXIsXHJcbiAgICBib3JkZXJJbmxpbmVTdGFydENvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBib3JkZXJJbmxpbmVTdGFydFdpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgYm9yZGVySW5saW5lV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJMZWZ0OiBXS0YuQm9yZGVyLFxyXG4gICAgYm9yZGVyTGVmdENvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBib3JkZXJMZWZ0V2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJSYWRpdXM6IFdLRi5Cb3JkZXJSYWRpdXMsXHJcbiAgICBib3JkZXJSaWdodDogV0tGLkJvcmRlcixcclxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IFdLRi5Db2xvcixcclxuICAgIGJvcmRlclJpZ2h0V2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJTcGFjaW5nOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBib3JkZXJTdGFydEVuZFJhZGl1czogV0tGLlJhZGl1cyxcclxuICAgIGJvcmRlclN0YXJ0U3RhcnRSYWRpdXM6IFdLRi5SYWRpdXMsXHJcbiAgICBib3JkZXJUb3A6IFdLRi5Cb3JkZXIsXHJcbiAgICBib3JkZXJUb3BDb2xvcjogV0tGLkNvbG9yLFxyXG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogV0tGLlJhZGl1cyxcclxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBXS0YuUmFkaXVzLFxyXG4gICAgYm9yZGVyVG9wV2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICBib3JkZXJXaWR0aDogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgYm90dG9tOiBXS0YuTGVuZ3RoLFxyXG4gICAgYm94U2hhZG93OiBXS0YuQm94U2hhZG93LFxyXG5cclxuICAgIGNhcmV0Q29sb3I6IFdLRi5Db2xvcixcclxuICAgIGNsaXA6ICB7XHJcbiAgICAgICAgYXJyOiB2ID0+IGByZWN0KCR7d2tmW1dLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZV0odil9YFxyXG4gICAgfSxcclxuICAgIGNvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBjb2x1bW5HYXA6IFdLRi5MZW5ndGgsXHJcbiAgICBjb2x1bW5SdWxlOiBXS0YuQm9yZGVyLFxyXG4gICAgY29sdW1uUnVsZUNvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBjb2x1bW5SdWxlV2lkdGg6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIGNvbHVtbldpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgY29udGVudDoge1xyXG4gICAgICAgIHN0cjogV0tGLlF1b3RlZCxcclxuICAgICAgICBpdGVtOiBXS0YuUXVvdGVkXHJcbiAgICB9LFxyXG4gICAgY3Vyc29yOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG5cclxuICAgIGZpbGw6IFdLRi5Db2xvcixcclxuICAgIGZpbGxPcGFjaXR5OiBXS0YuUGVyY2VudCxcclxuICAgIGZsZXg6IHtcclxuICAgICAgICBudW06IFdLRi5MZW5ndGgsXHJcbiAgICAgICAgYXJyOiB7XHJcbiAgICAgICAgICAgIDM6IFtXS0YuTnVtYmVyLCBXS0YuTnVtYmVyLCBXS0YuTGVuZ3RoXVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBmbGV4QmFzaXM6IFdLRi5MZW5ndGgsXHJcbiAgICBmbG9vZENvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICBmb250OiB7XHJcbiAgICAgICAgaXRlbTogV0tGLkxlbmd0aCxcclxuICAgICAgICBvYmo6IFtcclxuICAgICAgICAgICAgW1wic3R5bGVcIiwgV0tGLkZvbnRTdHlsZV0sXHJcbiAgICAgICAgICAgIFwidmFyaWFudFwiLFxyXG4gICAgICAgICAgICBcIndlaWdodFwiLFxyXG4gICAgICAgICAgICBcInN0cmV0Y2hcIixcclxuICAgICAgICAgICAgW1wic2l6ZVwiLCBXS0YuTGVuZ3RoXSxcclxuICAgICAgICAgICAgW1wibGluZUhlaWdodFwiLCB1bmRlZmluZWQsIFwiL1wiXSxcclxuICAgICAgICAgICAgXCJmYW1pbHlcIlxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBmb250U2l6ZTogV0tGLkxlbmd0aCxcclxuICAgIGZvbnRTdHJldGNoOiBXS0YuUGVyY2VudCxcclxuICAgIGZvbnRTdHlsZTogV0tGLkZvbnRTdHlsZSxcclxuXHJcbiAgICBnYXA6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIGdyaWRDb2x1bW5HYXA6IFdLRi5MZW5ndGgsXHJcbiAgICBncmlkR2FwOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBncmlkUm93R2FwOiBXS0YuTGVuZ3RoLFxyXG4gICAgZ3JpZEFyZWE6IFdLRi5PbmVPck1hbnlXaXRoU2xhc2gsXHJcbiAgICBncmlkQXV0b0NvbHVtbnM6IFdLRi5HcmlkQXhpcyxcclxuICAgIGdyaWRBdXRvUm93czogV0tGLkdyaWRBeGlzLFxyXG4gICAgZ3JpZENvbHVtbjogV0tGLk9uZU9yTWFueVdpdGhTbGFzaCxcclxuICAgIGdyaWRSb3c6IFdLRi5PbmVPck1hbnlXaXRoU2xhc2gsXHJcbiAgICBncmlkVGVtcGxhdGVBcmVhczogZ3JpZFRlbXBsYXRlQXJlYXNUb1N0cmluZyxcclxuICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IFdLRi5HcmlkQXhpcyxcclxuICAgIGdyaWRUZW1wbGF0ZVJvd3M6IFdLRi5HcmlkQXhpcyxcclxuXHJcbiAgICBoZWlnaHQ6IFdLRi5MZW5ndGgsXHJcblxyXG4gICAgaW5saW5lU2l6ZTogV0tGLkxlbmd0aCxcclxuICAgIGluc2V0OiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBpbnNldEJsb2NrOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBpbnNldEJsb2NrRW5kOiBXS0YuTGVuZ3RoLFxyXG4gICAgaW5zZXRCbG9ja1N0YXJ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgaW5zZXRJbmxpbmU6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIGluc2V0SW5saW5lRW5kOiBXS0YuTGVuZ3RoLFxyXG4gICAgaW5zZXRJbmxpbmVTdGFydDogV0tGLkxlbmd0aCxcclxuXHJcbiAgICBsZWZ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgbGV0dGVyU3BhY2luZzogV0tGLkxlbmd0aCxcclxuICAgIGxpZ2h0aW5nQ29sb3I6IFdLRi5Db2xvcixcclxuXHJcbiAgICBtYXJnaW46IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIG1hcmdpbkJsb2NrOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBtYXJnaW5CbG9ja0VuZDogV0tGLkxlbmd0aCxcclxuICAgIG1hcmdpbkJsb2NrU3RhcnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBtYXJnaW5Cb3R0b206IFdLRi5MZW5ndGgsXHJcbiAgICBtYXJnaW5JbmxpbmU6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIG1hcmdpbklubGluZUVuZDogV0tGLkxlbmd0aCxcclxuICAgIG1hcmdpbklubGluZVN0YXJ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgbWFyZ2luTGVmdDogV0tGLkxlbmd0aCxcclxuICAgIG1hcmdpblJpZ2h0OiBXS0YuTGVuZ3RoLFxyXG4gICAgbWFyZ2luVG9wOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWFya2VyRW5kOiBXS0YuTWFya2VyLFxyXG4gICAgbWFya2VyTWlkOiBXS0YuTWFya2VyLFxyXG4gICAgbWFya2VyU3RhcnQ6IFdLRi5NYXJrZXIsXHJcbiAgICBtYXNrQm9yZGVyOiB7XHJcbiAgICAgICAgb2JqOiBib3JkZXJJbWFnZVRvU3RyaW5nLFxyXG4gICAgfSxcclxuICAgIG1hc2tDbGlwOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgbWFza0NvbXBvc2l0ZTogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIG1hc2tJbWFnZTogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIG1hc2tNb2RlOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgbWFza09yaWdpbjogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIG1hc2tQb3NpdGlvbjogV0tGLk11bHRpUG9zaXRpb24sXHJcbiAgICBtYXNrUmVwZWF0OiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG4gICAgbWFza1NpemU6IHtcclxuICAgICAgICBudW06IFdLRi5MZW5ndGgsXHJcbiAgICAgICAgaXRlbTogeyBhbnk6IFdLRi5MZW5ndGggfSxcclxuICAgICAgICBzZXA6IFwiLFwiXHJcbiAgICB9LFxyXG4gICAgbWF4QmxvY2tTaXplOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWF4SGVpZ2h0OiBXS0YuTGVuZ3RoLFxyXG4gICAgbWF4SW5saW5lU2l6ZTogV0tGLkxlbmd0aCxcclxuICAgIG1heFdpZHRoOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWluQmxvY2tTaXplOiBXS0YuTGVuZ3RoLFxyXG4gICAgbWluSGVpZ2h0OiBXS0YuTGVuZ3RoLFxyXG4gICAgbWluSW5saW5lU2l6ZTogV0tGLkxlbmd0aCxcclxuXHRtaW5XaWR0aDogV0tGLkxlbmd0aCxcclxuXHJcbiAgICBvYmplY3RQb3NpdGlvbjogV0tGLlBvc2l0aW9uLFxyXG4gICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgb2JqOiBbXHJcbiAgICAgICAgICAgIFtcInBvc2l0aW9uXCIsIFdLRi5Qb3NpdGlvbl0sXHJcbiAgICAgICAgICAgIFwicGF0aFwiLFxyXG4gICAgICAgICAgICBbXCJkaXN0YW5jZVwiLCBXS0YuTGVuZ3RoXSxcclxuICAgICAgICAgICAgW1wicm90YXRlXCIsIHsgYW55OiBXS0YuQW5nbGUgfV0sXHJcbiAgICAgICAgICAgIFtcImFuY2hvclwiLCBXS0YuUG9zaXRpb24sIFwiL1wiXSxcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgb2Zmc2V0QW5jaG9yOiBXS0YuUG9zaXRpb24sXHJcbiAgICBvZmZzZXREaXN0YW5jZTogV0tGLkxlbmd0aCxcclxuICAgIG9mZnNldFBvc2l0aW9uOiBXS0YuUG9zaXRpb24sXHJcbiAgICBvZmZzZXRSb3RhdGU6IHtcclxuICAgICAgICBhbnk6IFdLRi5BbmdsZVxyXG4gICAgfSxcclxuICAgIG91dGxpbmU6IFdLRi5Cb3JkZXIsXHJcbiAgICBvdXRsaW5lQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIG91dGxpbmVPZmZzZXQ6IFdLRi5MZW5ndGgsXHJcbiAgICBvdmVyZmxvd0NsaXBNYXJnaW46IFdLRi5MZW5ndGgsXHJcblxyXG4gICAgcGFkZGluZzogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgcGFkZGluZ0Jsb2NrOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBwYWRkaW5nQmxvY2tFbmQ6IFdLRi5MZW5ndGgsXHJcbiAgICBwYWRkaW5nQmxvY2tTdGFydDogV0tGLkxlbmd0aCxcclxuICAgIHBhZGRpbmdCb3R0b206IFdLRi5MZW5ndGgsXHJcbiAgICBwYWRkaW5nSW5saW5lOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBwYWRkaW5nSW5saW5lRW5kOiBXS0YuTGVuZ3RoLFxyXG4gICAgcGFkZGluZ0lubGluZVN0YXJ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgcGFkZGluZ0xlZnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBwYWRkaW5nUmlnaHQ6IFdLRi5MZW5ndGgsXHJcbiAgICBwYWRkaW5nVG9wOiBXS0YuTGVuZ3RoLFxyXG4gICAgcGVyc3BlY3RpdmU6IFdLRi5MZW5ndGgsXHJcbiAgICBwZXJzcGVjdGl2ZU9yaWdpbjogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG5cclxuICAgIHF1b3Rlczoge1xyXG4gICAgICAgIGl0ZW06IHtcclxuICAgICAgICAgICAgc3RyOiBXS0YuUXVvdGVkLFxyXG4gICAgICAgICAgICBpdGVtOiBXS0YuUXVvdGVkLFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmlnaHQ6IFdLRi5MZW5ndGgsXHJcbiAgICByb3RhdGU6IHtcclxuICAgICAgICBudW06IFdLRi5BbmdsZSxcclxuICAgICAgICBhcnI6IHtcclxuICAgICAgICAgICAgMjogW1dLRi5EZWZhdWx0LCBXS0YuQW5nbGVdLFxyXG4gICAgICAgICAgICBhbnk6IFtXS0YuRGVmYXVsdCwgV0tGLkRlZmF1bHQsIFdLRi5EZWZhdWx0LCBXS0YuQW5nbGVdLFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByb3dHYXA6IFdLRi5MZW5ndGgsXHJcblxyXG4gICAgc2Nyb2xsTWFyZ2luOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBzY3JvbGxNYXJnaW5CbG9jazogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgc2Nyb2xsTWFyZ2luQmxvY2tFbmQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxNYXJnaW5CbG9ja1N0YXJ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsTWFyZ2luQm90dG9tOiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsTWFyZ2luSW5saW5lOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBzY3JvbGxNYXJnaW5JbmxpbmVFbmQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxNYXJnaW5JbmxpbmVTdGFydDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbE1hcmdpbkxlZnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxNYXJnaW5SaWdodDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbE1hcmdpblRvcDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbFBhZGRpbmc6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIHNjcm9sbFBhZGRpbmdCbG9jazogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgc2Nyb2xsUGFkZGluZ0Jsb2NrRW5kOiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsUGFkZGluZ0Jsb2NrU3RhcnQ6IFdLRi5MZW5ndGgsXHJcbiAgICBzY3JvbGxQYWRkaW5nQm90dG9tOiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsUGFkZGluZ0lubGluZTogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgc2Nyb2xsUGFkZGluZ0lubGluZUVuZDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbFBhZGRpbmdMZWZ0OiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsUGFkZGluZ1JpZ2h0OiBXS0YuTGVuZ3RoLFxyXG4gICAgc2Nyb2xsUGFkZGluZ1RvcDogV0tGLkxlbmd0aCxcclxuICAgIHNjcm9sbGJhckNvbG9yOiB7XHJcbiAgICAgICAgaXRlbTogV0tGLkNvbG9yXHJcbiAgICB9LFxyXG4gICAgc2hhcGVNYXJnaW46IFdLRi5MZW5ndGgsXHJcbiAgICBzdG9wQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIHN0cm9rZTogV0tGLkNvbG9yLFxyXG5cclxuICAgIHRleHRDb21iaW5lVXByaWdodDoge1xyXG4gICAgICAgIG51bTogdiA9PiBgZGlnaXRzICR7dn1gXHJcbiAgICB9LFxyXG4gICAgdGV4dERlY29yYXRpb246IHtcclxuICAgICAgICBudW06IFdLRi5Db2xvcixcclxuICAgICAgICBvYmo6IFtcclxuICAgICAgICAgICAgXCJsaW5lXCIsXHJcbiAgICAgICAgICAgIFwic3R5bGVcIixcclxuICAgICAgICAgICAgW1wiY29sb3JcIiwgV0tGLkNvbG9yXSxcclxuICAgICAgICAgICAgW1widGhpY2tuZXNzXCIsIFdLRi5MZW5ndGhdLFxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB0ZXh0RGVjb3JhdGlvbkNvbG9yOiBXS0YuQ29sb3IsXHJcbiAgICB0ZXh0RGVjb3JhdGlvblRoaWNrbmVzczogV0tGLkxlbmd0aCxcclxuICAgIHRleHRFbXBoYXNpczogV0tGLkNvbG9yLFxyXG4gICAgdGV4dEVtcGhhc2lzQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIHRleHRGaWxsQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIHRleHRJbmRlbnQ6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIHRleHRTaGFkb3c6IFdLRi5Cb3hTaGFkb3csXHJcbiAgICB0ZXh0U2l6ZUFkanVzdDogV0tGLlBlcmNlbnQsXHJcbiAgICB0ZXh0U3Ryb2tlQ29sb3I6IFdLRi5Db2xvcixcclxuICAgIHRleHRTdHJva2VXaWR0aDogV0tGLkxlbmd0aCxcclxuICAgIHRvcDogV0tGLkxlbmd0aCxcclxuICAgIHRyYW5zZm9ybU9yaWdpbjogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgdHJhbnNpdGlvbjoge1xyXG4gICAgICAgIGFueTogeyBvYmo6IFtcclxuICAgICAgICAgICAgW1wicHJvcGVydHlcIiwgY2FtZWxUb0Rhc2hdLFxyXG4gICAgICAgICAgICBbXCJkdXJhdGlvblwiLCBXS0YuVGltZV0sXHJcbiAgICAgICAgICAgIFwiZnVuY1wiLFxyXG4gICAgICAgICAgICBbXCJkZWxheVwiLCBXS0YuVGltZV1cclxuICAgICAgICBdfSxcclxuICAgICAgICBzZXA6IFwiLFwiLFxyXG4gICAgfSxcclxuICAgIHRyYW5zaXRpb25EZWxheTogV0tGLk11bHRpVGltZVdpdGhDb21tYSxcclxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogV0tGLk11bHRpVGltZVdpdGhDb21tYSxcclxuICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIHRyYW5zbGF0ZTogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG5cclxuICAgIHZlcnRpY2FsQWxpZ246IFdLRi5MZW5ndGgsXHJcblxyXG4gICAgd2lkdGg6IFdLRi5MZW5ndGgsXHJcbiAgICB3aWxsQ2hhbmdlOiB7XHJcbiAgICAgICAgc3RyOiBjYW1lbFRvRGFzaFxyXG4gICAgfSxcclxuICAgIHdvcmRTcGFjaW5nOiBXS0YuTGVuZ3RoLFxyXG5cclxuICAgIHpvb206IFdLRi5QZXJjZW50LFxyXG5cclxuICAgIC8vIHByb3BlcnRpZXMgZm9yIENTUyBzeW50YXggdmFsdWVzXHJcbiAgICBcIjxudW1iZXI+I1wiOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG5cclxuICAgIFwiPGxlbmd0aD5cIjogV0tGLkxlbmd0aCxcclxuICAgIFwiPGxlbmd0aD4rXCI6IFdLRi5NdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIFwiPGxlbmd0aD4jXCI6IHsgYW55OiBXS0YuTGVuZ3RoLCBzZXA6IFwiLFwifSxcclxuXHJcbiAgICBcIjxwZXJjZW50YWdlPlwiOiBXS0YuUGVyY2VudCxcclxuICAgIFwiPHBlcmNlbnRhZ2U+K1wiOiB7IGFueTogV0tGLlBlcmNlbnQgfSxcclxuICAgIFwiPHBlcmNlbnRhZ2U+I1wiOiB7IGFueTogV0tGLlBlcmNlbnQsIHNlcDogXCIsXCJ9LFxyXG5cclxuICAgIFwiPGxlbmd0aC1wZXJjZW50YWdlPlwiOiBXS0YuTGVuZ3RoLFxyXG4gICAgXCI8bGVuZ3RoLXBlcmNlbnRhZ2U+K1wiOiBXS0YuTXVsdGlMZW5ndGhXaXRoU3BhY2UsXHJcbiAgICBcIjxsZW5ndGgtcGVyY2VudGFnZT4jXCI6IHsgYW55OiBXS0YuTGVuZ3RoLCBzZXA6IFwiLFwifSxcclxuXHJcbiAgICBcIjxhbmdsZT5cIjogV0tGLkFuZ2xlLFxyXG4gICAgXCI8YW5nbGU+K1wiOiB7IGFueTogV0tGLkFuZ2xlIH0sXHJcbiAgICBcIjxhbmdsZT4jXCI6IHsgYW55OiBXS0YuQW5nbGUsIHNlcDogXCIsXCJ9LFxyXG5cclxuICAgIFwiPHRpbWU+XCI6IFdLRi5UaW1lLFxyXG4gICAgXCI8dGltZT4rXCI6IHsgYW55OiBXS0YuVGltZSB9LFxyXG4gICAgXCI8dGltZT4jXCI6IFdLRi5NdWx0aVRpbWVXaXRoQ29tbWEsXHJcblxyXG4gICAgXCI8cmVzb2x1dGlvbj5cIjogV0tGLlJlc29sdXRpb24sXHJcbiAgICBcIjxyZXNvbHV0aW9uPitcIjogeyBhbnk6IFdLRi5SZXNvbHV0aW9uIH0sXHJcbiAgICBcIjxyZXNvbHV0aW9uPiNcIjogeyBhbnk6IFdLRi5SZXNvbHV0aW9uLCBzZXA6IFwiLFwifSxcclxuXHJcbiAgICBcIjxjb2xvcj5cIjogV0tGLkNvbG9yLFxyXG4gICAgXCI8Y29sb3I+K1wiOiB7IGFueTogV0tGLkNvbG9yIH0sXHJcbiAgICBcIjxjb2xvcj4jXCI6IHsgYW55OiBXS0YuQ29sb3IsIHNlcDogXCIsXCJ9LFxyXG5cclxuICAgIFwiPGltYWdlPiNcIjogV0tGLk9uZU9yTWFueVdpdGhDb21tYSxcclxuXHJcbiAgICBcIjxjdXN0b20taWRlbnQ+I1wiOiBXS0YuT25lT3JNYW55V2l0aENvbW1hLFxyXG5cclxuICAgIC8vIHNwZWNpYWwgcHJvcGVydGllcyBmb3IgSVZhclJ1bGUgdHlwZXNcclxuICAgIFwiPHN0cmluZz5cIjogV0tGLlF1b3RlZCxcclxuICAgIFwiPGZyZXF1ZW5jeT5cIjogV0tGLkZyZXF1ZW5jeSxcclxuICAgIFwiPHNpemU+XCI6IFdLRi5MZW5ndGgsXHJcbiAgICBcIjxwb2ludD5cIjogV0tGLk11bHRpTGVuZ3RoV2l0aFNwYWNlLFxyXG4gICAgXCI8cG9zaXRpb24+XCI6IFdLRi5Qb3NpdGlvbixcclxuICAgIFwiPG11bHRpLXBvc2l0aW9uPlwiOiBXS0YuTXVsdGlQb3NpdGlvbixcclxuICAgIFwiPHJhZGl1cz5cIjogV0tGLlJhZGl1cyxcclxufTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFZlbmRvciBwcmVmaXggc3VwcG9ydFxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmNvbnN0IGVudW0gVmVuZG9yUHJlZml4XHJcbntcclxuICAgIHdlYmtpdCA9IDEsXHJcbiAgICBtb3ogPSAyLFxyXG4gICAgbXMgPSAzLFxyXG59XHJcblxyXG4vLyBWZW5kb3IgcHJlZml4ZXMgd2l0aCBpbmRleGVzIGZyb20gdGhlIFZlbmRvclByZWZpeCBlbnVtZXJhdGlvbi4gVGhlIGZpcnN0IG9uZSBpcyBvbmx5IGhlcmUgdG9cclxuLy8gYWxsb3cgdGhlIGZpcnN0IGVudW1lcmF0aW9uIHZhbHVlIHRvIGJlIDEgYW5kIG5vdCB6ZXJvLlxyXG5jb25zdCB2ZW5kb3JQcmVmaXhTdHJpbmdzID0gW1wiXCIsIFwid2Via2l0XCIsIFwibW96XCIsIFwibXNcIl07XHJcblxyXG5cclxuLy8gTW9kZSBpbmRpY2F0aW5nIHRvIHdoYXQgZW50aXR5IHRoZSBwcmVmaXggc2hvdWxkIGJlIGFkZGVkIGlmIGEgY2VydGFpbiB2YWx1ZSBpcyBmb3VuZCBpbiB0aGVcclxuLy8gcHJvcGVydHkuXHJcbmNvbnN0IGVudW0gVmFsdWVQcmVmaXhNb2RlXHJcbntcclxuICAgIC8vIEJvdGggdGhlIHZhbHVlIGFuZCB0aGUgcHJvcGVydHkgbmFtZSBhcmUgcHJlZml4ZWQuXHJcbiAgICBCb3RoID0gMCxcclxuXHJcbiAgICAvLyBPbmx5IHRoZSB2YWx1ZSBpcyBwcmVmaXhlZFxyXG4gICAgVmFsdWVPbmx5ID0gMSxcclxuXHJcbiAgICAvLyBPbmx5IHRoZSBwcm9wZXJ0eSBuYW1lIGlzIHByZWZpeGVkXHJcbiAgICBQcm9wZXJ0eU9ubHkgPSAyLFxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIGRlZmluaW5nIGEgdmFsdWUgd2hpY2ggc2hvdWxkIGJlIHByZWZpeGVkIG9yIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBwcm9wZXJ0eSBzaG91bGQgYmVcclxuICogcHJlZml4ZWQuXHJcbiAqL1xyXG50eXBlIFZhbHVlUHJlZml4SW5mbyA9XHJcbiAgICB7XHJcbiAgICAgICAgLy8gVmFsdWUgd2hpY2ggc2hvdWxkIGJlIHByZWZpeGVkIG9yIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcHJlZml4ZWQuXHJcbiAgICAgICAgdmFsOiBzdHJpbmc7XHJcblxyXG4gICAgICAgIC8vIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIG9yIHByb3BlcnR5IG9yIGJvdGggc2hvdWxkIGJlIHByZWZpeGVkLiBEZWZhdWx0IGlzIEJvdGguXHJcbiAgICAgICAgbW9kZT86IFZhbHVlUHJlZml4TW9kZTtcclxuXHJcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmUgbmFtZSBmb3IgdGhlIHZhbHVlIChzb21ldGltZXMgYSB2YWx1ZSBpcyBub3QganVzdCBwcmVmaXhlZCwgYnV0IGdldHNcclxuICAgICAgICAvLyB3aG9sbHkgZGlmZmVyZW50IG5hbWUpLlxyXG4gICAgICAgIGFsdD86IHN0cmluZztcclxuICAgIH07XHJcblxyXG4vKipcclxuICogVHlwZSBkZWZpbmluZyBhIHByb3BlcnR5IHdoaWNoIHNob3VsZCBiZSBwcmVmaXhlZCBvciB3aG9zZSB2YWx1ZXMgc2hvdWxkIGJlIHByZWZpeGVkLlxyXG4gKiAgIC0gc3RyaW5nIC0gc3BlY2lmaWVzIHRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvcGVydHlcclxuICogICAtIG51bWJlciAtIHNwZWNpZmllcyB0aGUgc2luZ2xlIHN1cHBvcnRlZCB2ZW5kb3IgcHJlZml4XHJcbiAqL1xyXG50eXBlIFByb3BQcmVmaXhJbmZvID0gc3RyaW5nIHwgbnVtYmVyIHxcclxuICAgIHtcclxuICAgICAgICAvLyBQcmVmaXggaW5kZXhcclxuICAgICAgICBwOiBWZW5kb3JQcmVmaXg7XHJcblxyXG4gICAgICAgIC8vIEFsdGVybmF0aXZlIG5hbWUgZm9yIHRoZSBwcm9wZXJ0eSAoc29tZXRpbWVzIGEgcHJvcGVydHkgaXMgbm90IGp1c3QgcHJlZml4ZWQsIGJ1dCBnZXRzXHJcbiAgICAgICAgLy8gd2hvbGx5IGRpZmZlcmVudCBuYW1lKS5cclxuICAgICAgICBhbHQ/OiBzdHJpbmc7XHJcblxyXG4gICAgICAgIC8vIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBpcyBhbHdheXMgcHJlZml4ZWQgb3Igb25seSBpZiBpdFxyXG4gICAgICAgIC8vIGNvbnRhaW5zIHNwZWNpYWwgdmFsdWVzIHNwZWNpZmllZCBieSB0aGUgYHZhbHNgIHByb3BlcnR5LlxyXG4gICAgICAgIHZhbHNPbmx5PzogYm9vbGVhbjtcclxuXHJcbiAgICAgICAgLy8gQXJyYXkgb2Ygb2JqZWN0cyBwcm92aWRpbmcgaW5mb21hdGlvbiBhYm91dCB2YWx1ZXMgd2hpY2ggc2hvdWxkIGJlIHByZWZpeGVkIG9yXHJcbiAgICAgICAgLy8gd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBwcmVmaXhlZC5cclxuICAgICAgICB2YWxzPzogVmFsdWVQcmVmaXhJbmZvW107XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5jb25zdCBnZXRQcmVmaXhWYXJpYW50cyA9IChuYW1lOiBrZXlvZiBJU3R5bGVzZXQsIHZhbHVlOiBzdHJpbmcpOiBQcm9wUHJlZml4VmFyaWFudFtdIHwgbnVsbCA9PlxyXG57XHJcbiAgICBsZXQgaW5mbyA9IHByb3BQcmVmaXhJbmZvc1tuYW1lXTtcclxuICAgIGlmICghaW5mbylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGluZm8gPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgcmV0dXJuIFtbaW5mbywgdmFsdWVdXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGluZm8gPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgcmV0dXJuIFtbZGFzaFRvQ2FtZWwoYCR7dmVuZG9yUHJlZml4U3RyaW5nc1tpbmZvXX0tJHtuYW1lfWApLCB2YWx1ZV1dO1xyXG5cclxuICAgIGxldCB2YXJpYW50czogUHJvcFByZWZpeFZhcmlhbnRbXSA9IFtdO1xyXG4gICAgZm9yKCBsZXQgaXRlbSBvZiBpbmZvKVxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgdmFyaWFudHMucHVzaCggW2l0ZW0sIHZhbHVlXSk7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHZhcmlhbnRzLnB1c2goIFtkYXNoVG9DYW1lbChgJHt2ZW5kb3JQcmVmaXhTdHJpbmdzW2l0ZW1dfS0ke25hbWV9YCksIHZhbHVlXSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IHByZWZpeFN0cmluZyA9IHZlbmRvclByZWZpeFN0cmluZ3NbaXRlbS5wXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBuYW1lIHNob3VsZCBiZSBwcmVmaXhlZC4gTm90ZSB0aGF0IGV2ZW4gaWYgd2UgZGVjaWRlXHJcbiAgICAgICAgICAgIC8vIGhlcmUgdGhhdCBpdCBzaG91bGQgbm90IGJlIHByZWZpeGVkLCBpdCBjYW4gY2hhbmdlIHdoZW4gd2UgZ28gb3ZlciBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgICAgICAgIGxldCBzaG91bGRQcmVmaXhQcm9wZXJ0eSA9ICFpdGVtLnZhbHNPbmx5O1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgcHJvcGVydHkgdmFsdWVzIGFyZSBkZWZpbmVkLCB0cnkgdG8gcmVwbGFjZSB0aGVtIHdpdGggcHJlZml4ZWQgdmVyc2lvbnMuIE5vdGUgdGhhdFxyXG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBhbHNvIHNldCB0aGUgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhlIHByb3BlcnR5IG5hbWUgc2hvdWxkIGJlIHByZWZpeGVkIHRvby5cclxuICAgICAgICAgICAgbGV0IG5ld1Byb3BWYWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBpdGVtLnZhbHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciggbGV0IHZhbHVlSW5mbyBvZiBpdGVtLnZhbHMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlVG9TZWFyY2ggPSB2YWx1ZUluZm8udmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCB2YWx1ZVRvU2VhcmNoKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVJbmZvLm1vZGUgIT09IFZhbHVlUHJlZml4TW9kZS5Qcm9wZXJ0eU9ubHkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wVmFsdWUgPSB2YWx1ZS5zcGxpdCh2YWx1ZVRvU2VhcmNoKS5qb2luKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJbmZvLmFsdCA/IHZhbHVlSW5mby5hbHQgOiBgLSR7cHJlZml4U3RyaW5nfS0ke3ZhbHVlVG9TZWFyY2h9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3UHJvcFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlSW5mby5tb2RlICE9PSBWYWx1ZVByZWZpeE1vZGUuVmFsdWVPbmx5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVmaXhQcm9wZXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBuZXdQcm9wTmFtZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRQcmVmaXhQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIG5ld1Byb3BOYW1lID0gaXRlbS5hbHQgPyBpdGVtLmFsdCA6IGRhc2hUb0NhbWVsKGAke3ByZWZpeFN0cmluZ30tJHtuYW1lfWApO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5ld1Byb3BOYW1lIHx8IG5ld1Byb3BWYWx1ZSlcclxuICAgICAgICAgICAgICAgIHZhcmlhbnRzLnB1c2goIFtuZXdQcm9wTmFtZSB8fCBuYW1lLCBuZXdQcm9wVmFsdWUgfHwgdmFsdWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhcmlhbnRzLmxlbmd0aCA+IDAgPyB2YXJpYW50cyA6IG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuLy8gUHJlZml4IGluZm9ybWF0aW9uIGZvciBzaXplLWxpa2UgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBcInN0cmV0Y2hcIiB2YWx1ZVxyXG5jb25zdCBzaXplUHJlZml4SW5mb3M6IFByb3BQcmVmaXhJbmZvW10gPSBbXHJcbiAgICB7cDogVmVuZG9yUHJlZml4LndlYmtpdCwgdmFsc09ubHk6IHRydWUsIHZhbHM6IFt7dmFsOiBcInN0cmV0Y2hcIiwgbW9kZTogVmFsdWVQcmVmaXhNb2RlLlZhbHVlT25seSwgYWx0OiBcIi13ZWJraXQtZmlsbC1hdmFpbGFibGVcIn1dfSxcclxuXTtcclxuXHJcbi8vIFByZWZpeCBpbmZvcm1hdGlvbiBmb3IgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBcImNyb3NzLWZhZGVcIiBhbmQgXCJpbWFnZS1zZXRcIiBmdW5jdGlvbnMgKHRoYXQgaXMsIGltYWdlcylcclxuY29uc3QgaW1hZ2VGdW5jc1ByZWZpeEluZm86IFByb3BQcmVmaXhJbmZvID0ge1xyXG4gICAgcDogVmVuZG9yUHJlZml4LndlYmtpdCwgdmFsc09ubHk6IHRydWUsIHZhbHM6IFtcclxuICAgICAgICB7dmFsOiBcImNyb3NzLWZhZGVcIiwgbW9kZTogVmFsdWVQcmVmaXhNb2RlLlZhbHVlT25seSB9LFxyXG4gICAgICAgIHt2YWw6IFwiaW1hZ2Utc2V0XCIsIG1vZGU6IFZhbHVlUHJlZml4TW9kZS5WYWx1ZU9ubHkgfVxyXG4gICAgXVxyXG59O1xyXG5cclxuY29uc3QgaW1hZ2VGdW5jc1ByZWZpeEluZm9zOiBQcm9wUHJlZml4SW5mb1tdID0gW2ltYWdlRnVuY3NQcmVmaXhJbmZvXTtcclxuXHJcblxyXG5jb25zdCBwcm9wUHJlZml4SW5mb3M6IHsgW0sgaW4ga2V5b2YgSVN0eWxlc2V0XT86IHN0cmluZyB8IG51bWJlciB8IFByb3BQcmVmaXhJbmZvW10gfSA9XHJcbntcclxuICAgIGFwcGVhcmFuY2U6IFsgVmVuZG9yUHJlZml4LndlYmtpdCwgVmVuZG9yUHJlZml4Lm1veiBdLFxyXG4gICAgYmFja2dyb3VuZENsaXA6IFtcclxuICAgICAgICB7cDogVmVuZG9yUHJlZml4LndlYmtpdCwgdmFsc09ubHk6IHRydWUsIHZhbHM6IFt7dmFsOiBcInRleHRcIiwgbW9kZTogVmFsdWVQcmVmaXhNb2RlLlByb3BlcnR5T25seX1dfVxyXG4gICAgXSxcclxuICAgIGJsb2NrU2l6ZTogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgYm94RGVjb3JhdGlvbkJyZWFrOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgYmFja2dyb3VuZDogaW1hZ2VGdW5jc1ByZWZpeEluZm9zLFxyXG4gICAgYmFja2dyb3VuZEltYWdlOiBpbWFnZUZ1bmNzUHJlZml4SW5mb3MsXHJcbiAgICBib3JkZXJJbWFnZTogaW1hZ2VGdW5jc1ByZWZpeEluZm9zLFxyXG4gICAgYm9yZGVySW1hZ2VTb3VyY2U6IGltYWdlRnVuY3NQcmVmaXhJbmZvcyxcclxuICAgIGNsaXBQYXRoOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgY29sb3JBZGp1c3Q6IFwid2Via2l0UHJpbnRDb2xvckFkanVzdFwiLFxyXG4gICAgY29udGVudDogaW1hZ2VGdW5jc1ByZWZpeEluZm9zLFxyXG4gICAgaGVpZ2h0OiBzaXplUHJlZml4SW5mb3MsXHJcbiAgICBoeXBoZW5zOiBbIFZlbmRvclByZWZpeC53ZWJraXQsIFZlbmRvclByZWZpeC5tb3osIFZlbmRvclByZWZpeC5tcyBdLFxyXG4gICAgaW5pdGlhbExldHRlcjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIGlubGluZVNpemU6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIGxpbmVDbGFtcDogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIG1hc2s6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBtYXNrQm9yZGVyOiBbXCJ3ZWJraXRNYXNrQm94SW1hZ2VcIiwgaW1hZ2VGdW5jc1ByZWZpeEluZm9dLFxyXG4gICAgbWFza0JvcmRlck91dHNldDogXCJ3ZWJraXRNYXNrQm94SW1hZ2VPdXRzZXRcIixcclxuICAgIG1hc2tCb3JkZXJSZXBlYXQ6IFwid2Via2l0TWFza0JveEltYWdlUmVwZWF0XCIsXHJcbiAgICBtYXNrQm9yZGVyU2xpY2U6IFwid2Via2l0TWFza0JveEltYWdlU2xpY2VcIixcclxuICAgIG1hc2tCb3JkZXJTb3VyY2U6IFwid2Via2l0TWFza0JveEltYWdlU291cmNlXCIsXHJcbiAgICBtYXNrQm9yZGVyV2lkdGg6IFwid2Via2l0TWFza0JveEltYWdlV2lkdGhcIixcclxuICAgIG1hc2tDbGlwOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWFza0NvbXBvc2l0ZTogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIG1hc2tJbWFnZTogW1ZlbmRvclByZWZpeC53ZWJraXQsIGltYWdlRnVuY3NQcmVmaXhJbmZvXSxcclxuICAgIG1hc2tNb2RlOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWFza09yaWdpbjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIG1hc2tQb3NpdGlvbjogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIG1hc2tSZXBlYXQ6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBtYXNrU2l6ZTogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIG1hc2tUeXBlOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgbWF4QmxvY2tTaXplOiBzaXplUHJlZml4SW5mb3MsXHJcbiAgICBtYXhIZWlnaHQ6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIG1heElubGluZVNpemU6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIG1heFdpZHRoOiBzaXplUHJlZml4SW5mb3MsXHJcbiAgICBtaW5CbG9ja1NpemU6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIG1pbkhlaWdodDogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgbWluSW5saW5lU2l6ZTogc2l6ZVByZWZpeEluZm9zLFxyXG4gICAgbWluV2lkdGg6IHNpemVQcmVmaXhJbmZvcyxcclxuICAgIHNoYXBlT3V0c2lkZTogaW1hZ2VGdW5jc1ByZWZpeEluZm9zLFxyXG4gICAgc2Nyb2xsYmFyQ29sb3I6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICBzY3JvbGxiYXJXaWR0aDogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRFbXBoYXNpczogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRFbXBoYXNpc0NvbG9yOiBWZW5kb3JQcmVmaXgud2Via2l0LFxyXG4gICAgdGV4dEVtcGhhc2lzUG9zaXRpb246IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICB0ZXh0RW1waGFzaXNTdHlsZTogVmVuZG9yUHJlZml4LndlYmtpdCxcclxuICAgIHRleHRGaWxsQ29sb3I6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICB0ZXh0T3JpZW50YXRpb246IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICB0ZXh0U2l6ZUFkanVzdDogWyBWZW5kb3JQcmVmaXgud2Via2l0LCBWZW5kb3JQcmVmaXgubW96LCBWZW5kb3JQcmVmaXgubXMgXSxcclxuICAgIHRleHRTdHJva2U6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICB0ZXh0U3Ryb2tlQ29sb3I6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICB0ZXh0U3Ryb2tlV2lkdGg6IFZlbmRvclByZWZpeC53ZWJraXQsXHJcbiAgICB1c2VyU2VsZWN0OiBbXHJcbiAgICAgICAge3A6IFZlbmRvclByZWZpeC53ZWJraXQsIHZhbHM6IFt7dmFsOiBcIm5vbmVcIiwgbW9kZTogVmFsdWVQcmVmaXhNb2RlLlByb3BlcnR5T25seX1dfVxyXG4gICAgXSxcclxuICAgIHdpZHRoOiBzaXplUHJlZml4SW5mb3MsXHJcbn1cclxuXHJcblxyXG5cclxuIiwi77u/Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIENhc2UgY29udmVyc2lvbnMgZm9yIHByb3BlcnR5IG5hbWVzLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmltcG9ydCB7IElDc3NGdW5jT2JqZWN0LCBOdGhFeHByZXNzaW9uIH0gZnJvbSBcIi4uL2FwaS9Db3JlVHlwZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBkYXNoZS1jYXNlIHRvIGNhbWVsQ2FzZSwgZS5nLiBmb250LXNpemUgdG8gZm9udFNpemUuXHJcbiAqIEBwYXJhbSBkYXNoXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGFzaFRvQ2FtZWwgPSAoZGFzaDogc3RyaW5nKTogc3RyaW5nID0+XHJcblx0IWRhc2ggPyBkYXNoIDogZGFzaC5yZXBsYWNlKCAvLShbYS16QS1aXSkvZywgKHgsICQxKSA9PiAkMS50b1VwcGVyQ2FzZSgpKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGNhbWVsQ2FzZSB0byBkYXNoLWNhc2UsIGUuZy4gZm9udFNpemUgdG8gZm9udC1zaXplLlxyXG4gKiBAcGFyYW0gY2FtZWxcclxuICovXHJcbmV4cG9ydCBjb25zdCBjYW1lbFRvRGFzaCA9IChjYW1lbDogc3RyaW5nKTogc3RyaW5nID0+XHJcbiAgICBjYW1lbC5yZXBsYWNlKCAvKFthLXpBLVpdKSg/PVtBLVpdKS9nLCAnJDEtJykudG9Mb3dlckNhc2UoKTtcclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIENvbnZlcnNpb24gb2YgdmFsdWVzIHRvIHN0cmluZ3MuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFN5bWJvbCB1bmRlciB3aGljaCBhIGZ1bmN0aW9uIGlzIGRlZmluZWQgdGhhdCBjb252ZXJ0cyBhbiBvYmplY3QgdG8gYSBzdHJpbmcuIFdlIG5lZWQgYSBzcGVjaWFsXHJcbiAqIHN5bWJvbCBiZWNhdXNlIHRoZSBzdGFuZGFyZCBtZXRob2QgdG9TdHJpbmcgZXhpc3RzIG9uIGV2ZXJ5IG9iamVjdCBhbmQgd2Ugb25seSB3YW50IHNvbWUgdG9cclxuICogZXhwbGljaXRseSBwcm92aWRlIHRoaXMgc3VwcG9ydC5cclxuICovXHJcbiBleHBvcnQgY29uc3Qgc3ltVjJTOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCk7XHJcblxyXG5cclxuXHJcbi8qKiBUeXBlIG9mIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSB2YWx1ZSBvZiBhcmJpdHJhcnkgdHlwZSB0byBhIHN0cmluZyAqL1xyXG5leHBvcnQgdHlwZSBBbnlUb1N0cmluZ0Z1bmMgPSAodmFsOiBhbnkpID0+IHN0cmluZztcclxuXHJcbi8qKiBUeXBlIG9mIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBudW1iZXIgdG8gYSBzdHJpbmcgKi9cclxuZXhwb3J0IHR5cGUgTnVtYmVyVG9TdHJpbmdGdW5jID0gKG46IG51bWJlcikgPT4gc3RyaW5nO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogTnVtZXJpYyBpZGVudGlmaWVycyBjb3JyZXNwb25kaW5nIHRvIFdlbGwgS25vd24gRnVuY3Rpb25zIHVzZWQgdG8gY29udmVydCBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXNcclxuICogdG8gc3RyaW5ncy4gVGhpcyBpcyB1c2VkIHRvIHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHVzZWQgZm9yIG1hcHBpbmcgc3R5bGUgcHJvcGVydGllcyB0b1xyXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlbnVtIFdLRlxyXG57XHJcbiAgICBEZWZhdWx0ID0gMCxcclxuICAgIE51bWJlcixcclxuICAgIFBlcmNlbnQsXHJcbiAgICBMZW5ndGgsXHJcbiAgICBBbmdsZSxcclxuICAgIFRpbWUsXHJcbiAgICBSZXNvbHV0aW9uLFxyXG4gICAgRnJlcXVlbmN5LFxyXG4gICAgUG9zaXRpb24sXHJcbiAgICBBdFBvc2l0aW9uLFxyXG4gICAgQXNwZWN0UmF0aW8sXHJcbiAgICBDb2xvcixcclxuICAgIE11bHRpUG9zaXRpb24sXHJcbiAgICBNdWx0aUxlbmd0aFdpdGhTcGFjZSxcclxuICAgIE11bHRpVGltZVdpdGhDb21tYSxcclxuICAgIE9uZU9yTWFueVdpdGhDb21tYSxcclxuICAgIE9uZU9yTWFueVdpdGhTbGFzaCxcclxuICAgIFVuaXRsZXNzT3JQZXJjZW50LFxyXG4gICAgUmFkaXVzLFxyXG4gICAgQm9yZGVyLFxyXG4gICAgQm9yZGVyUmFkaXVzLFxyXG4gICAgR3JpZEF4aXMsXHJcbiAgICBHcmlkVHJhY2ssXHJcbiAgICBRdW90ZWQsXHJcbiAgICBGb250U3R5bGUsXHJcbiAgICBCb3hTaGFkb3dTaW5nbGUsXHJcbiAgICBCb3hTaGFkb3csXHJcbiAgICBBbHdheXNQZXJjZW50LFxyXG4gICAgQ29sb3JTZXBhcmF0aW9uLFxyXG4gICAgTWFya2VyLFxyXG4gICAgQ29sb3JzLFxyXG5cclxuICAgIC8vIGluZGljYXRlcyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBuZWVkZWQgdG8ga2VlcCBjb252ZXJzaW9uIGZ1bmN0aW9ucy4gVGhpcyBpcyB1c2VkIHdoZW5cclxuICAgIC8vIHdlIGNyZWF0ZSB0aGlzIGFycmF5IGJlbG93LiBBbnkgbmV3IGVudW1lcmF0aW9uIG1lbWJlcnMgbXVzdCBiZSBhZGRlZCBiZWZvcmUgdGhpcy5cclxuICAgIExhc3RcclxufVxyXG5cclxuLyoqXHJcbiAqIEFycmF5IG9mIHdlbGwga25vd24gY29udmVyc2lvbiBmdW5jdGlvbnMuIEluZGV4ZXMgYXJlIHRoZSBpZGVudGlmaWVyIG9mIHdlbGwga25vd24gZnVuY3Rpb25zXHJcbiAqIGZyb20gdGhlIFdlbGxLbm93bkZ1bmMgZW51bWVyYXRpb25cclxuICovXHJcbmV4cG9ydCBsZXQgd2tmOiBBbnlUb1N0cmluZ0Z1bmNbXSA9IG5ldyBBcnJheSggV0tGLkxhc3QpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFAyU09wdGlvbiB0eXBlIGRlZmluZXMgYSBuYW1lIG9mIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0IGFsb25nIHdpdGggdGhlIG9wdGlvbnMgb2YgaG93XHJcbiAqIHRoaXMgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nLiBUaGUgdHlwZSBpcyBlaXRoZXIgYSBwcm9wZXJ0eSBuYW1lIG9yIGEgdHVwbGVcclxuICogd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIHByb3BlcnR5IG5hbWUgYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGUgVjJTT3B0aW9ucyB2YWx1ZS5cclxuICogSWYgdGhlIHR1cGxlIGhhcyBhIHRoaXJkIHN0cmluZyBlbGVtZW50IGl0IGlzIHBsYWNlZCBiZWZvcmUgdGhlIGNvbnZlcnRlZCBwcm9wZXJ0eSB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIFAyU09wdGlvbiA9IHN0cmluZyB8IFtzdHJpbmcsIFYyU09wdGlvbnM/LCBzdHJpbmc/XTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUDJTT3B0aW9ucyB0eXBlIGRlZmluZXMgbmFtZXMgb2YgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYWxvbmcgd2l0aCB0aGUgb3B0aW9ucyBvZiBob3dcclxuICogZWFjaCBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcuIFRoZSB0eXBlIGlzIGFuIGFycmF5IG9mIGVpdGhlciBwcm9wZXJ0eSBuYW1lcyBvciB0dXBsZXNcclxuICogd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIHByb3BlcnR5IG5hbWUgYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGUgVjJTT3B0aW9ucyB2YWx1ZS5cclxuICogSWYgdGhlIHR1cGxlIGhhcyBhIHRoaXJkIHN0cmluZyBlbGVtZW50IGl0IGlzIHBsYWNlZCBiZWZvcmUgdGhlIGNvbnZlcnRlZCBwcm9wZXJ0eSB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIFAyU09wdGlvbnMgPSBQMlNPcHRpb25bXTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIERlZmluZXMgb3B0aW9ucyB0byBwcm9jZXNzIHR1cGxlcy4gUHJvcGVydHkgbmFtZXMgYXJlIGFjdHVhbGx5IGludGVnZXIgbnVtYmVycywgd2hjaWggYXJlXHJcbiAqIGNvbXBhcmVkIHRvIHRoZSB0dXBsZXMnIGxlbmd0aHMuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBUMlNPcHRpb25zID0geyBbTjogbnVtYmVyXTogVjJTT3B0aW9uc1tdLCBhbnk/OiBWMlNPcHRpb25zW10gfTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBWMlNPcHRpb25zIHR5cGUgZGVmaW5lcyBvcHRpb25zIG9uIGhvdyB0byBjb252ZXJ0IHZhbHVlcyBvZiBkaWZmZXJudFxyXG4gKiB0eXBlcyB0byBzdHJpbmdzLiBBIHZhbHVlIGlzIGNvbnZlcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBydWxlczpcclxuICogLSBJZiB0aGUgb3B0aW9uIGlzIGEgbnVtYmVyIGl0IGlzIHRyZWF0ZWQgYXMgYW4gSUQgb2YgYSByZWdpc3RlcmVkIGNvbnZlcnNpb24gZnVuY3Rpb24uXHJcbiAqIC0gSWYgdGhlIG9wdGlvbiBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBpbnZva2VkIHRvIGNvbnZlcnQgdGhlIHZhbHVlLlxyXG4gKiAtIElmIHRoZSBvcHRpb24gaXMgYW4gb2JqZWN0LCB0aGVuIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiB0aGUgdmFsdWUsIG9uZSBvZiB0aGUgZnJvbVh4eFxyXG4gKiAgIG1ldGhvZHMgZGVmaW5lcyBob3cgdGhlIHZhbHVlIGlzIGNvbnZlcnRlZC5cclxuICovXHJcbmV4cG9ydCB0eXBlIFYyU09wdGlvbnMgPSBXS0YgfCBBbnlUb1N0cmluZ0Z1bmMgfFxyXG57XHJcbiAgICAvLyBTdHJpbmcgdmFsdWUgdG8gdXNlIG9yIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWRcclxuICAgIG5pbD86IHN0cmluZyB8ICgodmFsPzogbnVsbCkgPT4gc3RyaW5nKTtcclxuXHJcbiAgICAvLyBGZnVuY3Rpb24gdG8gY2FsbCBpZiB2YWx1ZSBpcyBhIGJvb2xlYW5cclxuICAgIGJvb2w/OiAodmFsOiBib29sZWFuKSA9PiBzdHJpbmc7XHJcblxyXG4gICAgLy8gT3B0aW9ucyB0byB1c2UgaWYgdmFsdWUgaXMgYSBzdHJpbmcuIFRoaXMgYWxsb3dzIHRyYW5zZm9ybWluZyBvbmUgc3RyaW5nIHRvIGFub3RoZXIuXHJcbiAgICBzdHI/OiBXS0YgfCAoKHZhbDogc3RyaW5nKSA9PiBzdHJpbmcpO1xyXG5cclxuICAgIC8vIE9wdGlvbnMgdG8gdXNlIGlmIHZhbHVlIGlzIGEgbnVtYmVyXHJcbiAgICBudW0/OiBXS0YgfCBOdW1iZXJUb1N0cmluZ0Z1bmM7XHJcblxyXG4gICAgLy8gT3B0aW9ucyB0byB1c2UgaWYgdmFsdWUgaXMgYW4gYXJyYXlcclxuICAgIGFycj86IFdLRiB8IFYyU09wdGlvbnNbXSB8IFQyU09wdGlvbnMgfCAoKHZhbDogYW55W10pID0+IHN0cmluZyk7XHJcblxyXG4gICAgLy8gT3B0aW9ucyB0byB1c2UgaWYgdmFsdWUgaXMgYW4gYXJyYXkgYW5kIHRoZSBmaXJzdCBlbGVtZW50IG9mIGl0IGlzIGFsc28gYW4gYXJyYXlcclxuICAgIGFycjI/OiBXS0YgfCBWMlNPcHRpb25zIHwgKCh2YWw6IGFueVtdKSA9PiBzdHJpbmcpO1xyXG5cclxuICAgIC8vIE9wdGlvbnMgdG8gdXNlIGlmIHZhbHVlIGlzIGFuIG9iamVjdFxyXG4gICAgb2JqPzogVjJTT3B0aW9ucyB8IFAyU09wdGlvbnM7XHJcblxyXG4gICAgLy8gT3B0aW9ucyB0byB1c2UgaWYgdHlwZS1zcGVjaWZpYyBmdW5jdGlvbiBpcyBub3QgZGVmaW5lZCBleGNlcHQgZm9yIG51bGwgYW5kIHN0cmluZyB2YWx1ZXMuXHJcbiAgICAvLyBUaGlzIGlzIGFsc28gdXNlZCBmb3IgYXJyYXkgZWxlbWVudHMgaWYgYXJySXRlbUZ1bmMgaXMgbm90IGRlZmluZWQuXHJcbiAgICBhbnk/OiBWMlNPcHRpb25zO1xyXG5cclxuICAgIC8vIE9wdGlvbnMgdG8gdXNlIHRvIGNvbnZlcnQgZWFjaCBhcnJheSBpdGVtIC0gdXNlZCBvbmx5IGlmIGBhcnJgIGlzIG5vdCBkZWZpbmVkXHJcbiAgICBpdGVtPzogVjJTT3B0aW9ucztcclxuXHJcbiAgICAvLyBTZXBhcmF0b3IgZm9yIGFycmF5IGl0ZW1zIHVzZWQgd2l0aCB0aGUgaXRlbSBvciBvYmogcHJvcGVydGllcy4gSWYgbm90IHNwZWNpZmllZCwgYVxyXG4gICAgLy8gc2luZ2xlIHNwYWNlIHdpbGwgYmUgdXNlZC5cclxuICAgIHNlcD86IHN0cmluZztcclxuXHJcbiAgICAvLyBGbGFnIGluZGljYXRpbmcgdGhhdCB0aGlzIG9wdGlvbiBvYmplY3Qgc2hvdWxkIGJlIHBhc3NlZCByZWN1cnNpdmVseSBpbnRvIGFycmF5cyB3aXRoaW5cclxuICAgIC8vIGFycmF5cy5cclxuICAgIHJlY3Vyc2l2ZT86IGJvb2xlYW47XHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHZhbHVlIG9mIGFuIGFyYml0cmFyeSB0eXBlIHRvIGEgc2luZ2xlIHN0cmluZy4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyXHJcbiAqIGNhbiBkZWZpbmUgaG93IHNwZWNpZmljIHR5cGVzIGFyZSBjb252ZXJ0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdjJzID0gKHZhbDogYW55LCBvcHRpb25zPzogVjJTT3B0aW9ucyk6IHN0cmluZyA9PlxyXG57XHJcbiAgICAvLyBpZiBvcHRpb25zIGlzIG5vdCBzcGVjaWZpZWQsIGRvIHN0YW5kYXJkIHByb2Nlc3NpbmdcclxuICAgIGlmIChvcHRpb25zID09IG51bGwpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxyXG4gICAgICAgICAgICByZXR1cm4gYTJzKCB2YWwpO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgcmV0dXJuIHYycyh2YWwoKSk7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWxbc3ltVjJTXSA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsW3N5bVYyU10oKTtcclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsLmZuID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICByZXR1cm4gZmRvMnMoIHZhbCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG8gZGlmZmVyZW50IHRoaW5ncyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIG9wdGlvbnNcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiB3a2Zbb3B0aW9uc10gPyB3a2Zbb3B0aW9uc10odmFsKSA6IFwiXCI7XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMoIHZhbCk7XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gcHJvY2Vzc2luZyB3aXRoIG9wdGlvbnMuIEZvciBhbGwgdHlwZXMgZXhjZXB0IG51bGwgYW5kIHN0cmluZywgaWYgdGhlIHR5cGUtc3BlY2lmaWNcclxuICAgICAgICAvLyBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZCwgdXNlIG9wdGlvbnMuYW55IGlmIGRlZmluZWQuXHJcbiAgICAgICAgbGV0IG5ld09wdGlvbnM6IFYyU09wdGlvbnMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubmlsID8gdHlwZW9mIG9wdGlvbnMubmlsID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5uaWwgOiBvcHRpb25zLm5pbCggdmFsKSA6IFwiXCI7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMubnVtID8/IG9wdGlvbnMuYW55O1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgcmV0dXJuIHYycyggdmFsKCkpO1xyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICggdmFsLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5hcnIgPT09IFwib2JqZWN0XCIpIC8vIHRoaXMgY2FuIGFsc28gYmUgYW4gYXJyYXlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0MnMoIHZhbCwgb3B0aW9ucy5hcnIsIG9wdGlvbnMuc2VwKVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmFycjIgJiYgQXJyYXkuaXNBcnJheSh2YWxbMF0pKVxyXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuYXJyMjtcclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5hcnIpXHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy5hcnI7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBhMnMoIHZhbCwgb3B0aW9ucy5pdGVtID8/IG9wdGlvbnMuYW55ID8/IChvcHRpb25zLnJlY3Vyc2l2ZSA/IG9wdGlvbnMgOiB1bmRlZmluZWQpLCBvcHRpb25zLnNlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbFtzeW1WMlNdID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsW3N5bVYyU10oKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbC5mbiA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBmZG8ycyggdmFsKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vYmogfHwgb3B0aW9ucy5hbnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub2JqKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbzJzKCB2YWwsIG9wdGlvbnMub2JqLCBvcHRpb25zLnNlcCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMub2JqID8/IG9wdGlvbnMuYW55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuc3RyID8/IG9wdGlvbnMuYW55O1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiKVxyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5ib29sID8gb3B0aW9ucy5ib29sKCB2YWwpIDogdmFsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHYycyggdmFsLCBuZXdPcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG53a2ZbV0tGLkRlZmF1bHRdID0gdjJzO1xyXG53a2ZbV0tGLk9uZU9yTWFueVdpdGhDb21tYV0gPSB2ID0+IHYycyggdiwgeyBzZXA6IFwiLFwiIH0pO1xyXG53a2ZbV0tGLk9uZU9yTWFueVdpdGhTbGFzaF0gPSB2ID0+IHYycyggdiwgeyBzZXA6IFwiL1wiIH0pO1xyXG53a2ZbV0tGLlF1b3RlZF0gPSB2ID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gYFwiJHt2fVwiYCA6IHYycyh2KTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhcnJheSB0byBhIHNpbmdsZSBzdHJpbmcgYnkgY29udmVydGluZyBldmVyeSBpdGVtIHVzaW5nIHRoZSBnaXZlbiBvdGlvbnNcclxuICogYW5kIGpvaW5pbmcgdGhlIHJlc3VsdHMgd2l0aCB0aGUgZ2l2ZW4gZGVsaW1pdGVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGEycyA9ICh2YWw6IGFueVtdLCBvcHRpb25zPzogVjJTT3B0aW9ucywgc2VwYXJhdG9yOiBzdHJpbmcgPSBcIiBcIik6IHN0cmluZyA9PlxyXG4gICAgIXZhbCB8fCB2YWwubGVuZ3RoID09PSAwXHJcbiAgICAgICAgPyBcIlwiXHJcbiAgICAgICAgOiB2YWwubWFwKCB2ID0+IHYycyggdiwgb3B0aW9ucykpLmZpbHRlciggdiA9PiAhIXYpLmpvaW4oIHNlcGFyYXRvcik7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYXJyYXkgdG8gYSBzaW5nbGUgc3RyaW5nIGJ5IGNvbnZlcnRpbmcgZXZlcnkgaXRlbSB1c2luZyB0aGUgZ2l2ZW4gb3Rpb25zXHJcbiAqIGFuZCBqb2luaW5nIHRoZSByZXN1bHRzIHdpdGggdGhlIGdpdmVuIGRlbGltaXRlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCB0MnMgPSAodmFsOiBhbnlbXSwgb3B0aW9uczogVjJTT3B0aW9uc1tdIHwgVDJTT3B0aW9ucywgc2VwYXJhdG9yOiBzdHJpbmcgPSBcIiBcIik6IHN0cmluZyA9PlxyXG57XHJcbiAgICBsZXQgdjJzT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucykgPyBvcHRpb25zIDogKG9wdGlvbnNbdmFsLmxlbmd0aF0gPz8gb3B0aW9ucy5hbnkpO1xyXG4gICAgaWYgKCF2MnNPcHRpb25zKVxyXG4gICAgICAgIHJldHVybiBhMnMoIHZhbCwgdW5kZWZpbmVkLCBzZXBhcmF0b3IpO1xyXG5cclxuICAgIGxldCBidWY6IHN0cmluZ1tdID0gW107XHJcbiAgICBmb3IoIGxldCBpID0gMDsgaSA8IHYyc09wdGlvbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYnVmLnB1c2goIHYycyggdmFsW2ldLCB2MnNPcHRpb25zW2ldKSk7XHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5maWx0ZXIoIHYgPT4gISF2KS5qb2luKHNlcGFyYXRvcik7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCB0byBzdHJpbmcgYnkgY29udmVydGluZyBlYWNoIHByb3BlcnR5IGZyb20gdGhlIG9wdGlvbnNcclxuICogYXJyYXkgYW5kIGpvaW5pbmcgdGhlbSB1c2luZyB0aGUgZ2l2ZW4gc2VwYXJhdG9yLlxyXG4gKiBAcGFyYW0gdmFsIE9iamVjdCB0byBjb252ZXJ0IHRvIHN0cmluZ1xyXG4gKiBAcGFyYW0gb3B0aW9ucyBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvciB0dXBsZXMgd2l0aCBwcm9wZXJ0eSBuYW1lcywgb3B0aW9ucyBhbmQgcHJlZml4ZXMuXHJcbiAqIEBwYXJhbSBzZXBhcmF0b3IgU2VwYXJhdG9yIGNoYXJhY3Rlci5cclxuICogQHBhcmFtIGRlZmF1bHRPcHRpb25zIC0gVjJTT3B0aW9ucyBmb3IgdGhvc2UgcHJvcGVydGllcyBpbiB0aGUgXCJwYXJhbXNcIiBhcnJheSB0aGF0IGRvbid0XHJcbiAqIGRlZmluZSB0aGVpciBvd24uIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGNhc2Ugd2hlbiBhbGwgZnVuY3Rpb24gcGFyYW1ldGVycyBhcmUgb2YgdGhlXHJcbiAqIHNhbWUgdHlwZVxyXG4gKiBAcGFyYW0gZGVmYXVsdFByZWZpeCAtIHByZWZpeCB0byB1c2UgZm9yIHRob3NlIHByb3BlcnRpZXMgaW4gdGhlIFwicGFyYW1zXCIgYXJyYXkgdGhhdCBkb24ndFxyXG4gKiBkZWZpbmUgdGhlaXIgb3duIHByZWZpeFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG8ycyA9ICh2YWw6IHtbcDpzdHJpbmddOiBhbnl9LCBvcHRpb25zOiBQMlNPcHRpb25zLCBzZXBhcmF0b3I/OiBzdHJpbmcsXHJcbiAgICBkZWZhdWx0T3B0aW9ucz86IFYyU09wdGlvbnMsIGRlZmF1bHRQcmVmaXg/OiBzdHJpbmcpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgaWYgKHZhbCA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGxldCBwYXJhbXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBmb3IoIGxldCBuYW1lT3JUdXBsZSBvZiBvcHRpb25zKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGdldCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWU7XHJcbiAgICAgICAgLy8gaWYgdGhlIHByb3BlcnRpZXMgdmFsdWUgaXMgbm90IGRlZmluZWQsIHNraXAgaXQuXHJcbiAgICAgICAgbGV0IHByb3BOYW1lID0gdHlwZW9mIG5hbWVPclR1cGxlID09PSBcInN0cmluZ1wiID8gbmFtZU9yVHVwbGUgOiBuYW1lT3JUdXBsZVswXTtcclxuICAgICAgICBsZXQgcHJvcFZhbCA9IHZhbFtwcm9wTmFtZV07XHJcbiAgICAgICAgaWYgKHByb3BWYWwgPT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHByZWZpeFxyXG4gICAgICAgIGxldCBwcmVmaXggPSB0eXBlb2YgbmFtZU9yVHVwbGUgPT09IFwic3RyaW5nXCIgPyBkZWZhdWx0UHJlZml4IDogbmFtZU9yVHVwbGVbMl07XHJcbiAgICAgICAgaWYgKHByZWZpeClcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goIHByZWZpeCk7XHJcblxyXG4gICAgICAgIGxldCBvcHRpb25zID0gdHlwZW9mIG5hbWVPclR1cGxlID09PSBcInN0cmluZ1wiID8gZGVmYXVsdE9wdGlvbnMgOiBuYW1lT3JUdXBsZVsxXTtcclxuICAgICAgICBwYXJhbXMucHVzaCggdjJzKCBwcm9wVmFsLCBvcHRpb25zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmFtcy5maWx0ZXIoIHYgPT4gISF2KS5qb2luKCBzZXBhcmF0b3IgPz8gXCIgXCIpO1xyXG59XHJcblxyXG5cclxuXHJcbi8vIFR5cGUgcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIHZhbHVlcyBvciB0d28taXRlbSB0dXBsZXMgd2hlcmUgdGhlIGl0ZW0gaXMgYSB2YWx1ZSBhbmQgdGhlXHJcbi8vIHNlY29uZCBpdGVtIGlzIHRoZSBWMlNPcHRpb25zIG9iamVjdCBkZXRlcm1pbmluZyBob3cgdGhpcyB2YWx1ZSBzaG91bGQgYmUgc2VyaWFsaXplZC5cclxuZXhwb3J0IHR5cGUgUGFyYW1MaXN0V2l0aE9wdGlvbnMgPSAoYW55IHwgW2FueSwgVjJTT3B0aW9ucz9dKVtdO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGFycmF5IG9mIHZhbHVlcyB0byBhIHNpbmdsZSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgb3B0aW9ucyBhbmRcclxuICogdXNpbmcgdGhlIGdpdmVuIHNlcGFyYXRvci4gRm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXksIHRoZSB2MnMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGNvbnZlcnRcclxuICogaXQgdG8gc3RyaW5nLlxyXG4gKiBAcGFyYW0gdmFsdWVzXHJcbiAqIEBwYXJhbSBzZXBhcmF0b3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBtdjJzID0gKHZhbHVlczogUGFyYW1MaXN0V2l0aE9wdGlvbnMsIHNlcGFyYXRvcjogc3RyaW5nID0gXCIgXCIpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgaWYgKHZhbHVlcyA9PSBudWxsIHx8IHZhbHVlcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgbGV0IGFycjogc3RyaW5nW10gPSBbXTtcclxuICAgIGZvciggbGV0IGl0ZW0gb2YgdmFsdWVzKVxyXG4gICAge1xyXG4gICAgICAgIGxldCB2YWw6IGFueTtcclxuICAgICAgICBsZXQgb3B0aW9uczogVjJTT3B0aW9ucyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbCA9IGl0ZW1bMF07XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpdGVtWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHZhbCA9IGl0ZW07XHJcblxyXG4gICAgICAgIGlmICh2YWwgfHwgKG9wdGlvbnMgJiYgKG9wdGlvbnMgYXMgYW55KS5uaWwpKVxyXG4gICAgICAgICAgICBhcnIucHVzaCggdjJzKCB2YWwsIG9wdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyLmZpbHRlciggdiA9PiAhIXYpLmpvaW4oIHNlcGFyYXRvcik7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZXMgYXMgcGFyYW1ldGVycyB0byB0aGUgZ2l2ZW4gQ1NTIGZ1bmN0aW9uIGludm9jYXRpb24uXHJcbiAqIEBwYXJhbSBuYW1lXHJcbiAqIEBwYXJhbSB2YWx1ZXNcclxuICogQHBhcmFtIHNlcGFyYXRvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGYycyA9IChuYW1lOiBzdHJpbmcsIHZhbHVlczogUGFyYW1MaXN0V2l0aE9wdGlvbnMsIHNlcGFyYXRvciA9IFwiLFwiKSA9PlxyXG4gICAgYCR7bmFtZX0oJHttdjJzKCB2YWx1ZXMsIHNlcGFyYXRvcil9KWA7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgdGFnMnMgaXMgYSB0YWcgZnVuY3Rpb24gaGVscGVyIHRoYXQgY29udmVydHMgdGhlIHRlbXBsYXRlIHN0cmluZyB3aXRoXHJcbiAqIHBhcmFtZXRlcnMgdG8gYSBzdHJpbmcgdXNpbmcgdGhlIGdpdmVuIG9wdGlvbnMgb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRhZzJzID0gKHBhcnRzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgcGFyYW1zOiBhbnlbXSwgb3B0aW9ucz86IFYyU09wdGlvbnMpOiBzdHJpbmcgPT5cclxue1xyXG4gICAgLy8gbnVtYmVyIG9mIHBhcmFtZXRlcnMgaXMgYWx3YXlzIDEgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2Ygc3RyaW5nIHBhcnRzXHJcbiAgICBsZXQgcGFyYW1zTGVuID0gcGFyYW1zLmxlbmd0aDtcclxuICAgIGlmIChwYXJhbXNMZW4gPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xyXG5cclxuICAgIGxldCBzID0gXCJcIjtcclxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgcGFyYW1zTGVuOyBpKyspXHJcbiAgICAgICAgcyArPSBwYXJ0c1tpXSArIHYycyggcGFyYW1zW2ldLCBvcHRpb25zKTtcclxuXHJcbiAgICAvLyBhZGQgdGhlIGxhc3QgcGFydFxyXG4gICAgcmV0dXJuIHMgKyBwYXJ0c1twYXJhbXNMZW5dO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBPYmplY3QgdGhhdCBzcGVjaWZ5aW5nIHN0cmluZyBzZXJpYWxpemF0aW9uIG9wdGlvbnMgZm9yIHByb3BlcnRpZXMgaW4gYSBwcm9wZXJ0eSBzZXQuIEVhY2hcclxuICogcHJvcGVydHkgb2YgYSBwcm9wZXJ0eSBzZXQgd2lsbCBiZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgVjJTT3B0aW9ucyBwYXJhbWV0ZXIgaW4gdGhpc1xyXG4gKiBvYmplY3Q7IGlmIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhpcyBvYmplY3QsIHRoZSB2MnMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUHJvcFNldEluZm9zID0geyBbSzogc3RyaW5nXTogVjJTT3B0aW9ucyB9O1xyXG5cclxuLyoqXHJcbiAqIE9iamVjdCB0aGF0IHNwZWNpZmllcyBvcHRpb25zIGZvciBzdHJpbmcgc2VyaWFsaXphdGlvbiBvZiBhIHByb3BlcnR5IHNldC5cclxuICovXHJcbmV4cG9ydCB0eXBlIFByb3BTZXQyU09wdGlvbnMgPSB7XHJcbiAgICBwcmVmaXg/OiBzdHJpbmc7XHJcbiAgICBzdWZmaXg/OiBzdHJpbmc7XHJcbiAgICBzZXBhcmF0b3I/OiBzdHJpbmc7XHJcbiAgICBwcm9wRnVuYz86IChkYXNoTmFtZTogc3RyaW5nLCBjYW1lbE5hbWU6IHN0cmluZywgdmFsOiBhbnksIG9wdGlvbnM6IFYyU09wdGlvbnMpID0+IHN0cmluZztcclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBwcm9wZXJ0eSBzZXQgb2JqZWN0IHRvIHRoZSBDU1Mgc3R5bGUgc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHByb3BTZXQycyA9ICh2YWw6IGFueSwgaW5mb3M6IFByb3BTZXRJbmZvcywgb3B0aW9ucz86IFByb3BTZXQyU09wdGlvbnMpOiBzdHJpbmcgPT5cclxuICAgIHYycyggdmFsLCB7XHJcbiAgICAgICAgb2JqOiB2ID0+IHtcclxuICAgICAgICAgICAgbGV0IHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKCB2KTtcclxuICAgICAgICAgICAgaWYgKHByb3BOYW1lcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgICAgIGxldCBmdW5jID0gb3B0aW9ucz8ucHJvcEZ1bmMgPz8gcHJvcEluUHJvcFNldDJzO1xyXG4gICAgICAgICAgICBsZXQgYXJyID0gcHJvcE5hbWVzLm1hcCggKHByb3BOYW1lKSA9PlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGFzaFByb3BOYW1lID0gY2FtZWxUb0Rhc2gocHJvcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNhbWVsUHJvcE5hbWUgPSBkYXNoVG9DYW1lbChwcm9wTmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuYyggZGFzaFByb3BOYW1lLCBjYW1lbFByb3BOYW1lLCB2W3Byb3BOYW1lXSwgaW5mb3NbY2FtZWxQcm9wTmFtZV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIChvcHRpb25zPy5wcmVmaXggPz8gXCJcIikgKyBgJHthcnIuam9pbiggb3B0aW9ucz8uc2VwYXJhdG9yID8/IFwiO1wiKX1gICsgKG9wdGlvbnM/LnN1ZmZpeCA/PyBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8vIGNvbnZlcnQgdGhlIHZhbHVlIHRvIHN0cmluZyBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gb2JqZWN0IGZvciB0aGUgcHJvcGVydHkgKGlmIGRlZmluZWQpXHJcbmNvbnN0IHByb3BJblByb3BTZXQycyA9IChkYXNoTmFtZTogc3RyaW5nLCBjYW1lbE5hbWU6IHN0cmluZywgdmFsOiBhbnksIG9wdGlvbnM6IFYyU09wdGlvbnMpOiBzdHJpbmcgPT5cclxuICAgIGAke2Rhc2hOYW1lfTokeyB2MnMoIHZhbCwgb3B0aW9ucyl9YDtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgdGhhdCBkZWZpbmVzIGhvdyB0byBzZXJpYWxpemUgYSB2YWx1ZSBmb3IgYW4gZW50cnkgaW4gdGhlIGZ1bmN0aW9uIGRlZmluaXRpb25zIG9iamVjdC5cclxuICogVGhlIHZhbHVlIGNhbiBiZSBvZiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlcyB3aXRoIGVhY2ggY29ycmVzcG9uZGluZyB0byBhIGNlcnRhaW4gd2F5IG9mXHJcbiAqIHN0cmluZyBzZXJpYWxpemF0aW9uOlxyXG4gKiAgIC0gZnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZC5cclxuICogICAtIG51bWJlciAtIGFsbCBvYmplY3QgcHJvcGVydGllcyBleGNlcHQgXCJmblwiIGFyZSBjb252ZXJ0ZWQgdXNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb25cclxuICogICAgIGZyb20gdGhlIFdLRiBlbnVtZXJhdGlvbi4gU2luY2UgdGhlIGVudW1lcmF0aW5nIG9yZGVyIG9mIHRoZSBwcm9wZXJ0aWVzIGlzIGluZGV0ZXJtaW5hdGUsXHJcbiAqICAgICB0aGlzIG9wdGlvbiBpcyBvbmx5IGdvb2QgZm9yIGZ1bmN0aW9ucyB3aXRoIGEgc2luZ2xlIHBhcmFtZXRlci5cclxuICogICAtIGFycmF5IG9mIFAyU09wdGlvbiB0eXBlcyAtIG8ycyBpcyBpdm9rZWRcclxuICogICAtIG9iamVjdCAtIG1heSBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICogICAgIC0gb3B0aW9uYWwgXCJmblwiIC0gcmVwbGFjZXMgZnVuY3Rpb24gbmFtZS5cclxuICogICAgIC0gb3B0aW9uYWwgXCJwXCIgLSBhcnJheSBvZiBQMlNPcHRpb24gdHlwZXMsIGZvciB3aGljaCBvMnMgaXMgaW52b2tlZC5cclxuICogICAgIC0gb3B0aW9uYWwgXCJmXCIgLSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGxpc3Qgb2YgcGFyYW1ldGVycy5cclxuICogICAgIC0gZWl0aGVyIFwicFwiIG9yIFwiZlwiIG11c3QgYmUgcHJlc2VudCBhbmQgXCJwXCIgaGFzIHByZWNlZGVuY2UuXHJcbiAqICAgICAtIG9wdGlvbmFsIFwic2VwXCIgZm9yIHNlcGFyYXRvciAoZGVmYXVsdCBpcyBcIixcIikuXHJcbiAqICAgICAtIG9wdGlvbmFsIFwiZG9cIiAtIGRlZmluZXMgVjJTT3B0aW9ucyBmb3IgdGhvc2UgcHJvcGVydGllcyBpbiB0aGUgXCJwYXJhbXNcIiBhcnJheSB0aGF0IGRvbid0XHJcbiAqICAgICAgIGRlZmluZSB0aGVpciBvd24uIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGNhc2Ugd2hlbiBhbGwgZnVuY3Rpb24gcGFyYW1ldGVycyBhcmUgb2YgdGhlXHJcbiAqICAgICAgIHNhbWUgdHlwZVxyXG4gKiAgICAgLSBvcHRpb25hbCBcImRwXCIgLSBkZWZhdWx0IHByZWZpeCB0byB1c2UgZm9yIHRob3NlIHByb3BlcnRpZXMgaW4gdGhlIFwicGFyYW1zXCIgYXJyYXkgdGhhdFxyXG4gKiAgICAgICBkb24ndCBkZWZpbmUgdGhlaXIgb3duIHByZWZpeFxyXG4gKi9cclxudHlwZSBGZG9PcHRpb25zID0gQW55VG9TdHJpbmdGdW5jIHwgbnVtYmVyIHwgUDJTT3B0aW9ucyB8XHJcbiAgICB7XHJcbiAgICAgICAgZm4/OiBzdHJpbmcgfCBBbnlUb1N0cmluZ0Z1bmMsXHJcbiAgICAgICAgcD86IFAyU09wdGlvbnMsXHJcbiAgICAgICAgZj86IEFueVRvU3RyaW5nRnVuYyxcclxuICAgICAgICBzPzogc3RyaW5nLFxyXG4gICAgICAgIGRvPzogVjJTT3B0aW9ucyxcclxuICAgICAgICBkcD86IHN0cmluZ1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4vLyBUaGlzIG9iamVjdCBpcyBmaWxsZWQgaW4gaW4gdGhlIFh4eEFQSSBmaWxlcyB3aGVyZSB0aGUgZnVuY3Rpb25zIGNvcnJlc3BvbmRpbmcgdG8gQ1NTIGZ1bmN0aW9uc1xyXG4vLyBhcmUgZGVmaW5lZC5cclxuZXhwb3J0IGNvbnN0IGZkbzogeyBbZm46IHN0cmluZ106IEZkb09wdGlvbnMgfSA9IHt9O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZnVuY3Rpb24gZGVmaW5pdGlvbiBvYmplY3QgdG8gc3RyaW5nLiBDb252ZXJzaW9uIGlzIHBlcmZvcm1lZCBhY2NvcmRpbmdcclxuICogdG8gdGhlIHR5cGUgZm91bmQgaW4gdGhlIFwiZmRvXCIgb2JqZWN0IGZvciB0aGUgcHJvcGVydHkgbmFtZSBlcXVhbCB0byB0aGUgXCJmblwiIHByb3BlcnR5IG9mXHJcbiAqIHRoZSBnaXZlbiB2YWx1ZS4gSWYgbm8gc3VjaCBwcm9wZXJ0eSBleGlzdCBpbiB0aGUgXCJmZG9cIiBvYmplY3QsIGFsbCBvYmplY3QncyBwcm9wZXJ0aWVzIGV4Y2VwdFxyXG4gKiBcImZuXCIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5ncyB1c2luZyB2MnMgYW5kIGNvbmNhdGVuYXRlZCB3aXRoIGNvbW1hLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsIEZ1bmN0aW9uIGRlZmluaXRpb24gb2JqZWN0IHRoYXQgaGFzIHRoZSBcImZuXCIgcHJvcGVydHkgZGVmaW5pbmcgdGhlIGZ1bmN0aW9uIG5hbWUuXHJcbiAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBDU1MgZnVuY3Rpb24gaW52b2NhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBmZG8ycyA9ICh2YWw6IElDc3NGdW5jT2JqZWN0KTogc3RyaW5nID0+XHJcbntcclxuICAgIGxldCBvcHRpb25zID0gZmRvW3ZhbC5mbl07XHJcbiAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgcmV0dXJuIGdvT3ZlclByb3BzKHZhbCk7XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICByZXR1cm4gZ29PdmVyUHJvcHMoIHZhbCwgb3B0aW9ucyk7XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zKCB2YWwpO1xyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSlcclxuICAgICAgICByZXR1cm4gYCR7dmFsLmZufSgke28ycyggdmFsLCBvcHRpb25zLCBcIixcIil9KWA7XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcclxuICAgICAgICBmbiA9ICFmbiA/IHZhbC5mbiA6IHR5cGVvZiBmbiA9PT0gXCJzdHJpbmdcIiA/IGZuIDogZm4odmFsKTtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5wXHJcbiAgICAgICAgICAgID8gYCR7Zm59KCR7bzJzKCB2YWwsIG9wdGlvbnMucCwgb3B0aW9ucy5zID8/IFwiLFwiLCBvcHRpb25zLmRvLCBvcHRpb25zLmRwKX0pYFxyXG4gICAgICAgICAgICA6IG9wdGlvbnMuZlxyXG4gICAgICAgICAgICAgICAgPyBgJHtmbn0oJHtvcHRpb25zLmYodmFsKX0pYFxyXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBnb2VzIG92ZXIgdGhlIHByb3BzIG9mIHRoZSBnaXZlbiBvYmplY3QgZXhjZXB0IHRoZSBcImZuXCIgcHJvcGVydHksXHJcbiAqIHNlcmlhbGl6ZXMgYWxsIHRoZSBwcm9wcyB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgY29uY2F0ZW5hdGVzIHRoZW0gd2l0aCB0aGUgZ2l2ZW5cclxuICogc2VwYXJhdG9yIChjb21tYSBieSBkZWZhdWx0KS5cclxuICogQHBhcmFtIHZhbFxyXG4gKiBAcGFyYW0gb3B0aW9uc1xyXG4gKiBAcGFyYW0gc2VwXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5jb25zdCBnb092ZXJQcm9wcyA9ICh2YWw6IElDc3NGdW5jT2JqZWN0LCBvcHRpb25zPzogVjJTT3B0aW9ucywgc2VwPzogc3RyaW5nKTogc3RyaW5nID0+XHJcbntcclxuICAgIGxldCBidWY6IHN0cmluZ1tdID0gW107XHJcbiAgICBmb3IoIGxldCBwIGluIHZhbClcclxuICAgIHtcclxuICAgICAgICBpZiAocCAhPT0gXCJmblwiKVxyXG4gICAgICAgICAgICBidWYucHVzaCggdjJzKCB2YWxbcF0sIG9wdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYCR7dmFsLmZufSgke2J1Zi5maWx0ZXIodj0+ISF2KS5qb2luKCBzZXAgPz8gXCIsXCIpfSlgO1xyXG59XHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7SUFuaW1hdGlvblJ1bGUsIEFuaW1hdGlvbkZyYW1lLCBBbmltYXRpb25XYXlwb2ludCwgSUFuaW1hdGlvbkZyYW1lUnVsZX0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIlxyXG5pbXBvcnQge0FuaW1hdGlvblN0eWxlc2V0fSBmcm9tIFwiLi4vYXBpL1N0eWxlc2V0c1wiO1xyXG5pbXBvcnQge1J1bGUsIElSdWxlQ29udGFpbmVyLCBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0fSBmcm9tIFwiLi9SdWxlXCJcclxuaW1wb3J0IHtTdHlsZVJ1bGV9IGZyb20gXCIuL1N0eWxlUnVsZXNcIjtcclxuaW1wb3J0IHt2MnMsIFdLRn0gZnJvbSBcIi4uL2ltcGwvVXRpbHNcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBBbmltYXRpb25SdWxlIGNsYXNzIGRlc2NyaWJlcyBhIEBrZXlmcmFtZXMgQ1NTIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uUnVsZSBleHRlbmRzIFJ1bGUgaW1wbGVtZW50cyBJQW5pbWF0aW9uUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBmcmFtZXM/OiBBbmltYXRpb25GcmFtZVtdLCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJQW5pbWF0aW9uUnVsZSlcclxuXHR7XHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdGlmIChmcmFtZXMpXHJcblx0XHRcdHRoaXMuZnJhbWVSdWxlcyA9IGZyYW1lcy5tYXAoIGZyYW1lID0+IG5ldyBBbmltYXRpb25GcmFtZVJ1bGUoIGZyYW1lWzBdLCBmcmFtZVsxXSkpO1xyXG5cclxuXHRcdHRoaXMubmFtZU92ZXJyaWRlID0gbmFtZU92ZXJyaWRlO1xyXG5cdH1cclxuXHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gY29udmVydCBhbiBvYmplY3QgdG8gYSBzdHJpbmcuIEFuaW1hdGlvbiBydWxlIHJldHVybnMgaXRzIG5hbWUuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMubmFtZTsgfVxyXG5cclxuXHJcblx0Ly8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBydWxlLlxyXG5cdHB1YmxpYyBwcm9jZXNzKCBjb250YWluZXI6IElSdWxlQ29udGFpbmVyLCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbClcclxuXHR7XHJcblx0XHRzdXBlci5wcm9jZXNzKCBjb250YWluZXIsIHJ1bGVOYW1lKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBjb250YWluZXIuZ2V0U2NvcGVkTmFtZSggcnVsZU5hbWUsIHRoaXMubmFtZU92ZXJyaWRlKTtcclxuXHJcblx0XHRmb3IoIGxldCBrZXlmcmFtZVJ1bGUgb2YgdGhpcy5mcmFtZVJ1bGVzKVxyXG5cdFx0XHRrZXlmcmFtZVJ1bGUucHJvY2VzcyggY29udGFpbmVyLCBydWxlTmFtZSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIEluc2VydHMgdGhpcyBydWxlIGludG8gdGhlIGdpdmVuIHBhcmVudCBydWxlIG9yIHN0eWxlc2hlZXQuXHJcblx0cHVibGljIGluc2VydCggcGFyZW50OiBDU1NTdHlsZVNoZWV0IHwgQ1NTR3JvdXBpbmdSdWxlKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICghdGhpcy5mcmFtZVJ1bGVzKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dGhpcy5jc3NSdWxlID0gUnVsZS50b0RPTSggYEBrZXlmcmFtZXMgJHt0aGlzLm5hbWV9IHt9YCwgcGFyZW50KSBhcyBDU1NLZXlmcmFtZXNSdWxlO1xyXG5cclxuXHRcdGxldCBjc3NLZXlmcmFtZXNSdWxlID0gdGhpcy5jc3NSdWxlIGFzIENTU0tleWZyYW1lc1J1bGU7XHJcblx0XHRmb3IoIGxldCBmcmFtZVJ1bGUgb2YgdGhpcy5mcmFtZVJ1bGVzKVxyXG5cdFx0e1xyXG5cdFx0XHR0cnlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGNzc0tleWZyYW1lc1J1bGUuYXBwZW5kUnVsZSggZnJhbWVSdWxlLnRvQ3NzKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFsdGhvdWdoIHRoZSBjc3NSdWxlIGluIHRoZSBmcmFtZSBpcyB0eXBlZCBhcyBDU1NTdHlsZVJ1bGUsIHdlIGtub3cgdGhhdCBpblxyXG4gICAgICAgICAgICAgICAgLy8gcHJhY3RpY2UsIGl0IGlzIG9mIHRoZSBDU1NLZXlmcmFtZVJ1bGUgdHlwZS5cclxuXHRcdFx0XHRmcmFtZVJ1bGUuY3NzUnVsZSA9IHRoaXMuY3NzUnVsZS5jc3NSdWxlcy5pdGVtKCAgdGhpcy5jc3NSdWxlLmNzc1J1bGVzLmxlbmd0aCAtIDEpIGFzIENTU1N0eWxlUnVsZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYXRjaCh4KVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJDYW5ub3QgYWRkIENTUyBrZXlmcmFtZSBydWxlXCIsIHgpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBTZXJpYWxpemVzIHRoaXMgcnVsZSB0byBhIHN0cmluZy5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWRcclxuICAgIHtcclxuXHRcdGlmICghdGhpcy5mcmFtZVJ1bGVzKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Y3R4LmFkZFJ1bGUoIGBAa2V5ZnJhbWVzICR7dGhpcy5uYW1lfSB7YCk7XHJcblxyXG5cdFx0Zm9yKCBsZXQgZnJhbWVSdWxlIG9mIHRoaXMuZnJhbWVSdWxlcylcclxuXHRcdFx0Y3R4LmFkZFJ1bGUoIGZyYW1lUnVsZS50b0NzcygpKVxyXG5cclxuXHRcdGN0eC5hZGRSdWxlKCBcIn1cIik7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0LyoqIFNPTSBrZXlmcmFtZXMgcnVsZSAqL1xyXG5cdHB1YmxpYyBjc3NSdWxlOiBDU1NLZXlmcmFtZXNSdWxlO1xyXG5cclxuXHQvKipcclxuXHQgKiBSdWxlJ3MgbmFtZSAtIHRoaXMgaXMgYSB1bmlxdWUgbmFtZSB0aGF0IGlzIGFzc2lnbmVkIGJ5IHRoZSBNaW1jc3MgaW5mcmFzdHVjdHVyZS4gVGhpcyBuYW1lXHJcblx0ICogZG9lc24ndCBoYXZlIHRoZSBwcmVmaXggdGhhdCBpcyB1c2VkIHdoZW4gcmVmZXJyaW5nIHRvIGNsYXNzZXMgKC4pLCBJRHMgKCMpIGFuZCBjdXN0b20gQ1NTXHJcblx0ICogcHJvcGVydGllcyAoLS0pLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBMaXN0IG9mIHN0eWxlIHJ1bGVzIHJlcHJlc2VudGluZyBhbmltYXRpb24gZnJhbWVzICovXHJcblx0cHVibGljIGZyYW1lUnVsZXM6IEFuaW1hdGlvbkZyYW1lUnVsZVtdO1xyXG5cclxuXHQvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG5cdC8vIGlzIG5vdCBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIGJlIHVuaXF1ZWx5IGdlbmVyYXRlZC5cclxuXHRwcml2YXRlIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElBbmltYXRpb25SdWxlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQW5pbWF0aW9uRnJhbWVSdWxlIGNsYXNzIHJlcHJlc2VudHMgYSBzaW5nbGUga2V5ZnJhbWUgY2xhdXNlIGluIHRoZSBhbmltYXRpb24gcnVsZS5cclxuICovXHJcbmNsYXNzIEFuaW1hdGlvbkZyYW1lUnVsZSBleHRlbmRzIFN0eWxlUnVsZSBpbXBsZW1lbnRzIElBbmltYXRpb25GcmFtZVJ1bGVcclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvciggd2F5cG9pbnQ6IEFuaW1hdGlvbldheXBvaW50LCBzdHlsZXNldD86IEFuaW1hdGlvblN0eWxlc2V0IHwgQW5pbWF0aW9uU3R5bGVzZXRbXSlcclxuXHR7XHJcblx0XHRzdXBlciggc3R5bGVzZXQpO1xyXG5cdFx0dGhpcy53YXlwb2ludCA9IHdheXBvaW50O1xyXG5cdH1cclxuXHJcblx0Ly8gUmV0dXJucyB0aGUgc2VsZWN0b3IgcGFydCBvZiB0aGUgc3R5bGUgcnVsZS5cclxuXHRwdWJsaWMgZ2V0U2VsKCk6IHN0cmluZ1xyXG5cdHtcclxuXHRcdHJldHVybiB2MnMoIHRoaXMud2F5cG9pbnQsIHsgYW55OiBXS0YuUGVyY2VudCwgc2VwOiBcIixcIiB9KTtcclxuXHR9XHJcblxyXG5cdC8qKiBJZGVudGlmaWVyIG9mIHRoZSB3YXlwb2ludCAqL1xyXG5cdHB1YmxpYyB3YXlwb2ludDogQW5pbWF0aW9uV2F5cG9pbnQ7XHJcblxyXG5cdC8qKlxyXG4gICAgICogU09NIGtleWZyYW1lIHJ1bGUuIEFsdGhvdWdoIHRoZSBjc3NSdWxlIGluIHRoZSBmcmFtZSBpcyB0eXBlZCBhcyBDU1NTdHlsZVJ1bGUsIHdlIGtub3cgdGhhdFxyXG4gICAgICogaW4gcHJhY3RpY2UsIGl0IGlzIG9mIHRoZSBDU1NLZXlmcmFtZVJ1bGUgdHlwZS5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBnZXQgY3NzS2V5ZnJhbWVSdWxlKCk6IENTU0tleWZyYW1lUnVsZSB7IHJldHVybiB0aGlzLmNzc1J1bGUgYXMgYW55IGFzIENTU0tleWZyYW1lUnVsZTsgfTtcclxufVxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQge0V4dGVuZGVkQ291bnRlclN0eWxlc2V0fSBmcm9tIFwiLi4vYXBpL0NvdW50ZXJUeXBlc1wiO1xyXG5pbXBvcnQge0lDb3VudGVyUnVsZSwgSUNvdW50ZXJTdHlsZVJ1bGV9IGZyb20gXCIuLi9hcGkvUnVsZVR5cGVzXCJcclxuaW1wb3J0IHtjb3VudGVyU3R5bGVzZXQyc30gZnJvbSBcIi4uL2ltcGwvTWlzY0ltcGxcIjtcclxuaW1wb3J0IHtJUnVsZUNvbnRhaW5lciwgSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCwgUnVsZSwgUnVsZUxpa2V9IGZyb20gXCIuL1J1bGVcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBDb3VudGVyUnVsZSBjbGFzcyBkZXNjcmliZXMgYSBuYW1lZCBjb3VudGVyIGRlZmluaXRpb24uIFVzZSB0aGlzIHJ1bGUgdG8gY3JlYXRlXHJcbiAqIGNvdW50ZXIgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGluIGNvdW50ZXItaW5jcmVtZW50LCBjb3VudGVyLXJlc2V0IGFuZCBjb3VudGVyLXNldCBzdHlsZVxyXG4gKiBwcm9wZXJ0aWVzLiBObyBDU1MgcnVsZSBpcyBjcmVhdGVkIGZvciBjb3VudGVycyAtIHRoZXkgYXJlIG5lZWRlZCBvbmx5IHRvIHByb3ZpZGUgdHlwZS1zYWZlXHJcbiAqIGNvdW50ZXIgZGVmaW5pdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ291bnRlclJ1bGUgZXh0ZW5kcyBSdWxlTGlrZSBpbXBsZW1lbnRzIElDb3VudGVyUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJQ291bnRlclJ1bGUpXHJcblx0e1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblx0XHR0aGlzLm5hbWVPdmVycmlkZSA9IG5hbWVPdmVycmlkZTtcclxuXHR9XHJcblxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS5cclxuICAgIC8vIFdlIHJldHVybiB0aGUgY291bnRlciBuYW1lLlxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuXHRwdWJsaWMgcHJvY2VzcyggY29udGFpbmVyOiBJUnVsZUNvbnRhaW5lciwgcnVsZU5hbWU6IHN0cmluZyB8IG51bGwpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIHN1cGVyLnByb2Nlc3MoIGNvbnRhaW5lciwgcnVsZU5hbWUpO1xyXG5cdFx0dGhpcy5uYW1lID0gY29udGFpbmVyLmdldFNjb3BlZE5hbWUoIHJ1bGVOYW1lLCB0aGlzLm5hbWVPdmVycmlkZSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJ1bGUncyBuYW1lIC0gdGhpcyBpcyBhIHVuaXF1ZSBuYW1lIHRoYXQgaXMgYXNzaWduZWQgYnkgdGhlIE1pbWNzcyBpbmZyYXN0dWN0dXJlLiBUaGlzIG5hbWVcclxuXHQgKiBkb2Vzbid0IGhhdmUgdGhlIHByZWZpeCB0aGF0IGlzIHVzZWQgd2hlbiByZWZlcnJpbmcgdG8gY2xhc3NlcyAoLiksIElEcyAoIykgYW5kIGN1c3RvbSBDU1NcclxuXHQgKiBwcm9wZXJ0aWVzICgtLSkuXHJcblx0ICovXHJcblx0cHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKiogTmFtZSBvZiB0aGUgY291bnRlciAqL1xyXG5cdHB1YmxpYyBnZXQgY291bnRlck5hbWUoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMubmFtZTsgfVxyXG5cclxuXHQvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG5cdC8vIGlzIG5vdCBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIGJlIHVuaXF1ZWx5IGdlbmVyYXRlZC5cclxuXHRwcml2YXRlIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElDb3VudGVyUnVsZTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIENvdW50ZXJTdHlsZVJ1bGUgY2xhc3MgZGVzY3JpYmVzIHRoZSBDU1MgQG5vdW50ZXItc3R5bGUgYXQtcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb3VudGVyU3R5bGVSdWxlIGV4dGVuZHMgUnVsZSBpbXBsZW1lbnRzIElDb3VudGVyU3R5bGVSdWxlXHJcbntcclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIGNvdW50ZXJTdHlsZXNldD86IEV4dGVuZGVkQ291bnRlclN0eWxlc2V0LCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJQ291bnRlclN0eWxlUnVsZSlcclxuXHR7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvdW50ZXJTdHlsZXNldCA9IGNvdW50ZXJTdHlsZXNldCA/PyB7fTtcclxuXHRcdHRoaXMubmFtZU92ZXJyaWRlID0gbmFtZU92ZXJyaWRlO1xyXG5cdH1cclxuXHJcblxyXG5cclxuICAgIC8qKiBOYW1lIG9mIHRoZSBjb3VudGVyICovXHJcblx0cHVibGljIGdldCBjb3VudGVyU3R5bGVOYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgaW4gYSBzdHlsZSBwcm9wZXJ0eSBvciBpblxyXG4gICAgLy8gYW5vdGhlciBjb3VudGVyIHN0eWxlIHJ1bGUuIFdlIHJldHVybiB0aGUgY291bnRlciBzdHlsZSBuYW1lLlxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuXHRwdWJsaWMgcHJvY2VzcyggY29udGFpbmVyOiBJUnVsZUNvbnRhaW5lciwgcnVsZU5hbWU6IHN0cmluZyB8IG51bGwpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIHN1cGVyLnByb2Nlc3MoIGNvbnRhaW5lciwgcnVsZU5hbWUpO1xyXG5cdFx0dGhpcy5uYW1lID0gY29udGFpbmVyLmdldFNjb3BlZE5hbWUoIHJ1bGVOYW1lLCB0aGlzLm5hbWVPdmVycmlkZSk7XHJcblx0fVxyXG5cclxuXHQvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LlxyXG5cdHB1YmxpYyBpbnNlcnQoIHBhcmVudDogQ1NTU3R5bGVTaGVldCB8IENTU0dyb3VwaW5nUnVsZSk6IHZvaWRcclxuXHR7XHJcblx0XHR0aGlzLmNzc1J1bGUgPSBSdWxlLnRvRE9NKCB0aGlzLnRvQ3NzKCksIHBhcmVudCk7XHJcblx0fVxyXG5cclxuXHQvLyBTZXJpYWxpemVzIHRoaXMgcnVsZSB0byBhIHN0cmluZy5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWRcclxuICAgIHtcclxuXHRcdGN0eC5hZGRSdWxlKCB0aGlzLnRvQ3NzKCkpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cdC8vIFNlcmlhbGl6ZXMgdGhpcyBydWxlIHRvIGEgc3RyaW5nLlxyXG4gICAgcHJpdmF0ZSB0b0NzcygpOiBzdHJpbmdcclxuICAgIHtcclxuXHRcdHJldHVybiBgQGNvdW50ZXItc3R5bGUgJHt0aGlzLm5hbWV9IHske2NvdW50ZXJTdHlsZXNldDJzKCB0aGlzLmNvdW50ZXJTdHlsZXNldCl9fWA7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0LyoqIFNPTSBjb3VudGVyLXN0eWxlIHJ1bGUgKi9cclxuXHQvLyBwdWJsaWMgY3NzUnVsZTogQ1NTQ291bnRlclN0eWxlUnVsZTtcclxuXHRwdWJsaWMgY3NzUnVsZTogQ1NTUnVsZSB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcblx0ICogUnVsZSdzIG5hbWUgLSB0aGlzIGlzIGEgdW5pcXVlIG5hbWUgdGhhdCBpcyBhc3NpZ25lZCBieSB0aGUgTWltY3NzIGluZnJhc3R1Y3R1cmUuIFRoaXMgbmFtZVxyXG5cdCAqIGRvZXNuJ3QgaGF2ZSB0aGUgcHJlZml4IHRoYXQgaXMgdXNlZCB3aGVuIHJlZmVycmluZyB0byBjbGFzc2VzICguKSwgSURzICgjKSBhbmQgY3VzdG9tIENTU1xyXG5cdCAqIHByb3BlcnRpZXMgKC0tKS5cclxuXHQgKi9cclxuXHRwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIC8vIE9iamVjdCBkZWZpbmluZyB0aGUgY291bnRlciBzdHlsZSBydWxlIGZlYXR1cmVzLlxyXG4gICAgcHJpdmF0ZSBjb3VudGVyU3R5bGVzZXQ6IEV4dGVuZGVkQ291bnRlclN0eWxlc2V0O1xyXG5cclxuICAgIC8vIE5hbWUgb3IgbmFtZWQgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGEgbmFtZSBmb3IgdGhpcyBydWxlLiBJZiB0aGlzIHByb3BlcnR5XHJcblx0Ly8gaXMgbm90IGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgYmUgdW5pcXVlbHkgZ2VuZXJhdGVkLlxyXG5cdHByaXZhdGUgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSUNvdW50ZXJTdHlsZVJ1bGU7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJR3JpZExpbmVSdWxlLCBJR3JpZEFyZWFSdWxlfSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiXHJcbmltcG9ydCB7SVJ1bGVDb250YWluZXIsIFJ1bGVMaWtlfSBmcm9tIFwiLi9SdWxlXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgR3JpZExpbmVSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIG5hbWVkIGdyaWQgbGluZSBkZWZpbml0aW9uLiBObyBDU1MgcnVsZSBpcyBjcmVhdGVkIGZvciBncmlkXHJcbiAqIGxpbmVzIC0gdGhleSBhcmUgbmVlZGVkIG9ubHkgdG8gcHJvdmlkZSB0eXBlLXNhZmUgZ3JpZCBsaW5lIGRlZmluaXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdyaWRMaW5lUnVsZSBleHRlbmRzIFJ1bGVMaWtlIGltcGxlbWVudHMgSUdyaWRMaW5lUnVsZVxyXG57XHJcbiAgICAvLyBpZiB0aGUgbmFtZU92ZXJyaWRlIGlzIGFuIGFyZWEgcnVsZSBvYmplY3QsIHRoZSBpc1N0YXJ0RW5kT3JOb25lIGZsYWcgaXMgYWx3YXlzIGRlZmluZWRcclxuICAgIC8vIGJlY2F1c2UgdGhpcyBjb25zdHJ1Y3RvciBjYW4gb25seSBiZSBpbnZva2VkIGZvciB0aGUgc3RhcnQgYW5kIGVuZCBsaW5lcyBvZiB0aGUgR3JpZEFyZWFSdWxlXHJcbiAgICAvLyBvYmplY3QuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkTGluZVJ1bGUgfCBJR3JpZEFyZWFSdWxlLCBpc1N0YXJ0RW5kT3JOb25lPzogYm9vbGVhbilcclxuXHR7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm5hbWVPdmVycmlkZSA9IG5hbWVPdmVycmlkZTtcclxuICAgICAgICB0aGlzLmlzU3RhcnRFbmRPck5vbmUgPSBpc1N0YXJ0RW5kT3JOb25lO1xyXG5cdH1cclxuXHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gdGhlIG9iamVjdCBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSBvZiBhIHN0eWxlIHByb3BlcnR5LlxyXG4gICAgLy8gV2UgcmV0dXJuIHRoZSBsaW5lIG5hbWUuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMubmFtZTsgfVxyXG5cclxuXHJcblx0Ly8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBydWxlLlxyXG5cdHB1YmxpYyBwcm9jZXNzKCBjb250YWluZXI6IElSdWxlQ29udGFpbmVyLCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgc3VwZXIucHJvY2VzcyggY29udGFpbmVyLCBydWxlTmFtZSk7XHJcblxyXG4gICAgICAgIGxldCBuYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgbGV0IGFyZWFOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGlzU3RhcnRFbmRPck5vbmU6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB0aGlzLmlzU3RhcnRFbmRPck5vbmU7XHJcbiAgICAgICAgbGV0IG5hbWVPdmVycmlkZSA9IHRoaXMubmFtZU92ZXJyaWRlO1xyXG4gICAgICAgIGlmIChuYW1lT3ZlcnJpZGUgaW5zdGFuY2VvZiBHcmlkTGluZVJ1bGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZU92ZXJyaWRlLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTdGFydEVuZE9yTm9uZSA9IG5hbWVPdmVycmlkZS5pc1N0YXJ0RW5kT3JOb25lO1xyXG4gICAgICAgICAgICBhcmVhTmFtZSA9IG5hbWVPdmVycmlkZS5hcmVhTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmFtZU92ZXJyaWRlIGluc3RhbmNlb2YgR3JpZEFyZWFSdWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWVPdmVycmlkZS5uYW1lICsgKGlzU3RhcnRFbmRPck5vbmUgPT09IHRydWUgPyBcIi1zdGFydFwiIDogaXNTdGFydEVuZE9yTm9uZSA9PT0gZmFsc2UgPyBcIi1lbmRcIiA6IFwiXCIpO1xyXG4gICAgICAgICAgICBhcmVhTmFtZSA9IG5hbWVPdmVycmlkZS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lID0gY29udGFpbmVyLmdldFNjb3BlZE5hbWUoIHJ1bGVOYW1lLCBuYW1lT3ZlcnJpZGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlIG9idGFpbmVkIG5hbWUgZG9lc24ndCBoYXZlIFwiLXN0YXJ0XCIgb3IgXCItZW5kXCIgYnV0IHRoZSBpc1N0YXJ0RW5kT3JOb25lIGZsYWcgaXNcclxuICAgICAgICAgICAgLy8gZGVmaW5lZCAodGhhdCBpcywgaXQgaXMgZWl0aGVyIHN0YXJ0IG9yIGVuZCBsaW5lKSwgd2UgbmVlZCB0byBhcHBlbmQgdGhlIHN1ZmZpeC4gSWYgdGhlXHJcbiAgICAgICAgICAgIC8vIG9idGFpbmVkIG5hbWUgYWxyZWFkeSBoYXMgXCItc3RhcnRcIiBvciBcIi1lbmRcIiBhbmQgdGhlIGlzU3RhcnRFbmRPck5vbmUgZmxhZyBpcyBub3RcclxuICAgICAgICAgICAgLy8gZGVmaW5lZCwgd2Ugc2V0IHRoaXMgZmxhZyB0byBlaXRoZXIgdHJ1ZSBvciBmYWxzZSBkZXBlbmRpbmcgb24gdGhlIHN1ZmZpeC4gTm90ZSB0aGF0IGlmXHJcbiAgICAgICAgICAgIC8vIHRoZSBuYW1lT3ZlcnJpZGUgaXMgYW4gYXJlYSBydWxlIG9iamVjdCwgdGhlIGlzU3RhcnRFbmRPck5vbmUgZmxhZyBpcyBhbHdheXMgZGVmaW5lZC5cclxuICAgICAgICAgICAgbGV0IG5hbWVIYXNTdGFydCA9IG5hbWUuZW5kc1dpdGgoXCItc3RhcnRcIik7XHJcbiAgICAgICAgICAgIGxldCBuYW1lSGFzRW5kID0gbmFtZS5lbmRzV2l0aChcIi1lbmRcIik7XHJcbiAgICAgICAgICAgIGlmIChuYW1lSGFzU3RhcnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTdGFydEVuZE9yTm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhcmVhTmFtZSA9IG5hbWUuc3Vic3RyKCAwLCBuYW1lLmxlbmd0aCAtIDYgLyogXCItc3RhcnRcIi5sZW5ndGggKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVIYXNFbmQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlzU3RhcnRFbmRPck5vbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGFyZWFOYW1lID0gbmFtZS5zdWJzdHIoIDAsIG5hbWUubGVuZ3RoIC0gNCAvKiBcIi1lbmRcIi5sZW5ndGggKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RhcnRFbmRPck5vbmUgPT09IHRydWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFyZWFOYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCItc3RhcnRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0YXJ0RW5kT3JOb25lID09PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYXJlYU5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgbmFtZSArPSBcIi1lbmRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmFyZWFOYW1lID0gYXJlYU5hbWU7XHJcbiAgICAgICAgdGhpcy5pc1N0YXJ0RW5kT3JOb25lID0gaXNTdGFydEVuZE9yTm9uZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJ1bGUncyBuYW1lIC0gdGhpcyBpcyBhIHVuaXF1ZSBuYW1lIHRoYXQgaXMgYXNzaWduZWQgYnkgdGhlIE1pbWNzcyBpbmZyYXN0dWN0dXJlLiBUaGlzIG5hbWVcclxuXHQgKiBkb2Vzbid0IGhhdmUgdGhlIHByZWZpeCB0aGF0IGlzIHVzZWQgd2hlbiByZWZlcnJpbmcgdG8gY2xhc3NlcyAoLiksIElEcyAoIykgYW5kIGN1c3RvbSBDU1NcclxuXHQgKiBwcm9wZXJ0aWVzICgtLSkuXHJcblx0ICovXHJcblx0cHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcblx0LyoqXHJcbiAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgbGluZSBpcyBhIHN0YXJ0IG9yIGVuZCBsaW5lIG9mIGEgZ3JpZCBhcmVhLiBUaGUgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICogaWYgdGhpcyBpcyB0aGUgc3RhcnQgbGluZTsgZmFsc2UgaWYgdGhpcyBpcyB0aGUgZW5kIGxpbmU7IGFuZCB1bmRlZmluZWQgaWYgdGhlIGxpbmUgaXNcclxuICAgICAqIG5vdCByZWxhdGVkIHRvIGFueSBhcmVhLlxyXG4gICAgICovXHJcblx0cHVibGljIGlzU3RhcnRFbmRPck5vbmU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSBncmlkIGFyZWEgb2Ygd2hpY2ggdGhlIGxpbmUgaXMgZWl0aGVyIGEgc3RhcnQgb3IgYW4gZW5kIGxpbmUuIEl0IGlzIGRlZmluZWRcclxuICAgICAqIG9ubHkgaWYgdGhlIGxpbmUgbmFtZSBlbmRzIHdpdGggXCItc3RhcnRcIiBvciBcIi1lbmRcIi5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBhcmVhTmFtZT86IHN0cmluZztcclxuXHJcbiAgICAvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG5cdC8vIGlzIG5vdCBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIGJlIHVuaXF1ZWx5IGdlbmVyYXRlZC5cclxuXHRwcml2YXRlIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkTGluZVJ1bGUgfCBJR3JpZEFyZWFSdWxlO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgR3JpZEFyZWFSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIG5hbWVkIGdyaWQgYXJlYSBkZWZpbml0aW9uLiBObyBDU1MgcnVsZSBpcyBjcmVhdGVkIGZvciBncmlkXHJcbiAqIGFyZWFzIC0gdGhleSBhcmUgbmVlZGVkIG9ubHkgdG8gcHJvdmlkZSB0eXBlLXNhZmUgZ3JpZCBhcmVhIGRlZmluaXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdyaWRBcmVhUnVsZSBleHRlbmRzIFJ1bGVMaWtlIGltcGxlbWVudHMgSUdyaWRBcmVhUnVsZVxyXG57XHJcbiAgICAvLyBpZiB0aGUgbmFtZU92ZXJyaWRlIGlzIGFuIGFyZWEgcnVsZSBvYmplY3QsIHRoZSBpc1N0YXJ0RW5kT3JOb25lIGZsYWcgaXMgYWx3YXlzIGRlZmluZWRcclxuICAgIC8vIGJlY2F1c2UgdGhpcyBjb25zdHJ1Y3RvciBjYW4gb25seSBiZSBpbnZva2VkIGZvciB0aGUgc3RhcnQgYW5kIGVuZCBsaW5lcyBvZiB0aGUgR3JpZEFyZWFSdWxlXHJcbiAgICAvLyBvYmplY3QuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkQXJlYVJ1bGUpXHJcblx0e1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5uYW1lT3ZlcnJpZGUgPSBuYW1lT3ZlcnJpZGU7XHJcblxyXG4gICAgICAgIC8vIGNyZWF0ZSBsaW5lIHJ1bGVzXHJcbiAgICAgICAgdGhpcy5zdGFydExpbmUgPSBuZXcgR3JpZExpbmVSdWxlKCB0aGlzLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmVuZExpbmUgPSBuZXcgR3JpZExpbmVSdWxlKCB0aGlzLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS5cclxuICAgIC8vIFdlIHJldHVybiB0aGUgYXJlYSBuYW1lLlxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLm5hbWU7IH1cclxuXHJcblx0Ly8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBydWxlLlxyXG5cdHB1YmxpYyBwcm9jZXNzKCBjb250YWluZXI6IElSdWxlQ29udGFpbmVyLCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgc3VwZXIucHJvY2VzcyggY29udGFpbmVyLCBydWxlTmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9IGNvbnRhaW5lci5nZXRTY29wZWROYW1lKCBydWxlTmFtZSwgdGhpcy5uYW1lT3ZlcnJpZGUpO1xyXG5cclxuICAgICAgICAvLyBwcm9jZXNzIGxpbmUgcnVsZXNcclxuICAgICAgICB0aGlzLnN0YXJ0TGluZS5wcm9jZXNzKCBjb250YWluZXIsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuZW5kTGluZS5wcm9jZXNzKCBjb250YWluZXIsIG51bGwpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUnVsZSdzIG5hbWUgLSB0aGlzIGlzIGEgdW5pcXVlIG5hbWUgdGhhdCBpcyBhc3NpZ25lZCBieSB0aGUgTWltY3NzIGluZnJhc3R1Y3R1cmUuIFRoaXMgbmFtZVxyXG5cdCAqIGRvZXNuJ3QgaGF2ZSB0aGUgcHJlZml4IHRoYXQgaXMgdXNlZCB3aGVuIHJlZmVycmluZyB0byBjbGFzc2VzICguKSwgSURzICgjKSBhbmQgY3VzdG9tIENTU1xyXG5cdCAqIHByb3BlcnRpZXMgKC0tKS5cclxuXHQgKi9cclxuXHRwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuXHQvKiogU3RhcnQgbGluZSBvZiB0aGUgYXJlYS4gKi9cclxuXHRwdWJsaWMgc3RhcnRMaW5lOiBHcmlkTGluZVJ1bGU7XHJcblxyXG4gICAgLyoqIEVuZCBsaW5lIG9mIHRoZSBhcmVhIGFyZWEuICovXHJcblx0cHVibGljIGVuZExpbmU6IEdyaWRMaW5lUnVsZTtcclxuXHJcbiAgICAvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG5cdC8vIGlzIG5vdCBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIGJlIHVuaXF1ZWx5IGdlbmVyYXRlZC5cclxuXHRwcml2YXRlIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElHcmlkQXJlYVJ1bGU7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJU3R5bGVEZWZpbml0aW9uQ2xhc3MsIElTdHlsZURlZmluaXRpb24sIElHcm91cFJ1bGUsIElNZWRpYVJ1bGUsIElTdXBwb3J0c1J1bGV9IGZyb20gXCIuLi9hcGkvUnVsZVR5cGVzXCJcclxuaW1wb3J0IHtNZWRpYVN0YXRlbWVudCwgU3VwcG9ydHNTdGF0ZW1lbnR9IGZyb20gXCIuLi9hcGkvTWVkaWFUeXBlc1wiO1xyXG5pbXBvcnQge2dldFJDZnJvbVNELCBwcm9jZXNzU0R9IGZyb20gXCIuL1J1bGVDb250YWluZXJcIlxyXG5pbXBvcnQge0lSdWxlQ29udGFpbmVyLCBSdWxlLCBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0fSBmcm9tIFwiLi9SdWxlXCJcclxuaW1wb3J0IHttZWRpYTJzLCBzdXBwb3J0czJzfSBmcm9tIFwiLi4vaW1wbC9NaXNjSW1wbFwiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIEdyb3VwUnVsZSBjbGFzcyBzZXJ2ZXMgYXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgZ3JvdXBpbmcgQ1NTIHJ1bGVzLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEdyb3VwUnVsZTxUIGV4dGVuZHMgSVN0eWxlRGVmaW5pdGlvbj4gZXh0ZW5kcyBSdWxlIGltcGxlbWVudHMgSUdyb3VwUnVsZTxUPlxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBpbnN0T3JDbGFzczogVCB8IElTdHlsZURlZmluaXRpb25DbGFzczxUPilcclxuXHR7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5pbnN0T3JDbGFzcyA9IGluc3RPckNsYXNzO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIGNvbnRhaW5lcjogSVJ1bGVDb250YWluZXIsIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKVxyXG5cdHtcclxuXHRcdHN1cGVyLnByb2Nlc3MoIGNvbnRhaW5lciwgcnVsZU5hbWUpO1xyXG5cclxuICAgICAgICAvLyBjb250YWluZXIgdG8gd2hpY2ggb3VyIGdyb3VwbmcgcnVsZSBiZWxvbmdzIGJlY29tZXMgdGhlIHBhcmVudCBjb250YWluZXIgZm9yIHRoZVxyXG4gICAgICAgIC8vIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2VcclxuXHRcdHRoaXMuc2MgPSBnZXRSQ2Zyb21TRCggdGhpcy5fc2QgPSBwcm9jZXNzU0QoIHRoaXMuaW5zdE9yQ2xhc3MsIGNvbnRhaW5lci5nZXREZWYoKSkpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LlxyXG5cdHB1YmxpYyBpbnNlcnQoIHBhcmVudDogQ1NTU3R5bGVTaGVldCB8IENTU0dyb3VwaW5nUnVsZSk6IHZvaWRcclxuXHR7XHJcblx0XHRsZXQgc2VsZWN0b3IgPSB0aGlzLmdldFNlbCgpO1xyXG5cdFx0aWYgKCFzZWxlY3RvcilcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHRoaXMuY3NzUnVsZSA9IFJ1bGUudG9ET00oIGAke3NlbGVjdG9yfSB7fWAsIHBhcmVudCkgYXMgQ1NTR3JvdXBpbmdSdWxlO1xyXG5cclxuXHRcdC8vIGluc2VydCBzdWItcnVsZXNcclxuXHRcdGlmICh0aGlzLmNzc1J1bGUpXHJcblx0XHRcdHRoaXMuc2MuaW5zZXJ0KCB0aGlzLmNzc1J1bGUpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBTZXJpYWxpemVzIHRoaXMgcnVsZSB0byBhIHN0cmluZy5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWRcclxuICAgIHtcclxuXHRcdGxldCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsKCk7XHJcblx0XHRpZiAoIXNlbGVjdG9yKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Y3R4LmFkZFJ1bGUoIGAke3NlbGVjdG9yfSB7YCk7XHJcblxyXG5cdFx0Ly8gaW5zZXJ0IHN1Yi1ydWxlc1xyXG5cdFx0dGhpcy5zYy5zZXJpYWxpemUoIGN0eCk7XHJcblxyXG5cdFx0Y3R4LmFkZFJ1bGUoIFwifVwiKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBDb25kaXRpb24gb2YgdGhpcyBncm91cGluZyBydWxlLlxyXG5cdHB1YmxpYyBnZXQgY29uZGl0aW9uKCk6IHN0cmluZ1xyXG4gICAge1xyXG4gICAgICAgIGlmICghdGhpcy5fY29uZClcclxuICAgICAgICAgICAgdGhpcy5fY29uZCA9IHRoaXMuZ2V0Q29uZCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZCA/PyBcIlwiO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cdC8vIFJldHVybnMgdGhlIGNvbmRpdGlvbiBzdHJpbmcgb2YgdGhpcyBncm91cGluZyBydWxlLlxyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBnZXRDb25kKCk6IHN0cmluZyB8IG51bGw7XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHN0cmluZyBvZiB0aGlzIGdyb3VwaW5nIHJ1bGUuXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGdldFNlbCgpOiBzdHJpbmcgfCBudWxsO1xyXG5cclxuXHJcblxyXG5cdC8vIENsZXJzIHRoZSBDU1MgcnVsZSBvYmplY3QuXHJcblx0cHVibGljIGNsZWFyKCk6IHZvaWRcclxuXHR7XHJcblx0XHRzdXBlci5jbGVhcigpO1xyXG5cclxuXHRcdC8vIGNsZWFyIHN1Yi1ydWxlc1xyXG5cdFx0dGhpcy5zYy5jbGVhcigpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBJbnN0YW5jZSBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBkZWZpbmluZyB0aGUgcnVsZXMgdW5kZXIgdGhpcyBncm91cGluZyBydWxlXHJcblx0cHVibGljIGdldCBzZCgpOiBUIHsgcmV0dXJuIHRoaXMuX3NkIGFzIFQ7IH1cclxuXHJcblx0LyoqIFNPTSBzdXBwb3J0cyBydWxlICovXHJcblx0cHVibGljIGNzc1J1bGU6IENTU0dyb3VwaW5nUnVsZSB8IG51bGw7XHJcblxyXG5cdC8vIFN0eWxlIGRlZmluaXRpb24gY2xhc3MgdGhhdCBkZWZpbmVzIHJ1bGVzIHVuZGVyIHRoaXMgZ3JvdXBpbmcgcnVsZS5cclxuXHRwcml2YXRlIGluc3RPckNsYXNzOiBUIHwgSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFQ+O1xyXG5cclxuXHQvLyBTdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlLlxyXG5cdHByaXZhdGUgX3NkOiBJU3R5bGVEZWZpbml0aW9uO1xyXG5cclxuXHQvLyBSdWxlIGNvbnRhaW5lciBmb3IgdGhlIGRlZmluaXRpb24gaW5zdGFuY2UgLSB0aGlzIGNvbnRhaW5lciBjb250YWlucyBzdWItcnVsZXMuXHJcblx0cHJpdmF0ZSBzYzogSVJ1bGVDb250YWluZXI7XHJcblxyXG5cdC8vIENvbmRpdGlvbiBvZiB0aGlzIGdyb3VwaW5nIHJ1bGUuXHJcblx0cHJpdmF0ZSBfY29uZDogc3RyaW5nIHwgbnVsbDtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFN1cHBvcnRSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIENTUyBAc3VwcG9ydHMgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdXBwb3J0c1J1bGU8VCBleHRlbmRzIElTdHlsZURlZmluaXRpb24+IGV4dGVuZHMgR3JvdXBSdWxlPFQ+IGltcGxlbWVudHMgSVN1cHBvcnRzUnVsZTxUPlxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzdGF0ZW1lbnQ6IFN1cHBvcnRzU3RhdGVtZW50LCBpbnN0T3JDbGFzczogVCB8IElTdHlsZURlZmluaXRpb25DbGFzczxUPilcclxuXHR7XHJcblx0XHRzdXBlciggaW5zdE9yQ2xhc3MpO1xyXG5cclxuXHRcdHRoaXMuc3RtdCA9IHN0YXRlbWVudDtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0LyoqIEZsYWcgaW5kaWNhdGVkIHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBydWxlJ3MgcXVlcnkgKi9cclxuICAgIHB1YmxpYyBnZXQgaXNTdXBwb3J0ZWQoKTogYm9vbGVhblxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiBDU1Muc3VwcG9ydHMoIHRoaXMuY29uZGl0aW9uKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBjb25kaXRpb24gc3RyaW5nIG9mIHRoaXMgZ3JvdXBpbmcgcnVsZS5cclxuXHRwcm90ZWN0ZWQgZ2V0Q29uZCgpOiBzdHJpbmcgfCBudWxsXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzMnMoIHRoaXMuc3RtdCk7XHJcbiAgICB9XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHN0cmluZyBvZiB0aGlzIGdyb3VwaW5nIHJ1bGUuXHJcblx0cHJvdGVjdGVkIGdldFNlbCgpOiBzdHJpbmcgfCBudWxsXHJcblx0e1xyXG5cdFx0cmV0dXJuIGBAc3VwcG9ydHMgJHt0aGlzLmNvbmRpdGlvbn1gO1xyXG5cdH1cclxuXHJcblxyXG5cclxuICAgIC8qKiBTT00gc3VwcG9ydHMgcnVsZSAqL1xyXG5cdHB1YmxpYyBjc3NSdWxlOiBDU1NTdXBwb3J0c1J1bGUgfCBudWxsO1xyXG5cclxuXHQvLyBzdXBwb3J0IHN0YXRlbWVudCBmb3IgdGhpcyBydWxlLlxyXG5cdHByaXZhdGUgc3RtdDogU3VwcG9ydHNTdGF0ZW1lbnQ7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBNZWRpYVJ1bGUgY2xhc3MgZGVzY3JpYmVzIGEgQ1NTIEBtZWRpYSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1lZGlhUnVsZTxUIGV4dGVuZHMgSVN0eWxlRGVmaW5pdGlvbj4gZXh0ZW5kcyBHcm91cFJ1bGU8VD4gaW1wbGVtZW50cyBJTWVkaWFSdWxlPFQ+XHJcbntcclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIHN0YXRlbWVudDogTWVkaWFTdGF0ZW1lbnQsIGluc3RPckNsYXNzOiBUIHwgSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFQ+KVxyXG5cdHtcclxuXHRcdHN1cGVyKCBpbnN0T3JDbGFzcyk7XHJcblxyXG5cdFx0dGhpcy5zdG10ID0gc3RhdGVtZW50O1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBjb25kaXRpb24gc3RyaW5nIG9mIHRoaXMgZ3JvdXBpbmcgcnVsZS5cclxuXHRwcm90ZWN0ZWQgZ2V0Q29uZCgpOiBzdHJpbmcgfCBudWxsXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIG1lZGlhMnMoIHRoaXMuc3RtdCk7XHJcbiAgICB9XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHN0cmluZyBvZiB0aGlzIGdyb3VwaW5nIHJ1bGUuXHJcblx0cHJvdGVjdGVkIGdldFNlbCgpOiBzdHJpbmcgfCBudWxsXHJcblx0e1xyXG5cdFx0cmV0dXJuIGBAbWVkaWEgJHt0aGlzLmNvbmRpdGlvbn1gO1xyXG5cdH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgTWVkaWFRdWVyeUxpc3RgIG9iamVjdCB0aGF0IGFsbG93cyBwcm9ncmFtbWF0aWMgY2hlY2tpbmcgd2hldGhlciB0aGUgZG9jdW1lbnQgbWF0Y2hlc1xyXG4gICAgICogdGhlIG1lZGlhIHN0YXRlbWVudCBhbmQgYWxzbyBhbGxvd3MgbGlzdGVuaW5nIHRvIGl0cyBgY2hhbmdlYCBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtcWwoKTogTWVkaWFRdWVyeUxpc3RcclxuICAgIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21xbClcclxuICAgICAgICAgICAgdGhpcy5fbXFsID0gd2luZG93Lm1hdGNoTWVkaWEoIHRoaXMuY29uZGl0aW9uKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21xbDtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKiBTT00gbWVkaWEgcnVsZSAqL1xyXG5cdHB1YmxpYyBjc3NSdWxlOiBDU1NNZWRpYVJ1bGUgfCBudWxsO1xyXG5cclxuXHQvLyBtZWRpYSBzdGF0ZW1lbnQgZm9yIHRoaXMgcnVsZS5cclxuXHRwcml2YXRlIHN0bXQ6IE1lZGlhU3RhdGVtZW50O1xyXG5cclxuICAgIC8vIGNhY2hlZCBNZWRpYVF1ZXJ5TGlzdCBvYmplY3QgY3JlYXRlZCBmb3IgdGhlIG1lZGlhIHN0YXRlbWVudFxyXG4gICAgcHJpdmF0ZSBfbXFsOiBNZWRpYVF1ZXJ5TGlzdCB8IG51bGwgPSBudWxsO1xyXG59XHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7UGFnZVBzZXVkb0NsYXNzfSBmcm9tIFwiLi4vYXBpL0NvcmVUeXBlc1wiO1xyXG5pbXBvcnQge0lGb250RmFjZVJ1bGUsIElJbXBvcnRSdWxlLCBJUGFnZVJ1bGUsIElOYW1lc3BhY2VSdWxlLCBJQ2xhc3NOYW1lUnVsZSwgSUNsYXNzUnVsZX0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHtTdHlsZXNldH0gZnJvbSBcIi4uL2FwaS9TdHlsZXNldHNcIjtcclxuaW1wb3J0IHtFeHRlbmRlZEZvbnRGYWNlfSBmcm9tIFwiLi4vYXBpL0ZvbnRUeXBlc1wiXHJcbmltcG9ydCB7TWVkaWFTdGF0ZW1lbnQsIFN1cHBvcnRzU3RhdGVtZW50fSBmcm9tIFwiLi4vYXBpL01lZGlhVHlwZXNcIjtcclxuaW1wb3J0IHtmb250RmFjZTJzfSBmcm9tIFwiLi4vaW1wbC9NaXNjSW1wbFwiXHJcbmltcG9ydCB7UnVsZSwgSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCwgUnVsZUxpa2UsIElSdWxlQ29udGFpbmVyfSBmcm9tIFwiLi9SdWxlXCI7XHJcbmltcG9ydCB7bWVkaWEycywgc3VwcG9ydHMyc30gZnJvbSBcIi4uL2ltcGwvTWlzY0ltcGxcIjtcclxuaW1wb3J0IHtTdHlsZVJ1bGV9IGZyb20gXCIuL1N0eWxlUnVsZXNcIjtcclxuaW1wb3J0IHtzeW1WMlN9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgTWlzY1J1bGUgY2xhc3Mgc2VydmVzIGFzIGEgYmFzZSBjbGFzcyBmb3Igc2ltcGxlIHJ1bGVzLlxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgTWlzY1J1bGU8VCBleHRlbmRzIENTU1J1bGU+IGV4dGVuZHMgUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBpc1RvcExldmVsUnVsZT86IGJvb2xlYW4pXHJcblx0e1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuaXNUb3BMZXZlbFJ1bGUgPSBpc1RvcExldmVsUnVsZTtcclxuXHR9XHJcblxyXG5cdC8vIEluc2VydHMgdGhpcyBydWxlIGludG8gdGhlIGdpdmVuIHBhcmVudCBydWxlIG9yIHN0eWxlc2hlZXQuXHJcblx0cHVibGljIGluc2VydCggcGFyZW50OiBDU1NTdHlsZVNoZWV0IHwgQ1NTR3JvdXBpbmdSdWxlKTogdm9pZFxyXG5cdHtcclxuXHRcdHRoaXMuY3NzUnVsZSA9IFJ1bGUudG9ET00oIHRoaXMudG9Dc3MoKSwgcGFyZW50KSBhcyBUO1xyXG5cdH1cclxuXHJcblx0Ly8gU2VyaWFsaXplcyB0aGlzIHJ1bGUgdG8gYSBzdHJpbmcuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCBjdHg6IElSdWxlU2VyaWFsaXphdGlvbkNvbnRleHQpOiB2b2lkXHJcbiAgICB7XHJcblx0XHRjdHguYWRkUnVsZSggdGhpcy50b0NzcygpLCB0aGlzLmlzVG9wTGV2ZWxSdWxlKTtcclxuICAgIH1cclxuXHJcblx0Ly8gUmV0dXJucyBDU1Mgc3RyaW5nIGZvciB0aGlzIHJ1bGUuXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgdG9Dc3MoKTogc3RyaW5nO1xyXG5cclxuXHQvKiogU09NIGZvbnQtZmFjZSBydWxlICovXHJcblx0cHVibGljIGNzc1J1bGU6IFQ7XHJcblxyXG4gICAgLy8gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBydWxlIGNhbiBvbmx5IGJlIGF0IHRoZSB0b3AtbGV2ZWwgb2Ygc3R5bGVzaGVldHMgKGUuZy4gQGltcG9ydFxyXG4gICAgLy8gYW5kIEBuYW1lc3BhY2UpLlxyXG4gICAgcHJpdmF0ZSBpc1RvcExldmVsUnVsZT86IGJvb2xlYW47XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJbXBvcnRSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIENTUyBAaW1wb3J0IHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW1wb3J0UnVsZSBleHRlbmRzIE1pc2NSdWxlPENTU0ltcG9ydFJ1bGU+IGltcGxlbWVudHMgSUltcG9ydFJ1bGVcclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3RvciggdXJsOiBzdHJpbmcsIG1lZGlhU3RhdGVtZW50PzogTWVkaWFTdGF0ZW1lbnQsIHN1cHBvcnRzU3RhdGVtZW50Pzogc3RyaW5nIHwgU3VwcG9ydHNTdGF0ZW1lbnQpXHJcblx0e1xyXG4gICAgICAgIC8vIHRoaXMgaXMgYSB0b3AtbGV2ZWwgcnVsZVxyXG5cdFx0c3VwZXIoIHRydWUpO1xyXG5cclxuXHRcdHRoaXMudXJsID0gdXJsO1xyXG5cdFx0dGhpcy5tZWRpYVN0YXRlbWVudCA9IG1lZGlhU3RhdGVtZW50O1xyXG5cdFx0dGhpcy5zdXBwb3J0c1N0YXRlbWVudCA9IHN1cHBvcnRzU3RhdGVtZW50O1xyXG5cdH1cclxuXHJcblx0Ly8gUmV0dXJucyBDU1Mgc3RyaW5nIGZvciB0aGlzIHJ1bGUuXHJcbiAgICBwcm90ZWN0ZWQgdG9Dc3MoKTogc3RyaW5nXHJcbiAgICB7XHJcblx0XHRsZXQgdXJsOiBzdHJpbmc7XHJcblx0XHRpZiAodGhpcy51cmwuc3RhcnRzV2l0aChcInVybFwiKSB8fCB0aGlzLnVybC5zdGFydHNXaXRoKFwiXFxcIlwiKSB8fCB0aGlzLnVybC5zdGFydHNXaXRoKFwiJ1wiKSlcclxuXHRcdFx0dXJsID0gdGhpcy51cmw7XHJcblx0XHRlbHNlXHJcblx0XHRcdHVybCA9IGB1cmwoJHt0aGlzLnVybH0pYDtcclxuXHJcblx0XHRsZXQgc3VwcG9ydHNRdWVyeVN0cmluZyA9ICF0aGlzLnN1cHBvcnRzU3RhdGVtZW50ID8gXCJcIiA6IHN1cHBvcnRzMnMoIHRoaXMuc3VwcG9ydHNTdGF0ZW1lbnQpO1xyXG5cdFx0aWYgKHN1cHBvcnRzUXVlcnlTdHJpbmcgJiYgIXN1cHBvcnRzUXVlcnlTdHJpbmcuc3RhcnRzV2l0aCggXCJzdXBwb3J0c1wiKSlcclxuXHRcdCAgICBzdXBwb3J0c1F1ZXJ5U3RyaW5nID0gYHN1cHBvcnRzKCAke3N1cHBvcnRzUXVlcnlTdHJpbmd9IClgO1xyXG5cclxuXHRcdGxldCBtZWRpYVF1ZXJ5U3RyaW5nID0gIXRoaXMubWVkaWFTdGF0ZW1lbnQgPyBcIlwiIDogbWVkaWEycyggdGhpcy5tZWRpYVN0YXRlbWVudCk7XHJcblx0XHRyZXR1cm4gYEBpbXBvcnQgJHt1cmx9ICR7c3VwcG9ydHNRdWVyeVN0cmluZ30gJHttZWRpYVF1ZXJ5U3RyaW5nfWA7XHJcbiAgICB9XHJcblxyXG5cdC8vIFVSTCB0byBpbXBvcnQgZnJvbS5cclxuXHRwdWJsaWMgdXJsOiBzdHJpbmc7XHJcblxyXG5cdC8vIE9wdGlvbmFsIG1lZGlhIHF1ZXJ5IGZvciB0aGlzIHJ1bGUuXHJcblx0cHVibGljIG1lZGlhU3RhdGVtZW50PzogTWVkaWFTdGF0ZW1lbnQ7XHJcblxyXG5cdC8vIE9wdGlvbmFsIHN1cHBvcnRzIHF1ZXJ5IGZvciB0aGlzIHJ1bGUuXHJcblx0cHVibGljIHN1cHBvcnRzU3RhdGVtZW50Pzogc3RyaW5nIHwgU3VwcG9ydHNTdGF0ZW1lbnQ7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBOYW1lc3BhY2VSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIENTUyBAbmFtZXNwYWNlIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmFtZXNwYWNlUnVsZSBleHRlbmRzIE1pc2NSdWxlPENTU05hbWVzcGFjZVJ1bGU+IGltcGxlbWVudHMgSU5hbWVzcGFjZVJ1bGVcclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3RvciggbmFtZXNwYWNlOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZylcclxuXHR7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBhIHRvcC1sZXZlbCBydWxlXHJcblx0XHRzdXBlciggdHJ1ZSk7XHJcblxyXG5cdFx0dGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcblx0XHR0aGlzLnByZWZpeCA9IHByZWZpeDtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgQ1NTIHN0cmluZyBmb3IgdGhpcyBydWxlLlxyXG4gICAgcHJvdGVjdGVkIHRvQ3NzKCk6IHN0cmluZ1xyXG4gICAge1xyXG5cdFx0bGV0IHVybCA9IHRoaXMubmFtZXNwYWNlLnN0YXJ0c1dpdGgoIFwidXJsKFwiKSA/IHRoaXMubmFtZXNwYWNlIDogYHVybCgke3RoaXMubmFtZXNwYWNlfSlgO1xyXG5cdFx0cmV0dXJuIGBAbmFtZXNwYWNlICR7dGhpcy5wcmVmaXggPyB0aGlzLnByZWZpeCA6IFwiXCJ9ICR7dXJsfWA7XHJcbiAgICB9XHJcblxyXG5cdC8qKiBOYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgcnVsZSAqL1xyXG5cdHB1YmxpYyBuYW1lc3BhY2U6IHN0cmluZztcclxuXHJcblx0LyoqIE9wdGlvbmFsIHByZWZpeCBmb3IgdGhlIHJ1bGUgKi9cclxuXHRwdWJsaWMgcHJlZml4OiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcblxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgRm9udEZhY2VSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIEBmb250LWZhY2UgQ1NTIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRm9udEZhY2VSdWxlIGV4dGVuZHMgTWlzY1J1bGU8Q1NTRm9udEZhY2VSdWxlPiBpbXBsZW1lbnRzIElGb250RmFjZVJ1bGVcclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3RvciggZm9udGZhY2U6IEV4dGVuZGVkRm9udEZhY2UpXHJcblx0e1xyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmZvbnRmYWNlID0gZm9udGZhY2U7XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm5zIENTUyBzdHJpbmcgZm9yIHRoaXMgcnVsZS5cclxuICAgIHByb3RlY3RlZCB0b0NzcygpOiBzdHJpbmdcclxuICAgIHtcclxuXHRcdHJldHVybiBgQGZvbnQtZmFjZSB7JHtmb250RmFjZTJzKCB0aGlzLmZvbnRmYWNlKX19YDtcclxuICAgIH1cclxuXHJcblx0Ly8gT2JqZWN0IGRlZmluaW5nIGZvbnQtZmFjZSBwcm9wZXJ0aWVzLlxyXG5cdHB1YmxpYyBmb250ZmFjZTogRXh0ZW5kZWRGb250RmFjZTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFBhZ2VSdWxlIGNsYXNzIHJlcHJlc2VudHMgdGhlIENTUyBAcGFnZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhZ2VSdWxlIGV4dGVuZHMgU3R5bGVSdWxlIGltcGxlbWVudHMgSVBhZ2VSdWxlXHJcbntcclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIHBzZXVkb0NsYXNzPzogUGFnZVBzZXVkb0NsYXNzLCBzdHlsZT86IFN0eWxlc2V0KVxyXG5cdHtcclxuXHRcdHN1cGVyKCBzdHlsZSk7XHJcblx0XHR0aGlzLnBzZXVkb0NsYXNzID0gcHNldWRvQ2xhc3M7XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBzZWxlY3RvciBwYXJ0IG9mIHRoZSBzdHlsZSBydWxlLlxyXG5cdHB1YmxpYyBnZXRTZWwoKTogc3RyaW5nXHJcblx0e1xyXG5cdFx0cmV0dXJuIGBAcGFnZSAke3RoaXMucHNldWRvQ2xhc3MgPyB0aGlzLnBzZXVkb0NsYXNzIDogXCJcIn1gO1xyXG5cdH1cclxuXHJcblx0LyoqIFNPTSBwYWdlIHJ1bGUgKi9cclxuXHRwdWJsaWMgY3NzUnVsZTogQ1NTUGFnZVJ1bGU7XHJcblxyXG5cdC8qKiBPcHRpb25hbCBuYW1lIG9mIHRoZSBwYWdlIHBzZXVkbyBzdHlsZSAoZS5nLiBcIlwiOmZpcnN0XCIpICovXHJcblx0cHVibGljIHBzZXVkb0NsYXNzPzogUGFnZVBzZXVkb0NsYXNzO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUGFnZVJ1bGUgY2xhc3MgcmVwcmVzZW50cyB0aGUgQ1NTIEBwYWdlIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2xhc3NOYW1lUnVsZSBleHRlbmRzIFJ1bGVMaWtlIGltcGxlbWVudHMgSUNsYXNzTmFtZVJ1bGVcclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3RvciggY2xhc3NlczogKElDbGFzc1J1bGUgfCBJQ2xhc3NOYW1lUnVsZSB8IHN0cmluZylbXSlcclxuXHR7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5jbGFzc2VzID0gY2xhc3NlcztcclxuXHR9XHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gdGhlIG9iamVjdCBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSBvZiBhIHN0eWxlIHByb3BlcnR5LlxyXG4gICAgLy8gV2UgcmV0dXJuIHRoZSBDU1MgY2xhc3MgbmFtZS5cclxuICAgIFtzeW1WMlNdKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLmNzc0NsYXNzTmFtZTsgfVxyXG5cclxuXHQvKiogQ1NTIHJ1bGUgc2VsZWN0b3Igc3RyaW5nICovXHJcblx0cHVibGljIGdldCBzZWxlY3RvclRleHQoKTogc3RyaW5nXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMuY3NzQ2xhc3NOYW1lO1xyXG5cdH1cclxuXHJcblx0Ly8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBydWxlLlxyXG5cdHB1YmxpYyBwcm9jZXNzKCBjb250YWluZXI6IElSdWxlQ29udGFpbmVyLCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgc3VwZXIucHJvY2VzcyggY29udGFpbmVyLCBydWxlTmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY2xhc3Nlcy5tYXAoIGNscyA9PiB0eXBlb2YgY2xzID09PSBcInN0cmluZ1wiID8gY2xzIDogY2xzLm5hbWUpLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgIHRoaXMuY3NzQ2xhc3NOYW1lID0gXCIuXCIgKyB0aGlzLmNsYXNzZXMubWFwKCBjbHMgPT4gdHlwZW9mIGNscyA9PT0gXCJzdHJpbmdcIiA/IGNscyA6IGNscy5uYW1lKS5qb2luKFwiLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdG9TdHJpbmcgbWV0aG9kIHJldHVybnMgdGhlIGNvbWJpbmVkIG5hbWUgb2YgdGhlIGNsYXNzZXMgKHdpdGhvdXRcclxuICAgIC8vIHRoZSBDU1MgcHJlZml4ZXMpLlxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmdcclxuXHR7XHJcblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xyXG5cdH1cclxuXHJcbiAgICAvKiogQWxsIGNsYXNzIG5hbWVzIGNvbmNhdGVuYXRlZCB3aXRoIHNwYWNlICovXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBBbGwgY2xhc3MgQ1NTIG5hbWVzICh3aXRoIGRvdHMpIGNvbmNhdGVuYXRlZCB0b2dldGhlciAqL1xyXG4gICAgcHVibGljIGNzc0NsYXNzTmFtZTogc3RyaW5nO1xyXG5cclxuICAgIHByaXZhdGUgY2xhc3NlczogKElDbGFzc1J1bGUgfCBJQ2xhc3NOYW1lUnVsZSB8IHN0cmluZylbXTtcclxufVxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQge0lSdWxlLCBJTmFtZWRFbnRpdHksIElTdHlsZURlZmluaXRpb259IGZyb20gXCIuLi9hcGkvUnVsZVR5cGVzXCJcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0IGludGVyZmFjZSBrZWVwcyBpbmZvcm1hdGlvbiBkdXJpbmcgc2VyaWFsaXphdGlvbiBvZiBzdHlsZVxyXG4gKiBkZWZpbml0aW9uIGNsYXNzZXMgYW5kIGluc3RhbmNlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dFxyXG57XHJcbiAgICAvLyBBZGRzIHJ1bGUgdGV4dFxyXG4gICAgYWRkUnVsZSggczogc3RyaW5nLCBpc1RvcExldmVsUnVsZT86IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8vIEFkZHMgU3R5bGVEZWZpbml0aW9uIGluc3RhbmNlXHJcbiAgICBhZGRTRCggaW5zdGFuY2U6IElTdHlsZURlZmluaXRpb24pOiB2b2lkO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgSVJ1bGVDb250YWluZXIgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW4gb2JqZWN0IHRoYXQgYWNjb21wYW5pZXMgYW5kIGlzIGFzc29jaWF0ZWQgd2l0aFxyXG4gKiBhIHN0eWxlIGRlZmluaXRpb24gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUnVsZUNvbnRhaW5lclxyXG57XHJcblx0LyoqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBzdHlsZXNoZWV0IGRlZmluaXRpb24gY2xhc3MgKi9cclxuXHRnZXREZWYoKTogSVN0eWxlRGVmaW5pdGlvbjtcclxuXHJcblx0LyoqIEdlbmVyYXRlcyBhIG5hbWUsIHdoaWNoIHdpbGwgYmUgdW5pcXVlIGluIHRoaXMgc3R5bGVzaGVldCAqL1xyXG5cdGdldFNjb3BlZE5hbWUoIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsLCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJTmFtZWRFbnRpdHkpOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBJbnNlcnRzIGFsbCBydWxlcyBkZWZpbmVkIGluIHRoaXMgY29udGFpbmVyIHRvIGVpdGhlciB0aGUgc3R5bGUgc2hlZXQgb3IgZ3JvdXBpbmcgcnVsZS4gKi9cclxuXHRpbnNlcnQoIHBhcmVudDogQ1NTU3R5bGVTaGVldCB8IENTU0dyb3VwaW5nUnVsZSk6IHZvaWQ7XHJcblxyXG5cdC8qKiBDbGVhcnMgYWxsIENTUyBydWxlIG9iamVjdHMgZGVmaW5lZCBpbiB0aGlzIGNvbnRhaW5lci4gKi9cclxuXHRjbGVhcigpOiB2b2lkO1xyXG5cclxuXHQvKiogV3JpdGVzIGFsbCBydWxlcyByZWN1cnNpdmVseSB0byB0aGUgZ2l2ZW4gc3RyaW5nLiAqL1xyXG5cdHNlcmlhbGl6ZSggY3R4OiBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0KTogdm9pZDtcclxuXHJcbiAgICAvKiogU2V0cyB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoZSBjdXN0b20gQ1NTIHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gKi9cclxuXHRzZXRWYXJWYWx1ZSggbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVsbCwgaW1wb3J0YW50PzogYm9vbGVhbiwgc2NoZWR1bGVyVHlwZT86IG51bWJlcik6IHZvaWQ7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBSdWxlTGlrZSBhYnN0cmFjdCBjbGFzcyBpcyBhIGJhc2UgZm9yIGFsbCBcInJ1bGVzXCIgZGVmaW5lZCBpbiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIC1cclxuICogd2hldGhlciB0aGV5IGNvcnJlc3BvbmQgdG8gcmVhbCBDU1MgcnVsZXMgKGFuZCB0aHVzIGRlcml2ZSBmcm9tIHRoZSBSdWxlIGNsYXNzKSBvciBub3QgKHN1Y2ggYXNcclxuICogY291bnRlcnMsIGdyaWQgbGluZXMgYW5kIGdyaWQgYXJlYXMpLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJ1bGVMaWtlXHJcbntcclxuXHQvLyBQcm9jZXNzZXMgdGhlIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIGM6IElSdWxlQ29udGFpbmVyLCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgdGhpcy5jID0gYztcclxuXHRcdHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gUnVsZSBjb250YWluZXIgdG8gd2hpY2ggdGhpcyBydWxlIGJlbG9uZ3MuXHJcblx0cHVibGljIGM6IElSdWxlQ29udGFpbmVyO1xyXG5cclxuXHQvLyBOYW1lIG9mIHRoZSBwcm9wZXJ0eSBvZiB0aGUgc3R5bGVzaGVldCBkZWZpbml0aW9uIHRvIHdoaWNoIHRoaXMgcnVsZSB3YXMgYXNzaWduZWQuIFRoaXMgY2FuXHJcblx0Ly8gYmUgbnVsbCBmb3IgcnVsZXMgbm90IGNyZWF0ZWQgdmlhIGFzc2lnbm1lbnQgdG8gc3R5bGUgZGVmaW5pdGlvbiBwcm9wZXJ0aWVzLlxyXG5cdHB1YmxpYyBydWxlTmFtZTogc3RyaW5nIHwgbnVsbDtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFJ1bGUgY2xhc3MgaXMgdXNlZCBhcyBhIGJhc2UgY2xhc3MgZm9yIGFsbCBydWxlcy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSdWxlIGV4dGVuZHMgUnVsZUxpa2UgaW1wbGVtZW50cyBJUnVsZVxyXG57XHJcblx0Ly8gSW5zZXJ0cyB0aGlzIHJ1bGUgaW50byB0aGUgZ2l2ZW4gcGFyZW50IHJ1bGUgb3Igc3R5bGVzaGVldC4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlXHJcblx0Ly8gc3R5bGUgZGVmaW5pdGlvbiBjbGFzcywgdG8gd2hpY2ggdGhpcyBydWxlIGJlbG9uZ3MsIGlzIGFjdGl2YXRlZC5cclxuXHRwdWJsaWMgYWJzdHJhY3QgaW5zZXJ0KCBwYXJlbnQ6IENTU1N0eWxlU2hlZXQgfCBDU1NHcm91cGluZ1J1bGUpOiB2b2lkO1xyXG5cclxuXHQvLyBDbGVycyB0aGUgQ1NTIHJ1bGUgb2JqZWN0LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcywgdG8gd2hpY2hcclxuXHQvLyB0aGlzIHJ1bGUgYmVsb25ncywgaXMgZGVhY3RpdmF0ZWQuXHJcblx0cHVibGljIGNsZWFyKCk6IHZvaWQgeyB0aGlzLmNzc1J1bGUgPSBudWxsOyB9XHJcblxyXG5cdC8vIFNlcmlhbGl6ZXMgdGhpcyBydWxlIHRvIGEgc3RyaW5nLlxyXG5cdHB1YmxpYyBhYnN0cmFjdCBzZXJpYWxpemUoIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWQ7XHJcblxyXG5cclxuXHJcblx0Ly8gSW5zZXJ0cyB0aGUgZ2l2ZW4gcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgZ3JvdXBpbmcgcnVsZSBvciBzdHlsZXNoZWV0LlxyXG5cdHB1YmxpYyBzdGF0aWMgdG9ET00oIHJ1bGVUZXh0OiBzdHJpbmcsIHBhcmVudDogQ1NTU3R5bGVTaGVldCB8IENTU0dyb3VwaW5nUnVsZSk6IENTU1J1bGUgfCBudWxsXHJcblx0e1xyXG5cdFx0dHJ5XHJcblx0XHR7XHJcblx0XHRcdGxldCBpbmRleCA9IHBhcmVudC5pbnNlcnRSdWxlKCBydWxlVGV4dCwgcGFyZW50LmNzc1J1bGVzLmxlbmd0aCk7XHJcblx0XHRcdHJldHVybiBwYXJlbnQuY3NzUnVsZXNbaW5kZXhdO1xyXG5cdFx0fVxyXG5cdFx0Y2F0Y2goIHgpXHJcblx0XHR7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIGBDYW5ub3QgYWRkIENTUyBydWxlICcke3J1bGVUZXh0fSdgLCB4KVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gQ1NTUnVsZS1kZXJpdmVkIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBhY3R1YWxsIENTUyBydWxlIGluc2VydGVkIGludG9cclxuXHQvLyB0aGUgc3R5bGVzIHNoZWV0IG9yIHRoZSBwYXJlbnQgcnVsZS5cclxuXHRwdWJsaWMgY3NzUnVsZTogQ1NTUnVsZSB8IG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJTmFtZWRFbnRpdHksIElTdHlsZURlZmluaXRpb24sIElTdHlsZURlZmluaXRpb25DbGFzcywgSVZhclJ1bGUsIE5hbWVHZW5lcmF0aW9uTWV0aG9kfSBmcm9tIFwiLi4vYXBpL1J1bGVUeXBlc1wiXHJcbmltcG9ydCB7U3R5bGVEZWZpbml0aW9uLCBUaGVtZURlZmluaXRpb259IGZyb20gXCIuLi9hcGkvUnVsZUFQSVwiXHJcbmltcG9ydCB7UnVsZSwgUnVsZUxpa2UsIElSdWxlU2VyaWFsaXphdGlvbkNvbnRleHQsIElSdWxlQ29udGFpbmVyfSBmcm9tIFwiLi9SdWxlXCJcclxuaW1wb3J0IHtWYXJSdWxlfSBmcm9tIFwiLi9WYXJSdWxlXCJcclxuaW1wb3J0IHtJbXBvcnRSdWxlLCBOYW1lc3BhY2VSdWxlfSBmcm9tIFwiLi9NaXNjUnVsZXNcIlxyXG5pbXBvcnQge2dldEFjdGl2YXRvciwgc2NoZWR1bGVTdHlsZVVwZGF0ZX0gZnJvbSBcIi4uL2ltcGwvU2NoZWR1bGluZ0ltcGxcIjtcclxuXHJcblxyXG5cclxuLy8gRGVmaW5lIHN5bWJvbHMgdGhhdCBhcmUgdXNlZCBmb3Iga2VlcGluZyBpbXBvcnRhbnQgaW5mb3JtYXRpb24gb24gdGhlIHN0eWxlIGRlZmluaXRpb25cclxuLy8gaW5zdGFuY2VzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBiZSB2aXNpYmxlIHRvIGRldmVsb3BlcnMuXHJcblxyXG4vKiogU3ltYm9sIG9uIHRoZSBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIHBvaW50aW5nIHRvIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuICovXHJcbmNvbnN0IHN5bUluc3RhbmNlID0gU3ltYm9sKFwic2RcIik7XHJcblxyXG4vKipcclxuICogU3ltYm9sIG9uIHRoZSBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlIHBvaW50aW5nIHRvIHRoZSBSdWxlQ29udGFpbmVyIG9iamVjdCB0aGF0IGlzXHJcbiAqIHJlc3BvbnNpYmxlIGZvciBwcm9jZXNzaW5nIHJ1bGVzLlxyXG4gKi9cclxuY29uc3Qgc3ltQ29udGFpbmVyID0gU3ltYm9sKFwicmNcIik7XHJcblxyXG4vKipcclxuICogU3ltYm9sIG9uIHRoZSBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlIHBvaW50aW5nIHRvIHRoZSBTdHlsZURlZmluaXRpb24gY2xhc3MgZm9yIHdoaWNoXHJcbiAqIHRoaXMgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQuXHJcbiAqL1xyXG5jb25zdCBzeW1DbGFzcyA9IFN5bWJvbChcInNkY1wiKTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEVsZW1lbnQgdGhhdCBpcyBjcmVhdGVkIGF0IHRoZSB0b3Agb2YgdGhlIFwiPGhlYWQ+XCIgZWxlbWVudCBiZWZvcmUgYW55IHRoZW1lIGlzIGFjdGl2YXRlZC4gV2hlblxyXG4gKiB0aGVtZXMgYXJlIGFjdGl2YXRlZCwgdGhlaXIgJzxzdHlsZT4nIGVsZW1lbnRzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGlzIGVsZW1lbnQuXHJcbiAqL1xyXG5sZXQgc190aGVtZVBsYWNlaG9sZGVyRWxtOiBFbGVtZW50O1xyXG5cclxuXHJcblxyXG4vKipcclxuICogRmxhZyBpbmRpY2F0aW5nIHRoYXQgYSBydWxlIGNvbnRhaW5lciBpcyBjcmVhdGVkIG5vdCBkaXJlY3RseSAoYXMgZm9yIHN0eWxlZCBjb21wb25lbnRzKVxyXG4gKiBidXQgZnJvbSB0aGUgcHJvY2Vzc0NsYXNzIGZ1bmN0aW9uLiBUaGlzIHZhcmlhYmxlIGlzIHNldCB0byB0cnVlIGJlZm9yZSBpbnN0YW50aWF0aW5nIHRoZVxyXG4gKiBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIChhbmQgdGh1cyB0aGUgUnVsZUNPbnRhaW5lciBvYmplY3QpIGFuZCBpcyBzZXQgYmFjayB0byBmYWxzZSBhZnRlclxyXG4gKiBpdCBpcyB1c2VkIGluIHRoZSBSdWxlQ29udGFpbmVyIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxubGV0IHNfcHJvY2Vzc2luZ1N0eWxlRGVmaW5pdGlvbkNsYXNzID0gZmFsc2U7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUnVsZUNvbnRhaW5lciBjbGFzcyBpcyBhIHNoYWRvdyBzdHJ1Y3R1cmUgdGhhdCBhY2NvbXBhbmllcyBldmVyeSBwcm9jZXNzZWQgc3R5bGUgZGVmaW5pdGlvblxyXG4gKiBvYmplY3QuIFNpbmNlIFN0eWxlRGVmaW5pdGlvbiBjbGFzcyBpcyBhbiBleHBvcnRlZCBjbGFzcyB2aXNpYmxlIHRvIGRldmVsb3BlcnMsIHdlIGRvbid0IHdhbnRcclxuICogdG8gaGF2ZSBhIGxvdCBvZiBmdW5jdGlvbmFsaXR5IGluIGl0LiBUaGUgUnVsZUNvbnRhaW5lciBvYmplY3QgaXMgbGlua2VkIHRvIHRoZSBTdHlsZURlZmluaXRpb25cclxuICogb2JqZWN0IHZpYSB0aGUgW3N5bUNvbnRhaW5lcl0gc3ltYm9sLiBJdCBjb250YWlucyBhbGwgdGhlIGZ1bmN0aW9uYWxpdHkgZm9yIHBhcnNpbmcgcnVsZVxyXG4gKiBkZWZpbml0aW9ucywgbmFtZSBhc3NpZ25tZW50IGFuZCBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQ29udGFpbmVyIGltcGxlbWVudHMgSVJ1bGVDb250YWluZXIsIFByb3h5SGFuZGxlcjxTdHlsZURlZmluaXRpb24+XHJcbntcclxuXHRjb25zdHJ1Y3Rvciggc2Q6IElTdHlsZURlZmluaXRpb24pXHJcblx0e1xyXG5cdFx0dGhpcy5zZCA9IHNkO1xyXG5cclxuICAgICAgICB0aGlzLnNkYyA9IHNkLmNvbnN0cnVjdG9yIGFzIElTdHlsZURlZmluaXRpb25DbGFzcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHNkLiRwYXJlbnQ7XHJcblx0XHR0aGlzLmVjID0gdGhpcy5zZGNbc3ltRW1iZWRkaW5nQ29udGFpbmVyXTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHBhcmVudCBhbmQgdG9wIGxldmVsIGNvbnRhaW5lcnNcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLnBjID0gdGhpcy5wYXJlbnRbc3ltQ29udGFpbmVyXTtcclxuICAgICAgICAgICAgdGhpcy50bGMgPSB0aGlzLnBjIS50bGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy50bGMgPSB0aGlzO1xyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIG5hbWUgZm9yIG91ciBjb250YWluZXIuIElmIHRoZSBjb250YWluZXIgaXMgY3JlYXRlZCBmb3IgYSBjbGFzcyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIHByb2Nlc3NDbGFzcyBmdW5jdGlvbiwgdGhlbiB0aGUgZmxhZyBzX3Byb2Nlc3NpbmdTdHlsZURlZmluaXRpb25DbGFzcyBpcyBkZWZpbmVkXHJcbiAgICAgICAgLy8gYW5kIHRoZSBuYW1lIGlzZ2VuZXJhdGVkIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBnZW5lcmF0aW9uIG1ldGhvZC4gSWYgdGhpcyBmbGFnIGlzXHJcbiAgICAgICAgLy8gZmFsc2UsIHRoYXQgbWVhbnMgdGhhdCB0aGUgY29udGFpbmVyIGlzIGNyZWF0ZWQgZnJvbSBhIGRpcmVjdCBcIm5ld1wiIGNhbGwgb24gdGhlIHN0eWxlXHJcbiAgICAgICAgLy8gZGVmaW5pdGlvbiBjbGFzcyBhbmQgdGhlIG5hbWUgaXMgZ2VuZXJhdGVkIHVuaXF1ZWx5LlxyXG4gICAgICAgIGxldCBuYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgaWYgKHNfcHJvY2Vzc2luZ1N0eWxlRGVmaW5pdGlvbkNsYXNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc19wcm9jZXNzaW5nU3R5bGVEZWZpbml0aW9uQ2xhc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgbmFtZSA9ICF0aGlzLnNkYy5uYW1lIHx8IHNfbmFtZUdlbmVyYXRvbk1ldGhvZCA9PT0gTmFtZUdlbmVyYXRpb25NZXRob2QuT3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGdlbmVyYXRlVW5pcXVlTmFtZSgpXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2RjLm5hbWU7XHJcblxyXG4gICAgICAgICAgICAvLyBhc3NvY2lhdGUgdGhlIGRlZmluaXRpb24gY2xhc3Mgd2l0aCB0aGUgY3JlYXRlZCBkZWZpbml0aW9uIGluc3RhbmNlXHJcbiAgICAgICAgICAgIHRoaXMuc2RjW3N5bUluc3RhbmNlXSA9IHNkO1xyXG4gICAgICAgICAgICBzZFtzeW1DbGFzc10gPSB0aGlzLnNkYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZSA9IGdlbmVyYXRlVW5pcXVlTmFtZSgpO1xyXG4gICAgICAgICAgICBpZiAoc19uYW1lR2VuZXJhdG9uTWV0aG9kICE9PSBOYW1lR2VuZXJhdGlvbk1ldGhvZC5PcHRpbWl6ZWQgJiYgdGhpcy5zZGMubmFtZSlcclxuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCJfXCIgKyB0aGlzLnNkYy5uYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3R5bGUgRGVmaW5pdGlvbiBpbnN0YW5jZSBwb2ludHMgdG8gdGhpcyBydWxlIGNvbnRhaW5lclxyXG4gICAgICAgIHNkW3N5bUNvbnRhaW5lcl0gPSB0aGlzO1xyXG5cclxuXHRcdC8vIGlmIG91ciBjb250YWluZXIgaGFzIHBhcmVudCBjb250YWluZXIsIHByZWZpeCBvdXIgbmFtZSB3aXRoIHRoZSB1cHBlciBvbmVcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnBjID8gYCR7dGhpcy5wYy5uYW1lfV8ke25hbWV9YCA6IG5hbWU7XHJcblx0fVxyXG5cclxuXHJcblxyXG4gICAgLy8gUHJveHlIYW5kbGVyIG1ldGhvZCwgd2hjaWggdmlydHVhbGl6ZXMgYWxsIG5vbi1hcnJheSBwcm9wZXJ0aWVzXHJcbiAgICBzZXQoIHQ6IFN0eWxlRGVmaW5pdGlvbiwgcDogUHJvcGVydHlLZXksIHY6IGFueSwgcjogYW55KTogYm9vbGVhblxyXG4gICAge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcCA9PT0gXCJzeW1ib2xcIiB8fCB0eXBlb2YgcCA9PT0gXCJudW1iZXJcIiB8fCBwIGluIHQgLyp0W3BdICE9PSB1bmRlZmluZWQqLylcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KCB0LCBwLCB2LCByKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB2aXJ0dWFsaXplIGFycmF5cyBiZWNhdXNlIHRoZXJlIGlzIG5vIHRyYXAgZm9yIGlzQXJyYXkoKSBtZXRob2QsIHdoaWNoXHJcbiAgICAgICAgICAgIC8vIHdlIHVzZSBsYXRlciBpbiB0aGUgcHJvY2Vzc1Byb3BlcnR5KCkgbWV0aG9kLlxyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpXHJcbiAgICAgICAgICAgICAgICB2aXJ0dWFsaXplKCB0LCBwKTtcclxuXHJcbiAgICAgICAgICAgIHRbcF0gPSB2O1xyXG4gICAgICAgICAgICB0aGlzLmtleXMucHVzaChwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLy8gUHJvY2Vzc2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlLiBUaGlzIGNyZWF0ZXMgbmFtZXMgZm9yIGNsYXNzZXMsXHJcblx0Ly8gSURzLCBhbmltYXRpb25zIGFuZCBjdXN0b20gdmFyaWFibGVzLlxyXG5cdHB1YmxpYyBwcm9jZXNzKCk6IHZvaWRcclxuXHR7XHJcblx0XHQvLyBsb29wIG92ZXIgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGRlZmluaXRpb24gb2JqZWN0IGFuZCBwcm9jZXNzIHRoZW0uXHJcblx0XHRmb3IoIGxldCBwcm9wTmFtZSBvZiB0aGlzLmtleXMpXHJcblx0XHRcdHRoaXMucHJvY2Vzc1Byb3BlcnR5KCBwcm9wTmFtZSwgdGhpcy5zZFtwcm9wTmFtZV0pO1xyXG5cclxuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc3R5bGUgZGVmaW5pdGlvbiBpbnN0YW5jZS4gVGhpcyBjcmVhdGVzIG5hbWVzIGZvciBjbGFzc2VzLFxyXG5cdC8vIElEcywgYW5pbWF0aW9ucyBhbmQgY3VzdG9tIHZhcmlhYmxlcy5cclxuXHRwcml2YXRlIHByb2Nlc3NQcm9wZXJ0eSggcHJvcE5hbWU6IHN0cmluZyB8IG51bGwsIHByb3BWYWw6IGFueSk6IHZvaWRcclxuXHR7XHJcblx0XHRpZiAocHJvcFZhbCBpbnN0YW5jZW9mIFN0eWxlRGVmaW5pdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NJbnN0YW5jZSggcHJvcFZhbCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcy5wdXNoKCBwcm9wVmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZWxzZSBpZiAocHJvcFZhbCBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBsb29wIG92ZXIgYXJyYXkgZWxlbWVudHMgYW5kIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgdGhlbS4gSW5kZXggYmVjb21lcyBwYXJ0IG9mIHRoZVxyXG4gICAgICAgICAgICAvLyBydWxlIG5hbWUuXHJcbiAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgZm9yKCBsZXQgaXRlbSBvZiBwcm9wVmFsKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUHJvcGVydHkoIGAke3Byb3BOYW1lfV8ke2krK31gLCBpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHByb3BWYWwgaW5zdGFuY2VvZiBSdWxlTGlrZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcHJvcFZhbC5wcm9jZXNzKCB0aGlzLCBwcm9wTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcFZhbCBpbnN0YW5jZW9mIFZhclJ1bGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJzLnB1c2goIHByb3BWYWwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcFZhbCBpbnN0YW5jZW9mIEltcG9ydFJ1bGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzLnB1c2goIHByb3BWYWwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcFZhbCBpbnN0YW5jZW9mIE5hbWVzcGFjZVJ1bGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2VzLnB1c2goIHByb3BWYWwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcFZhbCBpbnN0YW5jZW9mIFJ1bGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdGhlclJ1bGVzLnB1c2goIHByb3BWYWwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZUxpa2VzLnB1c2goIHByb3BWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKiogUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIHN0eWxlc2hlZXQgZGVmaW5pdGlvbiBjbGFzcyAqL1xyXG5cdHB1YmxpYyBnZXREZWYoKTogSVN0eWxlRGVmaW5pdGlvblxyXG5cdHtcclxuXHRcdHJldHVybiB0aGlzLnNkO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGN1c3RvbSBDU1Mgcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG5cdHB1YmxpYyBzZXRWYXJWYWx1ZSggbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBpbXBvcnRhbnQ/OiBib29sZWFuLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICh0aGlzLnZhclJvb3RSdWxlKVxyXG4gICAgICAgICAgICBzY2hlZHVsZVN0eWxlVXBkYXRlKCB0aGlzLnZhclJvb3RSdWxlLCBuYW1lLCB2YWx1ZSwgaW1wb3J0YW50LCBzY2hlZHVsZXJUeXBlKTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGVzIGEgZ2xvYmFsbHkgdW5pcXVlIENTUyBuYW1lIGZvciB0aGUgZ2l2ZW4gcnVsZSBuYW1lIHVubGVzcyB0aGlzIHJ1bGUgbmFtZSBhbHJlYWR5XHJcblx0ICogZXhpc3RzIGVpdGhlciBpbiBhIGJhc2UgY2xhc3Mgb3IgaW4gdGhlIGNoYWluIG9mIHBhcmVudCBncm91cGluZyBydWxlcy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0U2NvcGVkTmFtZSggcnVsZU5hbWU6IHN0cmluZywgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSU5hbWVkRW50aXR5KTogc3RyaW5nXHJcblx0e1xyXG4gICAgICAgIGlmIChuYW1lT3ZlcnJpZGUpXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmFtZU92ZXJyaWRlID09PSBcInN0cmluZ1wiID8gbmFtZU92ZXJyaWRlIDogbmFtZU92ZXJyaWRlLm5hbWU7XHJcblx0XHRlbHNlIGlmICghcnVsZU5hbWUpXHJcblx0XHRcdHJldHVybiBnZW5lcmF0ZVVuaXF1ZU5hbWUoKTtcclxuXHRcdGVsc2UgaWYgKHJ1bGVOYW1lIGluIHRoaXMuc2QgJiYgXCJuYW1lXCIgaW4gdGhpcy5zZFtydWxlTmFtZV0pXHJcblx0XHRcdHJldHVybiB0aGlzLnNkW3J1bGVOYW1lXS5uYW1lO1xyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHQvLyBmaW5kIG91dCBpZiB0aGVyZSBpcyBhIHJ1bGUgd2l0aCB0aGlzIG5hbWUgZGVmaW5lZCBpbiBhIHN0eWxlc2hlZXQgaW5zdGFuY2UgY3JlYXRlZFxyXG4gICAgICAgICAgICAvLyBmb3IgYSBjbGFzcyBmcm9tIHRoZSBwcm90b3R5cGUgY2hhaW4gb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MuIE90aGVyd2lzZSwgaWZcclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBwYXJlbnQgY29udGFpbmVyLCByZWN1cnNlIHRvIGl0OyBvdGhlcndpc2UsIGdlbmVyYXRlIHRoZSBuYW1lLlxyXG5cdFx0XHRsZXQgZXhpc3RpbmdOYW1lID0gZmluZE5hbWVGb3JSdWxlSW5Qcm90b3R5cGVDaGFpbiggdGhpcy5zZGMsIHJ1bGVOYW1lKTtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTmFtZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ05hbWU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYy5nZXRTY29wZWROYW1lKCBydWxlTmFtZSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuXHRcdFx0ICAgIHJldHVybiBnZW5lcmF0ZU5hbWUoIHRoaXMubmFtZSwgcnVsZU5hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuICAgIC8qKiBJbnNlcnRzIGFsbCBydWxlcyBkZWZpbmVkIGluIHRoaXMgY29udGFpbmVyIHRvIGVpdGhlciB0aGUgc3R5bGUgc2hlZXQgb3IgZ3JvdXBpbmcgcnVsZS4gKi9cclxuXHRwdWJsaWMgaW5zZXJ0KCBzaGVldE9yR3JvdXBpbmdSdWxlOiBDU1NTdHlsZVNoZWV0IHwgQ1NTR3JvdXBpbmdSdWxlKTogdm9pZFxyXG5cdHtcclxuXHRcdC8vIGluc2VydCBAaW1wb3J0IGFuZCBAbmFtZXNwYWNlIHJ1bGVzIGFzIHRoZXkgbXVzdCBiZSBiZWZvcmUgb3RoZXIgcnVsZXMuIElmIHRoZSBwYXJlbnQgaXMgYSBncm91cGluZ1xyXG5cdFx0Ly8gcnVsZSwgZG9uJ3QgaW5zZXJ0IEBpbXBvcnQgYW5kIEBuYW1lc3BhY2UgcnVsZXMgYXQgYWxsXHJcblx0XHRpZiAoc2hlZXRPckdyb3VwaW5nUnVsZSBpbnN0YW5jZW9mIENTU1N0eWxlU2hlZXQpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuaW1wb3J0cy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuaW5zZXJ0KCBzaGVldE9yR3JvdXBpbmdSdWxlKSk7XHJcblx0XHRcdHRoaXMubmFtZXNwYWNlcy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuaW5zZXJ0KCBzaGVldE9yR3JvdXBpbmdSdWxlKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWN0aXZhdGUgcmVmZXJlbmNlZCBzdHlsZSBkZWZpbml0aW9uc1xyXG5cdFx0Zm9yKCBsZXQgcmVmIG9mIHRoaXMucmVmcylcclxuXHRcdFx0cmVmW3N5bUNvbnRhaW5lcl0uYWN0aXZhdGUoIHRoaXMuZWxtKTtcclxuXHJcblx0XHQvLyBpbnNlcnQgb3VyIGN1c3RvbSB2YXJpYWJsZXMgaW50byB0aGUgXCI6cm9vdFwiIHJ1bGVcclxuXHRcdGlmICh0aGlzLnZhcnMubGVuZ3RoID4gMClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy52YXJSb290UnVsZSA9IFJ1bGUudG9ET00oIGdldFJvb3RDc3NGb3JWYXJzKCB0aGlzLnZhcnMpLCBzaGVldE9yR3JvdXBpbmdSdWxlKSBhcyBDU1NTdHlsZVJ1bGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5zZXJ0IGFsbCBvdGhlciBydWxlc1xyXG5cdFx0dGhpcy5vdGhlclJ1bGVzLmZvckVhY2goIHJ1bGUgPT4gcnVsZS5pbnNlcnQoIHNoZWV0T3JHcm91cGluZ1J1bGUpKTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0LyoqIENsZWFycyBhbGwgQ1NTIHJ1bGUgb2JqZWN0cyBkZWZpbmVkIGluIHRoaXMgY29udGFpbmVyLiAqL1xyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIC8vIGltcG9ydCBhbmQgbmFtZXNwYWNlIHJ1bGVzIGNhbiBvbmx5IGV4aXN0IGluIHRoZSB0b3AtbGV2ZWwgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc1xyXG5cdFx0aWYgKCF0aGlzLnBhcmVudClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5pbXBvcnRzLmZvckVhY2goIHJ1bGUgPT4gcnVsZS5jbGVhcigpKTtcclxuXHRcdFx0dGhpcy5uYW1lc3BhY2VzLmZvckVhY2goIHJ1bGUgPT4gcnVsZS5jbGVhcigpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnZhclJvb3RSdWxlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLm90aGVyUnVsZXMuZm9yRWFjaCggcnVsZSA9PiBydWxlLmNsZWFyKCkpO1xyXG5cclxuXHRcdC8vIGRlYWN0aXZhdGUgaW1wb3J0ZWQgc3R5bGVzaGVldHNcclxuXHRcdGZvciggbGV0IHJlZiBvZiB0aGlzLnJlZnMpXHJcblx0XHRcdHJlZltzeW1Db250YWluZXJdLmRlYWN0aXZhdGUoKTtcclxuXHR9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgdGhpcyBzdHlsZXNoZWV0IGludG8gRE9NLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnNlcnRCZWZvcmUgT3B0aW9uYWwgSFRNTCBlbGVtZW50IGJlZm9yZSB3aGljaCB0aGUgbmV3ICc8c3R5bGU+JyBlbGVtZW50IHNob3VsZCBiZVxyXG4gICAgICogaW5zZXJ0ZWQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBuZXcgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGFzIHRoZSBsYXN0IGVsZW1lbnQgdW5kZXIgdGhlXHJcbiAgICAgKiAnPGhlYWQ+JyBlbGVtZW50LlxyXG4gICAgICovXHJcblx0cHVibGljIGFjdGl2YXRlKCBpbnNlcnRCZWZvcmU6IEVsZW1lbnQgfCBudWxsID0gbnVsbCk6IHZvaWRcclxuXHR7XHJcblx0XHRpZiAoKyt0aGlzLnJlZkNvdW50ID4gMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBvbmx5IHRoZSB0b3AtbGV2ZWwgbm90LWVtYmVkZGVkIHN0eWxlIGRlZmluaXRpb25zIGNyZWF0ZSB0aGUgYDxzdHlsZT5gIGVsZW1lbnRcclxuICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZWMpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsbSA9IHRoaXMuZWMuZWxtO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZW1lcyBhcmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBzcGVjaWFsIHBsYWNlaG9sZGVyIGVsZW1lbnQsIHdoaWNoIGlzIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgIC8vIGF0IHRoZSB0b3Agb2YgdGhlICc8aGVhZD4nIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNkIGluc3RhbmNlb2YgVGhlbWVEZWZpbml0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc190aGVtZVBsYWNlaG9sZGVyRWxtKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc190aGVtZVBsYWNlaG9sZGVyRWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzdHlsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc190aGVtZVBsYWNlaG9sZGVyRWxtLmlkID0gZ2VuZXJhdGVVbmlxdWVOYW1lKCBcInRoZW1lUGxhY2Vob2xkZXJFbGVtZW50X1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoIHNfdGhlbWVQbGFjZWhvbGRlckVsbSwgZG9jdW1lbnQuaGVhZC5maXJzdEVsZW1lbnRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUgPSBzX3RoZW1lUGxhY2Vob2xkZXJFbG07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInN0eWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbG0uaWQgPSB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZSggdGhpcy5lbG0sIGluc2VydEJlZm9yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLmVsbSA9IHRoaXMudGxjLmVsbTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRoZW1lIGNsYXNzIGFjdGl2YXRpb24sIGNoZWNrIHdoZXRoZXIgdGhlIGluc3RhbmNlIGlzIHNldCBhcyB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vIG9uZSBmb3IgaXRzIHRoZW1lIGJhc2UgY2xhc3MuIElmIG5vLCB0aGVuIGRlYWN0aXZhdGUgdGhlIHRoZW1lIGluc3RhbmNlIGN1cnJlbnRseSBzZXRcclxuICAgICAgICAvLyBhcyBhY3RpdmUuIEluIGFueSBjYXNlLCBzZXQgb3VyIG5ldyBpbnN0YW5jZSBhcyB0aGUgY3VycmVudGx5IGFjdGl2ZSBvbmUuIFdlIGlnbm9yZVxyXG4gICAgICAgIC8vIHRoZW1lIGRlY2xhcmF0aW9uIGNsYXNzZXMgLSB0aG9zZSB0aGF0IGRpcmVjdGx5IGRlcml2ZSBmcm9tIFRoZW1lRGVmaW5pdGlvblxyXG4gICAgICAgIGlmICh0aGlzLnNkIGluc3RhbmNlb2YgVGhlbWVEZWZpbml0aW9uICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLnNkYykgIT09IFRoZW1lRGVmaW5pdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCB0aGVtZUNsYXNzID0gdGhpcy5zZFtzeW1DbGFzc10gYXMgdW5rbm93biBhcyBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VGhlbWVEZWZpbml0aW9uPjtcclxuICAgICAgICAgICAgaWYgKHRoZW1lQ2xhc3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJySW5zdGFuY2UgPSBnZXRDdXJyZW50VGhlbWUoIHRoZW1lQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJJbnN0YW5jZSAmJiBjdXJySW5zdGFuY2UgIT09IHRoaXMuc2QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJDb250YWluZXIgPSBjdXJySW5zdGFuY2Vbc3ltQ29udGFpbmVyXSBhcyBSdWxlQ29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJDb250YWluZXIuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUaGVtZSggdGhpcy5zZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5zZXJ0KCB0aGlzLmVsbSEuc2hlZXQgYXMgQ1NTU3R5bGVTaGVldCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0LyoqIFJlbW92ZXMgdGhpcyBzdHlsZXNoZWV0IGZyb20gRE9NLiAqL1xyXG5cdHB1YmxpYyBkZWFjdGl2YXRlKCk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgLy8gZ3VhcmQgZnJvbSBleHRyYSBkZWFjdGl2YXRlIGNhbGxzXHJcblx0XHRpZiAodGhpcy5yZWZDb3VudCA9PT0gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vLyAjaWYgREVCVUdcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGBFeHRyYSBjYWxsIHRvIGRlYWN0aXZhdGUoKSBmb3Igc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyAnJHt0aGlzLm5hbWV9J2ApO1xyXG4gICAgICAgICAgICAvLy8gI2VuZGlmXHJcblxyXG5cdFx0XHRyZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuXHRcdGlmICgtLXRoaXMucmVmQ291bnQgPiAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgLy8gb25seSB0aGUgdG9wLWxldmVsIG5vdC1lbWJlZGRlZCBzdHlsZSBkZWZpaXRpb25zIGNyZWF0ZSB0aGUgYDxzdHlsZT5gIGVsZW1lbnRcclxuICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmICF0aGlzLmVjKVxyXG4gICAgICAgICAgICB0aGlzLmVsbSEucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZWxtID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHRoZW1lIGNsYXNzIGRlYWN0aXZhdGlvbiwgY2hlY2sgd2hldGhlciB0aGUgaW5zdGFuY2UgaXMgc2V0IGFzIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gb25lIGZvciBpdHMgdGhlbWUgYmFzZSBjbGFzcy4gSWYgeWVzLCByZW1vdmUgaXQgYXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgb25lLlxyXG4gICAgICAgIGlmICh0aGlzLnNkIGluc3RhbmNlb2YgVGhlbWVEZWZpbml0aW9uICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLnNkYykgIT09IFRoZW1lRGVmaW5pdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCB0aGVtZUNsYXNzID0gdGhpcy5zZFtzeW1DbGFzc10gYXMgdW5rbm93biBhcyBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VGhlbWVEZWZpbml0aW9uPjtcclxuICAgICAgICAgICAgaWYgKHRoZW1lQ2xhc3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJySW5zdGFuY2UgPSBnZXRDdXJyZW50VGhlbWUoIHRoZW1lQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJJbnN0YW5jZSA9PT0gdGhpcy5zZClcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDdXJyZW50VGhlbWUoIHRoZW1lQ2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvKiogV3JpdGVzIGFsbCBydWxlcyByZWN1cnNpdmVseSB0byB0aGUgZ2l2ZW4gc3RyaW5nLiAqL1xyXG5cdHB1YmxpYyBzZXJpYWxpemUoIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWRcclxuXHR7XHJcblx0XHQvLyBpbnNlcnQgQGltcG9ydCBhbmQgQG5hbWVzcGFjZSBydWxlcyBhcyB0aGV5IG11c3QgYmUgYmVmb3JlIG90aGVyIHJ1bGVzLiBJZiB0aGUgcGFyZW50IGlzIGEgZ3JvdXBpbmdcclxuXHRcdC8vIHJ1bGUsIGRvbid0IGluc2VydCBAaW1wb3J0IGFuZCBAbmFtZXNwYWNlIHJ1bGVzIGF0IGFsbFxyXG5cdFx0aWYgKCF0aGlzLnBhcmVudClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5pbXBvcnRzLmZvckVhY2goIHJ1bGUgPT4gcnVsZS5zZXJpYWxpemUoIGN0eCkpO1xyXG5cdFx0XHR0aGlzLm5hbWVzcGFjZXMuZm9yRWFjaCggcnVsZSA9PiBydWxlLnNlcmlhbGl6ZSggY3R4KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWN0aXZhdGUgcmVmZXJlbmNlZCBzdHlsZSBkZWZpbml0aW9uc1xyXG4gICAgICAgIGZvciggbGV0IHJlZiBvZiB0aGlzLnJlZnMpXHJcbiAgICAgICAgICAgIGN0eC5hZGRTRCggcmVmKTtcclxuXHJcblx0XHQvLyBzZXJpYWxpemUgb3VyIGN1c3RvbSB2YXJpYWJsZXMgaW4gYSBcIjpyb290XCIgcnVsZVxyXG5cdFx0aWYgKHRoaXMudmFycy5sZW5ndGggPiAwKVxyXG5cdFx0XHRjdHguYWRkUnVsZSggZ2V0Um9vdENzc0ZvclZhcnMoIHRoaXMudmFycykpO1xyXG5cclxuXHRcdC8vIHNlcmlhbGl6ZSBhbGwgb3RoZXIgcnVsZXNcclxuXHRcdHRoaXMub3RoZXJSdWxlcy5mb3JFYWNoKCBydWxlID0+IHJ1bGUuc2VyaWFsaXplKCBjdHgpKTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gSW5zdGFuY2Ugb2YgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3MgdGhhdCB0aGlzIGNvbnRhaW5lciBwcm9jZXNzZWQuXHJcblx0cHVibGljIHNkOiBJU3R5bGVEZWZpbml0aW9uO1xyXG5cclxuXHQvLyBTdHlsZSBkZWZpbml0aW9uIGNsYXNzIHRoYXQgdGhpcyBjb250YWluZXIgY3JlYXRlcyBhbiBpbnN0YW5jZSBvZi5cclxuXHRwdWJsaWMgc2RjOiBJU3R5bGVEZWZpbml0aW9uQ2xhc3NcclxuXHJcblx0Ly8gTmFtZSBvZiB0aGlzIGNvbnRhaW5lciwgd2hpY2gsIGRlcGVuZGluZyBvbiB0aGUgbW9kZSwgaXMgZWl0aGVyIHRha2VuIGZyb20gdGhlIGNsYXNzXHJcblx0Ly8gZGVmaW5pdGlvbiBuYW1lIG9yIGdlbmVyYXRlZCB1bmlxdWVseS5cclxuXHRwdWJsaWMgbmFtZTogc3RyaW5nXHJcblxyXG5cdC8vIENvbnRhaW5lciB0aGF0IGlzIGVtYmVkZGluZyBvdXIgaW5zdGFuY2UgKHRoYXQgaXMsIHRoZSBpbnN0YW5jZSBjb3JyZXNwb25kaW5nIHRvIG91clxyXG4gICAgLy8gY29udGFpbmVyKS4gSWYgZGVmaW5lZCwgdGhpcyBjb250YWluZXIncyBgPHN0eWxlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGluc2VydCBDU1MgcnVsZXNcclxuICAgIC8vIGludG8gaW5zdGVhZCBvZiB0b3BMZXZlbENvbnRhaW5lci5cclxuXHRwdWJsaWMgZWM/OiBFbWJlZGRpbmdDb250YWluZXI7XHJcblxyXG5cdC8vIEluc3RhbmNlIG9mIHRoZSBwYXJlbnQgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyBpbiB0aGUgY2hhaW4gb2YgZ3JvdXBpbmcgcnVsZXMgdGhhdFxyXG5cdC8vIGxlYWQgdG8gdGhpcyBydWxlIGNvbnRhaW5lci4gRm9yIHRvcC1sZXZlbCBzdHlsZSBkZWZpbml0aW9ucywgdGhpcyBpcyB1bmRlZmluZWQuXHJcblx0cHJpdmF0ZSBwYXJlbnQ/OiBJU3R5bGVEZWZpbml0aW9uO1xyXG5cclxuXHQvLyBSdWxlIGNvbnRhaW5lciB0aGF0IGJlbG9uZ3MgdG8gdGhlIHBhcmVudCBzdHlsZSBkZWZpbnRpb24uIElmIG91ciBjb250YWluZXIgaXMgdG9wLWxldmVsLFxyXG5cdC8vIHRoaXMgcHJvcGVydHkgaXMgdW5kZWZpbmVkLlxyXG5cdHByaXZhdGUgcGM/OiBSdWxlQ29udGFpbmVyO1xyXG5cclxuXHQvLyBSdWxlIGNvbnRhaW5lciB0aGF0IGJlbG9uZ3MgdG8gdGhlIG93bmVyIHN0eWxlIGRlZmludGlvbi4gSWYgb3VyIGNvbnRhaW5lciBpcyB0b3AtbGV2ZWwsXHJcblx0Ly8gdGhpcyBwcm9wZXJ0eSBwb2ludHMgdG8gYHRoaXNgLiBOYW1lcyBmb3IgbmFtZWQgcnVsZXMgYXJlIGNyZWF0ZWQgdXNpbmcgdGhpcyBjb250YWluZXIuXHJcblx0cHJpdmF0ZSB0bGM6IFJ1bGVDb250YWluZXI7XHJcblxyXG4gICAgLy8gQXJyYXkgb2YgbmFtZXMgb2YgcHJvcGVydGllcyB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgXCJvd25cIiBwcm9wZXJ0aWVzIG9mIHRoZSBzdHlsZVxyXG4gICAgLy8gZGVmaW5pdGlvbiBvYmplY3QuIFRoaXMgYXJyYXkga2VlcHMgdGhlICBwcm9wZXJ0eSBuYW1lcyBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZGVmaW5lZFxyXG4gICAgLy8gaW4gdGhlIGNsYXNzXHJcbiAgICBwcml2YXRlIGtleXM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgLy8gRmxhZyBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY29udGFpbmVyIGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkXHJcbiAgICBwdWJsaWMgcHJvY2Vzc2VkOiBib29sZWFuO1xyXG5cclxuXHQvLyBMaXN0IG9mIHJlZmVyZW5jZXMgdG8gb3RoZXIgc3R5bGUgZGVmaW5pdGlvbnMgY3JlYWVkIHZpYSB0aGUgJHVzZSBmdW5jdGlvbi5cclxuXHRwcml2YXRlIHJlZnM6IFN0eWxlRGVmaW5pdGlvbltdID0gW107XHJcblxyXG5cdC8vIExpc3Qgb2YgQGltcG9ydCBydWxlc1xyXG5cdHByaXZhdGUgaW1wb3J0czogSW1wb3J0UnVsZVtdID0gW107XHJcblxyXG5cdC8vIExpc3Qgb2YgQG5hbWVzcGFjZSBydWxlc1xyXG5cdHByaXZhdGUgbmFtZXNwYWNlczogTmFtZXNwYWNlUnVsZVtdID0gW107XHJcblxyXG5cdC8vIExpc3Qgb2YgY3VzdG9tIHZhcmlhYmxlIHJ1bGVzLlxyXG5cdHByaXZhdGUgdmFyczogVmFyUnVsZVtdID0gW107XHJcbiAgICBwdWJsaWMgZ2V0VmFycygpOiBWYXJSdWxlW10geyByZXR1cm4gdGhpcy52YXJzOyB9XHJcblxyXG5cdC8vIExpc3Qgb2YgcnVsZXMgdGhhdCBhcmUgbm90IGltcG9ydHMsIG5hbWVzcGFjZXMsIGN1c3RvbSB2YXJzLCByZWZlcmVuY2VzIG9yIGdyb3VwaW5nIHJ1bGVzLlxyXG5cdHByaXZhdGUgb3RoZXJSdWxlczogUnVsZVtdID0gW107XHJcblxyXG5cdC8vIExpc3Qgb2YgcnVsZS1saWtlIG9iamVjdHMuXHJcblx0cHJpdmF0ZSBydWxlTGlrZXM6IFJ1bGVMaWtlW10gPSBbXTtcclxuXHJcblx0Ly8gXCI6cm9vdFwiIHJ1bGUgd2hlcmUgYWxsIGN1c3RvbSBDU1MgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXMgY29udGFpbmVyIGFyZSBkZWZpbmVkLlxyXG5cdHByaXZhdGUgdmFyUm9vdFJ1bGU6IENTU1N0eWxlUnVsZSB8IG51bGw7XHJcblxyXG5cdC8vIFJlZmVyZW5jZSBjb3VudCBvZiBhY3RpdmF0aW9uIHJlcXVlc3RzLlxyXG5cdHByaXZhdGUgcmVmQ291bnQ6IG51bWJlciA9IDA7XHJcblxyXG5cdC8vIERPTSBzdHlsZSBlbGVtbnRcclxuXHRwdWJsaWMgZWxtOiBIVE1MU3R5bGVFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuY29uc3QgZ2V0Um9vdENzc0ZvclZhcnMgPSAodmFyczogVmFyUnVsZVtdKTogc3RyaW5nID0+XHJcbiAgICBgOnJvb3QgeyR7dmFycy5tYXAoIHZhck9iaiA9PiB2YXJPYmoudG9Dc3MoKSkuZmlsdGVyKCB2ID0+ICEhdikuam9pbihcIjtcIil9fWA7XHJcblxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gTmFtZSBnZW5lcmF0aW9uXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHVzZSBvcHRpbWl6ZWQgKHNob3J0KSBydWxlIG5hbWVzLiBJZiB5ZXMsIHRoZSBuYW1lc1xyXG4gKiB3aWxsIGJlIGNyZWF0ZWQgYnkgYXBwZW5kaW5nIGEgdW5pcXVlIG51bWJlciB0byB0aGUgZ2l2ZW4gcHJlZml4LiBJZiB0aGUgcHJlZml4IGlzIG5vdFxyXG4gKiBzcGVjaWZpZWQsIHRoZSBzdGFuZGFyZCBwcmVmaXggXCJuXCIgd2lsbCBiZSB1c2VkLlxyXG4gKiBAcGFyYW0gZW5hYmxlXHJcbiAqIEBwYXJhbSBwcmVmaXhcclxuICovXHJcbmV4cG9ydCBjb25zdCBjb25maWdOYW1lcyA9IChtZXRob2Q6IE5hbWVHZW5lcmF0aW9uTWV0aG9kLCBwcmVmaXg/OiBzdHJpbmcpOiB2b2lkID0+XHJcbntcclxuXHRzX25hbWVHZW5lcmF0b25NZXRob2QgPSBtZXRob2Q7XHJcblx0c191bmlxdWVTdHlsZU5hbWVzUHJlZml4ID0gcHJlZml4ID8gcHJlZml4IDogXCJuXCI7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHVzZSBvcHRpbWl6ZWQgbmFtZXMgZm9yIHN0eWxlIGVsZW1lbnRzIChjbGFzc2VzLCAgYW5pbWF0aW9ucywgZXRjLilcclxuICogQnkgZGVmYXVsdCB0aGlzIGZsYWcgaXMgdHJ1ZSBpbiB0aGUgUmVsZWFzZSBidWlsZCBvZiB0aGUgbGlicmFyeSBhbmQgZmFsc2UgaW4gdGhlIERlYnVnIGJ1aWxkLlxyXG4gKi9cclxubGV0IHNfbmFtZUdlbmVyYXRvbk1ldGhvZCA9IE5hbWVHZW5lcmF0aW9uTWV0aG9kLk9wdGltaXplZDtcclxuXHJcbi8vLyAjaWYgREVCVUdcclxuc19uYW1lR2VuZXJhdG9uTWV0aG9kID0gTmFtZUdlbmVyYXRpb25NZXRob2QuVW5pcXVlU2NvcGVkO1xyXG4vLy8gI2VuZGlmXHJcblxyXG4vKipcclxuICogUHJlZml4IHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgdW5pcXVlIHN0eWxlIG5hbWVzLiBJZiB1bmRlZmluZWQsIGEgc3RhbmRhcmQgcHJlZml4IFwiblwiIHdpbGwgYmUgdXNlZC5cclxuICovXHJcbmxldCBzX3VuaXF1ZVN0eWxlTmFtZXNQcmVmaXggPSBcIm5cIjtcclxuXHJcbi8qKiBOZXh0IG51bWJlciB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHVuaXF1ZSBpZGVudGlmaWVycy4gKi9cclxubGV0IHNfbmV4dFVuaXF1ZUlEID0gMTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBuYW1lIHRvIHVzZSBmb3IgdGhlIGdpdmVuIHJ1bGUgZnJvbSB0aGUgZ2l2ZW4gc3R5bGUgc2hlZXQuXHJcbiAqL1xyXG5jb25zdCBnZW5lcmF0ZU5hbWUgPSAoc2hlZXROYW1lOiBzdHJpbmcsIHJ1bGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT5cclxue1xyXG5cdHN3aXRjaCggc19uYW1lR2VuZXJhdG9uTWV0aG9kKVxyXG4gICAge1xyXG5cdFx0Y2FzZSBOYW1lR2VuZXJhdGlvbk1ldGhvZC5VbmlxdWVTY29wZWQ6IHJldHVybiBgJHtzaGVldE5hbWV9XyR7cnVsZU5hbWV9XyR7c19uZXh0VW5pcXVlSUQrK31gO1xyXG5cdFx0Y2FzZSBOYW1lR2VuZXJhdGlvbk1ldGhvZC5PcHRpbWl6ZWQ6IHJldHVybiBnZW5lcmF0ZVVuaXF1ZU5hbWUoKTtcclxuICAgICAgICBjYXNlIE5hbWVHZW5lcmF0aW9uTWV0aG9kLlNjb3BlZDogcmV0dXJuIGAke3NoZWV0TmFtZX1fJHtydWxlTmFtZX1gO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgbmFtZSwgd2hpY2ggY2FuIGJlIHVzZWQgZWl0aGVyIGZvciBzdHlsZSBlbGVtZW50J3MgSUQgb3Igb3IgY2xhc3MsXHJcbiAqIGlkZW50aWZpZXIgb3IgYW5pbWF0aW9uIG5hbWUuIE5hbWVzIGFyZSBnZW5lcmF0ZWQgdXNpbmcgYSBzaW1wbGUgaW5jcmVtZW50aW5nIG51bWJlci5cclxuICovXHJcbmNvbnN0IGdlbmVyYXRlVW5pcXVlTmFtZSA9IChwcmVmaXg/OiBzdHJpbmcpOiBzdHJpbmcgPT5cclxuXHQocHJlZml4ID8gcHJlZml4IDogc191bmlxdWVTdHlsZU5hbWVzUHJlZml4KSArIHNfbmV4dFVuaXF1ZUlEKys7XHJcblxyXG5cclxuXHJcbi8vIExvb2tzIHVwIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uXHJcbi8vIGNsYXNzLiBJZiBmb3VuZCBhbmQgaWYgdGhlIHByb3BlcnR5IGlzIGEgcnVsZSwgdGhlbiByZXR1cm5zIHRoZSBuYW1lIGFzc2lnbmVkIGZvciBpdC5cclxuY29uc3QgZmluZE5hbWVGb3JSdWxlSW5Qcm90b3R5cGVDaGFpbiA9IChkZWZpbml0aW9uQ2xhc3M6IElTdHlsZURlZmluaXRpb25DbGFzcywgcnVsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT5cclxue1xyXG5cdGlmICghZGVmaW5pdGlvbkNsYXNzKVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdC8vIGxvb3Agb3ZlciBwcm90b3R5cGVzXHJcbiAgICBmb3IoIGxldCBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGRlZmluaXRpb25DbGFzcyk7XHJcbiAgICAgICAgICAgIGJhc2VDbGFzcyAhPT0gU3R5bGVEZWZpbml0aW9uICYmIGJhc2VDbGFzcyAhPT0gVGhlbWVEZWZpbml0aW9uO1xyXG4gICAgICAgICAgICAgICAgYmFzZUNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBiYXNlQ2xhc3MpKVxyXG5cdHtcclxuXHRcdC8vIGNoZWNrIGlmIHRoZSBiYXNlIGNsYXNzIGFscmVhZHkgaGFzIGFuIGFzc29jaWF0ZWQgaW5zdGFuY2U7IGlmIHllcywgY2hlY2sgd2hldGhlclxyXG5cdFx0Ly8gaXQgaGFzIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gcnVsZSBuYW1lLiBJZiB5ZXMsIHRoZW4gdXNlIHRoaXMgcnVsZSdzIGFscmVhZHlcclxuICAgICAgICAvLyBnZW5lcmF0ZWQgbmFtZSAoaWYgZXhpc3RzKS5cclxuXHRcdGlmIChiYXNlQ2xhc3MuaGFzT3duUHJvcGVydHkoc3ltSW5zdGFuY2UpKVxyXG5cdFx0e1xyXG4gICAgICAgICAgICBsZXQgYmFzZUluc3QgPSBiYXNlQ2xhc3Nbc3ltSW5zdGFuY2VdO1xyXG5cdFx0XHRpZiAoYmFzZUluc3QgJiYgIGJhc2VJbnN0W3J1bGVOYW1lXSAhPSBudWxsICYmIFwibmFtZVwiIGluIGJhc2VJbnN0W3J1bGVOYW1lXSlcclxuXHRcdFx0XHRyZXR1cm4gYmFzZUluc3RbcnVsZU5hbWVdLm5hbWU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbnVsbDtcclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gUHJvY2Vzc2luZyBmdW5jdGlvbnNcclxuLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogUHJvY2Vzc2VzIHRoZSBnaXZlbiBzdHlsZXNoZWV0IGRlZmluaXRpb24gY2xhc3Mgb3IgaW5zdGFuY2UgYW5kIGFzc2lnbnMgbmFtZXMgdG8gaXRzIHJ1bGVzLlxyXG4gKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB3ZSBjaGVjayB3aGV0aGVyIHRoZXJlIGlzIGFuIGluc3RhbmNlIGFscmVhZHlcclxuICogY3JlYXRlZCBmb3IgaXQgYXMgYSBjbGFzcyB3aWxsIGhhdmUgb25seSBhIHNpbmdsZSBhc3NvY2lhdGVkIGluc3RhbmUgbm8gbWF0dGVyIGhvdyBtYW55IHRpbWVzXHJcbiAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxyXG4gKlxyXG4gKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCAoYW4gaW5zdGFuY2Ugb2YgdGhlIFN0eWxlRGVmaW5pdGlvbiBjbGFzcykgdGhlbiB3ZSBjaGVjayB3aGV0aGVyXHJcbiAqIGl0IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkLiBJZiB5ZXMsIHdlIGp1c3QgcmV0dXJuIGl0IGJhY2s7IGlmIG5vLCB3ZSBhc3NpZ24gbmV3IHVuaXF1ZSBuYW1lc1xyXG4gKiB0byBpdHMgcnVsZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcHJvY2Vzc1NEID0gKGluc3RPckNsYXNzOiBJU3R5bGVEZWZpbml0aW9uIHwgSVN0eWxlRGVmaW5pdGlvbkNsYXNzLFxyXG5cdCAgICBwYXJlbnQ/OiBJU3R5bGVEZWZpbml0aW9uKTogSVN0eWxlRGVmaW5pdGlvbiA9PlxyXG5cdC8vIGluc3RPckNsYXNzIGhhcyB0eXBlIFwib2JqZWN0XCIgaWYgaXQgaXMgYW4gaW5zdGFuY2UgYW5kIFwiZnVuY3Rpb25cIiBpZiBpdCBpcyBhIGNsYXNzXHJcblx0dHlwZW9mIGluc3RPckNsYXNzID09PSBcIm9iamVjdFwiID8gcHJvY2Vzc0luc3RhbmNlKCBpbnN0T3JDbGFzcykgOiBwcm9jZXNzQ2xhc3MoIGluc3RPckNsYXNzLCBwYXJlbnQpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUHJvY2Vzc2VzIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIGJ5IGNyZWF0aW5nIGl0cyBpbnN0YW5jZSBhbmQgYXNzb2NpYXRpbmcgYVxyXG4gKiBydWxlIGNvbnRhaW5lciBvYmplY3Qgd2l0aCBpdC4gVGhlIGNsYXNzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBpbnN0YW5jZSB1c2luZyBhXHJcbiAqIFN5bWJvbCBwcm9wZXJ0eS4gVGhlIHBhcmVudCBwYXJhbWV0ZXIgaXMgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBzdHlsZSBkZWZpaXRpb25cclxuICogb2JqZWN0IG9yIG51bGwgaWYgdGhlIGdpdmVuIGNsYXNzIGlzIGl0c2VsZiBhIHRvcC1sZXZlbCBjbGFzcyAodGhhdCBpcywgaXMgbm90IGEgY2xhc3NcclxuICogdGhhdCBkZWZpbmVzIHJ1bGVzIHdpdGhpbiBuZXN0ZWQgZ3JvdXBpbmcgcnVsZXMpLlxyXG4gKi9cclxuY29uc3QgcHJvY2Vzc0NsYXNzID0gKHNkYzogSVN0eWxlRGVmaW5pdGlvbkNsYXNzLCBwYXJlbnQ/OiBJU3R5bGVEZWZpbml0aW9uKTogSVN0eWxlRGVmaW5pdGlvbiA9PlxyXG57XHJcbiAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgZGVmaW5pdGlvbiBjbGFzcyBpcyBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBhbiBpbnN0YW5jZS4gTm90ZSB0aGF0IHdlXHJcbiAgICAvLyB1c2UgaGFzT3duUHJvcGVydHkoKSBiZWNhdXNlIG90aGVyd2lzZSwgdGhpcyBjb3VsZCByZXR1cm4gaW5zdGFuY2UgZm9yIHRoZSBiYXNlIHN0eWxlXHJcbiAgICAvLyBkZWZpbml0aW9uIGNsYXNzLlxyXG5cdGlmIChzZGMuaGFzT3duUHJvcGVydHkoc3ltSW5zdGFuY2UpKVxyXG4gICAgICAgIHJldHVybiBzZGNbc3ltSW5zdGFuY2VdIGFzIElTdHlsZURlZmluaXRpb247XHJcblxyXG4gICAgLy8gcmVjdXJzaXZlbHkgcHJvY2VzcyBhbGwgYmFzZSBjbGFzc2VzIHNvIHRoYXQgcnVsZSBuYW1lcyBhcmUgZ2VuZXJhdGVkLiBXZSBkb24ndCBhY3RpdmF0ZSBzdHlsZXNcclxuICAgIC8vIGZvciB0aGVzZSBjbGFzc2VzIGJlY2F1c2UgZGVyaXZlZCBjbGFzc2VzIHdpbGwgaGF2ZSBhbGwgdGhlIHJ1bGVzIGZyb20gYWxsIHRoZSBiYXNlIGNsYXNzZXNcclxuICAgIC8vIGFzIHRoZWlyIG93biBhbmQgc28gdGhlc2UgcnVsZXMgd2lsbCBiZSBhY3RpdmF0ZWQgYXMgcGFydCBvZiB0aGUgZGVyaXZlZCBjbGFzcy5cclxuICAgIGxldCBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIHNkYyk7XHJcbiAgICBpZiAoYmFzZUNsYXNzICE9PSBTdHlsZURlZmluaXRpb24gJiYgYmFzZUNsYXNzICE9PSBUaGVtZURlZmluaXRpb24pXHJcbiAgICAgICAgcHJvY2Vzc0NsYXNzKCBiYXNlQ2xhc3MsIHBhcmVudCk7XHJcblxyXG4gICAgdHJ5XHJcbiAgICB7XHJcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBpbnN0YW5jZSBvZiB0aGUgZGVmaW5pdGlvbiBjbGFzc1xyXG4gICAgICAgIHNfcHJvY2Vzc2luZ1N0eWxlRGVmaW5pdGlvbkNsYXNzID0gdHJ1ZTtcclxuICAgICAgICBsZXQgc2QgPSBuZXcgc2RjKCBwYXJlbnQpO1xyXG5cclxuICAgICAgICAvLyBnZXQgcnVsZSBjb250YWluZXIgZnJvbSB0aGUgaW5zdGFuY2UgYW5kIHByb2Nlc3MgdGhlIHJ1bGVzLlxyXG4gICAgICAgIChzZFtzeW1Db250YWluZXJdIGFzIFJ1bGVDb250YWluZXIpLnByb2Nlc3MoKTtcclxuICAgICAgICByZXR1cm4gc2Q7XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5XHJcbiAgICB7XHJcbiAgICAgICAgc19wcm9jZXNzaW5nU3R5bGVEZWZpbml0aW9uQ2xhc3MgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUHJvY2Vzc2VzIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIGluc3RhbmNlIGFuZCBhc3NpZ25zIG5hbWVzIHRvIGl0cyBydWxlcy4gSWYgdGhlXHJcbiAqIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkLCB3ZSBkbyBub3RoaW5nOyBvdGhlcndpc2UsIHdlIGFzc2lnbiBuZXcgdW5pcXVlIG5hbWVzXHJcbiAqIHRvIGl0cyBydWxlcy5cclxuICovXHJcbmNvbnN0IHByb2Nlc3NJbnN0YW5jZSA9IChzZDogSVN0eWxlRGVmaW5pdGlvbik6IElTdHlsZURlZmluaXRpb24gPT5cclxue1xyXG5cdC8vIGlmIHRoZSBpbnN0YW5jZSBpcyBhbHJlYWR5IHByb2Nlc3NlZCwganVzdCByZXR1cm47IGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlXHJcblx0Ly8gZW1iZWRkaW5nQ29udGFpbmVyIHBhcmFtZXRlci5cclxuXHRsZXQgY29udGFpbmVyID0gc2Rbc3ltQ29udGFpbmVyXSBhcyBSdWxlQ29udGFpbmVyO1xyXG4gICAgaWYgKCFjb250YWluZXIucHJvY2Vzc2VkKVxyXG4gICAgICAgIGNvbnRhaW5lci5wcm9jZXNzKCk7XHJcblxyXG4gICAgcmV0dXJuIHNkO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzZXMgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gaW5zdGFuY2UgYW5kIGFzc2lnbnMgbmFtZXMgdG8gaXRzIHJ1bGVzLiBJZiB0aGVcclxuICogaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQsIHdlIGRvIG5vdGhpbmc7IG90aGVyd2lzZSwgd2UgYXNzaWduIG5ldyB1bmlxdWUgbmFtZXNcclxuICogdG8gaXRzIHJ1bGVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFZhcnNGcm9tU0QgPSAoaW5zdE9yQ2xhc3M6IElTdHlsZURlZmluaXRpb24gfCBJU3R5bGVEZWZpbml0aW9uQ2xhc3MpOiBJVmFyUnVsZVtdID0+XHJcbiAgICAocHJvY2Vzc1NEKCBpbnN0T3JDbGFzcylbc3ltQ29udGFpbmVyXSBhcyBSdWxlQ29udGFpbmVyKS5nZXRWYXJzKCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHJ1bGUgY29udGFpbmVyIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFJDZnJvbVNEID0gKGluc3RhbmNlOiBJU3R5bGVEZWZpbml0aW9uKTogUnVsZUNvbnRhaW5lciA9PlxyXG5cdGluc3RhbmNlID8gaW5zdGFuY2Vbc3ltQ29udGFpbmVyXSA6IG51bGw7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBY3RpdmF0ZXMgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gYW5kIGluc2VydHMgYWxsIGl0cyBydWxlcyBpbnRvIERPTS4gSWYgdGhlIGlucHV0IG9iamVjdCBpc1xyXG4gKiBub3QgYSBzdHlsZSBkZWZpbml0aW9uIGJ1dCBhIHN0eWxlIGRlZmluaXRpb24gY2xhc3MsIG9idGFpbiBzdHlsZSBkZWZpbml0aW9uIGJ5IGNhbGxpbmcgdGhlICR1c2VcclxuICogZnVuY3Rpb24uIE5vdGUgdGhhdCBlYWNoIHN0eWxlIGRlZmluaXRpb24gb2JqZWN0IG1haW50YWlucyBhIHJlZmVyZW5jZSBjb3VudGVyIG9mIGhvdyBtYW55IHRpbWVzXHJcbiAqIGl0IHdhcyBhY3RpdmF0ZWQgYW5kIGRlYWN0aXZhdGVkLiBUaGUgcnVsZXMgYXJlIGluc2VydGVkIHRvIERPTSBvbmx5IHdoZW4gdGhpcyByZWZlcmVuY2UgY291bnRlclxyXG4gKiBnb2VzIGZyb20gMCB0byAxLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFjdGl2YXRlU0QgPSAoaW5zdGFuY2U6IElTdHlsZURlZmluaXRpb24pOiB2b2lkID0+XHJcbntcclxuXHRsZXQgcnVsZUNvbnRhaW5lciA9IGdldFJDZnJvbVNEKCBpbnN0YW5jZSk7XHJcblx0aWYgKCFydWxlQ29udGFpbmVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyBpZiB0aGlzIGNvbnRhaW5lciBoYXMgYW4gZW1iZWRkaW5nIGNvbnRhaW5lciwgYWN0aXZhdGUgdGhlIGVtYmVkZGluZyBjb250YWluZXI7IG90aGVyd2lzZSxcclxuICAgIC8vIGFjdGl2YXRlIHRoZSBydWxlIGNvbnRhaW5lciBpdHNlbGYuXHJcbiAgICAocnVsZUNvbnRhaW5lci5lYyA/PyBydWxlQ29udGFpbmVyKS5hY3RpdmF0ZSgpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEZWFjdGl2YXRlcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBieSByZW1vdmluZyBpdHMgcnVsZXMgZnJvbSBET00uIE5vdGUgdGhhdCBlYWNoIHN0eWxlXHJcbiAqIGRlZmluaXRpb24gb2JqZWN0IG1haW50YWlucyBhIHJlZmVyZW5jZSBjb3VudGVyIG9mIGhvdyBtYW55IHRpbWVzIGl0IHdhcyBhY3RpdmF0ZWQgYW5kXHJcbiAqIGRlYWN0aXZhdGVkLiBUaGUgcnVsZXMgYXJlIHJlbW92ZWQgZnJvbSBET00gb25seSB3aGVuIHRoaXMgcmVmZXJlbmNlIGNvdW50ZXIgZ29lcyBmcm9tIDEgdG8gMC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWFjdGl2YXRlU0QgPSAoaW5zdGFuY2U6IElTdHlsZURlZmluaXRpb24pOiB2b2lkID0+XHJcbntcclxuXHRsZXQgcnVsZUNvbnRhaW5lciA9IGdldFJDZnJvbVNEKCBpbnN0YW5jZSk7XHJcblx0aWYgKCFydWxlQ29udGFpbmVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyBpZiB0aGlzIGNvbnRhaW5lciBoYXMgYW4gZW1iZWRkaW5nIGNvbnRhaW5lciwgZGVhY3RpdmF0ZSB0aGUgZW1iZWRkaW5nIGNvbnRhaW5lcjsgb3RoZXJ3aXNlLFxyXG4gICAgLy8gZGVhY3RpdmF0ZSB0aGUgcnVsZSBjb250YWluZXIgaXRzZWxmLlxyXG4gICAgKHJ1bGVDb250YWluZXIuZWMgPz8gcnVsZUNvbnRhaW5lcikuZGVhY3RpdmF0ZSgpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBzdHlsZSBkZWZpbml0aW9uIHRvIHRoZSBnaXZlbiBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplU0QgPSAoaW5zdGFuY2U6IElTdHlsZURlZmluaXRpb24sIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWQgPT5cclxue1xyXG5cdGxldCBydWxlQ29udGFpbmVyID0gZ2V0UkNmcm9tU0QoIGluc3RhbmNlKTtcclxuXHRpZiAocnVsZUNvbnRhaW5lcilcclxuXHQgICAgcnVsZUNvbnRhaW5lci5zZXJpYWxpemUoIGN0eCk7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIEVtYmVkZGluZ1xyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKiBTeW1ib2wgdXNlZCBpbiBzdHlsZSBkZWZpbml0aW9uIGNsYXNzZXMgdG8gcG9pbnQgdG8gYW4gZW1iZWRkaW5nIGNvbnRhaW5lciAqL1xyXG5sZXQgc3ltRW1iZWRkaW5nQ29udGFpbmVyID0gU3ltYm9sKCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgRW1iZWRkaW5nQ29udGFpbmVyIGNsYXNzIGNvbnRhaW5zIG11bHRpcGxlIHN0eWxlIGRlZmluaXRpb24gY2xhc3Nlcywgd2hpY2ggYXJlIGFjdGl2YXRlZCBhbmRcclxuICogZGVhY3RpdmF0ZWQgdG9nZXRoZXIgdW5kZXIgYSBzaW5nbGUgYDxzdHlsZT5gIG5vZGUuIFN0eWxlIGRlZmluaXRpb24gY2xhc3NlcyBhcmUgYWRkZWQgdG8gdGhlXHJcbiAqIGVtYmVkZGluZyBjb250YWluZXIgYnkgYmVpbmcgZGVjb3JhdGVkIHdpdGggdGhlIGBAZW1iZWRkZWRgIGRlY29yYXRvci5cclxuICovXHJcbmNsYXNzIEVtYmVkZGluZ0NvbnRhaW5lclxyXG57XHJcbiAgICAvKiogSUQgdG8gdXNlIGZvciB0aGUgYDxzdHlsZT5gIGVsZW1lbnQgKi9cclxuICAgIHByaXZhdGUgaWQ6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiBhY3RpdmF0ZWQgc3R5bGUgZGVmaW5pdGlvbnMgYmVsb25naW5nIHRvIHRoaXMgY29udGFpbmVyLiBUaGlzIG51bWJlciBpc1xyXG4gICAgICogaW5jcmVtZW50ZWQgdXBvbiBhY3RpdmF0aW9uIGFuZCBkZWNyZW1lbnRlZCB1cG9uIGRlYWN0aXZhdGlvbiBvZiBzdHlsZSBkZWZpbml0aW9ucy4gV2hlblxyXG4gICAgICogdGhpcyBudW1iZXIgZ29lcyBmcm9tIDAgdG8gMSwgdGhlIGA8c3R5bGU+YCBlbGVtZW50IGlzIGNyZWF0ZWQgYW5kIGFsbCBydWxlcyBmcm9tIGFsbFxyXG4gICAgICogc3R5bGUgZGVmaW5pdGlvbnMgYXJlIGluc2VydGVkIGludG8gaXQuIFdoZW4gdGhpcyBudW1iZXIgZ29lcyBmcm9tIDEgdG8gMCwgdGhlIGA8c3R5bGU+YFxyXG4gICAgICogZWxlbWVudCBpcyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlZkNvdW50OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIENvbGxlY3Rpb24gb2Ygc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzIFwiZW1iZWRkZWRcIiBpbiB0aGlzIGNvbnRhaW5lciAqL1xyXG4gICAgcHJpdmF0ZSBzZGNzOiBTZXQ8SVN0eWxlRGVmaW5pdGlvbkNsYXNzPjtcclxuXHJcblx0Ly8gRE9NIHN0eWxlIGVsZW1udFxyXG5cdHB1YmxpYyBlbG06IEhUTUxTdHlsZUVsZW1lbnQgfCBudWxsO1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCBpZDogc3RyaW5nKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnNkY3MgPSBuZXcgU2V0PElTdHlsZURlZmluaXRpb25DbGFzcz4oKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBjbGFzcyB0byB0aGUgbGlzdCBvZiBlbWJlZGRlZCBjbGFzc2VzLiBJZiB0aGUgY29udGFpbmVyIGlzXHJcbiAgICAgKiBjdXJyZW50bHkgYWN0aXZhdGVkLCB0aGUgY2xhc3Mgd2lsbCBiZSBhY3RpdmF0ZWQgdG9vLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKCBjbHM6IElTdHlsZURlZmluaXRpb25DbGFzcyk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICAvLyBhZGQgb3VyIGNsYXNzIHRvIHRoZSBjb250YWluZXJcclxuICAgICAgICB0aGlzLnNkY3MuYWRkKCBjbHMpO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIHN5bWJvbCBvbiBvdXIgY2xhc3MgdG8gcG9pbnQgdG8gdGhlIGNvbnRhaW5lclxyXG4gICAgICAgIGNsc1tzeW1FbWJlZGRpbmdDb250YWluZXJdID0gdGhpcztcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGVtYmVkZGluZyBjb250YWluZXIgaXMgY3VycmVudGx5IGFjdGl2YXRlZCwgd2UgbmVlZCB0byBhY3RpdmF0ZSB0aGUgYWRkZWRcclxuICAgICAgICAvLyBzdHlsZSBkZWZpbml0aW9uIGNsYXNzIHVzaW5nIHRoZSBjdXJyZW50bHkgZGVmYXVsdCBhY3RpdmF0b3JcclxuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA+IDApXHJcbiAgICAgICAgICAgIGdldEFjdGl2YXRvcigpLmFjdGl2YXRlKCBwcm9jZXNzQ2xhc3MoIGNscykhKTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBJbnNlcnRzIGFsbCBzdHlsZXNoZWV0cyBpbiB0aGlzIGNvbnRhaW5lciBpbnRvIERPTS5cclxuICAgICAqL1xyXG5cdHB1YmxpYyBhY3RpdmF0ZSgpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIC8vIG9ubHkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgYWN0aXZhdGlvbiBjYWxsLCBjcmVhdGUgdGhlIHN0eWxlIGVsZW1lbnQgYW5kIGluc2VydCBhbGxcclxuICAgICAgICAvLyBydWxlcyBmcm9tIGFsbCB0aGUgc3R5bGUgZGVmaW5pdGlvbiBjbGFzc2VzLlxyXG5cdFx0aWYgKCsrdGhpcy5yZWZDb3VudCA9PT0gMSlcclxuXHRcdHtcclxuICAgICAgICAgICAgdGhpcy5lbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInN0eWxlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmVsbS5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHRoaXMuZWxtKTtcclxuXHJcbiAgICAgICAgICAgIGZvciggbGV0IGNscyBvZiB0aGlzLnNkY3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlZmluaXRpb24gY2xhc3MgbWF5IGJlIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGFuIGluc3RhbmNlOyBpZiBub3QgLVxyXG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBpdCBub3cuXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBjbHMuaGFzT3duUHJvcGVydHkoc3ltSW5zdGFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjbHNbc3ltSW5zdGFuY2VdXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm9jZXNzQ2xhc3MoY2xzKTtcclxuXHJcbiAgICAgICAgICAgIFx0bGV0IHJ1bGVDb250YWluZXIgPSBpbnN0YW5jZVtzeW1Db250YWluZXJdIGFzIFJ1bGVDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICBydWxlQ29udGFpbmVyLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgc3R5bGVzaGVldHMgaW4gdGhpcyBjb250YWluZXIgaW50byBET00uXHJcbiAgICAgKi9cclxuXHRwdWJsaWMgZGVhY3RpdmF0ZSgpOiB2b2lkXHJcblx0e1xyXG4gICAgICAgIC8vIG9ubHkgaWYgdGhpcyBpcyB0aGUgbGFzdCBkZWFjdGl2YXRpb24gY2FsbCwgcmVtb3ZlIHRoZSBzdHlsZSBlbGVtZW50IGFuZCByZW1vdmUgYWxsXHJcbiAgICAgICAgLy8gcnVsZXMgZnJvbSBhbGwgdGhlIHN0eWxlIGRlZmluaXRpb24gY2xhc3Nlcy5cclxuXHRcdGlmICgtLXRoaXMucmVmQ291bnQgPT09IDApXHJcblx0XHR7XHJcbiAgICAgICAgICAgIHRoaXMuZWxtPy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbG0gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgZm9yKCBsZXQgY2xzIG9mIHRoaXMuc2RjcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5pdGlvbiBjbGFzcyBtdXN0IGJlIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGFuIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNscy5oYXNPd25Qcm9wZXJ0eShzeW1JbnN0YW5jZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gY2xzW3N5bUluc3RhbmNlXTtcclxuICAgICAgICAgICAgXHRsZXQgcnVsZUNvbnRhaW5lciA9IGluc3RhbmNlW3N5bUNvbnRhaW5lcl0gYXMgUnVsZUNvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIHJ1bGVDb250YWluZXIuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgY2F0ZWdvcnkgbmFtZXMgdG8gZW1iZWRkaW5nIGNvbnRhaW5lciBvYmplY3RzIGNvbnRhaW5pbmcgc3R5bGUgZGVmaW5pdGlvbnMgZm9yIHRoZSBnaXZlblxyXG4gKiBjYXRlZ29yeS5cclxuICovXHJcbmxldCBzX2VtYmVkZGluZ0NvbnRhaW5lcnMgPSBuZXcgTWFwPHN0cmluZyxFbWJlZGRpbmdDb250YWluZXI+KCk7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gZm9yIHN0eWxlIGRlZmluaXRpb24gY2xhc3NlcyB0aGF0IHdpbGwgYmUgZW1iZWRkZWQgaW50byBhbiBlbWJlZGRpbmdcclxuICogY29udGFpbmVyIGZvciB0aGUgZ2l2ZW4gY2F0ZWdvcnkuIEFsbCBzdHlsZSBkZWZpbml0aW9ucyBmb3IgYSBnaXZlbiBjYXRlZ29yeSB3aWxsIGJlIGFjdGl2YXRlZFxyXG4gKiBhbmQgZGVhY3RpdmF0ZWQgdG9nZXRoZXIgYW5kIHRoZWlyIHJ1bGVzIHdpbGwgYmUgaW5zZXJ0ZWQgaW50byBhIHNpbmdsZSBgPHN0eWxlPmAgZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlbWJlZGRlZERlY29yYXRvciA9IChjYXRlZ29yeTogc3RyaW5nLCB0YXJnZXQ6IElTdHlsZURlZmluaXRpb25DbGFzcyk6IGFueSA9PlxyXG57XHJcbiAgICAvLyBjaGVjayB3aGV0aGVyIHdlIGFscmVhZHkgaGF2ZSBjb250YWluZXIgZm9yIHRoaXMgY2F0ZWdvcnk7IGlmIG5vdCwgYWRkIGl0XHJcbiAgICBsZXQgZWMgPSBzX2VtYmVkZGluZ0NvbnRhaW5lcnMuZ2V0KCBjYXRlZ29yeSk7XHJcbiAgICBpZiAoIWVjKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIHVuaXF1ZSBJRCBmb3Igb3VyIGNvbnRhaW5lciwgd2hpY2ggd2lsbCBiZSB0aGUgSUQgb2YgdGhlIGA8c3R5bGU+YCBlbGVtZW50XHJcbiAgICAgICAgbGV0IGlkID0gYCR7Y2F0ZWdvcnl9XyR7c19uZXh0VW5pcXVlSUQrK31gO1xyXG4gICAgICAgIGVjID0gbmV3IEVtYmVkZGluZ0NvbnRhaW5lciggaWQpO1xyXG4gICAgICAgIHNfZW1iZWRkaW5nQ29udGFpbmVycy5zZXQoIGNhdGVnb3J5LCBlYyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIG91ciBjbGFzcyB0byB0aGUgY29udGFpbmVyXHJcbiAgICBlYy5hZGQoIHRhcmdldCk7XHJcbn1cclxuXHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vXHJcbi8vIFJ1bGUgdmlydHVhbGl6YXRpb24uXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGEgcnVsZSBpZiBpdCBpcyBkZWZpbmVkIGFuZCB1c2VkIGluIHRoZSBzYW1lIHN0eWxlXHJcbiAqIGRlZmluaXRpb24gY2xhc3MgYnV0IHRoZW4gaXMgb3ZlcnJpZGRlbiBpbiBhIGRlcml2ZWQgc3R5bGUgZGVmaW5pdGlvbiBjbGFzcy4gVGhlIHByb2JsZW1cclxuICogdGhpcyBzb2x2ZXMgaXMgdGhpczogd2hlbiBhIHJ1bGUgaXMgZGVmaW5lZCBpbiBhIGJhc2UgY2xhc3MgYW5kIHRoZW4gb3ZlcnJpZGRlbiBpbiBhIGRlcml2ZWRcclxuICogY2xhc3MsIHdoZW4gYW4gaW5zdGFuY2Ugb2YgdGhlIGRlcml2ZWQgY2xhc3MgaXMgY3JlYXRlZCwgdGhlIHJ1bGVzIHRoYXQgYXJlIGNyZWF0ZWQgaW4gdGhlXHJcbiAqIGJhc2UgYW5kIGRlcml2ZWQgY2xhc3NlcyBzZWUgZGlmZmVyZW50IHZhbHVlcyBvZiB0aGUgcnVsZS4gU2luY2Ugb3VyIHJ1bGVzIGFyZSBkZWZpbmVkIGFzXHJcbiAqIHBhcnQgb2YgdGhlIGNvbnN0cnVjdG9yLCB0aGUgYmFzZSBjbGFzcyBjb25zdHJ1Y3RvcidzIGNvZGUgb25seSBzZWVzIHRoZSB2YWx1ZSBhc3NpZ25lZCBpbiB0aGF0XHJcbiAqIGNvZGUuIElmIGFub3RoZXIgcnVsZSBpbiB0aGUgYmFzZSBjbGFzcyB1c2VzIHRoaXMgZmlyc3QgcnVsZSwgdGhpcyB2YWx1ZSBpcyByZW1lbWJlcmVkLlxyXG4gKlxyXG4gKiBUaGUgYEB2aXJ0dWFsYCBkZWNvcmF0b3IgY3JlYXRlcyBhIFByb3h5IG9iamVjdCBmb3IgdGhlIHJ1bGUgd2l0aCB0aGUgaGFuZGxlciB0aGF0IGtlZXBzIHRoZVxyXG4gKiBtb3N0IHJlY2VudCB2YWx1ZSBzZXQuIFRodXMgd2hlbiBhIHJ1bGUgaW4gdGhlIGJhc2UgY2xhc3MncyBjb25zdHJ1Y3RvciB1c2VzIGEgdmlydHVhbGl6ZWRcclxuICogcnVsZSwgdGhlIGZpcnN0IHJ1bGUgd2lsbCBzZWUgdGhlIG92ZXJyaWRkZW4gdmFsdWUgb2YgdGhlIHJ1bGUgd2hlbiBhY2Nlc3NlZCBpbiB0aGVcclxuICogcG9zdC1jb25zdHJ1Y3RvciBjb2RlLlxyXG4gKi9cclxuY29uc3QgdmlydHVhbGl6ZSA9ICh0YXJnZXQ6IGFueSwgbmFtZTogc3RyaW5nKTogdm9pZCA9PlxyXG57XHJcbiAgICAvLyBzeW1ib2wgdG8ga2VlcCB0aGUgcHJveHkgaGFuZGxlciB2YWx1ZVxyXG4gICAgbGV0IHN5bSA9IFN5bWJvbChuYW1lKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gZW5zdXJlSGFuZGxlckFuZFByb3h5KCB0aGlzLCBzeW0pLng7IH0sXHJcblxyXG4gICAgICAgIHNldCh2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gc2V0IHRoZSBuZXcgdmFsdWUgdG8gdGhlIGhhbmRsZXIgc28gdGhhdCBpdCB3aWxsIHVzZSBpdCBmcm9tIG5vdyBvbi4gVGhlIHByaW1pdGl2ZVxyXG4gICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIGJveGVkLlxyXG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiB2O1xyXG4gICAgICAgICAgICBlbnN1cmVIYW5kbGVyQW5kUHJveHkoIHRoaXMsIHN5bSkudCA9XHJcbiAgICAgICAgICAgICAgICB0eXBlID09PSBcInN0cmluZ1wiID8gbmV3IFN0cmluZyh2KSA6XHJcbiAgICAgICAgICAgICAgICB0eXBlID09PSBcIm51bWJlclwiID8gbmV3IE51bWJlcih2KSA6XHJcbiAgICAgICAgICAgICAgICB0eXBlID09PSBcImJvb2xlYW5cIiA/IG5ldyBCb29sZWFuKHYpIDpcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09IFwic3ltYm9sXCIgPyBuZXcgT2JqZWN0KHYpIDpcclxuICAgICAgICAgICAgICAgIHY7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgaGFuZGxlciBhbmQgcHJveHkgaW4gdGhlIGdpdmVuIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gc3ltYm9sIGlmIG5vdCBjcmVhdGVkIHlldC5cclxuICogUmV0dXJucyB0aGUgaGFuZGxlci4gUHJveHkgaXMgc3RvcmVkIGluIHRoZSBoYW5kbGVyJ3MgcHJvcGVydHkuXHJcbiAqL1xyXG5jb25zdCBlbnN1cmVIYW5kbGVyQW5kUHJveHkgPSAoaW5zdGFuY2U6IGFueSwgc3ltOiBzeW1ib2wpOiBWaXJ0SGFuZGxlciA9PlxyXG57XHJcbiAgICAvLyBjaGVjayB3aGV0aGVyIHdlIGFscmVhZHkgaGF2ZSB0aGUgaGFuZGxlciBhbmQgY3JlYXRlIGl0IGlmIHdlIGRvbid0LiBJbiB0aGlzXHJcbiAgICAvLyBjYXNlIHdlIGFsc28gY3JlYXRlIGEgcHJveHkgZm9yIGFuIGVtcHR5IG9iamVjdFxyXG4gICAgbGV0IGhhbmRsZXIgPSBpbnN0YW5jZVtzeW1dIGFzIFZpcnRIYW5kbGVyO1xyXG4gICAgaWYgKCFoYW5kbGVyKVxyXG4gICAge1xyXG4gICAgICAgIGluc3RhbmNlW3N5bV0gPSBoYW5kbGVyID0gbmV3IFZpcnRIYW5kbGVyKCk7XHJcbiAgICAgICAgaGFuZGxlci54ID0gbmV3IFByb3h5KCB7fSwgaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXIgZm9yIHRoZSBwcm94eSBjcmVhdGVkIGJ5IHRoZSBgQHZpcnR1YWxgIGRlY29yYXRvci4gSXQga2VlcHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYVxyXG4gKiBydWxlIHNvIHRoYXQgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGlzIHVzZWQgd2hlbmV2ZXIgdGhlIHByb3h5IGlzIGFjY2Vzc2VkLlxyXG4gKi9cclxuY2xhc3MgVmlydEhhbmRsZXIgaW1wbGVtZW50cyBQcm94eUhhbmRsZXI8YW55PlxyXG57XHJcbiAgICAvLyBQcm94eSBvYmplY3QsIHdoaWNoIHdvcmtzIHdpdGggdGhpcyBoYW5kbGVyXHJcbiAgICBwdWJsaWMgeDogYW55O1xyXG5cclxuICAgIC8vIHRoZSBsYXRlc3QgdGFyZ2V0IG9iamVjdCB0byB1c2UgZm9yIGFsbCBwcm94eSBoYW5kbGVyIG9wZXJhdGlvbnNcclxuICAgIHB1YmxpYyB0OiBhbnk7XHJcblxyXG4gICAgLy8gaW50ZXJlc3RpbmcgdGhpbmdzIGhhcHBlbiBpbiB0aGUgZ2V0IG1ldGhvZFxyXG4gICAgZ2V0KCB0OiBhbnksIHA6IFByb3BlcnR5S2V5LCByOiBhbnkpOiBhbnlcclxuICAgIHtcclxuICAgICAgICAvLyBpZiBvdXIgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgYW5kIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgYSB3ZWxsLWtub3duIHN5bWJvbFxyXG4gICAgICAgIC8vIHRvUHJpbWl0aXZlIHdlIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIgbnVsbCBvciB1bmRlZmluZWQuIFRoaXMgd2lsbCBoZWxwXHJcbiAgICAgICAgLy8gaWYgb3VyIHByb3h5IGVpdGhlciBwYXJ0aWNpcGF0ZSBpbiBhbiBhcml0aG1ldGljIGV4cHJlc3Npb24gb3IgaXMgY29tYmluZWQgd2l0aCBhXHJcbiAgICAgICAgLy8gc3RyaW5nLlxyXG4gICAgICAgIGlmICh0aGlzLnQgPT0gbnVsbCAmJiBwID09PSBTeW1ib2wudG9QcmltaXRpdmUpXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLnQ7XHJcblxyXG4gICAgICAgIC8vIGdldCB0aGUgdmFsdWUgb2YgdGhlIHJlcXVlc3QgcHJvcGVydHk7IGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYW4gZXhjZXB0aW9uXHJcbiAgICAgICAgLy8gd2lsbCBiZSB0aHJvd24gLSB3aGljaCBpcyBleHBlY3RlZC5cclxuICAgICAgICBsZXQgcHYgPSBSZWZsZWN0LmdldCggdGhpcy50LCBwLCByKTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBhIGZ1bmN0aW9uLCBiaW5kIHRoZSBvcmlnaW5hbCBtZXRob2QgdG8gdGhlIHRhcmdldCBvYmplY3RcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHB2ID09PSBcImZ1bmN0aW9uXCIgPyBwdi5iaW5kKCB0aGlzLnQpIDogcHY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlIHJlc3Qgb2YgdGhlIG1ldGhvZHMgbW9zdGx5IGRlbGVnYXRlIHRoZSBjYWxscyB0byB0aGUgbGF0ZXN0IHRhcmdldCBpbnN0ZWFkIG9mIHRoZVxyXG4gICAgLy8gb3JpZ2luYWwgdGFyZ2V0LiBJbiBzb21lIGNhc2VzLCB3ZSBjaGVjayB3aGV0aGVyIHRoZSB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQgc28gdGhhdFxyXG4gICAgLy8gd2UgZG9uJ3QgdGhyb3cgZXhjZXB0aW9ucyB3aGVyZSB3ZSBjYW4gYXZvaWQgaXQuXHJcblxyXG4gICAgZ2V0UHJvdG90eXBlT2YoIHQ6IGFueSk6IG9iamVjdCB8IG51bGxcclxuICAgICAgICB7IHJldHVybiB0aGlzLnQgPT0gbnVsbCA/IG51bGwgOiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKCB0aGlzLnQpOyB9XHJcbiAgICBzZXRQcm90b3R5cGVPZih0OiBhbnksIHY6IGFueSk6IGJvb2xlYW5cclxuICAgICAgICB7IHJldHVybiBSZWZsZWN0LnNldFByb3RvdHlwZU9mKCB0aGlzLnQsIHYpOyB9XHJcbiAgICBpc0V4dGVuc2libGUodDogYW55KTogYm9vbGVhblxyXG4gICAgICAgIHsgcmV0dXJuIHRoaXMudCA9PSBudWxsID8gZmFsc2UgOiBSZWZsZWN0LmlzRXh0ZW5zaWJsZSggdGhpcy50KTsgfVxyXG4gICAgcHJldmVudEV4dGVuc2lvbnModDogYW55KTogYm9vbGVhblxyXG4gICAgICAgIHsgcmV0dXJuIHRoaXMudCA9PSBudWxsID8gZmFsc2UgOiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKCB0aGlzLnQpOyB9XHJcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodDogYW55LCBwOiBQcm9wZXJ0eUtleSk6IFByb3BlcnR5RGVzY3JpcHRvciB8IHVuZGVmaW5lZFxyXG4gICAgICAgIHsgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB0aGlzLnQsIHApOyB9XHJcbiAgICBoYXModDogYW55LCBwOiBQcm9wZXJ0eUtleSk6IGJvb2xlYW5cclxuICAgICAgICB7IHJldHVybiB0aGlzLnQgPT0gbnVsbCA/IGZhbHNlIDogUmVmbGVjdC5oYXMoIHRoaXMudCwgcCk7IH1cclxuICAgIHNldCggdDogYW55LCBwOiBQcm9wZXJ0eUtleSwgdjogYW55LCByOiBhbnkpOiBib29sZWFuXHJcbiAgICAgICAgeyByZXR1cm4gUmVmbGVjdC5zZXQoIHRoaXMudCwgcCwgdiwgcik7IH1cclxuICAgIGRlbGV0ZVByb3BlcnR5KHQ6IGFueSwgcDogUHJvcGVydHlLZXkpOiBib29sZWFuXHJcbiAgICAgICAgeyByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSggdGhpcy50LCBwKTsgfVxyXG4gICAgZGVmaW5lUHJvcGVydHkodDogYW55LCBwOiBQcm9wZXJ0eUtleSwgYXR0cnM6IFByb3BlcnR5RGVzY3JpcHRvcik6IGJvb2xlYW5cclxuICAgICAgICB7IHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLnQsIHAsIGF0dHJzKTsgfVxyXG4gICAgb3duS2V5cyh0OiBhbnkpOiBBcnJheUxpa2U8c3RyaW5nIHwgc3ltYm9sPlxyXG4gICAgICAgIHsgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyggdGhpcy50KTsgfVxyXG4gICAgYXBwbHkodDogYW55LCB0aGlzQXJnOiBhbnksIGFyZ3M/OiBhbnkpOiBhbnlcclxuICAgICAgICB7IHJldHVybiB0aGlzLnQuYXBwbHkoIHRoaXNBcmcsIGFyZ3MpOyB9XHJcbiAgICBjb25zdHJ1Y3QodDogYW55LCBhcmdzOiBhbnksIG5ld1RhcmdldD86IGFueSk6IG9iamVjdFxyXG4gICAgICAgIHsgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KCB0aGlzLnQsIGFyZ3MsIG5ld1RhcmdldCk7IH1cclxufVxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gVGhlbWluZyBzdXBwb3J0LlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgdGhlbSBkZWZpbml0aW9uIGNsYXNzZXMgdG8gdGhlIGluc3RhbmNlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlIGZvciB0aGVzZSBjbGFzc2VzLlxyXG4gKi9cclxubGV0IHNfdGhlbWVJbnN0YW5jZU1hcCA9IG5ldyBNYXA8SVN0eWxlRGVmaW5pdGlvbkNsYXNzPFRoZW1lRGVmaW5pdGlvbj4sVGhlbWVEZWZpbml0aW9uPigpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdGhlbWUgYmFzZSBjbGFzcyBmb3IgdGhlIGdpdmVuIHRoZW1lIGNsYXNzLlxyXG4gKiBAcGFyYW0gdGhlbWVDbGFzcyBUaGVtZURlZmluaXRpb24tZGVyaXZlZCBjbGFzc1xyXG4gKiBAcmV0dXJucyBUaGVtZSBiYXNlIGNsYXNzLlxyXG4gKi9cclxuY29uc3QgZ2V0VGhlbWVCYXNlQ2xhc3MgPSAodGhlbWVDbGFzczogSVN0eWxlRGVmaW5pdGlvbkNsYXNzPFRoZW1lRGVmaW5pdGlvbj4pOiBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VGhlbWVEZWZpbml0aW9uPiB8IHVuZGVmaW5lZCA9PlxyXG57XHJcbiAgICAvLyBtYWtlIHN1cmUgd2UgYXJlIG5vdCBwYXNzZWQgdGhlIFRoZW1lRGVmaW5pdGlvbiBjbGFzcyBpdHNlbGZcclxuICAgIGlmICh0aGVtZUNsYXNzID09PSBUaGVtZURlZmluaXRpb24pXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAvLyBsb29wIG92ZXIgcHJvdG90eXBlcyB1bnRpbCB3ZSBmaW5kIHRoZSBjbGFzcywgd2hpY2ggZGVyaXZlcyBkaXJlY3RseSBmcm9tIFRoZW1lRGVmaW5pdGlvbi5cclxuICAgIC8vIFRoaXMgaXMgdGhlIHRoZW1lIGJhc2UgY2xhc3NcclxuICAgIGxldCB0aGVtZUJhc2VDbGFzcyA9IHRoZW1lQ2xhc3M7XHJcbiAgICBmb3IoIGxldCBjbHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIHRoZW1lQ2xhc3MpOyBjbHMgIT09IFRoZW1lRGVmaW5pdGlvbjsgY2xzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBjbHMpKVxyXG4gICAgICAgIHRoZW1lQmFzZUNsYXNzID0gY2xzO1xyXG5cclxuICAgIHJldHVybiB0aGVtZUJhc2VDbGFzcztcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdGhlbWUgZGVmaW5pdGlvbiBvYmplY3QsIHdoaWNoIGlzIGN1cnJlbnRseSBhY3RpdmF0ZWQgZm9yIHRoZSBnaXZlbiB0aGVtZS5cclxuICogQHBhcmFtIHRoZW1lQ2xhc3MgVGhlbWUgZGVmaW5pdGlvbiBjbGFzc1xyXG4gKiBAcmV0dXJucyBUaGVtZSBpbnN0YW5jZSwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2YXRlZCBmb3IgdGhlIGdpdmVuIHRoZW1lIGNsYXNzIG9yIG51bGxcclxuICogaWYgbm8gaXN0YW5jZSBpcyBjdXJyZW50bHkgYWN0aXZhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRUaGVtZSA9ICh0aGVtZUNsYXNzOiBJU3R5bGVEZWZpbml0aW9uQ2xhc3M8VGhlbWVEZWZpbml0aW9uPik6IFRoZW1lRGVmaW5pdGlvbiB8IHVuZGVmaW5lZCA9PlxyXG57XHJcbiAgICBsZXQgdGhlbWVCYXNlQ2xhc3MgPSBnZXRUaGVtZUJhc2VDbGFzcyh0aGVtZUNsYXNzKVxyXG4gICAgcmV0dXJuIHRoZW1lQmFzZUNsYXNzICYmIHNfdGhlbWVJbnN0YW5jZU1hcC5nZXQoIHRoZW1lQmFzZUNsYXNzKTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgdGhlbWUgZGVmaW5pdGlvbiBvYmplY3QgYXMgdGhlIGluc3RhbmNlIHRoYXQgaXMgY3VycmVudGx5IGFjdGl2YXRlZCBmb3IgdGhlXHJcbiAqIGNvcnJlc3BvbmRpbmcgYmFzZSB0aGVtZSBjbGFzcy5cclxuICogQHBhcmFtIHRoZW1lIHRoZW1lIGluc3RhbmNlIHRvIHNldCBhcyBjdXJyZW50IGZvciB0aGUgY29ycmVzcG9uZGluZyBiYXNlIHRoZW1lIGNsYXNzXHJcbiAqL1xyXG5jb25zdCBzZXRDdXJyZW50VGhlbWUgPSAodGhlbWU6IFRoZW1lRGVmaW5pdGlvbik6IHZvaWQgPT5cclxue1xyXG4gICAgbGV0IHRoZW1lQmFzZUNsYXNzID0gZ2V0VGhlbWVCYXNlQ2xhc3MoIHRoZW1lLmNvbnN0cnVjdG9yIGFzIElTdHlsZURlZmluaXRpb25DbGFzczxUaGVtZURlZmluaXRpb24+KTtcclxuICAgIHRoZW1lQmFzZUNsYXNzICYmIHNfdGhlbWVJbnN0YW5jZU1hcC5zZXQoIHRoZW1lQmFzZUNsYXNzLCB0aGVtZSk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSB0aGVtZSBkZWZpbml0aW9uIG9iamVjdCBzZXQgYXMgdGhlIGluc3RhbmNlIHRoYXQgaXMgY3VycmVudGx5IGFjdGl2YXRlZCBmb3IgdGhlXHJcbiAqIGNvcnJlc3BvbmRpbmcgYmFzZSB0aGVtZSBjbGFzcy5cclxuICogQHBhcmFtIHRoZW1lQ2xhc3MgVGhlbWUgZGVmaW5pdGlvbiBjbGFzc1xyXG4gKi9cclxuY29uc3QgcmVtb3ZlQ3VycmVudFRoZW1lID0gKHRoZW1lQ2xhc3M6IElTdHlsZURlZmluaXRpb25DbGFzczxUaGVtZURlZmluaXRpb24+KTogdm9pZCA9PlxyXG57XHJcbiAgICBsZXQgdGhlbWVCYXNlQ2xhc3MgPSBnZXRUaGVtZUJhc2VDbGFzcyggdGhlbWVDbGFzcyk7XHJcbiAgICB0aGVtZUJhc2VDbGFzcyAmJiBzX3RoZW1lSW5zdGFuY2VNYXAuZGVsZXRlKCB0aGVtZUJhc2VDbGFzcyk7XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHtJU3R5bGVSdWxlLCBJVmFyUnVsZSwgRGVwZW5kZW50UnVsZXMsIElOYW1lZEVudGl0eSwgSUNsYXNzUnVsZSwgSUlEUnVsZX0gZnJvbSBcIi4uL2FwaS9SdWxlVHlwZXNcIjtcclxuaW1wb3J0IHtcclxuICAgIEV4dGVuZGVkSVN0eWxlc2V0LCBTdHlsZXNldCwgVmFyVGVtcGxhdGVOYW1lLCBDdXN0b21WYXJfU3R5bGVUeXBlLCBFeHRlbmRlZFZhclZhbHVlLFxyXG4gICAgQ29tYmluZWRTdHlsZXNldCwgUGFyZW50Q2xhc3NUeXBlLCBJU3R5bGVzZXRcclxufSBmcm9tIFwiLi4vYXBpL1N0eWxlc2V0c1wiXHJcbmltcG9ydCB7Q3NzU2VsZWN0b3IsIElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5RnVuY30gZnJvbSBcIi4uL2FwaS9Db3JlVHlwZXNcIlxyXG5pbXBvcnQge1J1bGUsIElSdWxlQ29udGFpbmVyLCBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0fSBmcm9tIFwiLi9SdWxlXCI7XHJcbmltcG9ydCB7Y2FtZWxUb0Rhc2gsIGZkbzJzLCBzeW1WMlN9IGZyb20gXCIuLi9pbXBsL1V0aWxzXCI7XHJcbmltcG9ydCB7c3R5bGVzZXQycywgc3Ayc30gZnJvbSBcIi4uL2ltcGwvU3R5bGVJbXBsXCJcclxuaW1wb3J0IHtzY2hlZHVsZVN0eWxlVXBkYXRlfSBmcm9tIFwiLi4vaW1wbC9TY2hlZHVsaW5nSW1wbFwiO1xyXG5pbXBvcnQge3NlbGVjdG9yMnN9IGZyb20gXCIuLi9pbXBsL0NvcmVJbXBsXCI7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgU3R5bGVSdWxlIGNsYXNzIGlzIHVzZWQgYXMgYSBiYXNlIGNsYXNzIGZvciBydWxlcyB0aGF0IGNvbnRhaW4gYSBzdHlsZSBydWxlLiBUaGlzIGNsYXNzXHJcbiAqIGltcGxlbWVudHMgdGhlIHBhcnNpbmcgb2YgdGhlIENvbWJpbmVkU3R5bGVzZXQgb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0eWxlUnVsZSBleHRlbmRzIFJ1bGUgaW1wbGVtZW50cyBJU3R5bGVSdWxlXHJcbntcclxuXHQvLyBUaGUgc3R5bGVzZXQgY2FuIGJlIGFuIENvbWJpbmVkU3R5bGVzZXQgZm9yIG1hbnkgcnVsZXM7IGhvd2V2ZXIsIGZvciBzb21lIGl0IGlzIGp1c3RcclxuXHQvLyBvZiB0aGUgU3R5bGVzZXQgdHlwZS5cclxuXHRwdWJsaWMgY29uc3RydWN0b3IoIGlucHV0U3R5bGVzZXQ/OiBTdHlsZXNldCB8IFN0eWxlc2V0W10pXHJcblx0e1xyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnN0eWxlc2V0ID0ge307XHJcblx0XHR0aGlzLmRlcGVuZGVudFJ1bGVzID0ge307XHJcblxyXG5cdFx0aWYgKGlucHV0U3R5bGVzZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSggaW5wdXRTdHlsZXNldCkpXHJcbiAgICAgICAgICAgICAgICBpbnB1dFN0eWxlc2V0LmZvckVhY2goIHYgPT4gdGhpcy5wYXJzZSh2KSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuXHRcdFx0ICAgIHRoaXMucGFyc2UoIGlucHV0U3R5bGVzZXQpO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhlIG9iamVjdCB0byBwYXJ0aWNwYXRlIGluIFwidjJzXCIgc2VyaWFsaXphdGlvbi4gV2hlbmV2ZXIgdGhlXHJcbiAgICAgKiBTdHlsZVJ1bGUtZGVyaXZlZCBvYmplY3QgaXMgZW5jb3VudGVyZWQgYnkgdGhlIGB2MnNgIGZ1bmN0aW9uLCB0aGUgcnVsZSdzIHNlbGVjdG9yIHdpbGwgYmVcclxuICAgICAqIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIFtzeW1WMlNdKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLnNlbGVjdG9yVGV4dDsgfVxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogR29lcyBvdmVyIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuIHN0eWxlc2V0IGFuZCBwYXJzZXMgdGhlbSBpbnRvIHByb3BlciBzdHlsZXNldCwgc2V0IG9mXHJcblx0ICogaW1wb3J0YW50IHByb3BlcnRpZXMgYW5kIGRlcGVuZGVudCBydWxlcy5cclxuXHQgKi9cclxuXHRwcml2YXRlIHBhcnNlKCBpbnB1dFN0eWxlc2V0OiBTdHlsZXNldCk6IHZvaWRcclxuXHR7XHJcblx0XHRmb3IoIGxldCBwcm9wTmFtZSBpbiBpbnB1dFN0eWxlc2V0KVxyXG5cdFx0e1xyXG5cdFx0XHRsZXQgcHJvcFZhbCA9IGlucHV0U3R5bGVzZXRbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiK1wiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW5kc1Byb3BWYWwgPSBwcm9wVmFsIGFzIChTdHlsZVJ1bGUgfCBTdHlsZVJ1bGVbXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kc1Byb3BWYWwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIGlzIGEgc2luZ2xlIFN0eWxlUnVsZSBvciBhbiBhcnJheSBvZiBTdHlsZVJ1bGVzIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudFJ1bGVzID0gZXh0ZW5kc1Byb3BWYWwgaW5zdGFuY2VvZiBTdHlsZVJ1bGUgPyBbZXh0ZW5kc1Byb3BWYWxdIDogZXh0ZW5kc1Byb3BWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKCBsZXQgcGFyZW50IG9mIHBhcmVudFJ1bGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VTdHlsZXNldHMoIHRoaXMuc3R5bGVzZXQsIHBhcmVudC5zdHlsZXNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29weURlcFJ1bGVzKCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCItLVwiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcFZhbClcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZUN1c3RvbVByb3BzKCB0aGlzLnN0eWxlc2V0LCBwcm9wVmFsIGFzIEN1c3RvbVZhcl9TdHlsZVR5cGVbXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHRcdFx0ZWxzZSBpZiAocHJvcE5hbWUuc3RhcnRzV2l0aChcIjpcIikpXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvLyBpZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gdGhpcyBpcyBhbiBhcnJheSBvZiB0dXBsZXMgcmVwcmVzZW50aW5nXHJcblx0XHRcdFx0Ly8gcGFyYW1ldGVyaXNlZCBwc2V1ZG8gZW50aXRpZXMgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIHBhcmFtZXRlciB2YWx1ZVxyXG5cdFx0XHRcdC8vIChzdHJpbmcpIGFuZCB0aGUgc2Vjb25kIHRoZSBDb21iaW5lZFN0eWxlc2V0LiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBpcyBqdXN0IGFcclxuXHRcdFx0XHQvLyBDb21iaW5lZFN0eWxlc2V0LlxyXG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHByb3BWYWwpKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGxldCB0dXBsZXMgPSBwcm9wVmFsIGFzIFthbnksIENvbWJpbmVkU3R5bGVzZXQgfCBDb21iaW5lZFN0eWxlc2V0W11dW107XHJcblx0XHRcdFx0XHRpZiAodHVwbGVzLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHRoaXMuZGVwZW5kZW50UnVsZXNbcHJvcE5hbWVdID0gdHVwbGVzLm1hcCggdHVwbGUgPT4gbmV3IERlcFJ1bGUoXHJcblx0XHRcdFx0XHRcdFx0cHJvcE5hbWUsIHR1cGxlWzBdLCB0dXBsZVsxXSwgdGhpcykpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aGlzLmRlcGVuZGVudFJ1bGVzW3Byb3BOYW1lXSA9IG5ldyBEZXBSdWxlKCBcIiZcIiArIHByb3BOYW1lLCB1bmRlZmluZWQsXHJcblx0XHRcdFx0XHRcdHByb3BWYWwgYXMgQ29tYmluZWRTdHlsZXNldCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAocHJvcE5hbWUuaW5jbHVkZXMoXCImXCIpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBhbiBhcnJheSBvZiB0d28tZWxlbWVudCB0dXBsZXMgd2l0aCBzZWxlY3RvciBhbmQgc3R5bGVzZXRcclxuICAgICAgICAgICAgICAgIGxldCB0dXBsZXMgPSBwcm9wVmFsIGFzIFtDc3NTZWxlY3RvciwgQ29tYmluZWRTdHlsZXNldCB8IENvbWJpbmVkU3R5bGVzZXRbXV1bXTtcclxuICAgICAgICAgICAgICAgIGlmICh0dXBsZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVudFJ1bGVzW3Byb3BOYW1lXSA9IHR1cGxlcy5tYXAoIHR1cGxlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1NlbGVjdG9yID0gcHJvcE5hbWUgPT09IFwiJlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHR1cGxlWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByb3BOYW1lLnN0YXJ0c1dpdGgoXCImXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcHJvcE5hbWUsIHR1cGxlWzBdXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW3R1cGxlWzBdLCBwcm9wTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVwUnVsZSggbmV3U2VsZWN0b3IsIHVuZGVmaW5lZCwgdHVwbGVbMV0sIHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHRcdFx0ZWxzZSBpZiAodGhpcy5wYXJzZVNQKCBwcm9wTmFtZSwgcHJvcFZhbCkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvLyB0aGlzIGlzIGEgcmVndWxhciBDU1MgcHJvcGVydHk6IGNvcHkgdGhlIHByb3BlcnR5IHZhbHVlIHRvIG91ciBpbnRlcm5hbCBzdHlsZXNldFxyXG4gICAgICAgICAgICAgICAgbWVyZ2VQcm9wVmFsdWVzKCB0aGlzLnN0eWxlc2V0LCBwcm9wTmFtZSwgcHJvcFZhbClcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIGNvbnRhaW5lcjogSVJ1bGVDb250YWluZXIsIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKTogdm9pZFxyXG5cdHtcclxuXHRcdHN1cGVyLnByb2Nlc3MoIGNvbnRhaW5lciwgcnVsZU5hbWUpO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaERlcFJ1bGUoIChkZXBSdWxlOiBEZXBSdWxlKSA9PiBkZXBSdWxlLnByb2Nlc3MoIGNvbnRhaW5lciwgbnVsbCkpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBDb252ZXJ0cyB0aGUgcnVsZSB0byBDU1Mgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnVsZS5cclxuXHRwdWJsaWMgdG9Dc3MoKTogc3RyaW5nXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0b3JUZXh0ICsgc3R5bGVzZXQycyggdGhpcy5zdHlsZXNldCk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIEluc2VydHMgdGhpcyBydWxlIGludG8gdGhlIGdpdmVuIHBhcmVudCBydWxlIG9yIHN0eWxlc2hlZXQuXHJcblx0cHVibGljIGluc2VydCggcGFyZW50OiBDU1NTdHlsZVNoZWV0IHwgQ1NTR3JvdXBpbmdSdWxlKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmIChPYmplY3Qua2V5cyh0aGlzLnN0eWxlc2V0KS5sZW5ndGggPiAwKVxyXG5cdFx0XHR0aGlzLmNzc1J1bGUgPSBSdWxlLnRvRE9NKCB0aGlzLnRvQ3NzKCksIHBhcmVudCkgYXMgQ1NTU3R5bGVSdWxlO1xyXG5cclxuICAgICAgICAvLyBpbnNlcnQgZGVwZW5kZW50IHJ1bGVzIHVuZGVyIHRoZSBzYW1lIHBhcmVudFxyXG4gICAgICAgIHRoaXMuZm9yRWFjaERlcFJ1bGUoIChkZXBSdWxlOiBEZXBSdWxlKSA9PiBkZXBSdWxlLmluc2VydCggcGFyZW50KSk7XHJcblx0fVxyXG5cclxuXHQvLyBDbGVycyB0aGUgQ1NTIHJ1bGUgb2JqZWN0LlxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkXHJcblx0e1xyXG5cdFx0c3VwZXIuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgLy8gY2xlYXIgZGVwZW5kZW50IHJ1bGVzXHJcbiAgICAgICAgdGhpcy5mb3JFYWNoRGVwUnVsZSggKGRlcFJ1bGU6IERlcFJ1bGUpID0+IGRlcFJ1bGUuY2xlYXIoKSk7XHJcblx0fVxyXG5cclxuXHQvLyBTZXJpYWxpemVzIHRoaXMgcnVsZSB0byBhIHN0cmluZy5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWRcclxuICAgIHtcclxuXHRcdGlmIChPYmplY3Qua2V5cyh0aGlzLnN0eWxlc2V0KS5sZW5ndGggPiAwKVxyXG5cdFx0XHRjdHguYWRkUnVsZSggdGhpcy50b0NzcygpKTtcclxuXHJcbiAgICAgICAgLy8gaW5zZXJ0IGRlcGVuZGVudCBydWxlcyB1bmRlciB0aGUgc2FtZSBwYXJlbnRcclxuICAgICAgICB0aGlzLmZvckVhY2hEZXBSdWxlKCAoZGVwUnVsZTogRGVwUnVsZSkgPT4gZGVwUnVsZS5zZXJpYWxpemUoIGN0eCkpO1xyXG5cclxuICAgIH1cclxuXHJcblx0Ly8gSW52b2tlIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgZGVwZW5kZW50IHJ1bGVzLlxyXG5cdHByaXZhdGUgZm9yRWFjaERlcFJ1bGUoIGZ1bmM6IChkZXBSdWxlOiBEZXBSdWxlKSA9PiB2b2lkKTogdm9pZFxyXG5cdHtcclxuXHRcdGZvciggbGV0IHByb3BOYW1lIGluIHRoaXMuZGVwZW5kZW50UnVsZXMpXHJcblx0XHR7XHJcblx0XHRcdGxldCBwcm9wVmFsID0gdGhpcy5kZXBlbmRlbnRSdWxlc1twcm9wTmFtZV0gYXMgRGVwUnVsZSB8IERlcFJ1bGVbXTtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbCkpXHJcbiAgICAgICAgICAgICAgICBmb3IoIGxldCBkZXBSdWxlIG9mIHByb3BWYWwpIGZ1bmMoIGRlcFJ1bGUpO1xyXG5cdFx0XHRlbHNlXHJcbiAgICAgICAgICAgICAgICBmdW5jKCBwcm9wVmFsKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0LyoqIENTUyBydWxlIHNlbGVjdG9yIHN0cmluZyAqL1xyXG5cdHB1YmxpYyBnZXQgc2VsZWN0b3JUZXh0KCk6IHN0cmluZ1xyXG5cdHtcclxuXHRcdGlmICh0aGlzLl9zZWwgPT0gbnVsbClcclxuXHRcdFx0dGhpcy5fc2VsID0gdGhpcy5nZXRTZWwoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc2VsO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBDb3BpZXMgZGVwZW5kZW50IHJ1bGVzIGZyb20gYW5vdGhlciBzdHlsZSBydWxlIG9iamVjdC5cclxuXHRwcm90ZWN0ZWQgY29weURlcFJ1bGVzKCBzcmM6IFN0eWxlUnVsZSk6IHZvaWRcclxuXHR7XHJcbiAgICAgICAgbGV0IHNyc0RlcFJ1bGVzID0gc3JjLmRlcGVuZGVudFJ1bGVzO1xyXG4gICAgICAgIGxldCB0aGlzRGVwUnVsZXMgPSB0aGlzLmRlcGVuZGVudFJ1bGVzO1xyXG5cdFx0Zm9yKCBsZXQgcHJvcE5hbWUgaW4gc3JzRGVwUnVsZXMpXHJcblx0XHR7XHJcblx0XHRcdGxldCBzcmNSdWxlT3JBcnIgPSBzcnNEZXBSdWxlc1twcm9wTmFtZV0gYXMgRGVwUnVsZSB8IERlcFJ1bGVbXTtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc3JjUnVsZU9yQXJyKSlcclxuXHRcdFx0e1xyXG4gICAgICAgICAgICAgICAgaWYgKHNyY1J1bGVPckFyci5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aGlzQXJyID0gdGhpc0RlcFJ1bGVzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNBcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEZXBSdWxlc1twcm9wTmFtZV0gPSB0aGlzQXJyID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciggbGV0IHNyY0RlcFJ1bGUgb2Ygc3JjUnVsZU9yQXJyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQXJyLnB1c2goIHNyY0RlcFJ1bGUuY2xvbmUoIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhpc0RlcFJ1bGVzW3Byb3BOYW1lXSA9IHNyY1J1bGVPckFyci5jbG9uZSggdGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUuXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGdldFNlbCgpOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gQWxsb3dzIHRoZSBkZXJpdmVkIGNsYXNzZXMgdG8gcHJvY2VzcyBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgdGhlIFN0eWxlUnVsZSBkb2Vzbid0IGtub3cgYWJvdXQuXHJcbiAgICAvLyBJZiBmYWxzZSBpcyByZXR1cm5lZCwgdGhlIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHN0eWxlc2V0LlxyXG5cdHByb3RlY3RlZCBwYXJzZVNQKCBwcm9wTmFtZTogc3RyaW5nLCBwcm9wVmFsOiBhbnkpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzL3JlcGxhY2VzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gQ1NTIHByb3BlcnR5IGluIHRoaXMgcnVsZS5cclxuXHQgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBDU1MgcHJvcGVydHkuXHJcblx0ICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSBvZiB0aGUgQ1NTIHByb3BlcnR5LlxyXG5cdCAqIEBwYXJhbSBpbXBvcnRhbnQgRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gc2V0IHRoZSBcIiFpbXBvcnRhbnRcIiBmbGFnIG9uIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuXHQgKiBAcGFyYW0gc2NoZWR1bGVyVHlwZSBJRCBvZiBhIHJlZ2lzdGVyZWQgc2NoZWR1bGVyIHR5cGUgdGhhdCBpcyB1c2VkIHRvIHdyaXRlIHRoZSBwcm9wZXJ0eVxyXG5cdCAqIHZhbHVlIHRvIHRoZSBET00uIElmIHVuZGVmaW5lZCwgdGhlIGN1cnJlbnQgZGVmYXVsdCBzY2hlZHVsZXIgd2lsbCBiZSB1c2VkLlxyXG5cdCAqL1xyXG4gICAgcHVibGljIHNldFByb3A8SyBleHRlbmRzIGtleW9mIElTdHlsZXNldD4oIG5hbWU6IEssIHZhbHVlOiBFeHRlbmRlZElTdHlsZXNldFtLXSxcclxuICAgICAgICBpbXBvcnRhbnQ/OiBib29sZWFuLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG5cdHtcclxuXHRcdC8vIGZpcnN0IHNldC9yZW1vdmUgdGhlIHZhbHVlIGluIG91ciBpbnRlcm5hbCBzdHlsZXNldCBvYmplY3RcclxuXHRcdGlmICh2YWx1ZSA9PSBudWxsKVxyXG5cdFx0XHRkZWxldGUgdGhpcy5zdHlsZXNldFtuYW1lXTtcclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy5zdHlsZXNldFtuYW1lXSA9IGltcG9ydGFudCA/IHsgXCIhXCI6IHZhbHVlIGFzIGFueSB9IDogdmFsdWUgYXMgYW55O1xyXG5cclxuXHRcdC8vIHNlY29uZCwgaWYgQ1NTUnVsZSBhbHJlZHkgZXhpc3RzLCBzZXQvcmVtb3ZlIHRoZSBwcm9wZXJ0eSB2YWx1ZSB0aGVyZVxyXG5cdFx0aWYgKHRoaXMuY3NzUnVsZSlcclxuICAgICAgICB7XHJcblx0XHQgICAgc2NoZWR1bGVTdHlsZVVwZGF0ZSggdGhpcy5jc3NSdWxlLCBjYW1lbFRvRGFzaCggbmFtZSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHNwMnMoIG5hbWUsIHZhbHVlKSwgaW1wb3J0YW50LCBzY2hlZHVsZXJUeXBlKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMvcmVwbGFjZXMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBjdXN0b20gQ1NTIHByb3BlcnR5IGluIHRoaXMgcnVsZS5cclxuXHQgKiBAcGFyYW0gdmFyT2JqIElWYXJSdWxlIG9iamVjdCBkZWZpbmluZyBhIGN1c3RvbSBDU1MgcHJvcGVydHkuXHJcblx0ICogQHBhcmFtIHZhclZhbHVlIE5ldyB2YWx1ZSBvZiB0aGUgY3VzdG9tIENTUyBwcm9wZXJ0eS5cclxuXHQgKiBAcGFyYW0gaW1wb3J0YW50IEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHNldCB0aGUgXCIhaW1wb3J0YW50XCIgZmxhZyBvbiB0aGUgcHJvcGVydHkgdmFsdWUuXHJcblx0ICogQHBhcmFtIHNjaGVkdWxlclR5cGUgSUQgb2YgYSByZWdpc3RlcmVkIHNjaGVkdWxlciB0eXBlIHRoYXQgaXMgdXNlZCB0byB3cml0ZSB0aGUgcHJvcGVydHlcclxuXHQgKiB2YWx1ZSB0byB0aGUgRE9NLiBJZiB1bmRlZmluZWQsIHRoZSBjdXJyZW50IGRlZmF1bHQgc2NoZWR1bGVyIHdpbGwgYmUgdXNlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgc2V0Q3VzdG9tUHJvcDxLIGV4dGVuZHMgVmFyVGVtcGxhdGVOYW1lPiggdmFyT2JqOiBJVmFyUnVsZTxLPiwgdmFsdWU6IEV4dGVuZGVkVmFyVmFsdWU8Sz4sXHJcblx0XHRpbXBvcnRhbnQ/OiBib29sZWFuLCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG5cdHtcclxuXHRcdGlmICghdmFyT2JqKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Ly8gZmlyc3Qgc2V0L3JlbW92ZSB0aGUgdmFsdWUgaW4gb3VyIGludGVybmFsIHN0eWxlc2V0IG9iamVjdFxyXG5cdFx0bGV0IGN1cnJDdXN0b21Qcm9wcyA9IHRoaXMuc3R5bGVzZXRbXCItLVwiXSBhcyBDdXN0b21WYXJfU3R5bGVUeXBlW107XHJcblx0XHRpZiAoY3VyckN1c3RvbVByb3BzIHx8IHZhbHVlICE9IG51bGwpXHJcblx0XHR7XHJcblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsKVxyXG5cdFx0XHR7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjdXJyQ3VzdG9tUHJvcHMuZmluZEluZGV4KCBpdGVtID0+IGl0ZW1bMF0gPT09IHZhck9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMClcclxuICAgICAgICAgICAgICAgICAgICBjdXJyQ3VzdG9tUHJvcHMuc3BsaWNlKCBpbmRleCwgMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoIWN1cnJDdXN0b21Qcm9wcylcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzZXRbXCItLVwiXSA9IFtbdmFyT2JqLCB2YWx1ZV1dO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGN1cnJDdXN0b21Qcm9wcy5maW5kSW5kZXgoIGl0ZW0gPT4gaXRlbVswXSA9PT0gdmFyT2JqKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJDdXN0b21Qcm9wc1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjdXJyQ3VzdG9tUHJvcHMucHVzaCggW3Zhck9iaiwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNlY29uZCwgaWYgQ1NTUnVsZSBhbHJlZHkgZXhpc3RzLCBzZXQvcmVtb3ZlIHRoZSBwcm9wZXJ0eSB2YWx1ZSB0aGVyZVxyXG5cdFx0aWYgKHRoaXMuY3NzUnVsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlU3R5bGVVcGRhdGUoIHRoaXMuY3NzUnVsZSwgdmFyT2JqLmNzc1Zhck5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHNwMnMoIHZhck9iai50ZW1wbGF0ZSwgdmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgaW1wb3J0YW50LCBzY2hlZHVsZXJUeXBlKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKiBTT00gc3R5bGUgcnVsZSAqL1xyXG5cdHB1YmxpYyBjc3NSdWxlOiBDU1NTdHlsZVJ1bGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIE9iamVjdCBjb250YWluaW5nIGRlcGVuZGVudCBydWxlcy4gUHJvcGVydHkgbmFtZXMgYXJlIHRha2VuIGZyb20gc3BlY2lhbCBwcm9wZXJ0aWVzXHJcblx0ICogb2YgdGhlIENvbWJpbmVkU3R5bGVzZXQuIFRoaXMgb2JqZWN0IGFsbG93cyBjYWxsZXJzIHRvIGFjY2VzcyBkZXBlbmRlbnQgcnVsZXMgdG8gY2hhbmdlXHJcblx0ICogc3R5bGUgcHJvcGVydHkgdmFsdWVzIHByb2dyYW1tYXRpY2FsbHkuXHJcblx0ICovXHJcblx0cHVibGljIGRlcGVuZGVudFJ1bGVzOiBEZXBlbmRlbnRSdWxlcztcclxuXHJcblx0Ly8gUmVzdWx0YW50IG9iamVjdCBkZWZpbmluZyBwcm9wZXJ0aWVzIHRvIGJlIGluc2VydGVkIGludG8gRE9NLlxyXG5cdHByb3RlY3RlZCBzdHlsZXNldDogU3R5bGVzZXQ7XHJcblxyXG5cdC8vIFNlbGVjdG9yIHN0cmluZyBjYWNoZWQgYWZ0ZXIgaXQgaXMgZmlyc3Qgb2J0YWluZWQuIE5lZWRlZCB0byBub3QgaW52b2tlIGdldFNlbGVjdG9yU3RyaW5nXHJcblx0Ly8gbXVsdGlwbGUgdGltZXMgaW4gdGhlIHByZXNlbmNlIG9mIGRlcGVuZGVudCBydWxlcy5cclxuXHRwcml2YXRlIF9zZWw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgRGVwZW5kZW50UnVsZSBjbGFzcyBkZXNjcmliZXMgYSBzdHlsZXNldCB0aGF0IGRlcGVuZHMgb24gdGhlIGNvbnRhaW5pbmcgc3R5bGUgcnVsZS4gVGhpc1xyXG4gKiBpcyB1c2VkIGZvciBwc2V1ZG8gY2xhc3NlcywgcHNldWRvIGVsZW1lbnRzLCBjb21iaW5hdG9ycyBhbmQgb3RoZXIgc2VsZWN0b3JzIHRoYXQgY29tYmluZSB0aGVcclxuICogY29udGFpbmluZyBydWxlJ3Mgc2VsZWN0b3Igd2l0aCBhZGRpdGlvbmFsIHNlbGVjdG9yIGl0ZW1zLlxyXG4gKi9cclxuY2xhc3MgRGVwUnVsZSBleHRlbmRzIFN0eWxlUnVsZVxyXG57XHJcblx0Ly8gZm9yIHJlZ3VsYXIgc2VsZWN0b3JzLCBwc2V1ZG8gY2xhc3NlcyBhbmQgcHNldWRvIGVsZW1lbnRzLCB0aGUgc2VsZWN0b3IgYWxyZWFkeSBjb250YWluc1xyXG5cdC8vIHRoZSBhbXBlcnNhbmQgYW5kIHRoZSBzZWxlY3RvclBhcmFtIGlzIHVuZGVmaW5lZC4gRm9yIHBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzZXMsIHBzZXVkb1xyXG5cdC8vIGVsZW1lbnRzIGFuZCBjb21iaW5hdG9ycywgdGhlIHNlbGVjdG9yUGFyYW0gaXMgZGVmaW5lZCBhbmQgdGhlIHNlbGVjdG9yIGlzIGp1c3QgdGhlIGVudGl0eVxyXG5cdC8vIG5hbWUuXHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZWxlY3RvcjogQ3NzU2VsZWN0b3IsIHBhcmFtPzogYW55LCBzdHlsZXNldD86IENvbWJpbmVkU3R5bGVzZXQgfCBDb21iaW5lZFN0eWxlc2V0W10sXHJcblx0XHRwYXJlbnQ/OiBTdHlsZVJ1bGUpXHJcblx0e1xyXG5cdFx0c3VwZXIoIHN0eWxlc2V0KTtcclxuXHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMucGFyYW0gPSBwYXJhbTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIHJ1bGUgYnV0IHdpdGggbmV3IHBhcmVudCAoY29udGFpbmluZyBydWxlKS5cclxuXHRwdWJsaWMgY2xvbmUoIGNvbnRhaW5pbmdSdWxlOiBTdHlsZVJ1bGUpOiBEZXBSdWxlXHJcblx0e1xyXG5cdFx0bGV0IG5ld1J1bGUgPSBuZXcgRGVwUnVsZSggdGhpcy5zZWxlY3RvciwgdGhpcy5wYXJhbSwgdW5kZWZpbmVkLCBjb250YWluaW5nUnVsZSk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0IHNvIHdlIGRvbid0IGhhdmUgYW55IHByb3BlcnRpZXMgaW5cclxuXHRcdC8vIG91ciBvd24gc3R5bGVzZXQgeWV0XHJcblx0XHRtZXJnZVN0eWxlc2V0cyggbmV3UnVsZS5zdHlsZXNldCwgdGhpcy5zdHlsZXNldCk7XHJcblx0XHRuZXdSdWxlLmNvcHlEZXBSdWxlcyggdGhpcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdSdWxlO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBSZXR1cm5zIHRoZSBzZWxlY3RvciBwYXJ0IG9mIHRoZSBzdHlsZSBydWxlLlxyXG5cdHB1YmxpYyBnZXRTZWwoKTogc3RyaW5nXHJcblx0e1xyXG5cdFx0bGV0IHBhcmVudFNlbGVjdG9yID0gdGhpcy5wYXJlbnQhLnNlbGVjdG9yVGV4dDtcclxuXHRcdGlmICh0aGlzLnBhcmFtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gdGhlIFwicGFyYW1cIiB2YWx1ZSBpcyBvbmx5IHNldCBmb3IgcGFyYW1ldGVyaXplZCBwc2V1ZG8gZW50aXRpZXMsIHNvIHdlIGNvbnZlcnQgaXQgdG9cclxuICAgICAgICAgICAgLy8gdGhlIFwiZnVuY1wiIG9iamVjdCBmb3JtLiBXZSBhbHNvIGtub3cgdGhhdCB0aGUgc2VsZWN0b3IgaXMgYSBzdHJpbmcgLSBuYW1lIG9mIHRoZSBlbnRpdHkuXHJcblx0XHRcdHJldHVybiBgJHtwYXJlbnRTZWxlY3Rvcn0ke2ZkbzJzKHtmbjogdGhpcy5zZWxlY3RvciBhcyBzdHJpbmcsIHA6IHRoaXMucGFyYW19IGFzIElQYXJhbWV0ZXJpemVkUHNldWRvRW50aXR5RnVuYzxhbnk+KX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcblx0XHR7XHJcblx0XHRcdC8vIGNvbnZlcnQgc2VsZWN0b3IgdG8gc3RyaW5nLlxyXG5cdFx0XHRsZXQgc2VsZWN0b3IgPSBzZWxlY3RvcjJzKCB0aGlzLnNlbGVjdG9yKTtcclxuXHJcblx0XHRcdC8vIGlmIHRoZSBzZWxlY3RvciBzdHJpbmcgZG9lc24ndCBoYXZlIGFueSBvY2N1cnJlbmNlcyBvZiB0aGUgYW1wZXJzYW5kIHN5bWJvbCwgd2VcclxuXHRcdFx0Ly8gc2ltcGx5IGFwcGVuZCB0aGUgc2VsZWN0b3IgdG8gdGhlIHBhcmVudCBzZWxlY3Rvcjsgb3RoZXJ3aXNlLCB3ZSByZXBsYWNlIGFsbFxyXG5cdFx0XHQvLyBvY2N1cnJlbmNlcyBvZiB0aGUgYW1wZXJzYW5kIHN5bWJvbCBpbiB0aGUgc2VsZWN0b3Igc3RyaW5nIHdpdGggdGhlIHNlbGVjdG9yXHJcblx0XHRcdC8vIHN0cmluZyBvZiB0aGUgcGFyZW50IHJ1bGUuXHJcblx0XHRcdHJldHVybiBzZWxlY3Rvci5pbmRleE9mKCBcIiZcIikgPCAwXHJcblx0XHRcdFx0PyBgJHtwYXJlbnRTZWxlY3Rvcn0ke3NlbGVjdG9yfWBcclxuXHRcdFx0XHQ6IHNlbGVjdG9yLnJlcGxhY2UoIC8mL2csIHBhcmVudFNlbGVjdG9yKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gUGFyZW50IHN0eWxlIHJ1bGUgb2Ygd2hpY2ggdGhpcyBydWxlIGlzIGRlcGVuZGVudC5cclxuXHRwdWJsaWMgcGFyZW50PzogU3R5bGVSdWxlO1xyXG5cclxuXHQvLyBQYXJ0aWFsIHNlbGVjdG9yIHRoYXQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBwYXJlbnQgc2VsZWN0b3IuXHJcblx0cHJpdmF0ZSBzZWxlY3RvcjogQ3NzU2VsZWN0b3I7XHJcblxyXG5cdC8vIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWxlY3RvciAtIHVzZWQgZm9yIHBhcmFtZXRlcml6ZWQgcHNldWRvIGNsYXNzZXMgYW5kIGVsZW1lbnRzLlxyXG5cdHByaXZhdGUgcGFyYW0/OiBhbnk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBBYnN0cmFjdFJ1bGUgY2xhc3MgZGVzY3JpYmVzIGEgc3R5bGVzZXQgdGhhdCBjYW4gb25seSBiZSB1c2VkIGFzIGEgYmFzZSBmb3Igb3RoZXIgc3R5bGVcclxuICogcnVsZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RSdWxlIGV4dGVuZHMgU3R5bGVSdWxlXHJcbntcclxuXHQvLyBPdmVycmlkZXMgdGhlIFN0eWxlUnVsZSdzIGltcGxlbWVudGF0aW9uIHRvIGRvIG5vdGhpbmcuIE5vIENTU1N0eWxlUnVsZSBpcyBjcmVhdGVkIGZvclxyXG5cdC8vIGFic3RyYWN0IHJ1bGVzLlxyXG5cdHB1YmxpYyBpbnNlcnQoIHBhcmVudDogQ1NTU3R5bGVTaGVldCB8IENTU0dyb3VwaW5nUnVsZSk6IHZvaWQge31cclxuXHJcblx0Ly8gT3ZlcnJpZGVzIHRoZSBTdHlsZVJ1bGUncyBpbXBsZW1lbnRhdGlvbiB0byBkbyBub3RoaW5nLlxyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHt9XHJcblxyXG5cdC8vIE92ZXJyaWRlcyB0aGUgU3R5bGVSdWxlJ3MgaW1wbGVtZW50YXRpb24gdG8gZG8gbm90aGluZy5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoIGN0eDogSVJ1bGVTZXJpYWxpemF0aW9uQ29udGV4dCk6IHZvaWQge31cclxuXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBzZWxlY3RvciBwYXJ0IG9mIHRoZSBzdHlsZSBydWxlLlxyXG5cdHB1YmxpYyBnZXRTZWwoKTogc3RyaW5nIHsgcmV0dXJuIFwiXCI7IH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIE5hbWVkU3R5bGVSdWxlIGNsYXNzIGlzIGEgYmFzZSBmb3Igc3R5bGUgcnVsZSBjbGFzc2VzIHRoYXQgYXJlIGFsc28gbmFtZWQgZW50aXRpZXMgLSBzdWNoXHJcbiAqIGFzIGNsYXNzIHJ1bGUgYW5kIElEIHJ1bGUuXHJcbiAqL1xyXG5hYnN0cmFjdCBjbGFzcyBOYW1lZFN0eWxlUnVsZSBleHRlbmRzIFN0eWxlUnVsZSBpbXBsZW1lbnRzIElOYW1lZEVudGl0eVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzdHlsZXNldD86IENvbWJpbmVkU3R5bGVzZXQgfCBDb21iaW5lZFN0eWxlc2V0W10sIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElOYW1lZEVudGl0eSlcclxuXHR7XHJcblx0XHRzdXBlciggc3R5bGVzZXQpO1xyXG5cdFx0dGhpcy5uYW1lT3ZlcnJpZGUgPSBuYW1lT3ZlcnJpZGU7XHJcblx0fVxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIGNvbnRhaW5lcjogSVJ1bGVDb250YWluZXIsIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKTogdm9pZFxyXG5cdHtcclxuXHRcdHN1cGVyLnByb2Nlc3MoIGNvbnRhaW5lciwgcnVsZU5hbWUpO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IGNvbnRhaW5lci5nZXRTY29wZWROYW1lKCBydWxlTmFtZSwgdGhpcy5uYW1lT3ZlcnJpZGUpO1xyXG4gICAgICAgIHRoaXMuY3NzTmFtZSA9IHRoaXMuY3NzUHJlZml4ICsgdGhpcy5uYW1lLnJlcGxhY2UoIC8gL2csIHRoaXMuY3NzUHJlZml4KTtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHNlbGVjdG9yIHBhcnQgb2YgdGhlIHN0eWxlIHJ1bGUuXHJcblx0cHVibGljIGdldFNlbCgpOiBzdHJpbmdcclxuXHR7XHJcblx0XHRyZXR1cm4gdGhpcy5jc3NOYW1lO1xyXG5cdH1cclxuXHJcblx0Ly8gSW1wbGVtZW50YXRpb24gb2YgdGhlIHRvU3RyaW5nIG1ldGhvZCByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBydWxlICh3aXRob3V0IHRoZSBDU1MgcHJlZml4KS5cclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMubmFtZTtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgcHJlZml4IHRoYXQgaXMgcHV0IGJlZm9yZSB0aGUgZW50aXR5IG5hbWUgdG8gY3JlYXRlIGEgQ1NTIG5hbWUgdXNlZCBpbiBzdHlsZSBydWxlXHJcblx0Ly8gc2VsZWN0b3JzLlxyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBnZXQgY3NzUHJlZml4KCk6IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogUnVsZSdzIG5hbWUgLSB0aGlzIGlzIGEgdW5pcXVlIG5hbWUgdGhhdCBpcyBhc3NpZ25lZCBieSB0aGUgTWltY3NzIGluZnJhc3R1Y3R1cmUuIFRoaXMgbmFtZVxyXG5cdCAqIGRvZXNuJ3QgaGF2ZSB0aGUgcHJlZml4IHRoYXQgaXMgdXNlZCB3aGVuIHJlZmVycmluZyB0byBjbGFzc2VzICguKSwgSURzICgjKSBhbmQgY3VzdG9tIENTU1xyXG5cdCAqIHByb3BlcnRpZXMgKC0tKS5cclxuXHQgKi9cclxuXHRwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuXHQvKipcclxuXHQgKiBSdWxlJ3MgbmFtZSAtIHRoaXMgaXMgYSBuYW1lIHRoYXQgaGFzIHRoZSBwcmVmaXggdGhhdCBpcyB1c2VkIHdoZW4gcmVmZXJyaW5nIHRvIGNsYXNzZXMgKC4pLFxyXG5cdCAqIElEcyAoIykgYW5kIGN1c3RvbSBDU1MgcHJvcGVydGllcyAoLS0pLiBGb3IgYW5pbWF0aW9ucywgdGhpcyBuYW1lIGlzIHRoZSBzYW1lIGFzIGluIHRoZVxyXG5cdCAqIGBuYW1lYCBwcm9wZXJ0eS5cclxuXHQgKi9cclxuXHRwdWJsaWMgY3NzTmFtZTogc3RyaW5nO1xyXG5cclxuXHQvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG5cdC8vIGlzIG5vdCBkZWZpbmVkLCB0aGUgbmFtZSB3aWxsIGJlIHVuaXF1ZWx5IGdlbmVyYXRlZC5cclxuXHRwcm90ZWN0ZWQgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSU5hbWVkRW50aXR5O1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgQ2xhc3NSdWxlIGNsYXNzIGRlc2NyaWJlcyBhIHN0eWxlc2V0IHRoYXQgYXBwbGllcyB0byBlbGVtZW50cyBpZGVudGlmaWVkIGJ5IGEgQ1NTIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENsYXNzUnVsZSBleHRlbmRzIE5hbWVkU3R5bGVSdWxlIGltcGxlbWVudHMgSUNsYXNzUnVsZVxyXG57XHJcbiAgICAvLyBBbGxvd3MgdGhlIGRlcml2ZWQgY2xhc3NlcyB0byBwcm9jZXNzIHN0eWxlIHByb3BlcnRpZXMgdGhhdCB0aGUgU3R5bGVSdWxlIGRvZXNuJ3Qga25vdyBhYm91dC5cclxuICAgIC8vIElmIHJldHVybnMgZmFsc2UsIHRoZSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBzdHlsZXNldC5cclxuXHRwcm90ZWN0ZWQgcGFyc2VTUCggcHJvcE5hbWU6IHN0cmluZywgcHJvcFZhbDogYW55KTogYm9vbGVhblxyXG4gICAge1xyXG4gICAgICAgIGlmIChwcm9wTmFtZSA9PSBcIisrXCIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBwcm9wVmFsIGFzIFBhcmVudENsYXNzVHlwZSB8IFBhcmVudENsYXNzVHlwZVtdO1xyXG4gICAgICAgICAgICBpZiAocnVsZXMpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudHMgPSBBcnJheS5pc0FycmF5KHJ1bGVzKSA/IHJ1bGVzIDogW3J1bGVzXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZVNQKCBwcm9wTmFtZSwgcHJvcFZhbCk7XHJcbiAgICB9XHJcblxyXG5cdC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuXHRwdWJsaWMgcHJvY2VzcyggY29udGFpbmVyOiBJUnVsZUNvbnRhaW5lciwgcnVsZU5hbWU6IHN0cmluZyB8IG51bGwpOiB2b2lkXHJcblx0e1xyXG5cdFx0c3VwZXIucHJvY2VzcyggY29udGFpbmVyLCBydWxlTmFtZSk7XHJcblxyXG4gICAgICAgIC8vIGJ5IG5vdyBvdXIgbmFtZSBhbmQgY3NzTmFtZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQgdG8gcmVmbGVjdCBhIHNpbmdsZSBuYW1lLiBOb3dcclxuICAgICAgICAvLyBsb29rIGF0IHRoZSBwYXJlbnQgY2xhc3MgcnVlcyBkZWZpbmVkIHVzaW5nIHRoZSBcIisrXCIgcHJvcGVydHkgYW5kIHRha2UgbmFtZXMgZnJvbSB0aGVcclxuICAgICAgICAvLyByZWZlcmVuY2VkIGNsYXNzIHJ1bGVzIGFuZCBhcHBlbmQgdGhlbSB0byB0aGUgbmFtZS5cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5uYW1lICs9IFwiIFwiICsgdGhpcy5wYXJlbnRzLm1hcCggY2xzID0+IHR5cGVvZiBjbHMgPT09IFwic3RyaW5nXCIgPyBjbHMgOiBjbHMubmFtZSkuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgIHRoaXMuY3NzTmFtZSA9IFwiLlwiICsgdGhpcy5uYW1lLnJlcGxhY2UoIC8gL2csIFwiLlwiKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuXHQvKiogTmFtZSBvZiB0aGUgY2xhc3MgcHJlZml4ZWQgd2l0aCBcIi5cIiAqL1xyXG5cdHB1YmxpYyBnZXQgY3NzQ2xhc3NOYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLmNzc05hbWU7IH1cclxuXHJcblx0Ly8gUmV0dXJucyBwcmVmaXggdGhhdCBpcyBwdXQgYmVmb3JlIHRoZSBlbnRpdHkgbmFtZSB0byBjcmVhdGUgYSBDU1MgbmFtZSB1c2VkIGluIHN0eWxlIHJ1bGVcclxuXHQvLyBzZWxlY3RvcnMuXHJcblx0cHJvdGVjdGVkIGdldCBjc3NQcmVmaXgoKTogc3RyaW5nIHsgcmV0dXJuIFwiLlwiOyB9XHJcblxyXG4gICAgLy8gcmVtZW1iZXJlZCB2YWx1ZSBvZiB0aGUgXCIrK1wiIHByb3BlcnR5IG9mIHRoZSBpbnB1dCBzdHlsZXNldFxyXG4gICAgcHJpdmF0ZSBwYXJlbnRzPzogUGFyZW50Q2xhc3NUeXBlW107XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJRFJ1bGUgY2xhc3MgZGVzY3JpYmVzIGEgc3R5bGVzZXQgdGhhdCBhcHBsaWVzIHRvIGVsZW1lbnRzIGlkZW50aWZpZWQgYnkgYW4gSUQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSURSdWxlIGV4dGVuZHMgTmFtZWRTdHlsZVJ1bGUgaW1wbGVtZW50cyBJSURSdWxlXHJcbntcclxuXHQvKiogTmFtZSBvZiB0aGUgZWxlbWVudCBJRCBwcmVmaXhlZCB3aXRoIFwiI1wiICovXHJcblx0cHVibGljIGdldCBjc3NJRE5hbWUoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuY3NzTmFtZTsgfVxyXG5cclxuXHQvLyBSZXR1cm5zIHByZWZpeCB0aGF0IGlzIHB1dCBiZWZvcmUgdGhlIGVudGl0eSBuYW1lIHRvIGNyZWF0ZSBhIENTUyBuYW1lIHVzZWQgaW4gc3R5bGUgcnVsZVxyXG5cdC8vIHNlbGVjdG9ycy5cclxuXHRwcm90ZWN0ZWQgZ2V0IGNzc1ByZWZpeCgpOiBzdHJpbmcgeyByZXR1cm4gXCIjXCI7IH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFNlbGVjdG9yUnVsZSB0eXBlIGRlc2NyaWJlcyBhIHN0eWxlc2V0IHRoYXQgYXBwbGllcyB0byBlbGVtZW50cyBpZGVudGlmaWVkIGJ5IGEgQ1NTIHNlbGVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yUnVsZSBleHRlbmRzIFN0eWxlUnVsZVxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCBzZWxlY3RvcjogQ3NzU2VsZWN0b3IsIHN0eWxlc2V0PzogQ29tYmluZWRTdHlsZXNldCB8IENvbWJpbmVkU3R5bGVzZXRbXSlcclxuXHR7XHJcblx0XHRzdXBlciggc3R5bGVzZXQpO1xyXG5cdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG5cdH1cclxuXHJcblx0Ly8gUmV0dXJucyB0aGUgc2VsZWN0b3IgcGFydCBvZiB0aGUgc3R5bGUgcnVsZS5cclxuXHRwdWJsaWMgZ2V0U2VsKCk6IHN0cmluZ1xyXG5cdHtcclxuXHRcdHJldHVybiBzZWxlY3RvcjJzKCB0aGlzLnNlbGVjdG9yKTtcclxuXHR9XHJcblxyXG5cdC8vIHNlbGVjdG9yIG9iamVjdCBmb3IgdGhpcyBydWxlLlxyXG5cdHByaXZhdGUgc2VsZWN0b3I6IENzc1NlbGVjdG9yO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBNZXJnZXMgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugc3R5bGVzZXQgdG8gdGhlIHRhcmdldCBzdHlsZXNldC4gQWxsIHJlZ3VsYXIgcHJvcGVydGllcyBhcmVcclxuICogcmVwbGFjZWQuIFRoZSBcIi0tXCIgcHJvcGVydHkgZ2V0cyBzcGVjaWFsIHRyZWF0bWVudCBiZWNhdXNlIGl0IGlzIGFuIGFycmF5LlxyXG4gKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBTdHlsZXNldCBvYmplY3QgLSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQ7XHJcbiAqIEBwYXJhbSBzb3VyY2UgU291cmNlIFN0eWxlc2V0IG9iamVjdCAtIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cclxuICogQHBhcmFtIHNvdXJjZVxyXG4gKi9cclxuY29uc3QgbWVyZ2VTdHlsZXNldHMgPSAodGFyZ2V0OiBTdHlsZXNldCwgc291cmNlOiBTdHlsZXNldCk6IHZvaWQgPT5cclxue1xyXG4gICAgLy8gY29weSBhbGwgb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2VcclxuICAgIGlmIChPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCA9PT0gMClcclxuICAgICAgICBPYmplY3QuYXNzaWduKCB0YXJnZXQsIHNvdXJjZSk7XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcbiAgICAgICAgZm9yKCBsZXQgcHJvcE5hbWUgaW4gc291cmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcIi0tXCIpXHJcbiAgICAgICAgICAgICAgICBtZXJnZUN1c3RvbVByb3BzKCB0YXJnZXQsIHNvdXJjZVtwcm9wTmFtZV0hKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbWVyZ2VQcm9wVmFsdWVzKCB0YXJnZXQsIHByb3BOYW1lLCBzb3VyY2VbcHJvcE5hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyBcIi0tXCIgcHJvcGVydHkgZnJvbSB0aGUgc291cmNlIHN0eWxlc2V0IHRvIHRoZSB0YXJnZXQgc3R5bGVzZXQuXHJcbiAqL1xyXG5jb25zdCBtZXJnZUN1c3RvbVByb3BzID0gKHRhcmdldDogU3R5bGVzZXQsIHNvdXJjZVZhcnM6IEN1c3RvbVZhcl9TdHlsZVR5cGVbXSk6IHZvaWQgPT5cclxue1xyXG4gICAgbGV0IHRhcmdldFZhcnMgPSB0YXJnZXRbXCItLVwiXTtcclxuICAgIHRhcmdldFtcIi0tXCJdID0gIXRhcmdldFZhcnMgPyBzb3VyY2VWYXJzLnNsaWNlKCkgOiB0YXJnZXRWYXJzLmNvbmNhdCggc291cmNlVmFycyk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogTWVyZ2VzIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgZnJvbSB0aGUgc291cmNlIHN0eWxlc2V0IHRvIHRoZSB0YXJnZXQgc3R5bGVzZXQuIE5vdGUgdGhhdFxyXG4gKiBib3RoIHNvdXJjZSBvciB0YXJnZXQgdmFsdWUgY2FuIGJlIGVpdGhlciBudWxsIG9yIHNpbmdsZSB2YWx1ZSBvciBhbiBvYmplY3Qgd2l0aCB0aGUgYFwiW11cImBcclxuICogcHJvcGVydHkgdGhhdCBjb250YWlucyBtdWx0aXBsZSB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IFN0eWxlc2V0IG9iamVjdCAtIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cclxuICogQHBhcmFtIHByb3BOYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gKiBAcGFyYW0gc291cmNlVmFsIFZhbHVlIGZyb20gdGhlIHNvdXJjZSBzdHlsZXNldCB0byBtZXJnZSB3aXRoIHRoZSB0YXJnZXQgdmFsdWUgLSBjYW4gYmUgbnVsbCBvclxyXG4gKiB1bmRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBtZXJnZVByb3BWYWx1ZXMgPSAodGFyZ2V0OiBTdHlsZXNldCwgcHJvcE5hbWU6IHN0cmluZywgc291cmNlVmFsOiBhbnkpOiB2b2lkID0+XHJcbntcclxuICAgIGlmIChzb3VyY2VWYWwgPT0gbnVsbClcclxuICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BOYW1lXTtcclxuICAgIGVsc2VcclxuICAgIHtcclxuICAgICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W3Byb3BOYW1lXTtcclxuICAgICAgICBpZiAodGFyZ2V0VmFsID09IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBpZiBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgb3IgaXRzIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBqdXN0XHJcbiAgICAgICAgICAgIC8vIHRha2UgdGhlIHNvdXJjZSdzIHZhbHVlXHJcbiAgICAgICAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSBzb3VyY2VWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRBcnJheTogYW55W10gPSB0YXJnZXRWYWxbXCJbXVwiXTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXRBcnJheSlcclxuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSB7IFwiW11cIjogdGFyZ2V0QXJyYXkgPSBbdGFyZ2V0VmFsXSB9O1xyXG5cclxuICAgICAgICAgICAgbGV0IHNvdXJjZUFycmF5OiBhbnlbXSA9IHNvdXJjZVZhbFtcIltdXCJdO1xyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZUFycmF5KVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaCggc291cmNlVmFsKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaCggLi4uc291cmNlQXJyYXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7SVZhclJ1bGUsIElDb25zdFJ1bGV9IGZyb20gXCIuLi9hcGkvUnVsZVR5cGVzXCJcclxuaW1wb3J0IHtWYXJUZW1wbGF0ZU5hbWUsIEV4dGVuZGVkVmFyVmFsdWUsIElTeW50YXhUeXBlU3R5bGVzZXR9IGZyb20gXCIuLi9hcGkvU3R5bGVzZXRzXCJcclxuaW1wb3J0IHtzcDJzfSBmcm9tIFwiLi4vaW1wbC9TdHlsZUltcGxcIlxyXG5pbXBvcnQge0lSdWxlQ29udGFpbmVyLCBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0LCBSdWxlLCBSdWxlTGlrZX0gZnJvbSBcIi4vUnVsZVwiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFZhckJhc2VSdWxlIGNsYXNzIGNvbnRhaW5zIGZ1bmN0aW9uYWxpdHkgY29tbW9uIGZvciBWYXJSdWxlIGNsYXNzIGRlc2NyaWJpbmcgYSBjdXN0b20gQ1NTXHJcbiAqIHByb3BlcnR5IGRlZmluaXRpb24gaW4gdGhlIGA6cm9vdGAgcnVsZSBhbmQgZm9yIFByb3BlcnR5UnVsZSBjbGFzcyBkZXNjcmliaW5nIHRoZSBgQHByb3BlcnR5YFxyXG4gKiBhdC1ydWxlLlxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgVmFyQmFzZVJ1bGU8SyBleHRlbmRzIFZhclRlbXBsYXRlTmFtZSA9IGFueT4gZXh0ZW5kcyBSdWxlIGltcGxlbWVudHMgSVZhclJ1bGU8Sz5cclxue1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCB0ZW1wbGF0ZTogSywgdmFsdWU/OiBFeHRlbmRlZFZhclZhbHVlPEs+LCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJVmFyUnVsZTxLPilcclxuICAgIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5uYW1lT3ZlcnJpZGUgPSBuYW1lT3ZlcnJpZGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIHRoZSBvYmplY3QgaXMgc3BlY2lmaWVkIGFzIGEgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS5cclxuICAgIC8vIFdlIHJldHVybiB0aGUgdmFyKC0tbmFtZSkgZXhwcmVzc2lvbi5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmdcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gYHZhcigke3RoaXMuY3NzVmFyTmFtZX0pYDtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8vIFByb2Nlc3NlcyB0aGUgZ2l2ZW4gcnVsZS5cclxuICAgIHB1YmxpYyBwcm9jZXNzKCBjb250YWluZXI6IElSdWxlQ29udGFpbmVyLCBydWxlTmFtZTogc3RyaW5nIHwgbnVsbCk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICBzdXBlci5wcm9jZXNzKCBjb250YWluZXIsIHJ1bGVOYW1lKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBjb250YWluZXIuZ2V0U2NvcGVkTmFtZSggcnVsZU5hbWUsIHRoaXMubmFtZU92ZXJyaWRlKTtcclxuICAgICAgICBpZiAodGhpcy5uYW1lLnN0YXJ0c1dpdGgoXCItLVwiKSlcclxuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5uYW1lLnN1YnN0cigyKTtcclxuXHJcbiAgICAgICAgdGhpcy5jc3NWYXJOYW1lID0gXCItLVwiICsgdGhpcy5uYW1lO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLy8gSW5zZXJ0cyB0aGlzIHJ1bGUgaW50byB0aGUgZ2l2ZW4gcGFyZW50IHJ1bGUgb3Igc3R5bGVzaGVldC4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlXHJcbiAgICAvLyBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLCB0byB3aGljaCB0aGlzIHJ1bGUgYmVsb25ncywgaXMgYWN0aXZhdGVkLlxyXG4gICAgcHVibGljIGluc2VydCggcGFyZW50OiBDU1NTdHlsZVNoZWV0IHwgQ1NTR3JvdXBpbmdSdWxlKTogdm9pZCB7fVxyXG5cclxuICAgIC8vIFNlcmlhbGl6ZXMgdGhpcyBydWxlIHRvIGEgc3RyaW5nLlxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSggY3R4OiBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0KTogdm9pZCB7fVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRWYWx1ZSgpOiBFeHRlbmRlZFZhclZhbHVlPEs+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUhO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG5ldyB2YWx1ZSBvZiB0aGlzIGN1c3RvbSBDU1MgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGUgQ1NTIHByb3BlcnR5LlxyXG4gICAgICogQHBhcmFtIHNjaGVkdWxlclR5cGUgSUQgb2YgYSByZWdpc3RlcmVkIHNjaGVkdWxlciB0eXBlIHRoYXQgaXMgdXNlZCB0byB3cml0ZSB0aGUgcHJvcGVydHlcclxuICAgICAqIHZhbHVlIHRvIHRoZSBET00uIElmIHVuZGVmaW5lZCwgdGhlIGN1cnJlbnQgZGVmYXVsdCBzY2hlZHVsZXIgd2lsbCBiZSB1c2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VmFsdWUoIHZhbHVlOiBFeHRlbmRlZFZhclZhbHVlPEs+LCBzY2hlZHVsZXJUeXBlPzogbnVtYmVyKTogdm9pZFxyXG4gICAge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5jKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGltcG9ydGFudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCIhXCIgaW4gKHZhbHVlIGFzIGFueSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydGFudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW1wiIVwiXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jLnNldFZhclZhbHVlKCB0aGlzLmNzc1Zhck5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzcDJzKCB0aGlzLnRlbXBsYXRlLCB2YWx1ZSksIGltcG9ydGFudCwgc2NoZWR1bGVyVHlwZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvLyBOYW1lIG9mIGEgbm9uLWN1c3RvbSBDU1MgcHJvcGVydHkgd2hvc2UgdHlwZSBkZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRoZSBjdXN0b20gcHJvcGVydHkgdmFsdWUuXHJcbiAgICBwdWJsaWMgdGVtcGxhdGU6IEs7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdWxlJ3MgbmFtZSAtIHRoaXMgaXMgYSB1bmlxdWUgbmFtZSB0aGF0IGlzIGFzc2lnbmVkIGJ5IHRoZSBNaW1jc3MgaW5mcmFzdHVjdHVyZS4gVGhpcyBuYW1lXHJcbiAgICAgKiBkb2Vzbid0IGhhdmUgdGhlIHByZWZpeCB0aGF0IGlzIHVzZWQgd2hlbiByZWZlcnJpbmcgdG8gY2xhc3NlcyAoLiksIElEcyAoIykgYW5kIGN1c3RvbSBDU1NcclxuICAgICAqIHByb3BlcnRpZXMgKC0tKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1c3RvbSBDU1MgcHJvcGVydHkgbmFtZSBwcmVmaXhlZCB3aXRoIGBcIi0tXCJgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3NzVmFyTmFtZTogc3RyaW5nO1xyXG5cclxuICAgIC8vIFZhbHVlIG9mIHRoZSBjdXN0b20gQ1NTIHByb3BlcnR5LlxyXG4gICAgcHJvdGVjdGVkIHZhbHVlPzogRXh0ZW5kZWRWYXJWYWx1ZTxLPjtcclxuXHJcbiAgICAvLyBOYW1lIG9yIG5hbWVkIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5hbWUgZm9yIHRoaXMgcnVsZS4gSWYgdGhpcyBwcm9wZXJ0eVxyXG4gICAgLy8gaXMgbm90IGRlZmluZWQsIHRoZSBuYW1lIHdpbGwgYmUgdW5pcXVlbHkgZ2VuZXJhdGVkLlxyXG4gICAgcHJvdGVjdGVkIG5hbWVPdmVycmlkZT86IHN0cmluZyB8IElWYXJSdWxlPEs+O1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgVmFyUnVsZSBjbGFzcyBkZXNjcmliZXMgYSBjdXN0b20gQ1NTIHByb3BlcnR5LiBWYXJSdWxlIGlzIG5vdCBhIHJlYWwgQ1NTIHJ1bGU7IGhvd2V2ZXIsIGluXHJcbiAqIG1hbnkgYXNwZWN0cyBpdCByZXBlYXRzIHRoZSBSdWxlJ3MgZnVuY3Rpb25hbGl0eS4gSW4gcGFydGljdWxhciBpdCBoYXMgdGhlIHByb2Nlc3MgZnVuY3Rpb24gdGhhdFxyXG4gKiBhbGxvd3MgaXQgdG8gb2J0YWluIGFuIGFjdHVhbCBuYW1lLCB3aGljaCB3aWxsIGJlIHVzZWQgd2hlbiBkZWZpbmluZyBhbmQgdXNpbmcgdGhpcyBjdXN0b21cclxuICogcHJvcGVydHkgaW4gQ1NTLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFZhclJ1bGU8SyBleHRlbmRzIFZhclRlbXBsYXRlTmFtZSA9IGFueT4gZXh0ZW5kcyBWYXJCYXNlUnVsZTxLPlxyXG57XHJcblx0cHVibGljIGNvbnN0cnVjdG9yKCB0ZW1wbGF0ZTogSywgdmFsdWU/OiBFeHRlbmRlZFZhclZhbHVlPEs+LCBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJVmFyUnVsZTxLPilcclxuXHR7XHJcbiAgICAgICAgc3VwZXIoIHRlbXBsYXRlLCB2YWx1ZSwgbmFtZU92ZXJyaWRlKTtcclxuXHR9XHJcblxyXG5cclxuXHQvLyBDb252ZXJ0cyB0aGUgcnVsZSB0byBDU1Mgc3RyaW5nLlxyXG5cdHB1YmxpYyB0b0NzcygpOiBzdHJpbmcgfCBudWxsXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgPT0gbnVsbCA/IG51bGwgOiBgJHt0aGlzLmNzc1Zhck5hbWV9OiAke3NwMnMoIHRoaXMudGVtcGxhdGUsIHRoaXMudmFsdWUpfWA7XHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgUHJvcGVydHlSdWxlIGNsYXNzIGRlc2NyaWJlcyB0aGUgYEBwcm9wZXJ0eWAgYXQtcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eVJ1bGU8SyBleHRlbmRzIGtleW9mIElTeW50YXhUeXBlU3R5bGVzZXQgPSBhbnksIFQgZXh0ZW5kcyBLIHwgW3N0cmluZ10gPSBhbnk+IGV4dGVuZHMgVmFyQmFzZVJ1bGU8Sz5cclxue1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCBzeW50YXg6IFQsIGluaXRWYWx1ZT86IEV4dGVuZGVkVmFyVmFsdWU8Sz4sIGluaGVyaXRzOiBib29sZWFuID0gdHJ1ZSxcclxuICAgICAgICBuYW1lT3ZlcnJpZGU/OiBzdHJpbmcgfCBJVmFyUnVsZTxLPilcclxuICAgIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzeW50YXgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3VwZXIoIFwiKlwiIGFzIEssIGluaXRWYWx1ZSwgbmFtZU92ZXJyaWRlKTtcclxuICAgICAgICAgICAgdGhpcy5zeW50YXggPSBzeW50YXhbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN1cGVyKCBzeW50YXggYXMgSywgaW5pdFZhbHVlLCBuYW1lT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5oZXJpdHMgPSBpbmhlcml0cztcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoIHN5bnRheDogSywgaW5pdFZhbHVlOiBFeHRlbmRlZFZhclZhbHVlPEs+LCBpbmhlcml0czogYm9vbGVhbiwgbmFtZU92ZXJyaWRlPzogc3RyaW5nIHwgSVZhclJ1bGU8Sz4pXHJcblx0Ly8ge1xyXG4gICAgLy8gICAgIHN1cGVyKCBzeW50YXgsIGluaXRWYWx1ZSwgbmFtZU92ZXJyaWRlKTtcclxuXHQvLyBcdHRoaXMuaW5oZXJpdHMgPSBpbmhlcml0cztcclxuXHQvLyB9XHJcblxyXG5cclxuXHQvLyBJbnNlcnRzIHRoaXMgcnVsZSBpbnRvIHRoZSBnaXZlbiBwYXJlbnQgcnVsZSBvciBzdHlsZXNoZWV0LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVcclxuXHQvLyBzdHlsZSBkZWZpbml0aW9uIGNsYXNzLCB0byB3aGljaCB0aGlzIHJ1bGUgYmVsb25ncywgaXMgYWN0aXZhdGVkLlxyXG5cdHB1YmxpYyBpbnNlcnQoIHBhcmVudDogQ1NTU3R5bGVTaGVldCB8IENTU0dyb3VwaW5nUnVsZSk6IHZvaWRcclxuICAgIHtcclxuXHRcdHRoaXMuY3NzUnVsZSA9IFJ1bGUudG9ET00oIHRoaXMudG9Dc3MoKSwgcGFyZW50KTtcclxuICAgIH1cclxuXHJcblx0Ly8gU2VyaWFsaXplcyB0aGlzIHJ1bGUgdG8gYSBzdHJpbmcuXHJcblx0cHVibGljIHNlcmlhbGl6ZSggY3R4OiBJUnVsZVNlcmlhbGl6YXRpb25Db250ZXh0KTogdm9pZFxyXG4gICAge1xyXG5cdFx0Y3R4LmFkZFJ1bGUoIHRoaXMudG9Dc3MoKSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENvbnZlcnRzIHRoZSBydWxlIHRvIENTUyBzdHJpbmcuXHJcblx0cHVibGljIHRvQ3NzKCk6IHN0cmluZ1xyXG5cdHtcclxuXHRcdHJldHVybiBgQHByb3BlcnR5ICR7dGhpcy5jc3NWYXJOYW1lfXtzeW50YXg6JyR7dGhpcy5zeW50YXh9Jztpbmhlcml0czoke3RoaXMuaW5oZXJpdHN9O2AgK1xyXG4gICAgICAgICAgICBgaW5pdGlhbC12YWx1ZToke3NwMnMoIHRoaXMudGVtcGxhdGUsIHRoaXMudmFsdWUpfTt9YDtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGN1c3RvbSBwcm9wZXJ0eSByZWdpc3RyYXRpb24gaW5oZXJpdHMgYnkgZGVmYXVsdC5cclxuXHRwcml2YXRlIHN5bnRheDogc3RyaW5nO1xyXG5cclxuXHQvLyBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgY3VzdG9tIHByb3BlcnR5IHJlZ2lzdHJhdGlvbiBpbmhlcml0cyBieSBkZWZhdWx0LlxyXG5cdHByaXZhdGUgaW5oZXJpdHM6IGJvb2xlYW47XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBJQ29uc3RSdWxlIGludGVyZmFjZSByZXByZXNlbnRzIGEgXCJjb25zdGFudFwiIHRoYXQgY2FuIGJlIHVzZWQgYW55d2hlcmUgdGhlIHR5cGUgZGVmaW5lZCBieVxyXG4gKiB0aGUgYHRlbXBsYXRlYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQuIFRoZXNlIGFyZSBjYWxsZWQgY29uc3RhbnRzLCBiZWNhdXNlIHRoZXkgcHJvdmlkZSB0aGVcclxuICogY29udmVuaWVudCBhbmQgbGlnaHR3ZWlnaHQgd2F5IG9mIGRlZmluaW5nIHZhbHVlcyB0aGF0IGFyZSB1bmNoYW5nZWQgZHVyaW5nIHRoZSBhcHBsaWNhdGlvblxyXG4gKiBsaWZldGltZS4gQWx0aG91Z2ggY29uc3RhbnRzIGFyZSBkZWZpbmVkIHZlcnkgc2ltaWxhcmx5IHRvIGN1c3RvbSBwcm9wZXJ0aWVzIChzZWUgdGhlXHJcbiAqIFtbSVZhclJ1bGVdXSBmdW5jdGlvbiksIHRoZXkgY2Fubm90IHBhcnRpY2lwYXRlIGluIHRoZSBjYXNjYWRlIGFuZCBjYW5ub3QgYmUgcmVkZWZpbmVkIHVuZGVyXHJcbiAqIGVsZW1lbnRzLiBDb25zdGFudCBjYW4sIGhvd2V2ZXIsIHVzZSBhbnkgZXhwcmVzc2lvbiB0aGF0IHNhdGlzZmllcyB0aGUgdHlwZSBkZWZpbmVkIGJ5IHRoZVxyXG4gKiBgdGVtcGxhdGVgIHBhcmFtZXRlciBpbmNsdWRpbmcgb3RoZXIgY29uc3RhbnRzLCBjdXN0b20gcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zLlxyXG4gKiBPYmplY3RzIGltcGxlbWVudGluZyB0aGlzIGludGVyZmFjZSBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgW1skY29uc3RdXSBmdW5jdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb25zdFJ1bGU8SyBleHRlbmRzIFZhclRlbXBsYXRlTmFtZSA9IGFueT4gZXh0ZW5kcyBSdWxlTGlrZSBpbXBsZW1lbnRzIElDb25zdFJ1bGU8Sz5cclxue1xyXG5cdHB1YmxpYyBjb25zdHJ1Y3RvciggdGVtcGxhdGU6IEssIHZhbHVlPzogRXh0ZW5kZWRWYXJWYWx1ZTxLPiwgY2FjaGVkVmFsdWU/OiBzdHJpbmcpXHJcblx0e1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblx0XHR0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3ZhbCA9IGNhY2hlZFZhbHVlO1xyXG5cdH1cclxuXHJcblxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gdGhlIG9iamVjdCBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSBvZiBhIHN0eWxlIHByb3BlcnR5LlxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl92YWwhOyB9XHJcblxyXG5cclxuXHQvLyBQcm9jZXNzZXMgdGhlIGdpdmVuIHJ1bGUuXHJcblx0cHVibGljIHByb2Nlc3MoIGNvbnRhaW5lcjogSVJ1bGVDb250YWluZXIsIHJ1bGVOYW1lOiBzdHJpbmcgfCBudWxsKTogdm9pZFxyXG5cdHtcclxuICAgICAgICBzdXBlci5wcm9jZXNzKCBjb250YWluZXIsIHJ1bGVOYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl92YWwpXHJcblx0XHQgICAgdGhpcy5fdmFsID0gc3AycyggdGhpcy50ZW1wbGF0ZSwgdGhpcy52YWx1ZSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cclxuXHQgKi9cclxuICAgIHB1YmxpYyBnZXRWYWx1ZSgpOiBFeHRlbmRlZFZhclZhbHVlPEs+XHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUhO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cdC8vIE5hbWUgb2YgYSBub24tY3VzdG9tIENTUyBwcm9wZXJ0eSB3aG9zZSB0eXBlIGRldGVybWluZXMgdGhlIHR5cGUgb2YgdGhlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZS5cclxuXHRwdWJsaWMgdGVtcGxhdGU6IEs7XHJcblxyXG5cdC8vIFZhbHVlIG9mIHRoZSBjdXN0b20gQ1NTIHByb3BlcnR5LlxyXG5cdHByaXZhdGUgdmFsdWU/OiBFeHRlbmRlZFZhclZhbHVlPEs+O1xyXG5cclxuXHQvLyBQcm9wZXJ0eSB2YWx1ZSBjYWNoZWQgd2hlbiB0aGUgcnVsZSBpcyBwcm9jZWVkLlxyXG5cdHByaXZhdGUgX3ZhbD86IHN0cmluZztcclxufVxyXG5cclxuXHJcblxyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIFR5cGUgZGVmaW5pdGlvbnMgZm9yIG1pbWNzc1xyXG5cclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL0NvcmVUeXBlc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvTnVtZXJpY1R5cGVzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9Db2xvclR5cGVzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9TaGFwZVR5cGVzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9Gb250VHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL01lZGlhVHlwZXNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL1J1bGVUeXBlc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvU2NoZWR1bGluZ1R5cGVzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9TdHlsZVR5cGVzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9TdHlsZXNldHNcIjtcclxuXHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9Db3JlQVBJXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9OdW1lcmljQVBJXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwaS9Db2xvckFQSVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkvU2hhcGVBUElcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL1J1bGVBUElcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL1NjaGVkdWxpbmdBUElcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vYXBpL1N0eWxlQVBJXCI7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=